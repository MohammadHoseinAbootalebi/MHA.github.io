//##############################################################################################################################################################
//##############################################################################################################################################################
//##############################################################################################################################################################
//##############################################################################################################################################################
//################################################# © All Rights reserved BY Muhammad Husain Aboutalebi © ######################################################
//##############################################################################################################################################################
//##############################################################################################################################################################
//##############################################################################################################################################################
//##############################################################################################################################################################

// --------------------- ↓ Static Informations for Individual Skills Page ↓ ---------------------

// Documentation
// This is the dictionary of book short information tags
var boorRecordsShortInformationTags = {
    "AuthorTagName": {
        "English": {
            "Female": "Instructor : ",
            "Male": "Instructor : ",
        },
        "Deutsch": {
            "Female": "Lehrerin : ",
            "Male": "Lehrer : ",
        },
        "中国人": {
            "Female": "讲师 ：",
            "Male": "讲师 ：",
        },
        "Русский": {
            "Female": "Инструктор : ",
            "Male": "Инструктор : ",
        },
        "Français": {
            "Female": "Instructrice : ",
            "Male": "Instructeur : ",
        },
        "日本語": {
            "Female": "講師 ：",
            "Male": "講師 ：",
        },
        "한국인": {
            "Female": "강사 : ",
            "Male": "강사 : ",
        },
        "Español": {
            "Female": "Instructora : ",
            "Male": "Instructor : ",
        },
        "हिंदी": {
            "Female": "प्रशिक्षक : ",
            "Male": "प्रशिक्षक : ",
        },
        "Português": {
            "Female": "Instrutor : ",
            "Male": "Instrutor : ",
        },
        "বাংলা": {
            "Female": "প্রশিক্ষক : ",
            "Male": "প্রশিক্ষক : ",
        },
        "عَرَبِيّ": {
            "Female": "مدرب : ",
            "Male": "مدرب : ",
        },
        "فارسی": {
            "Female": "مربی : ",
            "Male": "مربی : ",
        },
    },
    "EditionNumberTag": {
        "English": "Course Duration : ",
        "Deutsch": "Kursdauer : ",
        "中国人": "课程时长：",
        "Русский": "Длительность курса : ",
        "Français": "Durée du cours : ",
        "日本語": "コース期間 ：",
        "한국인": "수업 기간 : ",
        "Español": "Duración del curso : ",
        "हिंदी": "पाठ्यक्रम की अवधि : ",
        "Português": "Duração do curso : ",
        "বাংলা": "কোর্স সময়কাল : ",
        "عَرَبِيّ": "مدة الدورة : ",
        "فارسی": "طول دوره : ",
    },
    "PlatformNameTag": {
        "English": "Platform : ",
        "Deutsch": "Plattform : ",
        "中国人": "平台 ：",
        "Русский": "Платформа : ",
        "Français": "Plate-forme : ",
        "日本語": "プラットホーム : ",
        "한국인": "플랫폼 : ",
        "Español": "Plataforma : ",
        "हिंदी": "प्लैटफ़ॉर्म : ",
        "Português": "Plataforma : ",
        "বাংলা": "প্ল্যাটফর্ম : ",
        "عَرَبِيّ": "منصة : ",
        "فارسی": "پلتفرم : ",
    },
    "YearNumberTag": {
        "English": "Year : ",
        "Deutsch": "Jahr : ",
        "中国人": "年 ：",
        "Русский": "Год : ",
        "Français": "Année : ",
        "日本語": "年 ：",
        "한국인": "년도 : ",
        "Español": "Año : ",
        "हिंदी": "वर्ष : ",
        "Português": "Ano : ",
        "বাংলা": "বছর : ",
        "عَرَبِيّ": "سنة : ",
        "فارسی": "سال : ",
    },
    "ProgrammingLanguagesTag": {
        "English": "Programming Languages : ",
        "Deutsch": "Programmiersprachen : ",
        "中国人": "编程语言 ：",
        "Русский": "Языки программирования : ",
        "Français": "Langages de programmation : ",
        "日本語": "プログラミング言語 ：",
        "한국인": "프로그래밍 언어 : ",
        "Español": "Lenguajes de programación : ",
        "हिंदी": "प्रोग्रामिंग भाषा : ",
        "Português": "Linguagens de programação : ",
        "বাংলা": "প্রোগ্রামিং ভাষা : ",
        "عَرَبِيّ": "لغات البرمجة : ",
        "فارسی": "زبانهای برنامه نویسی : ",
    },
    "ShortDescriptionTag": {
        "English": "Short Description : ",
        "Deutsch": "Kurze Beschreibung : ",
        "中国人": "简短的介绍 ：",
        "Русский": "Краткое описание : ",
        "Français": "Brève description : ",
        "日本語": "簡単な説明 ：",
        "한국인": "간단한 설명 : ",
        "Español": "Breve descripción : ",
        "हिंदी": "संक्षिप्त वर्णन : ",
        "Português": "Pequena descrição : ",
        "বাংলা": "ছোট বিবরণ : ",
        "عَرَبِيّ": "وصف قصير : ",
        "فارسی": "توضیح کوتاه : ",
    },
    "SeeMoreRowTag": {
        "English": "See More",
        "Deutsch": "Mehr sehen",
        "中国人": "查看更多",
        "Русский": "Узнать больше",
        "Français": "Voir plus",
        "日本語": "続きを見る",
        "한국인": "더보기",
        "Español": "Ver más",
        "हिंदी": "और देखें",
        "Português": "Ver mais",
        "বাংলা": "আরো দেখুন",
        "عَرَبِيّ": "شاهد المزيد",
        "فارسی": "بیشتر ببین",
    },
}

// Documentation
// This dictionary contains all bold font text contents
var BoldFirstHeireachyFont = {
    // English
    'English': {
        'DownloadMyResumeButtonTopNavigationBar': 'Download My Resume',
        'HomeButtonLinkTopNavigationBar': 'Home',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "UI & UX Designer",
            "Flutter Developer": "Flutter Developer",
            "Full Stack Developer": "Full Stack Developer",
            "Android Developer": "Android Developer",
            "AI Engineer": "AI Engineer",
            "Industrial Designer": "Industrial Designer",
            "Self-Driving Automobile Engineer": "Self-Driving Automobile Engineer",
            "Mechanical Engineer": "Mechanical Engineer",
        },
        'fontFamily': "'Lilita One', serif",
    },
    // German
    'Deutsch': {
        'DownloadMyResumeButtonTopNavigationBar': 'Laden Sie meinen Lebenslauf herunter',
        'HomeButtonLinkTopNavigationBar': 'Heim',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "UI & UX Designer",
            "Flutter Developer": "Flutter-Entwickler",
            "Full Stack Developer": "Full-Stack-Entwickler",
            "Android Developer": "Android-Entwickler",
            "AI Engineer": "KI-Ingenieur",
            "Industrial Designer": "Industriedesigner",
            "Self-Driving Automobile Engineer": "Ingenieur für selbstfahrende Automobile",
            "Mechanical Engineer": "Maschinenbauingenieur",
        },
        'fontFamily': "'Lilita One', serif",
    },
    // Chinese
    '中国人': {
        'DownloadMyResumeButtonTopNavigationBar': '下载我的简历',
        'HomeButtonLinkTopNavigationBar': '家',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "UI 和 UX 设计师",
            "Flutter Developer": "Flutter 开发人员",
            "Full Stack Developer": "全栈开发人员",
            "Android Developer": "Android 开发者",
            "AI Engineer": "AI工程师",
            "Industrial Designer": "工业设计师",
            "Self-Driving Automobile Engineer": "自动驾驶汽车工程师",
            "Mechanical Engineer": "机械工程师",
        },
        'fontFamily': "'Ma Shan Zheng', serif",
    },
    // Russian
    'Русский': {
        'DownloadMyResumeButtonTopNavigationBar': 'Скачать мое резюме',
        'HomeButtonLinkTopNavigationBar': 'Дом',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "UI и UX дизайнер",
            "Flutter Developer": "Разработчик Flutter",
            "Full Stack Developer": "Полный стек разработчик",
            "Android Developer": "Android-разработчик",
            "AI Engineer": "Инженер по искусственному интеллекту",
            "Industrial Designer": "Промышленный дизайнер",
            "Self-Driving Automobile Engineer": "Инженер по беспилотным автомобилям",
            "Mechanical Engineer": "Инженер-механик",
        },
        'fontFamily': "'Lilita One', serif",
    },
    // French
    'Français': {
        'DownloadMyResumeButtonTopNavigationBar': 'Télécharger mon CV',
        'HomeButtonLinkTopNavigationBar': 'Maison',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "Concepteur UI et UX",
            "Flutter Developer": "Développeur Flutter",
            "Full Stack Developer": "Développeur Full Stack",
            "Android Developer": "Développeur Android",
            "AI Engineer": "Ingénieur IA",
            "Industrial Designer": "Designer industriel",
            "Self-Driving Automobile Engineer": "Ingénieur automobile autonome",
            "Mechanical Engineer": "Ingénieur mécanique",
        },
        'fontFamily': "'Lilita One', serif",
    },
    // Japanese
    '日本語': {
        'DownloadMyResumeButtonTopNavigationBar': '履歴書をダウンロード',
        'HomeButtonLinkTopNavigationBar': '家',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "UI & UX デザイナー",
            "Flutter Developer": "フラッター開発者",
            "Full Stack Developer": "フルスタック開発者",
            "Android Developer": "Android 開発者",
            "AI Engineer": "AIエンジニア",
            "Industrial Designer": "工業デザイナー",
            "Self-Driving Automobile Engineer": "自動運転自動車エンジニア",
            "Mechanical Engineer": "機械工学士",
        },
        'fontFamily': "'Dela Gothic One', serif",
    },
    // Korean
    '한국인': {
        'DownloadMyResumeButtonTopNavigationBar': '내 이력서 다운로드',
        'HomeButtonLinkTopNavigationBar': '집',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "UI & UX 디자이너",
            "Flutter Developer": "Flutter 개발자",
            "Full Stack Developer": "풀스택 개발자",
            "Android Developer": "안드로이드 개발자",
            "AI Engineer": "AI 엔지니어",
            "Industrial Designer": "산업 디자이너",
            "Self-Driving Automobile Engineer": "자율주행 자동차 엔지니어",
            "Mechanical Engineer": "기계 엔지니어",
        },
        'fontFamily': "'Black Han Sans'",
    },
    // Spanish
    'Español': {
        'DownloadMyResumeButtonTopNavigationBar': 'Descargar mi currículum',
        'HomeButtonLinkTopNavigationBar': 'Hogar',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "Diseñador de interfaz de usuario y UX",
            "Flutter Developer": "Desarrollador Flutter",
            "Full Stack Developer": "Desarrollador de pila completa",
            "Android Developer": "Desarrollador de Android",
            "AI Engineer": "Ingeniero de inteligencia artificial",
            "Industrial Designer": "Diseñador industrial",
            "Self-Driving Automobile Engineer": "Ingeniero de automóviles autónomos",
            "Mechanical Engineer": "Ingeniero mecanico",
        },
        'fontFamily': "'Lilita One', serif",
    },
    // Hindi
    'हिंदी': {
        'DownloadMyResumeButtonTopNavigationBar': 'मेरा बायोडाटा डाउनलोड करें',
        'HomeButtonLinkTopNavigationBar': 'घर',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "यूआई और यूएक्स डिजाइनर",
            "Flutter Developer": "फ़्लटर डेवलपर",
            "Full Stack Developer": "पूरी स्टैक बनानेवाला",
            "Android Developer": "एंड्रॉइड डेवलपर",
            "AI Engineer": "एआई इंजीनियर",
            "Industrial Designer": "इंडस्ट्रियल डिजाइनर",
            "Self-Driving Automobile Engineer": "स्व-चालित ऑटोमोबाइल इंजीनियर",
            "Mechanical Engineer": "यांत्रिक इंजीनियर",
        },
        'fontFamily': "'Lilita One', serif",
    },
    // Portuguese
    'Português': {
        'DownloadMyResumeButtonTopNavigationBar': 'Baixe meu currículo',
        'HomeButtonLinkTopNavigationBar': 'Lar',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "Designer de UI e UX",
            "Flutter Developer": "Desenvolvedor Flutter",
            "Full Stack Developer": "Desenvolvedor Full Stack",
            "Android Developer": "Desenvolvedor Android",
            "AI Engineer": "Engenheiro de IA",
            "Industrial Designer": "Designer industrial",
            "Self-Driving Automobile Engineer": "Engenheiro de automóveis autônomo",
            "Mechanical Engineer": "Engenheiro mecânico",
        },
        'fontFamily': "'Lilita One', serif",
    },
    // Bengali
    'বাংলা': {
        'DownloadMyResumeButtonTopNavigationBar': 'আমার জীবনবৃত্তান্ত ডাউনলোড করুন',
        'HomeButtonLinkTopNavigationBar': 'বাড়ি',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "UI এবং UX ডিজাইনার",
            "Flutter Developer": "ফ্লটার ডেভেলপার",
            "Full Stack Developer": "সম্পূর্ণ স্ট্যাক ডেভেলপার",
            "Android Developer": "অ্যান্ড্রয়েড ডেভেলপার",
            "AI Engineer": "এআই ইঞ্জিনিয়ার",
            "Industrial Designer": "ইন্ডাস্ট্রিয়াল ডিজাইনার",
            "Self-Driving Automobile Engineer": "স্ব-ড্রাইভিং অটোমোবাইল ইঞ্জিনিয়ার",
            "Mechanical Engineer": "যন্ত্র কৌশলী",
        },
        'fontFamily': "'Galada', serif",
    },
    // Arabic
    'عَرَبِيّ': {
        'DownloadMyResumeButtonTopNavigationBar': 'تحميل سيرتي الذاتية',
        'HomeButtonLinkTopNavigationBar': 'بيت',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "مصمم واجهة المستخدم وتجربة المستخدم",
            "Flutter Developer": "مطور الرفرفة",
            "Full Stack Developer": "مطور مكدس كامل",
            "Android Developer": "الروبوت المطور",
            "AI Engineer": "مهندس الذكاء الاصطناعي",
            "Industrial Designer": "المصمم الصناعي",
            "Self-Driving Automobile Engineer": "مهندس سيارات ذاتية القيادة",
            "Mechanical Engineer": "مهندس ميكانيكي",
        },
        'fontFamily': "'Lalezar', serif",
    },
    // Persian
    'فارسی': {
        'DownloadMyResumeButtonTopNavigationBar': 'دانلود رزومه من',
        'HomeButtonLinkTopNavigationBar': 'صفحه اصلی',
        'FirstViewIntroductionHeadingWhichSkillIsSelected': {
            "UI & UX Designer": "طراح رابطه و تجربه کاربری",
            "Flutter Developer": "توسعه دهنده فلاتر",
            "Full Stack Developer": "توسعه دهنده فول استک",
            "Android Developer": "توسعه دهنده اندروید",
            "AI Engineer": "مهندس هوش مصنوعی",
            "Industrial Designer": "طراح صنعتی",
            "Self-Driving Automobile Engineer": "مهندس خودروی خودران",
            "Mechanical Engineer": "مهندس مکانیک",
        },
        'fontFamily': "'Lalezar', serif",
    },
    'FirstViewSkillImageCardImage': {
        "UI & UX Designer": "../assets/img/Book Covers/FirstViewCardSkillsImages/UI - UX Designer.jpg",
        "Flutter Developer": "../assets/img/Book Covers/FirstViewCardSkillsImages/Flutter Card.jpg",
        "Full Stack Developer": "../assets/img/Book Covers/FirstViewCardSkillsImages/Full Stack Developer.jpg",
        "Android Developer": "../assets/img/Book Covers/FirstViewCardSkillsImages/Android Developer.jpg",
        "AI Engineer": "../assets/img/Book Covers/FirstViewCardSkillsImages/AI Engineer.jpeg",
        "Industrial Designer": "../assets/img/Book Covers/FirstViewCardSkillsImages/Industrial Designer.jpg",
        "Self-Driving Automobile Engineer": "../assets/img/Book Covers/FirstViewCardSkillsImages/SDC Engineer.jpeg",
        "Mechanical Engineer": "../assets/img/Book Covers/FirstViewCardSkillsImages/Mechanical Engineer Simulation.png",
    },
};

// Documentation
// This dictionary contains all second font common font text contents
var individualSkillsDescriptionsSecondhierachy = {
    // English
    "English": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "On this page, you can see the complete list of my books which I read about user interface and user experience design and its related topics.",
            "Flutter Developer": "On this page, you can see the complete list of my books which I read about flutter development and its related topics.",
            "Full Stack Developer": "On this page, you can see the complete list of my books which I read about full stack development and its related topics.",
            "Android Developer": "On this page, you can see the complete list of my books which I read about android development and its related topics.",
            "AI Engineer": "On this page, you can see the complete list of my books which I read about artificial intelligence engineering and its related topics.",
            "Industrial Designer": "On this page, you can see the complete list of my books which I read about industrial design and its related topics.",
            "Self-Driving Automobile Engineer": "On this page, you can see the complete list of my books which I read about self-driving automobile engineering and its related topics.",
            "Mechanical Engineer": "On this page, you can see the complete list of my books which I read about mechanical engineering and its related topics.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "As a Senior UI/UX Designer, I specialize in creating intuitive and engaging user interfaces that enhance user satisfaction. My approach integrates user research, design psychology, and the latest design trends to produce innovative and accessible designs. With a strong portfolio of successful projects, I have a proven ability to deliver designs that are not only aesthetically pleasing but also functionality seamless, resulting in improved user experiences and business outcomes.",
            "Flutter Developer": "As a Senior Flutter Developer, I am adept at building cross-platform applications that deliver a native experience on both Android and iOS. My extensive knowledge of Dart and the Flutter framework enables me to craft fluid UIs and maintainable codebases. I have a strong track record of successfully integrating complex functionalities with backend services, ensuring a seamless user journey.",
            "Full Stack Developer": "As a Senior Full Stack Developer, I bring a comprehensive skill set and a forward-thinking mindset to the development of full-stack applications. My expertise in both front-end and back-end technologies, including React, Node.js, and cloud services, allows me to build scalable, high-performance web applications that meet the strategic objectives of businesses.",
            "Android Developer": "As a Senior Android Developer, I have honed my skills in crafting robust and scalable Android applications, leveraging my deep understanding of the Android platform and ecosystem. My expertise in Kotlin, Java, and Android SDK, combined with a strong focus on clean architecture and design patterns, enables me to deliver applications with optimal performance and user experience.",
            "AI Engineer": "As a Senior AI Engineer, I am deeply immersed in the development and deployment of sophisticated artificial intelligence systems. My expertise lies in creating robust machine learning algorithms, pioneering advancements in deep learning, and implementing AI solutions that significantly enhance operational efficiency.",
            "Industrial Designer": "As a Senior Industrial Designer, I have a proven track record of developing innovative product designs that merge functionality with aesthetics. My expertise in 3D modeling, user-centered design, and material science has enabled me to lead design projects from ideation to manufacturing.",
            "Self-Driving Automobile Engineer": "As a Senior Self-Driving Automobile Engineer, I bring a wealth of experience in developing autonomous vehicle systems that prioritize safety and efficiency. My expertise spans sensor fusion, machine learning, and robotics control systems, enabling me to innovate cutting-edge solutions for the future of transportation. I have a proven track record of leading cross-functional teams to deliver complex projects that meet rigorous industry standards.",
            "Mechanical Engineer": "As a seasoned Mechanical Engineer, I bring a proven track record of designing and optimizing mechanical systems that enhance efficiency and performance. My expertise encompasses CAD modeling, thermal analysis, and materials engineering, allowing me to innovate solutions that meet the evolving demands of the industry. I am adept at leading projects from concept through production, ensuring that all mechanical components operate at peak functionality.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "See my UI and UX designing skill in action by seeing my done projects.",
            "Flutter Developer": "See my Flutter Development skills in action by seeing my done projects.",
            "Full Stack Developer": "See my Full Stack Development skills in action by seeing my done projects.",
            "Android Developer": "See my Android Development skills in action by seeing my done projects.",
            "AI Engineer": "See my Artificial Intelligence Engineering skills in action by seeing my done projects.",
            "Industrial Designer": "See my Industrial design skills in action by seeing my done projects.",
            "Self-Driving Automobile Engineer": "See my Self-Driving Automobile Engineering skills in action by seeing my done projects.",
            "Mechanical Engineer": "See my Mechanical Engineering skills in action by seeing my done projects.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "As a Senior User Interface and User Experience designer, see the courses that help me to build this skill.",
            "Flutter Developer": "As a Senior Flutter Developer, see the courses that help me to build this skill.",
            "Full Stack Developer": "As a Senior Full Stack Developer, see the courses that help me to build this skill.",
            "Android Developer": "As a Senior Android Developer, see the courses that help me to build this skill.",
            "AI Engineer": "As a Senior Artificial Intelligence Engineer, see the courses that help me to build this skill.",
            "Industrial Designer": "As a Senior Industrial Designer, see the courses that help me to build this skill.",
            "Self-Driving Automobile Engineer": "As a Senior Self-Driving Automobile Engineer, see the courses that help me to build this skill.",
            "Mechanical Engineer": "As a Seasoned Mechanical Engineer, see the courses that help me to build this skill.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "As a Senior User Interface and User Experience designer, see which books help me in the learning journey of this skill.",
            "Flutter Developer": "As a Senior Flutter Developer, see which books help me in the learning journey of this skill.",
            "Full Stack Developer": "As a Senior Full Stack Developer, see which books help me in the learning journey of this skill.",
            "Android Developer": "As a Senior Android Developer, see which books help me in the learning journey of this skill.",
            "AI Engineer": "As a Senior Artificial Intelligence Engineer, see which books help me in the learning journey of this skill.",
            "Industrial Designer": "As a Seasoned Industrial Designer, see which books help me in the learning journey of this skill.",
            "Self-Driving Automobile Engineer": "As a Senior Self-Driving Automobile Engineer, see which books help me in the learning journey of this skill.",
            "Mechanical Engineer": "As a Seasoned Mechanical Engineer, see which books help me in the learning journey of this skill.",
        },
        "AllRightsAreReservedLastView": "© 2024 Muhammad Husain Aboutalebi. All rights reserved.",
        "fontFamily": "'Roboto Condensed', sans-serif",
    },
    // German
    "Deutsch": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "Auf dieser Seite sehen Sie die vollständige Liste meiner Bücher, die ich über User Interface- und User Experience-Design und verwandte Themen gelesen habe.",
            "Flutter Developer": "Auf dieser Seite sehen Sie die vollständige Liste meiner Bücher, die ich über die Flutter-Entwicklung und verwandte Themen gelesen habe.",
            "Full Stack Developer": "Auf dieser Seite sehen Sie die vollständige Liste meiner Bücher, die ich über Full-Stack-Entwicklung und verwandte Themen gelesen habe.",
            "Android Developer": "Auf dieser Seite sehen Sie die vollständige Liste meiner Bücher, die ich über die Android-Entwicklung und verwandte Themen gelesen habe.",
            "AI Engineer": "Auf dieser Seite sehen Sie die vollständige Liste meiner Bücher, die ich über künstliche Intelligenz und verwandte Themen gelesen habe.",
            "Industrial Designer": "Auf dieser Seite sehen Sie die vollständige Liste meiner Bücher, die ich über Industriedesign und verwandte Themen gelesen habe.",
            "Self-Driving Automobile Engineer": "Auf dieser Seite finden Sie die vollständige Liste meiner Bücher, die ich über die Entwicklung selbstfahrender Autos und verwandte Themen gelesen habe.",
            "Mechanical Engineer": "Auf dieser Seite sehen Sie die vollständige Liste meiner Bücher, die ich über Maschinenbau und verwandte Themen gelesen habe.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "Als Senior UI/UX Designer bin ich auf die Erstellung intuitiver und ansprechender Benutzeroberflächen spezialisiert, die die Benutzerzufriedenheit steigern. Mein Ansatz integriert Benutzerforschung, Designpsychologie und die neuesten Designtrends, um innovative und zugängliche Designs zu erstellen. Mit einem umfangreichen Portfolio erfolgreicher Projekte verfüge ich nachweislich über die Fähigkeit, Designs zu liefern, die nicht nur ästhetisch ansprechend, sondern auch nahtlos funktional sind, was zu verbesserten Benutzererlebnissen und Geschäftsergebnissen führt.",
            "Flutter Developer": "Als Senior Flutter Developer bin ich in der Entwicklung plattformübergreifender Anwendungen versiert, die ein natives Erlebnis sowohl auf Android als auch auf iOS bieten. Meine umfassenden Kenntnisse über Dart und das Flutter-Framework ermöglichen es mir, flüssige Benutzeroberflächen und wartbare Codebasen zu erstellen. Ich verfüge über eine lange Erfolgsbilanz bei der erfolgreichen Integration komplexer Funktionalitäten in Backend-Dienste und stelle so eine nahtlose User Journey sicher.",
            "Full Stack Developer": "Als Senior Full-Stack-Entwickler bringe ich umfassende Fähigkeiten und eine zukunftsorientierte Denkweise in die Entwicklung von Full-Stack-Anwendungen ein. Mein Fachwissen sowohl in Front-End- als auch in Back-End-Technologien, einschließlich React, Node.js und Cloud-Services, ermöglicht es mir, skalierbare, leistungsstarke Webanwendungen zu erstellen, die die strategischen Ziele von Unternehmen erfüllen.",
            "Android Developer": "Als leitender Android-Entwickler habe ich meine Fähigkeiten in der Erstellung robuster und skalierbarer Android-Anwendungen verfeinert und dabei mein tiefes Verständnis der Android-Plattform und des Android-Ökosystems genutzt. Meine Fachkenntnisse in Kotlin, Java und Android SDK, kombiniert mit einem starken Fokus auf saubere Architektur und Designmuster, ermöglichen es mir, Anwendungen mit optimaler Leistung und Benutzererfahrung bereitzustellen.",
            "AI Engineer": "Als leitender KI-Ingenieur bin ich tief in die Entwicklung und den Einsatz anspruchsvoller Systeme der künstlichen Intelligenz vertieft. Meine Expertise liegt in der Entwicklung robuster Algorithmen für maschinelles Lernen, der Vorreiterrolle bei Fortschritten im Bereich Deep Learning und der Implementierung von KI-Lösungen, die die betriebliche Effizienz erheblich steigern.",
            "Industrial Designer": "Als Senior Industrial Designer verfüge ich über eine nachgewiesene Erfolgsbilanz bei der Entwicklung innovativer Produktdesigns, die Funktionalität mit Ästhetik verbinden. Meine Fachkenntnisse in 3D-Modellierung, benutzerzentriertem Design und Materialwissenschaft haben es mir ermöglicht, Designprojekte von der Idee bis zur Fertigung zu leiten.",
            "Self-Driving Automobile Engineer": "Als leitender Ingenieur für selbstfahrende Automobile bringe ich umfangreiche Erfahrung in der Entwicklung autonomer Fahrzeugsysteme mit, bei denen Sicherheit und Effizienz im Vordergrund stehen. Meine Fachkenntnisse umfassen Sensorfusion, maschinelles Lernen und Robotersteuerungssysteme und ermöglichen es mir, innovative Lösungen für die Zukunft des Transportwesens zu entwickeln. Ich verfüge über eine nachgewiesene Erfolgsbilanz bei der Leitung funktionsübergreifender Teams zur Umsetzung komplexer Projekte, die strengen Industriestandards entsprechen.",
            "Mechanical Engineer": "Als erfahrener Maschinenbauingenieur verfüge ich über eine nachgewiesene Erfolgsbilanz bei der Entwicklung und Optimierung mechanischer Systeme, die Effizienz und Leistung steigern. Meine Fachkenntnisse umfassen CAD-Modellierung, thermische Analyse und Werkstofftechnik und ermöglichen es mir, innovative Lösungen zu entwickeln, die den sich verändernden Anforderungen der Branche gerecht werden. Ich bin in der Lage, Projekte vom Konzept bis zur Produktion zu leiten und sicherzustellen, dass alle mechanischen Komponenten mit höchster Funktionalität funktionieren.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "Erleben Sie meine UI- und UX-Designfähigkeiten in Aktion, indem Sie meine abgeschlossenen Projekte sehen.",
            "Flutter Developer": "Erleben Sie meine Flutter-Entwicklungsfähigkeiten in Aktion, indem Sie meine abgeschlossenen Projekte sehen.",
            "Full Stack Developer": "Erleben Sie meine Full-Stack-Entwicklungsfähigkeiten in Aktion, indem Sie meine abgeschlossenen Projekte sehen.",
            "Android Developer": "Erleben Sie meine Android-Entwicklungsfähigkeiten in Aktion, indem Sie meine abgeschlossenen Projekte sehen.",
            "AI Engineer": "Erleben Sie meine Fähigkeiten im Bereich der künstlichen Intelligenz in Aktion, indem Sie meine abgeschlossenen Projekte sehen.",
            "Industrial Designer": "Erleben Sie meine Fähigkeiten im Bereich Industriedesign in Aktion, indem Sie meine abgeschlossenen Projekte sehen.",
            "Self-Driving Automobile Engineer": "Erleben Sie meine Fähigkeiten im Bereich der selbstfahrenden Automobiltechnik in Aktion, indem Sie meine abgeschlossenen Projekte sehen.",
            "Mechanical Engineer": "Erleben Sie meine Fähigkeiten im Bereich Maschinenbau in Aktion, indem Sie meine abgeschlossenen Projekte sehen.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "Sehen Sie sich als Senior User Interface- und User Experience-Designer die Kurse an, die mir beim Aufbau dieser Fähigkeiten helfen.",
            "Flutter Developer": "Sehen Sie sich als Senior Flutter Developer die Kurse an, die mir beim Aufbau dieser Fähigkeit helfen.",
            "Full Stack Developer": "Sehen Sie sich als Senior Full Stack Developer die Kurse an, die mir beim Aufbau dieser Fähigkeit helfen.",
            "Android Developer": "Sehen Sie sich als leitender Android-Entwickler die Kurse an, die mir beim Aufbau dieser Fähigkeit helfen.",
            "AI Engineer": "Sehen Sie sich als leitender Ingenieur für künstliche Intelligenz die Kurse an, die mir beim Aufbau dieser Fähigkeit helfen.",
            "Industrial Designer": "Sehen Sie sich als Senior Industrial Designer die Kurse an, die mir dabei helfen, diese Fähigkeit zu erwerben.",
            "Self-Driving Automobile Engineer": "Sehen Sie sich als Senior-Ingenieur für selbstfahrende Automobile die Kurse an, die mir beim Aufbau dieser Fähigkeit helfen.",
            "Mechanical Engineer": "Sehen Sie sich als erfahrener Maschinenbauingenieur die Kurse an, die mir beim Aufbau dieser Fähigkeiten helfen.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "Sehen Sie sich als Senior User Interface und User Experience Designer an, welche Bücher mir beim Erlernen dieser Fähigkeit helfen.",
            "Flutter Developer": "Sehen Sie sich als Senior Flutter Developer an, welche Bücher mir beim Erlernen dieser Fähigkeit helfen.",
            "Full Stack Developer": "Sehen Sie sich als Senior Full Stack Developer an, welche Bücher mir beim Erlernen dieser Fähigkeit helfen.",
            "Android Developer": "Sehen Sie sich als leitender Android-Entwickler an, welche Bücher mir beim Erlernen dieser Fähigkeit helfen.",
            "AI Engineer": "Erfahren Sie, welche Bücher mir als leitender Ingenieur für künstliche Intelligenz beim Erlernen dieser Fähigkeit helfen.",
            "Industrial Designer": "Sehen Sie sich als erfahrener Industriedesigner an, welche Bücher mir beim Erlernen dieser Fähigkeit helfen.",
            "Self-Driving Automobile Engineer": "Erfahren Sie, welche Bücher mir als leitender Ingenieur für selbstfahrende Automobile beim Erlernen dieser Fähigkeit helfen.",
            "Mechanical Engineer": "Erfahren Sie, welche Bücher mir als erfahrenem Maschinenbauingenieur beim Erlernen dieser Fähigkeit helfen.",
        },
        "AllRightsAreReservedLastView": "© 2024 Muhammad Husain Aboutalebi. Alle Rechte vorbehalten.",
        "fontFamily": "'Roboto Condensed', sans-serif",
    },
    // Chinese
    "中国人": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "在此页面上，您可以看到我阅读的有关用户界面和用户体验设计及其相关主题的书籍的完整列表。",
            "Flutter Developer": "在此页面上，您可以看到我阅读的有关 Flutter 开发及其相关主题的书籍的完整列表。",
            "Full Stack Developer": "在此页面上，您可以看到我阅读的有关全栈开发及其相关主题的书籍的完整列表。",
            "Android Developer": "在此页面上，您可以看到我阅读的有关 Android 开发及其相关主题的书籍的完整列表。",
            "AI Engineer": "在此页面上，您可以看到我阅读的有关人工智能工程及其相关主题的书籍的完整列表。",
            "Industrial Designer": "在此页面上，您可以看到我阅读的有关工业设计及其相关主题的书籍的完整列表。",
            "Self-Driving Automobile Engineer": "在此页面上，您可以看到我阅读的有关自动驾驶汽车工程及其相关主题的书籍的完整列表。",
            "Mechanical Engineer": "在此页面上，您可以看到我阅读的有关机械工程及其相关主题的书籍的完整列表。",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "作为一名高级 UI/UX 设计师，我专注于创建直观且引人入胜的用户界面，以提高用户满意度。 我的方法整合了用户研究、设计心理学和最新的设计趋势，以产生创新且易于理解的设计。 凭借强大的成功项目组合，我有能力提供不仅美观而且功能无缝的设计，从而改善用户体验和业务成果。",
            "Flutter Developer": "作为一名高级 Flutter 开发人员，我擅长构建跨平台应用程序，在 Android 和 iOS 上提供原生体验。 我对 Dart 和 Flutter 框架的广泛了解使我能够制作流畅的 UI 和可维护的代码库。 我在成功将复杂功能与后端服务集成、确保无缝用户旅程方面拥有良好的记录。",
            "Full Stack Developer": "作为一名高级全栈开发人员，我为全栈应用程序的开发带来了全面的技能和前瞻性思维。 我在前端和后端技术（包括 React、Node.js 和云服务）方面的专业知识使我能够构建可扩展、高性能的 Web 应用程序，以满足企业的战略目标。",
            "Android Developer": "作为一名高级 Android 开发人员，我利用对 Android 平台和生态系统的深刻理解，磨练了制作强大且可扩展的 Android 应用程序的技能。 我在 Kotlin、Java 和 Android SDK 方面的专业知识，加上对简洁架构和设计模式的强烈关注，使我能够交付具有最佳性能和用户体验的应用程序。",
            "AI Engineer": "作为一名高级人工智能工程师，我深深沉浸在复杂人工智能系统的开发和部署中。 我的专长在于创建强大的机器学习算法、开拓深度学习的进步以及实施可显着提高运营效率的人工智能解决方案。",
            "Industrial Designer": "作为一名高级工业设计师，我在开发将功能与美学融为一体的创新产品设计方面拥有良好的记录。 我在 3D 建模、以用户为中心的设计和材料科学方面的专业知识使我能够领导设计项目从构思到制造。",
            "Self-Driving Automobile Engineer": "作为一名高级自动驾驶汽车工程师，我在开发优先考虑安全性和效率的自动驾驶汽车系统方面拥有丰富的经验。 我的专业知识涵盖传感器融合、机器学习和机器人控制系统，使我能够为未来的交通创新尖端解决方案。 我在领导跨职能团队交付符合严格行业标准的复杂项目方面拥有良好的记录。",
            "Mechanical Engineer": "作为一名经验丰富的机械工程师，我在设计和优化机械系统以提高效率和性能方面拥有良好的记录。 我的专业知识涵盖 CAD 建模、热分析和材料工程，使我能够创新解决方案，以满足行业不断变化的需求。 我擅长领导从概念到生产的项目，确保所有机械部件都以最佳功能运行。",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "通过查看我完成的项目来了解我的 UI 和 UX 设计技能。",
            "Flutter Developer": "通过查看我完成的项目来了解我的 Flutter 开发技能。",
            "Full Stack Developer": "通过查看我完成的项目来了解我的全栈开发技能的实际应用。",
            "Android Developer": "通过查看我完成的项目来了解我的 Android 开发技能。",
            "AI Engineer": "通过查看我完成的项目来了解我的人工智能工程技能的实际应用。",
            "Industrial Designer": "通过查看我完成的项目来了解我的工业设计技能。",
            "Self-Driving Automobile Engineer": "通过查看我完成的项目来了解我的自动驾驶汽车工程技能的实际应用。",
            "Mechanical Engineer": "通过查看我完成的项目来了解我的机械工程技能的实际运用。",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "作为高级用户界面和用户体验设计师，请参阅帮助我培养此技能的课程。",
            "Flutter Developer": "作为高级 Flutter 开发人员，请参阅帮助我培养此技能的课程。",
            "Full Stack Developer": "作为高级全栈开发人员，请参阅帮助我培养此技能的课程。",
            "Android Developer": "作为高级 Android 开发人员，请参阅帮助我培养此技能的课程。",
            "AI Engineer": "作为高级人工智能工程师，请参阅帮助我培养此技能的课程。",
            "Industrial Designer": "作为高级工业设计师，请参阅帮助我培养这项技能的课程。",
            "Self-Driving Automobile Engineer": "作为高级自动驾驶汽车工程师，请参阅帮助我培养这项技能的课程。",
            "Mechanical Engineer": "作为一名经验丰富的机械工程师，请参阅帮助我培养这项技能的课程。",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "作为一名高级用户界面和用户体验设计师，看看哪些书籍可以帮助我完成这项技能的学习之旅。",
            "Flutter Developer": "作为一名高级 Flutter 开发人员，看看哪些书籍可以帮助我完成这项技能的学习之旅。",
            "Full Stack Developer": "作为一名高级全栈开发人员，看看哪些书籍可以帮助我完成这项技能的学习之旅。",
            "Android Developer": "作为一名高级 Android 开发人员，看看哪些书籍可以帮助我完成这项技能的学习之旅。",
            "AI Engineer": "作为一名高级人工智能工程师，看看哪些书籍可以帮助我完成这项技能的学习之旅。",
            "Industrial Designer": "作为一名经验丰富的工业设计师，看看哪些书籍可以帮助我学习这项技能。",
            "Self-Driving Automobile Engineer": "作为一名高级自动驾驶汽车工程师，看看哪些书籍可以帮助我完成这项技能的学习之旅。",
            "Mechanical Engineer": "作为一名经验丰富的机械工程师，看看哪些书籍可以帮助我完成这项技能的学习之旅。",
        },
        "AllRightsAreReservedLastView": "© 2024 穆罕默德·侯赛因·阿布塔莱比。 版权所有。",
        "fontFamily": "'Ma Shan Zheng', serif",
    },
    // Russian
    "Русский": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "На этой странице вы можете увидеть полный список моих книг, которые я прочитал о пользовательском интерфейсе и дизайне пользовательского опыта, а также связанных с этим темах.",
            "Flutter Developer": "На этой странице вы можете увидеть полный список моих книг о разработке флаттера и связанных с этим темах, которые я прочитал.",
            "Full Stack Developer": "На этой странице вы можете увидеть полный список моих книг о фуллстековой разработке и связанных с ней темах, которые я прочитал.",
            "Android Developer": "На этой странице вы можете увидеть полный список моих книг о разработке под Android и связанных с ней темах, которые я прочитал.",
            "AI Engineer": "На этой странице вы можете увидеть полный список моих книг о разработке искусственного интеллекта и связанных с ней темах, которые я прочитал.",
            "Industrial Designer": "На этой странице вы можете увидеть полный список моих книг о промышленном дизайне и связанных с ним темах, которые я прочитал.",
            "Self-Driving Automobile Engineer": "На этой странице вы можете увидеть полный список моих книг о беспилотных автомобилях и связанных с ними темах, которые я прочитал.",
            "Mechanical Engineer": "На этой странице вы можете увидеть полный список моих книг о машиностроении и связанных с ним темах, которые я прочитал.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "Как старший UI/UX-дизайнер, я специализируюсь на создании интуитивно понятных и привлекательных пользовательских интерфейсов, которые повышают удовлетворенность пользователей. Мой подход объединяет исследования пользователей, психологию дизайна и последние тенденции дизайна для создания инновационных и доступных проектов. Обладая обширным портфолио успешных проектов, я доказал свою способность создавать проекты, которые не только эстетически приятны, но и безупречны по функциональности, что приводит к улучшению пользовательского опыта и бизнес-результатов.",
            "Flutter Developer": "Как старший разработчик Flutter, я умею создавать кроссплатформенные приложения, которые обеспечивают удобство работы как на Android, так и на iOS. Мои обширные знания Dart и среды Flutter позволяют мне создавать гибкие пользовательские интерфейсы и поддерживаемые базы кода. У меня большой опыт успешной интеграции сложных функций с серверными службами, обеспечивающих бесперебойную работу пользователя.",
            "Full Stack Developer": "Как старший Full Stack Developer, я привношу обширный набор навыков и дальновидный подход к разработке полнофункциональных приложений. Мой опыт работы как с интерфейсными, так и с серверными технологиями, включая React, Node.js и облачные сервисы, позволяет мне создавать масштабируемые, высокопроизводительные веб-приложения, отвечающие стратегическим целям бизнеса.",
            "Android Developer": "Будучи старшим разработчиком Android, я оттачивал свои навыки создания надежных и масштабируемых приложений для Android, используя свое глубокое понимание платформы и экосистемы Android. Мой опыт работы с Kotlin, Java и Android SDK в сочетании с сильным вниманием к чистой архитектуре и шаблонам проектирования позволяет мне создавать приложения с оптимальной производительностью и удобством для пользователей.",
            "AI Engineer": "Будучи старшим инженером по искусственному интеллекту, я глубоко погружен в разработку и внедрение сложных систем искусственного интеллекта. Мой опыт заключается в создании надежных алгоритмов машинного обучения, новаторских достижениях в области глубокого обучения и внедрении решений искусственного интеллекта, которые значительно повышают операционную эффективность.",
            "Industrial Designer": "Как старший промышленный дизайнер, я имею успешный опыт разработки инновационных продуктов, сочетающих в себе функциональность и эстетику. Мой опыт в области 3D-моделирования, пользовательско-ориентированного проектирования и материаловедения позволил мне вести дизайнерские проекты от идеи до производства.",
            "Self-Driving Automobile Engineer": "Будучи старшим инженером по беспилотным автомобилям, я обладаю богатым опытом разработки автономных транспортных систем, в которых безопасность и эффективность имеют приоритет. Мой опыт охватывает синтез датчиков, машинное обучение и системы управления робототехникой, что позволяет мне внедрять передовые решения для будущего транспорта. У меня есть успешный опыт руководства межфункциональными командами для реализации сложных проектов, соответствующих строгим отраслевым стандартам.",
            "Mechanical Engineer": "Как опытный инженер-механик, я имею успешный опыт проектирования и оптимизации механических систем, которые повышают эффективность и производительность. Мой опыт охватывает CAD-моделирование, термический анализ и инженерию материалов, что позволяет мне предлагать инновационные решения, отвечающие меняющимся потребностям отрасли. Я умею вести проекты от концепции до производства, гарантируя, что все механические компоненты работают с максимальной функциональностью.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "Посмотрите мои реализованные проекты и посмотрите на мои навыки проектирования пользовательского интерфейса и UX в действии.",
            "Flutter Developer": "Посмотрите мои навыки разработки Flutter в действии, просмотрев мои выполненные проекты.",
            "Full Stack Developer": "Посмотрите мои навыки разработки полного стека в действии, просмотрев мои выполненные проекты.",
            "Android Developer": "Посмотрите на мои навыки разработки Android в действии, просмотрев мои выполненные проекты.",
            "AI Engineer": "Посмотрите мои реализованные проекты в области искусственного интеллекта в действии.",
            "Industrial Designer": "Посмотрите на мои навыки промышленного дизайна в действии, просмотрев мои выполненные проекты.",
            "Self-Driving Automobile Engineer": "Посмотрите мои реализованные проекты, чтобы увидеть мои навыки в области разработки беспилотных автомобилей в действии.",
            "Mechanical Engineer": "Посмотрите на мои навыки в области машиностроения в действии, просмотрев мои выполненные проекты.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "Как старший дизайнер пользовательского интерфейса и пользовательского опыта, ознакомьтесь с курсами, которые помогут мне развить этот навык.",
            "Flutter Developer": "Как старший разработчик Flutter, ознакомьтесь с курсами, которые помогут мне развить этот навык.",
            "Full Stack Developer": "Как старший Full Stack разработчик, ознакомьтесь с курсами, которые помогут мне развить этот навык.",
            "Android Developer": "Как старший разработчик Android, ознакомьтесь с курсами, которые помогут мне развить этот навык.",
            "AI Engineer": "Как старший инженер по искусственному интеллекту, ознакомьтесь с курсами, которые помогут мне развить этот навык.",
            "Industrial Designer": "Как старший промышленный дизайнер, ознакомьтесь с курсами, которые помогут мне развить этот навык.",
            "Self-Driving Automobile Engineer": "Как старший инженер по беспилотным автомобилям, ознакомьтесь с курсами, которые помогут мне развить этот навык.",
            "Mechanical Engineer": "Как опытный инженер-механик, ознакомьтесь с курсами, которые помогут мне развить этот навык.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "Как старший дизайнер пользовательского интерфейса и пользовательского опыта, узнайте, какие книги помогают мне в освоении этого навыка.",
            "Flutter Developer": "Как старший разработчик Flutter, узнайте, какие книги помогают мне в освоении этого навыка.",
            "Full Stack Developer": "Как старший Full Stack разработчик, узнайте, какие книги помогают мне в освоении этого навыка.",
            "Android Developer": "Как старший разработчик Android, узнайте, какие книги помогают мне в освоении этого навыка.",
            "AI Engineer": "Как старший инженер по искусственному интеллекту, узнайте, какие книги помогают мне в освоении этого навыка.",
            "Industrial Designer": "Как опытному промышленному дизайнеру, посмотрите, какие книги помогают мне в освоении этого навыка.",
            "Self-Driving Automobile Engineer": "Как старший инженер по беспилотным автомобилям, узнайте, какие книги помогают мне в освоении этого навыка.",
            "Mechanical Engineer": "Как опытному инженеру-механику, посмотрите, какие книги помогают мне в освоении этого навыка.",
        },
        "AllRightsAreReservedLastView": "© 2024 Мухаммад Хусейн Обалеби. Все права защищены.",
        "fontFamily": "'Roboto Condensed', sans-serif",
    },
    // French
    "Français": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "Sur cette page, vous pouvez voir la liste complète de mes livres que j'ai lus sur la conception de l'interface utilisateur et de l'expérience utilisateur et ses sujets connexes.",
            "Flutter Developer": "Sur cette page, vous pouvez voir la liste complète de mes livres que j'ai lus sur le développement de Flutter et ses sujets connexes.",
            "Full Stack Developer": "Sur cette page, vous pouvez voir la liste complète de mes livres que j'ai lus sur le développement full stack et ses sujets connexes.",
            "Android Developer": "Sur cette page, vous pouvez voir la liste complète de mes livres que j'ai lus sur le développement Android et ses sujets connexes.",
            "AI Engineer": "Sur cette page, vous pouvez voir la liste complète de mes livres que j'ai lus sur l'ingénierie de l'intelligence artificielle et ses sujets connexes.",
            "Industrial Designer": "Sur cette page, vous pouvez voir la liste complète de mes livres que j'ai lus sur le design industriel et ses sujets connexes.",
            "Self-Driving Automobile Engineer": "Sur cette page, vous pouvez voir la liste complète de mes livres que j'ai lus sur l'ingénierie automobile autonome et ses sujets connexes.",
            "Mechanical Engineer": "Sur cette page, vous pouvez voir la liste complète de mes livres que j'ai lus sur le génie mécanique et ses sujets connexes.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "En tant que Senior UI/UX Designer, je me spécialise dans la création d'interfaces utilisateur intuitives et attrayantes qui améliorent la satisfaction des utilisateurs. Mon approche intègre la recherche sur les utilisateurs, la psychologie du design et les dernières tendances du design pour produire des designs innovants et accessibles. Avec un solide portefeuille de projets réussis, j'ai une capacité avérée à proposer des conceptions non seulement esthétiques, mais également fonctionnelles, améliorant ainsi l'expérience utilisateur et les résultats commerciaux.",
            "Flutter Developer": "En tant que développeur Flutter senior, je suis expert dans la création d'applications multiplateformes offrant une expérience native sur Android et iOS. Ma connaissance approfondie de Dart et du framework Flutter me permet de créer des interfaces utilisateur fluides et des bases de code maintenables. J'ai une solide expérience dans l'intégration réussie de fonctionnalités complexes avec des services backend, garantissant ainsi un parcours utilisateur fluide.",
            "Full Stack Developer": "En tant que développeur Full Stack senior, j'apporte un ensemble complet de compétences et un état d'esprit avant-gardiste au développement d'applications full-stack. Mon expertise dans les technologies front-end et back-end, notamment React, Node.js et les services cloud, me permet de créer des applications Web évolutives et performantes qui répondent aux objectifs stratégiques des entreprises.",
            "Android Developer": "En tant que développeur Android senior, j'ai perfectionné mes compétences dans la création d'applications Android robustes et évolutives, en tirant parti de ma compréhension approfondie de la plate-forme et de l'écosystème Android. Mon expertise dans les SDK Kotlin, Java et Android, combinée à une forte concentration sur une architecture et des modèles de conception propres, me permet de fournir des applications avec des performances et une expérience utilisateur optimales.",
            "AI Engineer": "En tant qu'ingénieur senior en IA, je suis profondément immergé dans le développement et le déploiement de systèmes d'intelligence artificielle sophistiqués. Mon expertise réside dans la création d'algorithmes d'apprentissage automatique robustes, les avancées pionnières en matière d'apprentissage profond et la mise en œuvre de solutions d'IA qui améliorent considérablement l'efficacité opérationnelle.",
            "Industrial Designer": "En tant que designer industriel senior, j'ai fait ses preuves dans le développement de conceptions de produits innovants qui allient fonctionnalité et esthétique. Mon expertise en modélisation 3D, en conception centrée utilisateur et en science des matériaux m'a permis de diriger des projets de conception, de l'idéation à la fabrication.",
            "Self-Driving Automobile Engineer": "En tant qu'ingénieur automobile autonome senior, j'apporte une riche expérience dans le développement de systèmes de véhicules autonomes qui privilégient la sécurité et l'efficacité. Mon expertise couvre la fusion de capteurs, l'apprentissage automatique et les systèmes de contrôle robotique, me permettant d'innover des solutions de pointe pour l'avenir du transport. J'ai fait ses preuves dans la direction d'équipes interfonctionnelles pour réaliser des projets complexes répondant aux normes rigoureuses de l'industrie.",
            "Mechanical Engineer": "En tant qu'ingénieur mécanique chevronné, j'apporte une expérience éprouvée dans la conception et l'optimisation de systèmes mécaniques qui améliorent l'efficacité et les performances. Mon expertise englobe la modélisation CAO, l'analyse thermique et l'ingénierie des matériaux, me permettant d'innover des solutions qui répondent aux demandes évolutives de l'industrie. Je suis apte à diriger des projets depuis la conception jusqu'à la production, en veillant à ce que tous les composants mécaniques fonctionnent au maximum de leurs fonctionnalités.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "Découvrez mes compétences en conception UI et UX en action en voyant mes projets réalisés.",
            "Flutter Developer": "Découvrez mes compétences en développement Flutter en action en voyant mes projets réalisés.",
            "Full Stack Developer": "Découvrez mes compétences en développement Full Stack en action en voyant mes projets réalisés.",
            "Android Developer": "Découvrez mes compétences en développement Android en action en consultant mes projets réalisés.",
            "AI Engineer": "Découvrez mes compétences en ingénierie de l'intelligence artificielle en action en voyant mes projets réalisés.",
            "Industrial Designer": "Découvrez mes compétences en design industriel en action en voyant mes projets réalisés.",
            "Self-Driving Automobile Engineer": "Découvrez mes compétences en ingénierie automobile autonome en action en voyant mes projets réalisés.",
            "Mechanical Engineer": "Découvrez mes compétences en génie mécanique en action en voyant mes projets réalisés.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "En tant que concepteur senior d'interface utilisateur et d'expérience utilisateur, consultez les cours qui m'aident à développer cette compétence.",
            "Flutter Developer": "En tant que développeur Flutter senior, consultez les cours qui m'aident à développer cette compétence.",
            "Full Stack Developer": "En tant que développeur Full Stack senior, consultez les cours qui m'aident à développer cette compétence.",
            "Android Developer": "En tant que développeur Android senior, consultez les cours qui m'aident à développer cette compétence.",
            "AI Engineer": "En tant qu'ingénieur senior en intelligence artificielle, découvrez les cours qui m'aident à développer cette compétence.",
            "Industrial Designer": "En tant que designer industriel senior, découvrez les cours qui m'aident à développer cette compétence.",
            "Self-Driving Automobile Engineer": "En tant qu'ingénieur automobile autonome senior, consultez les cours qui m'aident à développer cette compétence.",
            "Mechanical Engineer": "En tant qu'ingénieur mécanique chevronné, consultez les cours qui m'aident à développer cette compétence.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "En tant que concepteur senior d'interface utilisateur et d'expérience utilisateur, découvrez quels livres m'aident dans le parcours d'apprentissage de cette compétence.",
            "Flutter Developer": "En tant que développeur Flutter senior, découvrez quels livres m'aident dans le parcours d'apprentissage de cette compétence.",
            "Full Stack Developer": "En tant que développeur Full Stack senior, découvrez quels livres m'aident dans le parcours d'apprentissage de cette compétence.",
            "Android Developer": "En tant que développeur Android senior, découvrez quels livres m'aident dans le parcours d'apprentissage de cette compétence.",
            "AI Engineer": "En tant qu'ingénieur senior en intelligence artificielle, découvrez quels livres m'aident dans le parcours d'apprentissage de cette compétence.",
            "Industrial Designer": "En tant que designer industriel chevronné, découvrez quels livres m'aident dans l'apprentissage de cette compétence.",
            "Self-Driving Automobile Engineer": "En tant qu'ingénieur automobile autonome senior, découvrez quels livres m'aident dans le parcours d'apprentissage de cette compétence.",
            "Mechanical Engineer": "En tant qu'ingénieur mécanique chevronné, découvrez quels livres m'aident dans le parcours d'apprentissage de cette compétence.",
        },
        "AllRightsAreReservedLastView": "© 2024 Muhammad Husain Aboutalebi. Tous droits réservés.",
        "fontFamily": "'Roboto Condensed', sans-serif",
    },
    // Japanese
    "日本語": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "このページでは、ユーザー インターフェイスとユーザー エクスペリエンス デザイン、およびその関連トピックについて私が読んだ本の完全なリストを見ることができます。",
            "Flutter Developer": "このページでは、私が読んだフラッター開発と関連トピックに関する書籍の完全なリストを見ることができます。",
            "Full Stack Developer": "このページでは、フルスタック開発とその関連トピックについて私が読んだ本の完全なリストを見ることができます。",
            "Android Developer": "このページでは、Android 開発とその関連トピックについて私が読んだ本の完全なリストを見ることができます。",
            "AI Engineer": "このページでは、私が人工知能工学とその関連トピックについて読んだ本の完全なリストを見ることができます。",
            "Industrial Designer": "このページでは、私が工業デザインとその関連トピックについて読んだ本の完全なリストを見ることができます。",
            "Self-Driving Automobile Engineer": "このページでは、自動運転自動車工学とその関連トピックについて私が読んだ本の完全なリストを見ることができます。",
            "Mechanical Engineer": "このページでは、私が機械工学とその関連トピックについて読んだ本の完全なリストを見ることができます。",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "シニア ユーザー インターフェイスおよびユーザー エクスペリエンス デザイナーとして、私はユーザーの満足度を高める直感的で魅力的なユーザー インターフェイスの作成を専門としています。 私のアプローチは、ユーザー調査、デザイン心理学、最新のデザイントレンドを統合して、革新的でアクセスしやすいデザインを生み出します。 成功したプロジェクトの強力なポートフォリオにより、私は見た目が美しいだけでなく、シームレスな機能を備えたデザインを提供し、その結果、ユーザー エクスペリエンスとビジネス成果が向上するという実証済みの能力を持っています。",
            "Flutter Developer": "私はシニア Flutter 開発者として、Android と iOS の両方でネイティブ エクスペリエンスを提供するクロスプラットフォーム アプリケーションの構築に熟達しています。 Dart と Flutter フレームワークに関する広範な知識により、滑らかな UI と保守可能なコードベースを作成することができます。 私には、複雑な機能をバックエンド サービスとうまく統合し、シームレスなユーザー ジャーニーを保証するという強力な実績があります。",
            "Full Stack Developer": "上級フルスタック開発者として、私はフルスタック アプリケーションの開発に包括的なスキルセットと先進的な考え方をもたらします。 React、Node.js、クラウド サービスなど、フロントエンドとバックエンドの両方のテクノロジに関する私の専門知識により、ビジネスの戦略目標を満たすスケーラブルで高性能な Web アプリケーションを構築できます。",
            "Android Developer": "私はシニア Android 開発者として、Android プラットフォームとエコシステムについての深い理解を活用して、堅牢でスケーラブルな Android アプリケーションを作成するスキルを磨いてきました。 Kotlin、Java、Android SDK に関する私の専門知識と、クリーンなアーキテクチャとデザイン パターンに重点を置くことにより、最適なパフォーマンスとユーザー エクスペリエンスを備えたアプリケーションを提供できるようになります。",
            "AI Engineer": "私はシニア AI エンジニアとして、高度な人工知能システムの開発と導入に深く関わっています。 私の専門知識は、堅牢な機械学習アルゴリズムの作成、深層学習の先駆的な進歩、および業務効率を大幅に向上させる AI ソリューションの実装にあります。",
            "Industrial Designer": "私は上級工業デザイナーとして、機能性と美しさを融合させた革新的な製品デザインを開発してきた実績があります。 3D モデリング、ユーザー中心の設計、材料科学に関する専門知識により、アイデアから製造まで設計プロジェクトを主導することができました。",
            "Self-Driving Automobile Engineer": "私は自動運転自動車の上級エンジニアとして、安全性と効率性を優先した自動運転車システムの開発に豊富な経験を持っています。 私の専門知識はセンサー フュージョン、機械学習、ロボティクス制御システムに及び、交通の未来に向けた最先端のソリューションを革新することができます。 私には、厳格な業界基準を満たす複雑なプロジェクトを遂行するために、部門を超えたチームを率いてきた実績があります。",
            "Mechanical Engineer": "私は経験豊富な機械エンジニアとして、効率とパフォーマンスを向上させる機械システムの設計と最適化において確かな実績をもたらしています。 私の専門知識には CAD モデリング、熱解析、材料工学が含まれており、進化する業界の需要を満たすソリューションを革新することができます。 私は、コンセプトから生産に至るまでプロジェクトを主導し、すべての機械コンポーネントが最高の機能で動作することを保証することに熟達しています。",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "完成したプロジェクトを見て、ユーザー インターフェイスとユーザー エクスペリエンスのデザイン スキルが実際に動作していることを確認してください。",
            "Flutter Developer": "私の完了したプロジェクトを見て、実際の Flutter 開発スキルを確認してください。",
            "Full Stack Developer": "私の完了したプロジェクトを見て、私のフルスタック開発スキルが実際に動作していることを確認してください。",
            "Android Developer": "私の完成したプロジェクトを見て、Android 開発スキルが実際に動作していることを確認してください。",
            "AI Engineer": "私の完成したプロジェクトを見て、人工知能エンジニアリングのスキルが実際に動作していることを確認してください。",
            "Industrial Designer": "私の完成したプロジェクトを見て、私の工業デザインスキルが実際に動作していることを確認してください。",
            "Self-Driving Automobile Engineer": "私の完了したプロジェクトを見て、自動運転自動車エンジニアリングのスキルが実際に動作していることを確認してください。",
            "Mechanical Engineer": "私の完成したプロジェクトを見て、機械工学のスキルが実際にどのように機能しているかを確認してください。",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "上級ユーザー インターフェイスおよびユーザー エクスペリエンス デザイナーとして、このスキルを構築するのに役立つコースをご覧ください。",
            "Flutter Developer": "上級 Flutter 開発者として、このスキルを構築するのに役立つコースをご覧ください。",
            "Full Stack Developer": "上級フルスタック開発者として、このスキルを構築するのに役立つコースをご覧ください。",
            "Android Developer": "上級 Android 開発者として、このスキルの構築に役立つコースをご覧ください。",
            "AI Engineer": "上級人工知能エンジニアとして、このスキルを構築するのに役立つコースをご覧ください。",
            "Industrial Designer": "シニア インダストリアル デザイナーとして、このスキルを身に付けるのに役立つコースをご覧ください。",
            "Self-Driving Automobile Engineer": "上級自動運転自動車エンジニアとして、このスキルを身に付けるのに役立つコースをご覧ください。",
            "Mechanical Engineer": "経験豊かな機械エンジニアとして、このスキルを身に付けるのに役立つコースをご覧ください。",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "上級ユーザー インターフェイスおよびユーザー エクスペリエンス デザイナーとして、このスキルの学習に役立つ書籍をご覧ください。",
            "Flutter Developer": "上級 Flutter 開発者として、このスキルの学習にどの書籍が役立つかを確認してください。",
            "Full Stack Developer": "上級フルスタック開発者として、このスキルの学習にどの書籍が役立つかを確認してください。",
            "Android Developer": "上級 Android 開発者として、このスキルの学習に役立つ書籍をご覧ください。",
            "AI Engineer": "上級人工知能エンジニアとして、このスキルの学習に役立つ書籍をご覧ください。",
            "Industrial Designer": "経験豊富な工業デザイナーとして、このスキルの学習に役立つ本をご覧ください。",
            "Self-Driving Automobile Engineer": "上級自動運転自動車エンジニアとして、このスキルの学習に役立つ書籍をご覧ください。",
            "Mechanical Engineer": "経験豊富な機械エンジニアとして、このスキルの学習に役立つ書籍をご覧ください。",
        },
        "AllRightsAreReservedLastView": "© 2024 ムハマド・フセイン アバウトアレビ。 無断転載を禁じます。",
        "fontFamily": "'Hina Mincho', serif",
    },
    // Korean
    "한국인": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "이 페이지에서는 사용자 인터페이스, 사용자 경험 디자인 및 관련 주제에 대해 내가 읽은 책의 전체 목록을 볼 수 있습니다.",
            "Flutter Developer": "이 페이지에서는 Flutter 개발 및 관련 주제에 관해 제가 읽은 책의 전체 목록을 볼 수 있습니다.",
            "Full Stack Developer": "이 페이지에서는 내가 풀 스택 개발 및 관련 주제에 대해 읽은 책의 전체 목록을 볼 수 있습니다.",
            "Android Developer": "이 페이지에서는 내가 안드로이드 개발 및 관련 주제에 대해 읽은 책의 전체 목록을 볼 수 있습니다.",
            "AI Engineer": "이 페이지에서는 인공 지능 공학 및 관련 주제에 대해 내가 읽은 책의 전체 목록을 볼 수 있습니다.",
            "Industrial Designer": "이 페이지에서는 산업 디자인 및 관련 주제에 관해 내가 읽은 책의 전체 목록을 볼 수 있습니다.",
            "Self-Driving Automobile Engineer": "이 페이지에서는 자율주행 자동차 공학 및 관련 주제에 대해 내가 읽은 책의 전체 목록을 볼 수 있습니다.",
            "Mechanical Engineer": "이 페이지에서는 기계 공학 및 관련 주제에 관해 내가 읽은 책의 전체 목록을 볼 수 있습니다.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "저는 수석 사용자 인터페이스 및 사용자 경험 디자이너로서 사용자 만족도를 높이는 직관적이고 매력적인 사용자 인터페이스를 만드는 것을 전문으로 합니다. 나의 접근 방식은 사용자 연구, 디자인 심리학, 최신 디자인 트렌드를 통합하여 혁신적이고 접근하기 쉬운 디자인을 만들어냅니다. 성공적인 프로젝트로 구성된 강력한 포트폴리오를 통해 저는 미학적으로 만족스러울 뿐만 아니라 기능적으로도 원활한 디자인을 제공하여 사용자 경험과 비즈니스 성과를 향상시킬 수 있는 입증된 능력을 보유하고 있습니다.",
            "Flutter Developer": "선임 Flutter 개발자로서 저는 Android와 iOS 모두에서 기본 경험을 제공하는 크로스 플랫폼 애플리케이션을 구축하는 데 능숙합니다. Dart와 Flutter 프레임워크에 대한 폭넓은 지식을 통해 유연한 UI와 유지 관리 가능한 코드베이스를 만들 수 있습니다. 저는 복잡한 기능을 백엔드 서비스와 성공적으로 통합하여 원활한 사용자 여정을 보장한 강력한 실적을 보유하고 있습니다.",
            "Full Stack Developer": "저는 수석 풀스택 개발자로서 풀스택 애플리케이션 개발에 포괄적인 기술과 미래 지향적인 사고방식을 적용합니다. React, Node.js 및 클라우드 서비스를 포함한 프런트엔드 및 백엔드 기술에 대한 전문 지식을 통해 비즈니스의 전략적 목표를 충족하는 확장 가능한 고성능 웹 애플리케이션을 구축할 수 있습니다.",
            "Android Developer": "선임 Android 개발자로서 저는 Android 플랫폼과 생태계에 대한 깊은 이해를 활용하여 강력하고 확장 가능한 Android 애플리케이션을 제작하는 기술을 연마했습니다. Kotlin, Java 및 Android SDK에 대한 전문 지식과 깔끔한 아키텍처 및 디자인 패턴에 대한 강한 집중을 통해 최적의 성능과 사용자 경험을 갖춘 애플리케이션을 제공할 수 있습니다.",
            "AI Engineer": "저는 수석 인공지능 엔지니어로서 정교한 인공지능 시스템의 개발과 배포에 깊이 관여하고 있습니다. 저의 전문 분야는 강력한 기계 학습 알고리즘을 만들고, 딥 러닝의 발전을 선도하며, 운영 효율성을 크게 향상시키는 AI 솔루션을 구현하는 것입니다.",
            "Industrial Designer": "저는 수석 산업 디자이너로서 기능성과 미학을 결합한 혁신적인 제품 디자인을 개발한 입증된 실적을 보유하고 있습니다. 3D 모델링, 사용자 중심 디자인, 재료 과학에 대한 전문 지식을 바탕으로 아이디어 구상부터 제조까지 디자인 프로젝트를 주도할 수 있었습니다.",
            "Self-Driving Automobile Engineer": "저는 수석 자율주행 자동차 엔지니어로서 안전과 효율성을 우선시하는 자율주행 자동차 시스템 개발에 대한 풍부한 경험을 갖고 있습니다. 저의 전문 지식은 센서 융합, 기계 학습, 로봇 제어 시스템에 걸쳐 있어 미래 교통 수단을 위한 최첨단 솔루션을 혁신할 수 있습니다. 저는 엄격한 업계 표준을 충족하는 복잡한 프로젝트를 제공하기 위해 다기능 팀을 이끄는 입증된 실적을 보유하고 있습니다.",
            "Mechanical Engineer": "노련한 기계 엔지니어로서 저는 효율성과 성능을 향상시키는 기계 시스템을 설계하고 최적화하는 입증된 실적을 보유하고 있습니다. 저의 전문 지식은 CAD 모델링, 열 분석 및 재료 엔지니어링을 포괄하므로 진화하는 업계 요구 사항을 충족하는 솔루션을 혁신할 수 있습니다. 저는 개념부터 생산까지 프로젝트를 주도하는 데 능숙하여 모든 기계 구성 요소가 최고의 기능으로 작동하도록 보장합니다.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "내가 완료한 프로젝트를 보고 나의 사용자 인터페이스 및 사용자 경험 디자인 기술이 실제로 작동하는지 확인하세요.",
            "Flutter Developer": "내가 완료한 프로젝트를 보고 Flutter 개발 기술이 실제로 사용되는 모습을 확인하세요.",
            "Full Stack Developer": "내가 완료한 프로젝트를 보고 나의 풀 스택 개발 기술이 어떻게 작동하는지 확인하세요.",
            "Android Developer": "내가 완료한 프로젝트를 보고 실제 Android 개발 기술을 확인하세요.",
            "AI Engineer": "내가 완료한 프로젝트를 보고 실제 인공지능 엔지니어링 기술을 확인하세요.",
            "Industrial Designer": "내가 완료한 프로젝트를 보고 실제 산업 디자인 기술을 확인하세요.",
            "Self-Driving Automobile Engineer": "내가 완료한 프로젝트를 통해 나의 자율주행 자동차 엔지니어링 기술이 실제로 작동하는 모습을 확인하세요.",
            "Mechanical Engineer": "내가 완료한 프로젝트를 보고 실제 기계 공학 기술을 확인하세요.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "수석 사용자 인터페이스 및 사용자 경험 디자이너로서 이 기술을 구축하는 데 도움이 되는 과정을 참조하세요.",
            "Flutter Developer": "선임 Flutter 개발자로서 이 기술을 구축하는 데 도움이 되는 과정을 확인하세요.",
            "Full Stack Developer": "수석 풀스택 개발자로서 이 기술을 구축하는 데 도움이 되는 과정을 확인하세요.",
            "Android Developer": "선임 Android 개발자로서 이 기술을 구축하는 데 도움이 되는 과정을 확인하세요.",
            "AI Engineer": "수석 인공 지능 엔지니어로서 이 기술을 구축하는 데 도움이 되는 과정을 확인하세요.",
            "Industrial Designer": "수석 산업 디자이너로서 이 기술을 구축하는 데 도움이 되는 과정을 확인하세요.",
            "Self-Driving Automobile Engineer": "수석 자율주행차 엔지니어로서 제가 이 기술을 익히는 데 도움이 되는 강좌를 확인해 보세요.",
            "Mechanical Engineer": "숙련된 기계 엔지니어로서 이 기술을 구축하는 데 도움이 되는 과정을 확인하세요.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "수석 사용자 인터페이스 및 사용자 경험 디자이너로서 이 기술의 학습 여정에 어떤 책이 도움이 되는지 확인하세요.",
            "Flutter Developer": "선임 Flutter 개발자로서 이 기술을 학습하는 데 어떤 책이 도움이 되는지 알아보세요.",
            "Full Stack Developer": "수석 풀스택 개발자로서 이 기술을 학습하는 데 어떤 책이 도움이 되는지 알아보세요.",
            "Android Developer": "선임 Android 개발자로서 이 기술을 학습하는 데 어떤 책이 도움이 되는지 알아보세요.",
            "AI Engineer": "수석 인공 지능 엔지니어로서 이 기술을 학습하는 데 어떤 책이 도움이 되는지 알아보세요.",
            "Industrial Designer": "숙련된 산업 디자이너로서 이 기술을 학습하는 데 어떤 책이 도움이 되는지 확인하세요.",
            "Self-Driving Automobile Engineer": "수석 자율주행차 엔지니어로서 이 기술을 학습하는 데 어떤 책이 도움이 되는지 알아보세요.",
            "Mechanical Engineer": "노련한 기계 엔지니어로서 이 기술을 배우는 과정에서 어떤 책이 도움이 되는지 알아보세요.",
        },
        "AllRightsAreReservedLastView": "© 2024 무하마드 후세인 아바탈레비. 판권 소유.",
        "fontFamily": "'Gowun Batang', serif",
    },
    // Spanish
    "Español": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "En esta página, puede ver la lista completa de mis libros que leí sobre interfaz de usuario y diseño de experiencia de usuario y sus temas relacionados.",
            "Flutter Developer": "En esta página, puedes ver la lista completa de mis libros que leí sobre el desarrollo de Flutter y sus temas relacionados.",
            "Full Stack Developer": "En esta página, puede ver la lista completa de mis libros que leí sobre el desarrollo completo y sus temas relacionados.",
            "Android Developer": "En esta página, puedes ver la lista completa de mis libros que leí sobre el desarrollo de Android y sus temas relacionados.",
            "AI Engineer": "En esta página puedes ver la lista completa de mis libros que leí sobre ingeniería de inteligencia artificial y sus temas relacionados.",
            "Industrial Designer": "En esta página puedes ver la lista completa de mis libros que leí sobre diseño industrial y sus temas relacionados.",
            "Self-Driving Automobile Engineer": "En esta página, puede ver la lista completa de mis libros que leí sobre ingeniería de automóviles autónomos y sus temas relacionados.",
            "Mechanical Engineer": "En esta página puedes ver la lista completa de mis libros que leí sobre ingeniería mecánica y sus temas relacionados.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "Como diseñador sénior de interfaces de usuario y experiencias de usuario, me especializo en la creación de interfaces de usuario intuitivas y atractivas que mejoran la satisfacción del usuario. Mi enfoque integra la investigación de usuarios, la psicología del diseño y las últimas tendencias de diseño para producir diseños innovadores y accesibles. Con una sólida cartera de proyectos exitosos, tengo una capacidad comprobada para ofrecer diseños que no solo son estéticamente agradables sino que también funcionan perfectamente, lo que resulta en mejores experiencias de usuario y resultados comerciales.",
            "Flutter Developer": "Como desarrollador senior de Flutter, soy experto en crear aplicaciones multiplataforma que brinden una experiencia nativa tanto en Android como en iOS. Mi amplio conocimiento de Dart y el marco Flutter me permite crear interfaces de usuario fluidas y bases de código mantenibles. Tengo una sólida trayectoria en la integración exitosa de funcionalidades complejas con servicios backend, garantizando un viaje de usuario fluido.",
            "Full Stack Developer": "Como desarrollador senior Full Stack, aporto un conjunto integral de habilidades y una mentalidad con visión de futuro al desarrollo de aplicaciones Full Stack. Mi experiencia en tecnologías front-end y back-end, incluidos React, Node.js y servicios en la nube, me permite crear aplicaciones web escalables y de alto rendimiento que cumplan con los objetivos estratégicos de las empresas.",
            "Android Developer": "Como desarrollador senior de Android, he perfeccionado mis habilidades para crear aplicaciones de Android sólidas y escalables, aprovechando mi profundo conocimiento de la plataforma y el ecosistema de Android. Mi experiencia en Kotlin, Java y Android SDK, combinada con un fuerte enfoque en arquitectura limpia y patrones de diseño, me permite ofrecer aplicaciones con un rendimiento y una experiencia de usuario óptimos.",
            "AI Engineer": "Como Ingeniero Senior en Inteligencia Artificial, estoy profundamente inmerso en el desarrollo y despliegue de sofisticados sistemas de inteligencia artificial. Mi experiencia radica en la creación de algoritmos sólidos de aprendizaje automático, avances pioneros en aprendizaje profundo e implementación de soluciones de inteligencia artificial que mejoran significativamente la eficiencia operativa.",
            "Industrial Designer": "Como diseñador industrial senior, tengo una trayectoria comprobada en el desarrollo de diseños de productos innovadores que combinan funcionalidad con estética. Mi experiencia en modelado 3D, diseño centrado en el usuario y ciencia de materiales me ha permitido liderar proyectos de diseño desde la ideación hasta la fabricación.",
            "Self-Driving Automobile Engineer": "Como ingeniero senior de vehículos autónomos, aporto una gran experiencia en el desarrollo de sistemas de vehículos autónomos que priorizan la seguridad y la eficiencia. Mi experiencia abarca la fusión de sensores, el aprendizaje automático y los sistemas de control robótico, lo que me permite innovar en soluciones de vanguardia para el futuro del transporte. Tengo un historial comprobado de liderar equipos multifuncionales para entregar proyectos complejos que cumplen con rigurosos estándares de la industria.",
            "Mechanical Engineer": "Como ingeniero mecánico experimentado, cuento con una trayectoria comprobada en el diseño y optimización de sistemas mecánicos que mejoran la eficiencia y el rendimiento. Mi experiencia abarca el modelado CAD, el análisis térmico y la ingeniería de materiales, lo que me permite innovar en soluciones que satisfacen las demandas cambiantes de la industria. Soy experto en liderar proyectos desde el concepto hasta la producción, asegurando que todos los componentes mecánicos funcionen con la máxima funcionalidad.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "Vea mis habilidades de diseño de interfaz de usuario y experiencia de usuario en acción al ver mis proyectos realizados.",
            "Flutter Developer": "Vea mis habilidades de desarrollo de Flutter en acción viendo mis proyectos realizados.",
            "Full Stack Developer": "Vea mis habilidades de desarrollo Full Stack en acción viendo mis proyectos realizados.",
            "Android Developer": "Vea mis habilidades de desarrollo de Android en acción viendo mis proyectos realizados.",
            "AI Engineer": "Vea mis habilidades de Ingeniería de Inteligencia Artificial en acción viendo mis proyectos realizados.",
            "Industrial Designer": "Vea mis habilidades de diseño industrial en acción viendo mis proyectos realizados.",
            "Self-Driving Automobile Engineer": "Vea mis habilidades de ingeniería de automóviles autónomos en acción al ver mis proyectos realizados.",
            "Mechanical Engineer": "Vea mis habilidades de Ingeniería Mecánica en acción viendo mis proyectos realizados.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "Como diseñador sénior de interfaz de usuario y experiencia de usuario, consulte los cursos que me ayudan a desarrollar esta habilidad.",
            "Flutter Developer": "Como desarrollador sénior de Flutter, consulta los cursos que me ayudan a desarrollar esta habilidad.",
            "Full Stack Developer": "Como desarrollador senior Full Stack, consulta los cursos que me ayudan a desarrollar esta habilidad.",
            "Android Developer": "Como desarrollador sénior de Android, consulte los cursos que me ayudan a desarrollar esta habilidad.",
            "AI Engineer": "Como ingeniero senior en inteligencia artificial, consulte los cursos que me ayudan a desarrollar esta habilidad.",
            "Industrial Designer": "Como Diseñador Industrial Senior, consulte los cursos que me ayudan a desarrollar esta habilidad.",
            "Self-Driving Automobile Engineer": "Como ingeniero sénior de automóviles autónomos, consulte los cursos que me ayudan a desarrollar esta habilidad.",
            "Mechanical Engineer": "Como ingeniero mecánico experimentado, consulte los cursos que me ayudan a desarrollar esta habilidad.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "Como diseñador sénior de interfaz de usuario y experiencia de usuario, vea qué libros me ayudan en el proceso de aprendizaje de esta habilidad.",
            "Flutter Developer": "Como desarrollador sénior de Flutter, vea qué libros me ayudan en el proceso de aprendizaje de esta habilidad.",
            "Full Stack Developer": "Como desarrollador senior Full Stack, vea qué libros me ayudan en el viaje de aprendizaje de esta habilidad.",
            "Android Developer": "Como desarrollador sénior de Android, vea qué libros me ayudan en el proceso de aprendizaje de esta habilidad.",
            "AI Engineer": "Como ingeniero senior en inteligencia artificial, vea qué libros me ayudan en el viaje de aprendizaje de esta habilidad.",
            "Industrial Designer": "Como diseñador industrial experimentado, vea qué libros me ayudan en el aprendizaje de esta habilidad.",
            "Self-Driving Automobile Engineer": "Como ingeniero senior de automóviles autónomos, vea qué libros me ayudan en el aprendizaje de esta habilidad.",
            "Mechanical Engineer": "Como ingeniero mecánico experimentado, vea qué libros me ayudan en el aprendizaje de esta habilidad.",
        },
        "AllRightsAreReservedLastView": "© 2024 Muhammad Husain Aboutalebi. Reservados todos los derechos.",
        "fontFamily": "'Roboto Condensed', sans-serif",
    },
    // Hindi
    "हिंदी": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "इस पृष्ठ पर, आप मेरी पुस्तकों की पूरी सूची देख सकते हैं जो मैंने यूजर इंटरफेस और यूजर अनुभव डिजाइन और इससे संबंधित विषयों के बारे में पढ़ी हैं।",
            "Flutter Developer": "इस पृष्ठ पर, आप मेरी पुस्तकों की पूरी सूची देख सकते हैं जो मैंने फ़्लटर विकास और इससे संबंधित विषयों के बारे में पढ़ी हैं।",
            "Full Stack Developer": "इस पृष्ठ पर आप मेरी पुस्तकों की पूरी सूची देख सकते हैं जो मैंने फुल स्टैक डेवलपमेंट और इससे संबंधित विषयों पर पढ़ी हैं।",
            "Android Developer": "इस पृष्ठ पर, आप मेरी पुस्तकों की पूरी सूची देख सकते हैं जो मैंने एंड्रॉइड विकास और इससे संबंधित विषयों के बारे में पढ़ी हैं।",
            "AI Engineer": "इस पृष्ठ पर आप मेरी उन पुस्तकों की पूरी सूची देख सकते हैं जो मैंने कृत्रिम बुद्धिमत्ता इंजीनियरिंग और इससे संबंधित विषयों पर पढ़ी हैं।",
            "Industrial Designer": "इस पृष्ठ पर आप मेरी उन पुस्तकों की पूरी सूची देख सकते हैं जो मैंने औद्योगिक डिजाइन और इससे संबंधित विषयों पर पढ़ी हैं।",
            "Self-Driving Automobile Engineer": "इस पृष्ठ पर आप मेरी पुस्तकों की पूरी सूची देख सकते हैं जो मैंने स्व-चालित ऑटोमोबाइल इंजीनियरिंग और इससे संबंधित विषयों पर पढ़ी हैं।",
            "Mechanical Engineer": "इस पृष्ठ पर आप मेरी उन पुस्तकों की पूरी सूची देख सकते हैं जो मैंने मैकेनिकल इंजीनियरिंग और इससे संबंधित विषयों पर पढ़ी हैं।",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "एक वरिष्ठ यूजर इंटरफेस और यूजर एक्सपीरियंस डिजाइनर के रूप में, मैं सहज और आकर्षक यूजर इंटरफेस बनाने में माहिर हूं जो उपयोगकर्ता की संतुष्टि को बढ़ाता है। मेरा दृष्टिकोण नवीन और सुलभ डिज़ाइन तैयार करने के लिए उपयोगकर्ता अनुसंधान, डिज़ाइन मनोविज्ञान और नवीनतम डिज़ाइन रुझानों को एकीकृत करता है। सफल परियोजनाओं के एक मजबूत पोर्टफोलियो के साथ, मेरे पास ऐसे डिज़ाइन देने की सिद्ध क्षमता है जो न केवल सौंदर्य की दृष्टि से मनभावन हैं, बल्कि कार्यक्षमता में भी सहज हैं, जिसके परिणामस्वरूप उपयोगकर्ता अनुभव और व्यावसायिक परिणाम बेहतर होते हैं।",
            "Flutter Developer": "एक वरिष्ठ फ़्लटर डेवलपर के रूप में, मैं क्रॉस-प्लेटफ़ॉर्म एप्लिकेशन बनाने में माहिर हूं जो एंड्रॉइड और आईओएस दोनों पर मूल अनुभव प्रदान करता है। डार्ट और फ़्लटर फ्रेमवर्क के बारे में मेरा व्यापक ज्ञान मुझे तरल यूआई और रखरखाव योग्य कोडबेस तैयार करने में सक्षम बनाता है। मेरे पास बैकएंड सेवाओं के साथ जटिल कार्यात्मकताओं को सफलतापूर्वक एकीकृत करने, एक निर्बाध उपयोगकर्ता यात्रा सुनिश्चित करने का एक मजबूत ट्रैक रिकॉर्ड है।",
            "Full Stack Developer": "एक वरिष्ठ पूर्ण स्टैक डेवलपर के रूप में, मैं पूर्ण-स्टैक अनुप्रयोगों के विकास के लिए एक व्यापक कौशल सेट और दूरदर्शी मानसिकता लाता हूं। रिएक्ट, नोड.जेएस और क्लाउड सेवाओं सहित फ्रंट-एंड और बैक-एंड दोनों तकनीकों में मेरी विशेषज्ञता मुझे स्केलेबल, उच्च-प्रदर्शन वाले वेब एप्लिकेशन बनाने की अनुमति देती है जो व्यवसायों के रणनीतिक उद्देश्यों को पूरा करते हैं।",
            "Android Developer": "एक वरिष्ठ एंड्रॉइड डेवलपर के रूप में, मैंने एंड्रॉइड प्लेटफ़ॉर्म और पारिस्थितिकी तंत्र की अपनी गहरी समझ का लाभ उठाते हुए, मजबूत और स्केलेबल एंड्रॉइड एप्लिकेशन तैयार करने में अपने कौशल को निखारा है। कोटलिन, जावा और एंड्रॉइड एसडीके में मेरी विशेषज्ञता, स्वच्छ वास्तुकला और डिजाइन पैटर्न पर एक मजबूत फोकस के साथ मिलकर, मुझे इष्टतम प्रदर्शन और उपयोगकर्ता अनुभव के साथ एप्लिकेशन वितरित करने में सक्षम बनाती है।",
            "AI Engineer": "एक वरिष्ठ आर्टिफिशियल इंटेलिजेंस इंजीनियर के रूप में, मैं परिष्कृत कृत्रिम इंटेलिजेंस प्रणालियों के विकास और तैनाती में गहराई से डूबा हुआ हूं। मेरी विशेषज्ञता मजबूत मशीन लर्निंग एल्गोरिदम बनाने, गहन शिक्षण में अग्रणी प्रगति करने और एआई समाधानों को लागू करने में निहित है जो परिचालन दक्षता को महत्वपूर्ण रूप से बढ़ाते हैं।",
            "Industrial Designer": "एक वरिष्ठ औद्योगिक डिजाइनर के रूप में, मेरे पास नवीन उत्पाद डिजाइन विकसित करने का एक सिद्ध ट्रैक रिकॉर्ड है जो कार्यक्षमता को सौंदर्यशास्त्र के साथ जोड़ता है। 3डी मॉडलिंग, उपयोगकर्ता-केंद्रित डिजाइन और सामग्री विज्ञान में मेरी विशेषज्ञता ने मुझे डिजाइन परियोजनाओं को विचार से विनिर्माण तक नेतृत्व करने में सक्षम बनाया है।",
            "Self-Driving Automobile Engineer": "एक वरिष्ठ सेल्फ-ड्राइविंग ऑटोमोबाइल इंजीनियर के रूप में, मेरे पास सुरक्षा और दक्षता को प्राथमिकता देने वाले स्वायत्त वाहन सिस्टम विकसित करने का भरपूर अनुभव है। मेरी विशेषज्ञता सेंसर फ़्यूज़न, मशीन लर्निंग और रोबोटिक्स नियंत्रण प्रणालियों तक फैली हुई है, जो मुझे परिवहन के भविष्य के लिए अत्याधुनिक समाधानों का आविष्कार करने में सक्षम बनाती है। मेरे पास कठोर उद्योग मानकों को पूरा करने वाली जटिल परियोजनाओं को वितरित करने के लिए अग्रणी क्रॉस-फ़ंक्शनल टीमों का एक सिद्ध ट्रैक रिकॉर्ड है।",
            "Mechanical Engineer": "एक अनुभवी मैकेनिकल इंजीनियर के रूप में, मैं यांत्रिक प्रणालियों को डिजाइन और अनुकूलित करने का एक सिद्ध ट्रैक रिकॉर्ड रखता हूं जो दक्षता और प्रदर्शन को बढ़ाता है। मेरी विशेषज्ञता में सीएडी मॉडलिंग, थर्मल विश्लेषण और सामग्री इंजीनियरिंग शामिल है, जो मुझे उद्योग की उभरती मांगों को पूरा करने वाले समाधानों को नया करने की इजाजत देता है। मैं अवधारणा से उत्पादन तक परियोजनाओं का नेतृत्व करने में माहिर हूं, यह सुनिश्चित करते हुए कि सभी यांत्रिक घटक चरम कार्यक्षमता पर काम करते हैं।",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "मेरे द्वारा किए गए प्रोजेक्ट्स को देखकर मेरे यूजर इंटरफेस और यूजर एक्सपीरियंस डिजाइन कौशल को कार्यान्वित होते हुए देखें।",
            "Flutter Developer": "मेरे पूर्ण किए गए प्रोजेक्ट्स को देखकर मेरे स्पंदन विकास कौशल को कार्यान्वित होते हुए देखें।",
            "Full Stack Developer": "मेरे पूर्ण किए गए प्रोजेक्टों को देखकर मेरे पूर्ण स्टैक विकास कौशल को कार्यान्वित होते हुए देखें।",
            "Android Developer": "मेरे द्वारा किए गए प्रोजेक्ट्स को देखकर मेरे Android विकास कौशल को कार्यान्वित होते हुए देखें।",
            "AI Engineer": "मेरे द्वारा किए गए प्रोजेक्ट्स को देखकर मेरे आर्टिफिशियल इंटेलिजेंस इंजीनियरिंग कौशल को कार्यान्वित होते हुए देखें।",
            "Industrial Designer": "मेरी पूरी की गई परियोजनाओं को देखकर मेरे औद्योगिक डिजाइन कौशल को कार्यान्वित होते हुए देखें।",
            "Self-Driving Automobile Engineer": "मेरे द्वारा किए गए प्रोजेक्ट्स को देखकर मेरे सेल्फ-ड्राइविंग ऑटोमोबाइल इंजीनियरिंग कौशल को कार्यान्वित होते हुए देखें।",
            "Mechanical Engineer": "मेरे द्वारा तैयार किए गए प्रोजेक्टों को देखकर मेरे मैकेनिकल इंजीनियरिंग कौशल को कार्यान्वित होते हुए देखें।",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "एक वरिष्ठ उपयोगकर्ता इंटरफ़ेस और उपयोगकर्ता अनुभव डिजाइनर के रूप में, उन पाठ्यक्रमों को देखें जो मुझे इस कौशल को विकसित करने में मदद करते हैं।",
            "Flutter Developer": "एक वरिष्ठ फ़्लटर डेवलपर के रूप में, वे पाठ्यक्रम देखें जो मुझे यह कौशल विकसित करने में मदद करते हैं।",
            "Full Stack Developer": "एक वरिष्ठ पूर्ण स्टैक डेवलपर के रूप में, वे पाठ्यक्रम देखें जो मुझे यह कौशल विकसित करने में मदद करते हैं।",
            "Android Developer": "एक वरिष्ठ एंड्रॉइड डेवलपर के रूप में, वे पाठ्यक्रम देखें जो मुझे यह कौशल विकसित करने में मदद करते हैं।",
            "AI Engineer": "एक वरिष्ठ आर्टिफिशियल इंटेलिजेंस इंजीनियर के रूप में, वे पाठ्यक्रम देखें जो मुझे यह कौशल विकसित करने में मदद करते हैं।",
            "Industrial Designer": "एक वरिष्ठ औद्योगिक डिजाइनर के रूप में, वे पाठ्यक्रम देखें जो मुझे यह कौशल विकसित करने में मदद करते हैं।",
            "Self-Driving Automobile Engineer": "एक वरिष्ठ सेल्फ-ड्राइविंग ऑटोमोबाइल इंजीनियर के रूप में, वे पाठ्यक्रम देखें जो मुझे इस कौशल को विकसित करने में मदद करते हैं।",
            "Mechanical Engineer": "एक अनुभवी मैकेनिकल इंजीनियर के रूप में, वे पाठ्यक्रम देखें जो मुझे यह कौशल विकसित करने में मदद करते हैं।",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "एक वरिष्ठ यूजर इंटरफेस और यूजर एक्सपीरियंस डिजाइनर के रूप में, देखें कि कौन सी किताबें इस कौशल को सीखने की यात्रा में मेरी मदद करती हैं।",
            "Flutter Developer": "एक वरिष्ठ फ़्लटर डेवलपर के रूप में, देखें कि इस कौशल को सीखने की यात्रा में कौन सी किताबें मेरी मदद करती हैं।",
            "Full Stack Developer": "एक वरिष्ठ पूर्ण स्टैक डेवलपर के रूप में, देखें कि इस कौशल को सीखने की यात्रा में कौन सी किताबें मेरी मदद करती हैं।",
            "Android Developer": "एक वरिष्ठ एंड्रॉइड डेवलपर के रूप में, देखें कि इस कौशल को सीखने की यात्रा में कौन सी किताबें मेरी मदद करती हैं।",
            "AI Engineer": "एक वरिष्ठ आर्टिफिशियल इंटेलिजेंस इंजीनियर के रूप में, देखें कि इस कौशल को सीखने की यात्रा में कौन सी किताबें मेरी मदद करती हैं।",
            "Industrial Designer": "एक अनुभवी औद्योगिक डिजाइनर के रूप में, देखें कि इस कौशल को सीखने की यात्रा में कौन सी किताबें मेरी मदद करती हैं।",
            "Self-Driving Automobile Engineer": "एक वरिष्ठ सेल्फ-ड्राइविंग ऑटोमोबाइल इंजीनियर के रूप में, देखें कि कौन सी किताबें इस कौशल को सीखने की यात्रा में मेरी मदद करती हैं।",
            "Mechanical Engineer": "एक अनुभवी मैकेनिकल इंजीनियर के रूप में, देखें कि इस कौशल को सीखने की यात्रा में कौन सी किताबें मेरी मदद करती हैं।",
        },
        "AllRightsAreReservedLastView": "© 2024 मुहम्मद हुसैन अबाउटलेबी। सर्वाधिकार सुरक्षित।",
        "fontFamily": "'Roboto Condensed', sans-serif",
    },
    // Portuguese
    "Português": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "Nesta página, você pode ver a lista completa dos meus livros que li sobre interface do usuário e design de experiência do usuário e seus tópicos relacionados.",
            "Flutter Developer": "Nesta página você pode ver a lista completa dos meus livros que li sobre desenvolvimento de flutter e tópicos relacionados.",
            "Full Stack Developer": "Nesta página você pode ver a lista completa dos meus livros que li sobre desenvolvimento full stack e seus tópicos relacionados.",
            "Android Developer": "Nesta página você pode ver a lista completa dos meus livros que li sobre desenvolvimento Android e seus tópicos relacionados.",
            "AI Engineer": "Nesta página você pode ver a lista completa dos meus livros que li sobre engenharia de inteligência artificial e seus tópicos relacionados.",
            "Industrial Designer": "Nesta página você pode ver a lista completa dos meus livros que li sobre design industrial e temas relacionados.",
            "Self-Driving Automobile Engineer": "Nesta página você pode ver a lista completa dos meus livros que li sobre engenharia automobilística autônoma e tópicos relacionados.",
            "Mechanical Engineer": "Nesta página você pode ver a lista completa dos meus livros que li sobre engenharia mecânica e assuntos relacionados.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "Como designer sênior de interface de usuário e experiência do usuário, me especializo na criação de interfaces de usuário intuitivas e envolventes que aumentam a satisfação do usuário. Minha abordagem integra pesquisa de usuários, psicologia de design e as últimas tendências de design para produzir designs inovadores e acessíveis. Com um forte portfólio de projetos bem-sucedidos, tenho capacidade comprovada de entregar designs que não são apenas esteticamente agradáveis, mas também funcionais, resultando em melhores experiências de usuário e resultados de negócios.",
            "Flutter Developer": "Como desenvolvedor sênior de Flutter, sou adepto da construção de aplicativos multiplataforma que oferecem uma experiência nativa em Android e iOS. Meu amplo conhecimento do Dart e da estrutura Flutter me permite criar UIs fluidas e bases de código sustentáveis. Tenho um forte histórico de integração bem-sucedida de funcionalidades complexas com serviços de backend, garantindo uma jornada de usuário perfeita.",
            "Full Stack Developer": "Como Desenvolvedor Full Stack Sênior, trago um conjunto abrangente de habilidades e uma mentalidade inovadora para o desenvolvimento de aplicações full stack. Minha experiência em tecnologias front-end e back-end, incluindo React, Node.js e serviços em nuvem, me permite construir aplicações web escaláveis e de alto desempenho que atendam aos objetivos estratégicos das empresas.",
            "Android Developer": "Como desenvolvedor Android sênior, aprimorei minhas habilidades na criação de aplicativos Android robustos e escaláveis, aproveitando meu profundo conhecimento da plataforma e do ecossistema Android. Minha experiência em Kotlin, Java e Android SDK, combinada com um forte foco em arquitetura limpa e padrões de design, me permite entregar aplicativos com desempenho e experiência de usuário ideais.",
            "AI Engineer": "Como Engenheiro Sênior de Inteligência Artificial, estou profundamente imerso no desenvolvimento e implantação de sistemas sofisticados de inteligência artificial. Minha experiência reside na criação de algoritmos robustos de aprendizado de máquina, em avanços pioneiros em aprendizado profundo e na implementação de soluções de IA que melhoram significativamente a eficiência operacional.",
            "Industrial Designer": "Como Designer Industrial Sênior, tenho um histórico comprovado no desenvolvimento de designs de produtos inovadores que mesclam funcionalidade com estética. Minha experiência em modelagem 3D, design centrado no usuário e ciência de materiais me permitiu liderar projetos de design desde a concepção até a fabricação.",
            "Self-Driving Automobile Engineer": "Como engenheiro sênior de automóveis autônomos, trago vasta experiência no desenvolvimento de sistemas de veículos autônomos que priorizam segurança e eficiência. Minha experiência abrange fusão de sensores, aprendizado de máquina e sistemas de controle robótico, o que me permite inovar em soluções de ponta para o futuro do transporte. Tenho um histórico comprovado de liderança de equipes multifuncionais para entregar projetos complexos que atendem aos rigorosos padrões do setor.",
            "Mechanical Engineer": "Como engenheiro mecânico experiente, trago um histórico comprovado de projeto e otimização de sistemas mecânicos que melhoram a eficiência e o desempenho. Minha experiência abrange modelagem CAD, análise térmica e engenharia de materiais, o que me permite inovar em soluções que atendam às crescentes demandas da indústria. Sou adepto de liderar projetos desde o conceito até a produção, garantindo que todos os componentes mecânicos operem com funcionalidade máxima.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "Veja minhas habilidades de design de interface e experiência do usuário em ação, vendo meus projetos concluídos.",
            "Flutter Developer": "Veja minhas habilidades de desenvolvimento de Flutter em ação vendo meus projetos concluídos.",
            "Full Stack Developer": "Veja minhas habilidades de desenvolvimento Full Stack em ação vendo meus projetos concluídos.",
            "Android Developer": "Veja minhas habilidades de desenvolvimento Android em ação vendo meus projetos concluídos.",
            "AI Engineer": "Veja minhas habilidades em Engenharia de Inteligência Artificial em ação vendo meus projetos realizados.",
            "Industrial Designer": "Veja minhas habilidades de design industrial em ação vendo meus projetos realizados.",
            "Self-Driving Automobile Engineer": "Veja minhas habilidades de engenharia automotiva autônoma em ação, vendo meus projetos realizados.",
            "Mechanical Engineer": "Veja minhas habilidades em Engenharia Mecânica em ação vendo meus projetos realizados.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "Como designer sênior de interface de usuário e experiência do usuário, veja os cursos que me ajudam a desenvolver essa habilidade.",
            "Flutter Developer": "Como desenvolvedor sênior de Flutter, veja os cursos que me ajudam a desenvolver essa habilidade.",
            "Full Stack Developer": "Como Desenvolvedor Full Stack Sênior, veja os cursos que me ajudam a desenvolver essa habilidade.",
            "Android Developer": "Como Desenvolvedor Android Sênior, veja os cursos que me ajudam a desenvolver essa habilidade.",
            "AI Engineer": "Como Engenheiro Sênior de Inteligência Artificial, veja os cursos que me ajudam a desenvolver essa habilidade.",
            "Industrial Designer": "Como Designer Industrial Sênior, veja os cursos que me ajudam a desenvolver essa habilidade.",
            "Self-Driving Automobile Engineer": "Como engenheiro automotivo autônomo sênior, veja os cursos que me ajudam a desenvolver essa habilidade.",
            "Mechanical Engineer": "Como engenheiro mecânico experiente, veja os cursos que me ajudam a desenvolver essa habilidade.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "Como designer sênior de interface de usuário e experiência do usuário, veja quais livros me ajudam na jornada de aprendizado dessa habilidade.",
            "Flutter Developer": "Como Desenvolvedor Sênior de Flutter, veja quais livros me ajudam na jornada de aprendizado dessa habilidade.",
            "Full Stack Developer": "Como Desenvolvedor Full Stack Sênior, veja quais livros me ajudam na jornada de aprendizado dessa habilidade.",
            "Android Developer": "Como Desenvolvedor Android Sênior, veja quais livros me ajudam na jornada de aprendizado dessa habilidade.",
            "AI Engineer": "Como Engenheiro Sênior de Inteligência Artificial, veja quais livros me ajudam na jornada de aprendizado dessa habilidade.",
            "Industrial Designer": "Como Designer Industrial Experiente, veja quais livros me ajudam na jornada de aprendizado dessa habilidade.",
            "Self-Driving Automobile Engineer": "Como engenheiro automotivo autônomo sênior, veja quais livros me ajudam na jornada de aprendizado dessa habilidade.",
            "Mechanical Engineer": "Como engenheiro mecânico experiente, veja quais livros me ajudam na jornada de aprendizado dessa habilidade.",
        },
        "AllRightsAreReservedLastView": "© 2024 Muhammad Husain Aboutalebi. Todos os direitos reservados.",
        "fontFamily": "'Roboto Condensed', sans-serif",
    },
    // Bengali
    "বাংলা": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "এই পৃষ্ঠায়, আপনি আমার বইগুলির সম্পূর্ণ তালিকা দেখতে পারেন যা আমি ইউজার ইন্টারফেস এবং ব্যবহারকারীর অভিজ্ঞতা ডিজাইন এবং এর সাথে সম্পর্কিত বিষয়গুলি সম্পর্কে পড়েছি।",
            "Flutter Developer": "এই পৃষ্ঠায়, আপনি আমার বইগুলির সম্পূর্ণ তালিকা দেখতে পারেন যা আমি ফ্লটার ডেভেলপমেন্ট এবং এর সাথে সম্পর্কিত বিষয়গুলি সম্পর্কে পড়েছি।",
            "Full Stack Developer": "এই পৃষ্ঠায়, আপনি আমার বইগুলির সম্পূর্ণ তালিকা দেখতে পারেন যা আমি সম্পূর্ণ স্ট্যাক বিকাশ এবং এর সাথে সম্পর্কিত বিষয়গুলি সম্পর্কে পড়েছি।",
            "Android Developer": "এই পৃষ্ঠায়, আপনি আমার বইগুলির সম্পূর্ণ তালিকা দেখতে পারেন যা আমি অ্যান্ড্রয়েড বিকাশ এবং এর সম্পর্কিত বিষয়গুলি সম্পর্কে পড়েছি।",
            "AI Engineer": "এই পৃষ্ঠায়, আপনি আমার বইগুলির সম্পূর্ণ তালিকা দেখতে পারেন যা আমি কৃত্রিম বুদ্ধিমত্তা প্রকৌশল এবং এর সাথে সম্পর্কিত বিষয়গুলি সম্পর্কে পড়েছি।",
            "Industrial Designer": "এই পৃষ্ঠায়, আপনি আমার বইগুলির সম্পূর্ণ তালিকা দেখতে পারেন যা আমি শিল্প নকশা এবং এর সম্পর্কিত বিষয়গুলি সম্পর্কে পড়েছি।",
            "Self-Driving Automobile Engineer": "এই পৃষ্ঠায়, আপনি আমার বইগুলির সম্পূর্ণ তালিকা দেখতে পারেন যা আমি স্ব-ড্রাইভিং অটোমোবাইল ইঞ্জিনিয়ারিং এবং এর সম্পর্কিত বিষয়গুলি সম্পর্কে পড়েছি।",
            "Mechanical Engineer": "এই পৃষ্ঠায়, আপনি আমার বইগুলির সম্পূর্ণ তালিকা দেখতে পারেন যা আমি যান্ত্রিক প্রকৌশল এবং এর সম্পর্কিত বিষয়গুলি সম্পর্কে পড়েছি।",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "একজন সিনিয়র ইউজার ইন্টারফেস এবং ইউজার এক্সপেরিয়েন্স ডিজাইনার হিসেবে, আমি স্বজ্ঞাত এবং আকর্ষক ইউজার ইন্টারফেস তৈরি করতে পারদর্শী যা ব্যবহারকারীর সন্তুষ্টি বাড়ায়। আমার পদ্ধতি ব্যবহারকারী গবেষণা, নকশা মনোবিজ্ঞান, এবং উদ্ভাবনী এবং অ্যাক্সেসযোগ্য ডিজাইন তৈরি করতে সর্বশেষ ডিজাইন প্রবণতাকে একীভূত করে। সফল প্রকল্পগুলির একটি শক্তিশালী পোর্টফোলিওর সাথে, আমার কাছে এমন ডিজাইনগুলি সরবরাহ করার প্রমাণিত ক্ষমতা রয়েছে যা কেবল নান্দনিকভাবে আনন্দদায়ক নয় কিন্তু কার্যকারিতাও নিরবচ্ছিন্ন, যার ফলে ব্যবহারকারীর অভিজ্ঞতা এবং ব্যবসায়িক ফলাফল উন্নত হয়।",
            "Flutter Developer": "একজন সিনিয়র ফ্লাটার ডেভেলপার হিসেবে, আমি ক্রস-প্ল্যাটফর্ম অ্যাপ্লিকেশন তৈরিতে পারদর্শী যা Android এবং iOS উভয় ক্ষেত্রেই একটি স্থানীয় অভিজ্ঞতা প্রদান করে। ডার্ট এবং ফ্লাটার ফ্রেমওয়ার্ক সম্পর্কে আমার বিস্তৃত জ্ঞান আমাকে তরল UI এবং রক্ষণাবেক্ষণযোগ্য কোডবেস তৈরি করতে সক্ষম করে। ব্যাকএন্ড পরিষেবাগুলির সাথে জটিল কার্যকারিতাগুলিকে সফলভাবে একীভূত করার একটি শক্তিশালী ট্র্যাক রেকর্ড রয়েছে, একটি নির্বিঘ্ন ব্যবহারকারীর যাত্রা নিশ্চিত করে৷",
            "Full Stack Developer": "একজন সিনিয়র ফুল স্ট্যাক ডেভেলপার হিসেবে, আমি পূর্ণ-স্ট্যাক অ্যাপ্লিকেশনগুলির বিকাশের জন্য একটি বিস্তৃত দক্ষতা সেট এবং একটি এগিয়ে-চিন্তার মানসিকতা নিয়ে এসেছি। রিঅ্যাক্ট, Node.js এবং ক্লাউড পরিষেবা সহ ফ্রন্ট-এন্ড এবং ব্যাক-এন্ড উভয় প্রযুক্তিতেই আমার দক্ষতা আমাকে স্কেলযোগ্য, উচ্চ-পারফরম্যান্স ওয়েব অ্যাপ্লিকেশন তৈরি করতে দেয় যা ব্যবসার কৌশলগত উদ্দেশ্য পূরণ করে।",
            "Android Developer": "একজন সিনিয়র অ্যান্ড্রয়েড ডেভেলপার হিসেবে, আমি অ্যান্ড্রয়েড প্ল্যাটফর্ম এবং ইকোসিস্টেম সম্পর্কে আমার গভীর বোঝাপড়ার মাধ্যমে শক্তিশালী এবং মাপযোগ্য অ্যান্ড্রয়েড অ্যাপ্লিকেশান তৈরিতে আমার দক্ষতাকে সম্মানিত করেছি। কোটলিন, জাভা, এবং অ্যান্ড্রয়েড SDK-এ আমার দক্ষতা, পরিষ্কার আর্কিটেকচার এবং ডিজাইন প্যাটার্নের উপর দৃঢ় ফোকাসের সাথে মিলিত, আমাকে সর্বোত্তম কর্মক্ষমতা এবং ব্যবহারকারীর অভিজ্ঞতা সহ অ্যাপ্লিকেশন সরবরাহ করতে সক্ষম করে।",
            "AI Engineer": "একজন সিনিয়র কৃত্রিম বুদ্ধিমত্তা প্রকৌশলী হিসাবে, আমি অত্যাধুনিক কৃত্রিম বুদ্ধিমত্তা সিস্টেমের বিকাশ এবং স্থাপনায় গভীরভাবে নিমগ্ন। আমার দক্ষতার মধ্যে রয়েছে শক্তিশালী মেশিন লার্নিং অ্যালগরিদম তৈরি করা, গভীর শিক্ষায় অগ্রগামী অগ্রগতি, এবং AI সমাধানগুলি বাস্তবায়ন করা যা উল্লেখযোগ্যভাবে অপারেশনাল দক্ষতা বাড়ায়।",
            "Industrial Designer": "একজন সিনিয়র ইন্ডাস্ট্রিয়াল ডিজাইনার হিসেবে, আমার কাছে উদ্ভাবনী পণ্য ডিজাইন তৈরির একটি প্রমাণিত ট্র্যাক রেকর্ড রয়েছে যা নন্দনতত্ত্বের সাথে কার্যকারিতা একত্রিত করে। 3D মডেলিং, ব্যবহারকারী-কেন্দ্রিক নকশা, এবং উপাদান বিজ্ঞানে আমার দক্ষতা আমাকে আদর্শ থেকে উত্পাদন পর্যন্ত ডিজাইন প্রকল্পগুলিকে নেতৃত্ব দিতে সক্ষম করেছে।",
            "Self-Driving Automobile Engineer": "একজন সিনিয়র সেলফ-ড্রাইভিং অটোমোবাইল ইঞ্জিনিয়ার হিসাবে, আমি স্বায়ত্তশাসিত যানবাহন সিস্টেমগুলি বিকাশে প্রচুর অভিজ্ঞতা নিয়ে এসেছি যা সুরক্ষা এবং দক্ষতাকে অগ্রাধিকার দেয়। আমার দক্ষতা সেন্সর ফিউশন, মেশিন লার্নিং এবং রোবোটিক্স কন্ট্রোল সিস্টেমে বিস্তৃত, যা আমাকে পরিবহণের ভবিষ্যতের জন্য অত্যাধুনিক সমাধান উদ্ভাবন করতে সক্ষম করে। আমার কাছে একটি প্রমাণিত ট্র্যাক রেকর্ড রয়েছে নেতৃস্থানীয় ক্রস-ফাংশনাল টিমের জটিল প্রকল্পগুলি সরবরাহ করার জন্য যা কঠোর শিল্পের মান পূরণ করে।",
            "Mechanical Engineer": "একজন পাকা মেকানিক্যাল ইঞ্জিনিয়ার হিসাবে, আমি মেকানিক্যাল সিস্টেম ডিজাইন এবং অপ্টিমাইজ করার একটি প্রমাণিত ট্র্যাক রেকর্ড নিয়ে এসেছি যা দক্ষতা এবং কর্মক্ষমতা বাড়ায়। আমার দক্ষতা CAD মডেলিং, তাপীয় বিশ্লেষণ এবং উপকরণ প্রকৌশল অন্তর্ভুক্ত করে, যা আমাকে শিল্পের ক্রমবর্ধমান চাহিদা পূরণ করে এমন সমাধান উদ্ভাবন করতে দেয়। আমি উত্পাদনের মাধ্যমে ধারণা থেকে নেতৃস্থানীয় প্রকল্পগুলিতে পারদর্শী, সমস্ত যান্ত্রিক উপাদানগুলি সর্বোচ্চ কার্যকারিতাতে কাজ করে তা নিশ্চিত করে।",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "আমার ইউজার ইন্টারফেস এবং ইউজার এক্সপেরিয়েন্স ডিজাইনের দক্ষতা দেখুন আমার করা প্রজেক্টগুলো দেখে।",
            "Flutter Developer": "আমার সম্পাদিত প্রকল্পগুলি দেখে আমার ফ্লটার ডেভেলপমেন্ট দক্ষতাগুলি কর্মে দেখুন৷",
            "Full Stack Developer": "আমার সম্পাদিত প্রকল্পগুলি দেখে আমার সম্পূর্ণ স্ট্যাক ডেভেলপমেন্ট দক্ষতাগুলি কর্মে দেখুন।",
            "Android Developer": "আমার সম্পাদিত প্রজেক্টগুলি দেখে আমার অ্যান্ড্রয়েড ডেভেলপমেন্টের দক্ষতাগুলি দেখুন৷",
            "AI Engineer": "আমার করা প্রকল্পগুলি দেখে আমার কৃত্রিম বুদ্ধিমত্তা প্রকৌশল দক্ষতাগুলি কর্মে দেখুন৷",
            "Industrial Designer": "আমার সম্পন্ন প্রকল্পগুলি দেখে কর্মে আমার শিল্প নকশা দক্ষতা দেখুন।",
            "Self-Driving Automobile Engineer": "আমার সম্পন্ন প্রজেক্টগুলি দেখে আমার স্ব-ড্রাইভিং অটোমোবাইল ইঞ্জিনিয়ারিং দক্ষতাগুলি কর্মে দেখুন৷",
            "Mechanical Engineer": "আমার সম্পন্ন প্রকল্পগুলি দেখে আমার মেকানিক্যাল ইঞ্জিনিয়ারিং দক্ষতাগুলি কর্মে দেখুন।",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "একজন সিনিয়র ইউজার ইন্টারফেস এবং ইউজার এক্সপেরিয়েন্স ডিজাইনার হিসেবে, কোর্সগুলো দেখুন যা আমাকে এই দক্ষতা তৈরি করতে সাহায্য করে।",
            "Flutter Developer": "একজন সিনিয়র ফ্লাটার ডেভেলপার হিসেবে, কোর্সগুলো দেখুন যেগুলো আমাকে এই দক্ষতা তৈরি করতে সাহায্য করে।",
            "Full Stack Developer": "একজন সিনিয়র ফুল স্ট্যাক ডেভেলপার হিসেবে, কোর্সগুলো দেখুন যা আমাকে এই দক্ষতা তৈরি করতে সাহায্য করে।",
            "Android Developer": "একজন সিনিয়র অ্যান্ড্রয়েড ডেভেলপার হিসেবে, সেই কোর্সগুলি দেখুন যা আমাকে এই দক্ষতা তৈরি করতে সাহায্য করে৷",
            "AI Engineer": "একজন সিনিয়র কৃত্রিম বুদ্ধিমত্তা প্রকৌশলী হিসাবে, কোর্সগুলি দেখুন যা আমাকে এই দক্ষতা তৈরি করতে সাহায্য করে।",
            "Industrial Designer": "একজন সিনিয়র ইন্ডাস্ট্রিয়াল ডিজাইনার হিসেবে, কোর্সগুলো দেখুন যেগুলো আমাকে এই দক্ষতা তৈরি করতে সাহায্য করে।",
            "Self-Driving Automobile Engineer": "একজন সিনিয়র সেলফ-ড্রাইভিং অটোমোবাইল ইঞ্জিনিয়ার হিসাবে, এই দক্ষতা তৈরি করতে আমাকে সাহায্য করে এমন কোর্সগুলি দেখুন।",
            "Mechanical Engineer": "একজন অভিজ্ঞ যান্ত্রিক প্রকৌশলী হিসাবে, কোর্সগুলি দেখুন যা আমাকে এই দক্ষতা তৈরি করতে সাহায্য করে।",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "একজন সিনিয়র ইউজার ইন্টারফেস এবং ইউজার এক্সপেরিয়েন্স ডিজাইনার হিসেবে, দেখুন কোন বই আমাকে এই দক্ষতা শেখার যাত্রায় সাহায্য করে।",
            "Flutter Developer": "একজন সিনিয়র ফ্লাটার ডেভেলপার হিসেবে, দেখুন কোন বই আমাকে এই দক্ষতা শেখার যাত্রায় সাহায্য করে।",
            "Full Stack Developer": "একজন সিনিয়র ফুল স্ট্যাক ডেভেলপার হিসেবে, দেখুন কোন বই আমাকে এই দক্ষতা শেখার যাত্রায় সাহায্য করে।",
            "Android Developer": "একজন সিনিয়র অ্যান্ড্রয়েড ডেভেলপার হিসেবে, দেখুন কোন বই আমাকে এই দক্ষতা শেখার যাত্রায় সাহায্য করে।",
            "AI Engineer": "একজন সিনিয়র কৃত্রিম বুদ্ধিমত্তা প্রকৌশলী হিসাবে, দেখুন কোন বই আমাকে এই দক্ষতার শেখার যাত্রায় সাহায্য করে।",
            "Industrial Designer": "একজন অভিজ্ঞ শিল্প ডিজাইনার হিসাবে, দেখুন কোন বই আমাকে এই দক্ষতা শেখার যাত্রায় সাহায্য করে।",
            "Self-Driving Automobile Engineer": "একজন সিনিয়র সেলফ-ড্রাইভিং অটোমোবাইল ইঞ্জিনিয়ার হিসেবে, দেখুন কোন বই আমাকে এই দক্ষতার শেখার যাত্রায় সাহায্য করে।",
            "Mechanical Engineer": "একজন অভিজ্ঞ মেকানিক্যাল ইঞ্জিনিয়ার হিসেবে, দেখুন কোন বই আমাকে এই দক্ষতার শেখার যাত্রায় সাহায্য করে।",
        },
        "AllRightsAreReservedLastView": "© 2024 মুহাম্মদ হুসাইন আবুতালেবী। সমস্ত অধিকার সংরক্ষিত.",
        "fontFamily": "'Noto Serif Bengali', serif",
    },
    // Arabic
    "عَرَبِيّ": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "في هذه الصفحة، يمكنك الاطلاع على القائمة الكاملة لكتبي التي قرأتها عن واجهة المستخدم وتصميم تجربة المستخدم والمواضيع المرتبطة بها.",
            "Flutter Developer": "في هذه الصفحة، يمكنك الاطلاع على القائمة الكاملة لكتبي التي قرأتها عن تطوير الرفرفة والمواضيع المرتبطة بها.",
            "Full Stack Developer": "في هذه الصفحة، يمكنك رؤية القائمة الكاملة لكتبي التي قرأتها عن تطوير المكدس الكامل والمواضيع المرتبطة به.",
            "Android Developer": "في هذه الصفحة، يمكنك الاطلاع على القائمة الكاملة لكتبي التي قرأتها عن تطوير أندرويد والمواضيع المرتبطة به.",
            "AI Engineer": "في هذه الصفحة، يمكنك الاطلاع على القائمة الكاملة لكتبي التي قرأتها عن هندسة الذكاء الاصطناعي والمواضيع المرتبطة بها.",
            "Industrial Designer": "في هذه الصفحة، يمكنك الاطلاع على القائمة الكاملة لكتبي التي قرأتها عن التصميم الصناعي والمواضيع المرتبطة به.",
            "Self-Driving Automobile Engineer": "في هذه الصفحة، يمكنك الاطلاع على القائمة الكاملة لكتبي التي قرأتها عن هندسة السيارات ذاتية القيادة والمواضيع المرتبطة بها.",
            "Mechanical Engineer": "في هذه الصفحة، يمكنك الاطلاع على القائمة الكاملة لكتبي التي قرأتها عن الهندسة الميكانيكية والمواضيع المرتبطة بها.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "باعتباري أحد كبار مصممي واجهات المستخدم وتجربة المستخدم، فأنا متخصص في إنشاء واجهات مستخدم بديهية وجذابة تعزز رضا المستخدم. يدمج أسلوبي أبحاث المستخدم وعلم نفس التصميم وأحدث اتجاهات التصميم لإنتاج تصميمات مبتكرة ويمكن الوصول إليها. من خلال مجموعة قوية من المشاريع الناجحة، لدي قدرة مثبتة على تقديم تصميمات ليست فقط مبهجة من الناحية الجمالية ولكن أيضًا وظيفية سلسة، مما يؤدي إلى تحسين تجارب المستخدم ونتائج الأعمال.",
            "Flutter Developer": "باعتباري أحد كبار مطوري Flutter، فأنا ماهر في إنشاء تطبيقات مشتركة بين الأنظمة الأساسية توفر تجربة أصلية على كل من Android وiOS. إن معرفتي الواسعة بإطار عمل Dart وFlutter تمكنني من صياغة واجهات مستخدم مرنة وقواعد تعليمات برمجية قابلة للصيانة. لدي سجل حافل من النجاح في دمج الوظائف المعقدة مع الخدمات الخلفية، مما يضمن رحلة مستخدم سلسة.",
            "Full Stack Developer": "باعتباري أحد كبار مطوري Full Stack، أحمل مجموعة مهارات شاملة وعقلية تفكير تقدمي لتطوير التطبيقات الكاملة. تتيح لي خبرتي في تقنيات الواجهة الأمامية والخلفية، بما في ذلك React وNode.js والخدمات السحابية، إنشاء تطبيقات ويب قابلة للتطوير وعالية الأداء تلبي الأهداف الإستراتيجية للشركات.",
            "Android Developer": "باعتباري أحد كبار مطوري Android، فقد عززت مهاراتي في تصميم تطبيقات Android قوية وقابلة للتطوير، مما أدى إلى الاستفادة من فهمي العميق لمنصة Android ونظامه البيئي. خبرتي في Kotlin وJava وAndroid SDK، بالإضافة إلى التركيز القوي على الهندسة المعمارية النظيفة وأنماط التصميم، تمكنني من تقديم التطبيقات ذات الأداء الأمثل وتجربة المستخدم.",
            "AI Engineer": "باعتباري أحد كبار مهندسي الذكاء الاصطناعي، فأنا منغمس بشدة في تطوير ونشر أنظمة الذكاء الاصطناعي المتطورة. تكمن خبرتي في إنشاء خوارزميات قوية للتعلم الآلي، والتقدم الرائد في التعلم العميق، وتنفيذ حلول الذكاء الاصطناعي التي تعزز الكفاءة التشغيلية بشكل كبير.",
            "Industrial Designer": "باعتباري أحد كبار المصممين الصناعيين، لدي سجل حافل في تطوير تصميمات المنتجات المبتكرة التي تدمج الوظيفة مع الجماليات. لقد مكنتني خبرتي في النمذجة ثلاثية الأبعاد والتصميم الذي يركز على المستخدم وعلوم المواد من قيادة مشاريع التصميم من التفكير إلى التصنيع.",
            "Self-Driving Automobile Engineer": "باعتباري أحد كبار مهندسي السيارات ذاتية القيادة، أمتلك ثروة من الخبرة في تطوير أنظمة المركبات ذاتية القيادة التي تعطي الأولوية للسلامة والكفاءة. تشمل خبرتي دمج أجهزة الاستشعار، والتعلم الآلي، وأنظمة التحكم في الروبوتات، مما مكنني من ابتكار حلول متطورة لمستقبل النقل. لدي سجل حافل من قيادة الفرق متعددة الوظائف لتقديم مشاريع معقدة تلبي معايير الصناعة الصارمة.",
            "Mechanical Engineer": "باعتباري مهندسًا ميكانيكيًا متمرسًا، أحمل سجلاً حافلًا في تصميم وتحسين الأنظمة الميكانيكية التي تعزز الكفاءة والأداء. تشمل خبرتي نمذجة التصميم بمساعدة الكمبيوتر (CAD)، والتحليل الحراري، وهندسة المواد، مما يسمح لي بابتكار حلول تلبي المتطلبات المتطورة لهذه الصناعة. أنا ماهر في قيادة المشاريع بدءًا من المفهوم وحتى الإنتاج، مما يضمن أن جميع المكونات الميكانيكية تعمل بأعلى وظائفها.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "شاهد مهاراتي في تصميم واجهة المستخدم وتجربة المستخدم أثناء العمل من خلال رؤية مشاريعي المنجزة.",
            "Flutter Developer": "شاهد مهاراتي في تطوير Flutter أثناء العمل من خلال رؤية مشاريعي المنجزة.",
            "Full Stack Developer": "شاهد مهاراتي في تطوير Full Stack أثناء العمل من خلال رؤية مشاريعي المنجزة.",
            "Android Developer": "شاهد مهاراتي في تطوير Android أثناء العمل من خلال رؤية مشاريعي المنجزة.",
            "AI Engineer": "شاهد مهاراتي في هندسة الذكاء الاصطناعي أثناء العمل من خلال رؤية مشاريعي المنجزة.",
            "Industrial Designer": "شاهد مهاراتي في التصميم الصناعي أثناء العمل من خلال رؤية مشاريعي المنجزة.",
            "Self-Driving Automobile Engineer": "شاهد مهاراتي في هندسة السيارات ذاتية القيادة أثناء العمل من خلال رؤية مشاريعي المنجزة.",
            "Mechanical Engineer": "شاهد مهاراتي في الهندسة الميكانيكية أثناء العمل من خلال رؤية مشاريعي المنجزة.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "باعتباري أحد كبار مصممي واجهة المستخدم وتجربة المستخدم، اطلع على الدورات التدريبية التي تساعدني في بناء هذه المهارة.",
            "Flutter Developer": "باعتباري أحد كبار مطوري Flutter، اطلع على الدورات التدريبية التي تساعدني في بناء هذه المهارة.",
            "Full Stack Developer": "باعتباري أحد كبار مطوري Full Stack، اطلع على الدورات التدريبية التي تساعدني في بناء هذه المهارة.",
            "Android Developer": "باعتباري مطور Android أول، اطلع على الدورات التدريبية التي تساعدني في بناء هذه المهارة.",
            "AI Engineer": "باعتباري أحد كبار مهندسي الذكاء الاصطناعي، اطلع على الدورات التدريبية التي تساعدني في بناء هذه المهارة.",
            "Industrial Designer": "باعتباري أحد كبار المصممين الصناعيين، اطلع على الدورات التدريبية التي تساعدني في بناء هذه المهارة.",
            "Self-Driving Automobile Engineer": "باعتباري أحد كبار مهندسي السيارات ذاتية القيادة، اطلع على الدورات التدريبية التي تساعدني في بناء هذه المهارة.",
            "Mechanical Engineer": "باعتباري مهندسًا ميكانيكيًا متمرسًا، اطلع على الدورات التدريبية التي تساعدني في بناء هذه المهارة.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "باعتباري أحد كبار مصممي واجهات المستخدم وتجربة المستخدم، اطلع على الكتب التي تساعدني في رحلة تعلم هذه المهارة.",
            "Flutter Developer": "باعتباري أحد كبار مطوري Flutter، تعرف على الكتب التي تساعدني في رحلة تعلم هذه المهارة.",
            "Full Stack Developer": "باعتباري أحد كبار مطوري Full Stack، تعرف على الكتب التي تساعدني في رحلة تعلم هذه المهارة.",
            "Android Developer": "باعتباري أحد كبار مطوري برامج Android، اطلع على الكتب التي تساعدني في رحلة تعلم هذه المهارة.",
            "AI Engineer": "باعتباري أحد كبار مهندسي الذكاء الاصطناعي، تعرف على الكتب التي تساعدني في رحلة تعلم هذه المهارة.",
            "Industrial Designer": "باعتباري مصممًا صناعيًا متمرسًا، تعرف على الكتب التي تساعدني في رحلة تعلم هذه المهارة.",
            "Self-Driving Automobile Engineer": "باعتباري أحد كبار مهندسي السيارات ذاتية القيادة، اطلع على الكتب التي تساعدني في رحلة تعلم هذه المهارة.",
            "Mechanical Engineer": "كمهندس ميكانيكي متمرس، تعرف على الكتب التي تساعدني في رحلة تعلم هذه المهارة.",
        },
        "AllRightsAreReservedLastView": "© 2024 محمد حسين أبوطالبي. كل الحقوق محفوظة.",
        "fontFamily": "Amiri, serif",
    },
    // Persian
    "فارسی": {
        "FirstViewBooksListPageFirstViewIntroductionShortHelp": {
            "UI & UX Designer": "در این صفحه می توانید لیست کامل کتاب های من را که در مورد طراحی رابط کاربری و تجربه کاربری و موضوعات مرتبط با آن خوانده ام را مشاهده کنید.",
            "Flutter Developer": "در این صفحه می‌توانید فهرست کامل کتاب‌های من را که در مورد توسعه فلوتر و موضوعات مرتبط با آن خوانده‌ام، مشاهده کنید.",
            "Full Stack Developer": "در این صفحه می‌توانید فهرست کامل کتاب‌های من را که درباره توسعه فول استک و موضوعات مرتبط با آن خوانده‌ام، مشاهده کنید.",
            "Android Developer": "در این صفحه می توانید لیست کامل کتاب هایی که در مورد توسعه اندروید و موضوعات مرتبط با آن خوانده ام را مشاهده کنید.",
            "AI Engineer": "در این صفحه می توانید لیست کامل کتاب های من که در مورد مهندسی هوش مصنوعی و موضوعات مرتبط با آن خوانده ام را مشاهده کنید.",
            "Industrial Designer": "در این صفحه می توانید فهرست کامل کتاب های من را که در مورد طراحی صنعتی و موضوعات مرتبط با آن خوانده ام را مشاهده کنید.",
            "Self-Driving Automobile Engineer": "در این صفحه می توانید لیست کامل کتاب های من را که در مورد مهندسی خودروهای خودران و موضوعات مرتبط با آن خوانده ام را مشاهده کنید.",
            "Mechanical Engineer": "در این صفحه می توانید لیست کامل کتاب های من که در مورد مهندسی مکانیک و موضوعات مرتبط با آن خوانده ام را مشاهده کنید.",
        },
        "FirstIntroFirstViewDescription": {
            "UI & UX Designer": "من به عنوان یک طراح ارشد رابط کاربری و تجربه کاربری، در ایجاد رابط های کاربری بصری و جذاب که رضایت کاربر را افزایش می دهد، تخصص دارم. رویکرد من تحقیقات کاربر، روانشناسی طراحی و آخرین گرایش های طراحی را برای تولید طرح های نوآورانه و در دسترس ادغام می کند. با مجموعه ای قوی از پروژه های موفق، من توانایی اثبات شده ای برای ارائه طرح هایی دارم که نه تنها از نظر زیبایی شناسی دلپذیر هستند، بلکه عملکردی یکپارچه نیز دارند، که منجر به بهبود تجربیات کاربر و نتایج تجاری می شود.",
            "Flutter Developer": "من به‌عنوان یک توسعه‌دهنده ارشد Flutter، در ساخت برنامه‌های بین پلتفرمی که تجربه‌ای بومی را در اندروید و iOS ارائه می‌کنند، مهارت دارم. دانش گسترده من در مورد دارت و چارچوب فلاتر به من این امکان را می دهد که رابط های کاربری سیال و پایگاه های کد قابل نگهداری ایجاد کنم. من سابقه قوی در ادغام موفقیت آمیز عملکردهای پیچیده با خدمات باطن دارم که سفر یکپارچه کاربر را تضمین می کند.",
            "Full Stack Developer": "من به‌عنوان یک توسعه‌دهنده ارشد Full Stack، مجموعه‌ای از مهارت‌های جامع و طرز فکری آینده‌نگر را برای توسعه برنامه‌های فول استک آورده‌ام. تخصص من در هر دو فناوری‌های فرانت‌اند و بک‌اند، از جمله React، Node.js، و سرویس‌های ابری، به من اجازه می‌دهد تا برنامه‌های وب مقیاس‌پذیر و با کارایی بالا بسازم که اهداف استراتژیک کسب‌وکارها را برآورده کنند.",
            "Android Developer": "به‌عنوان یک توسعه‌دهنده ارشد اندروید، مهارت‌های خود را در ایجاد برنامه‌های اندرویدی قوی و مقیاس‌پذیر تقویت کرده‌ام، و از درک عمیق خود از پلتفرم و اکوسیستم اندروید بهره می‌برم. تخصص من در Kotlin، جاوا و Android SDK، همراه با تمرکز قوی بر معماری و الگوهای طراحی تمیز، به من امکان می‌دهد تا برنامه‌هایی را با عملکرد بهینه و تجربه کاربری ارائه دهم.",
            "AI Engineer": "به عنوان یک مهندس ارشد هوش مصنوعی، عمیقاً در توسعه و استقرار سیستم‌های هوش مصنوعی پیچیده غوطه‌ور هستم. تخصص من در ایجاد الگوریتم های یادگیری ماشینی قوی، پیشرفت های پیشگام در یادگیری عمیق و پیاده سازی راه حل های هوش مصنوعی است که کارایی عملیاتی را به طور قابل توجهی افزایش می دهد.",
            "Industrial Designer": "من به عنوان یک طراح ارشد صنعتی، سابقه اثبات شده ای در توسعه طرح های محصول نوآورانه دارم که عملکرد را با زیبایی شناسی ادغام می کند. تخصص من در مدل سازی سه بعدی، طراحی کاربر محور و علم مواد به من این امکان را داده است که پروژه های طراحی را از ایده پردازی تا تولید هدایت کنم.",
            "Self-Driving Automobile Engineer": "من به عنوان یک مهندس ارشد خودروی خودران، تجربه زیادی در توسعه سیستم های خودروی خودمختار که ایمنی و کارایی را در اولویت قرار می دهند، به ارمغان آورده ام. تخصص من شامل ترکیب حسگرها، یادگیری ماشین و سیستم های کنترل رباتیک است که به من امکان می دهد راه حل های پیشرفته ای را برای حمل و نقل آینده ابداع کنم. من سابقه اثبات شده ای از تیم های پیشرو بین عملکردی برای ارائه پروژه های پیچیده که مطابق با استانداردهای صنعتی دقیق هستند، دارم.",
            "Mechanical Engineer": "به عنوان یک مهندس مکانیک باتجربه، من سابقه اثبات شده ای از طراحی و بهینه سازی سیستم های مکانیکی که کارایی و عملکرد را افزایش می دهد، به ارمغان می آورم. تخصص من شامل مدل سازی CAD، تجزیه و تحلیل حرارتی و مهندسی مواد است که به من امکان می دهد راه حل هایی را ابداع کنم که نیازهای در حال تحول صنعت را برآورده کند. من در هدایت پروژه ها از مفهوم تا تولید ماهر هستم و اطمینان می دهم که تمام اجزای مکانیکی در اوج عملکرد کار می کنند.",
        },
        "ThirdViewProjectSlideParagraphShortDescription": {
            "UI & UX Designer": "با دیدن پروژه های انجام شده من، مهارت های طراحی رابط کاربری و تجربه کاربری من را در عمل مشاهده کنید.",
            "Flutter Developer": "با دیدن پروژه های انجام شده من، مهارت های توسعه فلوتر من را در عمل مشاهده کنید.",
            "Full Stack Developer": "با دیدن پروژه های انجام شده من، مهارت های توسعه کامل پشته من را در عمل مشاهده کنید.",
            "Android Developer": "با دیدن پروژه های انجام شده من، مهارت های توسعه اندروید من را در عمل مشاهده کنید.",
            "AI Engineer": "با دیدن پروژه های انجام شده من، مهارت های مهندسی هوش مصنوعی من را در عمل ببینید.",
            "Industrial Designer": "با دیدن پروژه های انجام شده من، مهارت های طراحی صنعتی من را در عمل ببینید.",
            "Self-Driving Automobile Engineer": "با دیدن پروژه های انجام شده من، مهارت های مهندسی خودروی خودران من را در عمل مشاهده کنید.",
            "Mechanical Engineer": "با دیدن پروژه های انجام شده من، مهارت های مهندسی مکانیک من را در عمل ببینید.",
        },
        "ThirdViewCourcesWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "به عنوان یک طراح ارشد رابط کاربری و تجربه کاربری، دوره هایی را ببینید که به من در ایجاد این مهارت کمک می کنند.",
            "Flutter Developer": "به عنوان یک توسعه دهنده ارشد فلاتر، دوره هایی را ببینید که به من در ایجاد این مهارت کمک می کنند.",
            "Full Stack Developer": "به‌عنوان یک توسعه‌دهنده ارشد Full Stack، دوره‌هایی را ببینید که به من در ایجاد این مهارت کمک می‌کنند.",
            "Android Developer": "به عنوان یک توسعه‌دهنده ارشد اندروید، دوره‌هایی را ببینید که به من در ایجاد این مهارت کمک می‌کنند.",
            "AI Engineer": "به عنوان یک مهندس ارشد هوش مصنوعی، دوره هایی را ببینید که به من در ایجاد این مهارت کمک می کند.",
            "Industrial Designer": "به عنوان یک طراح ارشد صنعتی، دوره هایی را ببینید که به من در ایجاد این مهارت کمک می کند.",
            "Self-Driving Automobile Engineer": "به عنوان یک مهندس ارشد خودروی خودران، دوره هایی را ببینید که به من در ایجاد این مهارت کمک می کند.",
            "Mechanical Engineer": "به عنوان یک مهندس مکانیک باتجربه، دوره هایی را ببینید که به من در ایجاد این مهارت کمک می کنند.",
        },
        "ThirdViewReadBooksWatchedSlideParagraphShortDescription": {
            "UI & UX Designer": "به عنوان یک طراح ارشد رابط کاربری و تجربه کاربری، ببینید کدام کتاب به من در سفر یادگیری این مهارت کمک می کند.",
            "Flutter Developer": "به عنوان یک توسعه‌دهنده ارشد فلاتر، ببینید کدام کتاب‌ها به من در سفر یادگیری این مهارت کمک می‌کنند.",
            "Full Stack Developer": "به عنوان یک توسعه‌دهنده ارشد Full Stack، ببینید کدام کتاب‌ها به من در سفر یادگیری این مهارت کمک می‌کنند.",
            "Android Developer": "به عنوان یک برنامه نویس ارشد اندروید، ببینید کدام کتاب به من در سفر یادگیری این مهارت کمک می کند.",
            "AI Engineer": "به عنوان یک مهندس ارشد هوش مصنوعی، ببینید کدام کتاب به من در سفر یادگیری این مهارت کمک می کند.",
            "Industrial Designer": "به عنوان یک طراح صنعتی با تجربه، ببینید کدام کتاب به من در سفر یادگیری این مهارت کمک می کند.",
            "Self-Driving Automobile Engineer": "به عنوان یک مهندس ارشد خودروی خودران، ببینید کدام کتاب به من در سفر یادگیری این مهارت کمک می کند.",
            "Mechanical Engineer": "به عنوان یک مهندس مکانیک باتجربه، ببینید کدام کتاب به من در سفر یادگیری این مهارت کمک می کند.",
        },
        "AllRightsAreReservedLastView": "© 2024 محمد حسین ابوطالبی. تمامی حقوق محفوظ است.",
        "fontFamily": "'B Nazanin'",
    },
};

// Documentation
// This dictionary contains all the books statically to be used in the preview section or the Book List Page
var PassedCoursesForEachSkillStaticContainer = {
    // UI & UX Designer
    "UI & UX Designer": [

    ],
    // Flutter Developer
    "Flutter Developer": [
        // Flutter & Dart - The Complete Guide
        {
            "CourseName": "Flutter & Dart - The Complete Guide",
            "InstructorName": "Maximilian Schwarzmüller",
            "Gender": "M", // F: Female, M: Male
            "CourseTime": {
                "English": "30 hours, 1 minute",
                "Deutsch": "30 Stunden, 1 Minute",
                "中国人": "30 小时 1 分钟",
                "Русский": "30 часов, 1 минута",
                "Français": "30 heures, 1 minute",
                "日本語": "30時間1分",
                "한국인": "30시간 1분",
                "Español": "30 horas, 1 minuto",
                "हिंदी": "30 घंटे, 1 मिनट",
                "Português": "30 horas, 1 minuto",
                "বাংলা": "30 ঘন্টা, 1 মিনিট",
                "عَرَبِيّ": " ٣٠ ساعة و ١ دقيقة ",
                "فارسی": " ٣٠ ساعت و ١ دقیقه ",
            },
            "PlatformName": "Udemy",
            "Ratings": "4.6",
            "YearNumber": "2021",
            "ProgrammingLanguages": "Flutter and Dart",
            "TableOfContents": [
                // Section 1 : Introduction
                {
                    "SectionName": "Introduction",
                    "Videos": [
                        // 1 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video course introduction, instructor Maximum Schwartzmann enthusiastically welcomes learners to the course on Flutter development. The course promises to cover everything from the basics to advanced topics, including working with native device features and Flutter internal state management. Schwartzmann emphasizes hands-on learning through example-driven projects and building multiple apps throughout the course. Learners can expect quizzes, additional resources for deepening their understanding, and Q&A support. By the end of the course, participants will be well-prepared to create their own Flutter apps with the knowledge gained. Schwartzmann's expertise and passion for Flutter development shine through, setting the stage for an engaging learning experience.",
                                // German
                                "Deutsch": "In dieser Videokurseinführung begrüßt der Kursleiter Maximum Schwartzmann die Teilnehmer enthusiastisch zum Kurs zur Flutter-Entwicklung. Der Kurs verspricht, alles von den Grundlagen bis hin zu fortgeschrittenen Themen abzudecken, einschließlich der Arbeit mit nativen Gerätefunktionen und der internen Zustandsverwaltung von Flutter. Schwartzmann legt Wert auf praxisorientiertes Lernen durch beispielbasierte Projekte und das Erstellen mehrerer Apps während des Kurses. Die Teilnehmer können sich auf Tests, zusätzliche Ressourcen zur Vertiefung ihres Verständnisses und Fragen-und-Antwort-Support freuen. Am Ende des Kurses sind die Teilnehmer gut vorbereitet, um mit dem erworbenen Wissen ihre eigenen Flutter-Apps zu erstellen. Schwartzmanns Fachwissen und Leidenschaft für die Flutter-Entwicklung kommen zum Vorschein und schaffen die Grundlage für ein spannendes Lernerlebnis.",
                                // Chinese
                                "中国人": "在此视频课程介绍中，讲师 Maximum Schwartzmann 热情地欢迎学习者参加 Flutter 开发课程。该课程承诺涵盖从基础到高级主题的所有内容，包括使用本机设备功能和 Flutter 内部状态管理。Schwartzmann 强调通过示例驱动的项目和在整个课程中构建多个应用程序来进行动手学习。学习者可以期待测验、加深理解的额外资源和问答支持。在课程结束时，参与者将做好充分准备，利用所学知识创建自己的 Flutter 应用程序。Schwartzmann 对 Flutter 开发的专业知识和热情闪耀其中，为引人入胜的学习体验奠定了基础。",
                                // Russian
                                "Русский": "В этом видеокурсе инструктор Максимум Шварцманн с энтузиазмом приветствует учащихся на курсе по разработке Flutter. Курс обещает охватить все от основ до продвинутых тем, включая работу с собственными функциями устройств и управление внутренним состоянием Flutter. Шварцманн делает акцент на практическом обучении с помощью проектов на основе примеров и создания нескольких приложений на протяжении всего курса. Учащиеся могут рассчитывать на тесты, дополнительные ресурсы для углубления своего понимания и поддержку вопросов и ответов. К концу курса участники будут хорошо подготовлены к созданию собственных приложений Flutter с полученными знаниями. Опыт и страсть Шварцманна к разработке Flutter проявляются, подготавливая почву для увлекательного обучения.",
                                // French
                                "Français": "Dans cette introduction au cours vidéo, l'instructeur Maximum Schwartzmann accueille avec enthousiasme les apprenants au cours sur le développement Flutter. Le cours promet de couvrir tout, des bases aux sujets avancés, y compris le travail avec les fonctionnalités natives des appareils et la gestion interne de l'état de Flutter. Schwartzmann met l'accent sur l'apprentissage pratique à travers des projets basés sur des exemples et la création de plusieurs applications tout au long du cours. Les apprenants peuvent s'attendre à des quiz, des ressources supplémentaires pour approfondir leur compréhension et une assistance sous forme de questions-réponses. À la fin du cours, les participants seront bien préparés à créer leurs propres applications Flutter avec les connaissances acquises. L'expertise et la passion de Schwartzmann pour le développement Flutter transparaissent, ouvrant la voie à une expérience d'apprentissage engageante.",
                                // Japanese
                                "日本語": "このビデオ コース紹介では、インストラクターの Maximum Schwartzmann が、Flutter 開発コースへの受講者を熱烈に歓迎します。このコースでは、ネイティブ デバイス機能の操作や Flutter 内部状態管理など、基本から高度なトピックまですべてを網羅します。Schwartzmann は、例に基づくプロジェクトやコース全体を通して複数のアプリの構築を通じて、実践的な学習を重視しています。受講者は、クイズ、理解を深めるための追加リソース、Q&A サポートを利用できます。コース終了時には、受講者は習得した知識を使って独自の Flutter アプリを作成する準備が整っています。Schwartzmann の Flutter 開発に関する専門知識と情熱が光り輝き、魅力的な学習体験の土台となっています。",
                                // Korean
                                "한국인": "이 비디오 과정 소개에서 강사인 맥시멈 슈워츠만은 플러터 개발 과정에 참여하는 학습자를 열렬히 환영합니다. 이 과정은 기본부터 고급 주제까지 모든 것을 다룰 예정이며, 여기에는 기본 장치 기능 및 플러터 내부 상태 관리 작업이 포함됩니다. 슈워츠만은 과정 전반에 걸쳐 예제 중심 프로젝트와 여러 앱 구축을 통한 실습 학습을 강조합니다. 학습자는 퀴즈, 이해를 심화하기 위한 추가 리소스, Q&A 지원을 기대할 수 있습니다. 과정이 끝나면 참가자는 습득한 지식으로 자신의 플러터 앱을 만들 준비가 됩니다. 슈워츠만의 플러터 개발에 대한 전문성과 열정이 빛을 발하며 매력적인 학습 경험을 위한 무대를 마련합니다.",
                                // Spanish
                                "Español": "En esta introducción al curso en video, el instructor Maximum Schwartzmann da una entusiasta bienvenida a los alumnos al curso sobre desarrollo de Flutter. El curso promete cubrir todo, desde los conceptos básicos hasta temas avanzados, incluido el trabajo con funciones nativas de dispositivos y la administración del estado interno de Flutter. Schwartzmann enfatiza el aprendizaje práctico a través de proyectos basados ​​en ejemplos y la creación de múltiples aplicaciones a lo largo del curso. Los alumnos pueden esperar exámenes, recursos adicionales para profundizar su comprensión y soporte de preguntas y respuestas. Al final del curso, los participantes estarán bien preparados para crear sus propias aplicaciones de Flutter con el conocimiento adquirido. La experiencia y la pasión de Schwartzmann por el desarrollo de Flutter se destacan, preparando el escenario para una experiencia de aprendizaje interesante.",
                                // Hindi
                                "हिंदी": "इस वीडियो कोर्स परिचय में, प्रशिक्षक मैक्सिमम श्वार्टज़मैन फ़्लटर डेवलपमेंट पर कोर्स में शिक्षार्थियों का उत्साहपूर्वक स्वागत करते हैं। यह कोर्स मूल बातों से लेकर उन्नत विषयों तक सब कुछ कवर करने का वादा करता है, जिसमें मूल डिवाइस सुविधाओं और फ़्लटर आंतरिक स्थिति प्रबंधन के साथ काम करना शामिल है। श्वार्टज़मैन पूरे कोर्स में उदाहरण-संचालित परियोजनाओं और कई ऐप बनाने के माध्यम से व्यावहारिक सीखने पर जोर देते हैं। शिक्षार्थी क्विज़, अपनी समझ को गहरा करने के लिए अतिरिक्त संसाधन और प्रश्नोत्तर सहायता की अपेक्षा कर सकते हैं। कोर्स के अंत तक, प्रतिभागी प्राप्त ज्ञान के साथ अपने स्वयं के फ़्लटर ऐप बनाने के लिए अच्छी तरह से तैयार हो जाएँगे। फ़्लटर डेवलपमेंट के लिए श्वार्टज़मैन की विशेषज्ञता और जुनून चमकता है, जो एक आकर्षक सीखने के अनुभव के लिए मंच तैयार करता है।",
                                // Portuguese
                                "Português": "Nesta introdução ao curso em vídeo, o instrutor Maximum Schwartzmann dá as boas-vindas aos alunos ao curso sobre o desenvolvimento de Flutter. O curso promete cobrir tudo, desde o básico até tópicos avançados, incluindo o trabalho com recursos nativos do dispositivo e a gestão de estado interno do Flutter. Schwartzmann enfatiza a aprendizagem prática através de projetos baseados em exemplos e na construção de várias aplicações ao longo do curso. Os alunos podem esperar questionários, recursos adicionais para aprofundar a sua compreensão e apoio para perguntas e respostas. No final do curso, os participantes estarão bem preparados para criar as suas próprias aplicações Flutter com o conhecimento adquirido. A experiência e a paixão de Schwartzmann pelo desenvolvimento do Flutter brilham, preparando o terreno para uma experiência de aprendizagem envolvente.",
                                // Bengali
                                "বাংলা": "এই ভিডিও কোর্সের ভূমিকায়, প্রশিক্ষক ম্যাক্সিমাম শোয়ার্টজম্যান ফ্লটার ডেভেলপমেন্ট কোর্সে শিক্ষার্থীদের উৎসাহের সাথে স্বাগত জানান। এই কোর্সটি মৌলিক ডিভাইসের বৈশিষ্ট্য এবং ফ্লাটার অভ্যন্তরীণ অবস্থা ব্যবস্থাপনার সাথে কাজ করা সহ মৌলিক বিষয়গুলি থেকে শুরু করে উন্নত বিষয়গুলির সমস্ত কিছু কভার করার প্রতিশ্রুতি দেয়৷ শোয়ার্টজম্যান উদাহরণ-চালিত প্রকল্পের মাধ্যমে হাতে-কলমে শেখার উপর জোর দেন এবং পুরো কোর্স জুড়ে একাধিক অ্যাপ তৈরি করেন। শিক্ষার্থীরা কুইজ, তাদের বোঝাপড়া গভীর করার জন্য অতিরিক্ত সংস্থান এবং প্রশ্নোত্তর সমর্থন আশা করতে পারে। কোর্সের শেষে, অংশগ্রহণকারীরা অর্জিত জ্ঞানের সাথে তাদের নিজস্ব ফ্লাটার অ্যাপ তৈরি করতে ভালোভাবে প্রস্তুত হবে। ফ্লটার ডেভেলপমেন্টের জন্য শোয়ার্টজম্যানের দক্ষতা এবং আবেগ উজ্জ্বল হয়ে ওঠে, একটি আকর্ষক শেখার অভিজ্ঞতার মঞ্চ তৈরি করে।",
                                // Arabic
                                "عَرَبِيّ": "في مقدمة دورة الفيديو هذه، يرحب المدرب ماكسيموم شوارتزمان بحماس بالمتعلمين في دورة تطوير Flutter. تعد الدورة بتغطية كل شيء من الأساسيات إلى المواضيع المتقدمة، بما في ذلك العمل مع ميزات الجهاز الأصلية وإدارة الحالة الداخلية لـ Flutter. يؤكد شوارتزمان على التعلم العملي من خلال المشاريع القائمة على الأمثلة وبناء تطبيقات متعددة طوال الدورة. يمكن للمتعلمين توقع اختبارات وموارد إضافية لتعميق فهمهم ودعم الأسئلة والأجوبة. بحلول نهاية الدورة، سيكون المشاركون مستعدين جيدًا لإنشاء تطبيقات Flutter الخاصة بهم بالمعرفة المكتسبة. تتألق خبرة شوارتزمان وشغفه بتطوير Flutter، مما يمهد الطريق لتجربة تعليمية جذابة.",
                                // Persian
                                "فارسی": "در معرفی این دوره ویدیویی، مدرس ماکسیوم شوارتزمن مشتاقانه از فراگیران در دوره توسعه فلوتر استقبال می کند. این دوره وعده می دهد که همه چیز را از مبانی تا موضوعات پیشرفته، از جمله کار با ویژگی های دستگاه بومی و مدیریت داخلی Flutter پوشش دهد. شوارتزمن بر یادگیری عملی از طریق پروژه های نمونه محور و ساختن چندین اپلیکیشن در طول دوره تاکید دارد. فراگیران می توانند منتظر آزمون ها، منابع اضافی برای تعمیق درک خود و پشتیبانی پرسش و پاسخ باشند. در پایان دوره، شرکت کنندگان به خوبی آماده خواهند شد تا با دانش به دست آمده، اپلیکیشن های Flutter خود را ایجاد کنند. تخصص و اشتیاق شوارتزمن برای توسعه فلاتر می درخشد و زمینه را برای یک تجربه یادگیری جذاب فراهم می کند.",
                            },
                        },
                        // 2 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "What is Flutter",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "Flutter is a tool that allows developers to build native cross-platform apps for both iOS and Android using one programming language and codebase. It eliminates the need to learn different languages for each platform, as it uses Dart as the primary language. Flutter includes a framework, widget library, and SDK to compile code into native machine code for iOS and Android. Dart is a user interface-focused programming language developed by Google and used in conjunction with Flutter to build front-end apps. Together, Flutter and Dart provide a seamless solution for developing mobile applications.",
                                // German
                                "Deutsch": "Flutter ist ein Tool, mit dem Entwickler native plattformübergreifende Apps für iOS und Android mit einer einzigen Programmiersprache und Codebasis erstellen können. Da Dart als primäre Sprache verwendet wird, müssen Sie nicht für jede Plattform eine andere Sprache lernen. Flutter enthält ein Framework, eine Widget-Bibliothek und ein SDK zum Kompilieren von Code in nativen Maschinencode für iOS und Android. Dart ist eine auf die Benutzeroberfläche ausgerichtete Programmiersprache, die von Google entwickelt und in Verbindung mit Flutter zum Erstellen von Front-End-Apps verwendet wird. Gemeinsam bieten Flutter und Dart eine nahtlose Lösung für die Entwicklung mobiler Anwendungen.",
                                // Chinese
                                "中国人": "Flutter 是一款工具，允许开发人员使用一种编程语言和代码库为 iOS 和 Android 构建原生跨平台应用。它使用 Dart 作为主要语言，因此无需为每个平台学习不同的语言。Flutter 包含一个框架、小部件库和 SDK，可将代码编译为 iOS 和 Android 的原生机器代码。Dart 是一种由 Google 开发的以用户界面为中心的编程语言，与 Flutter 结合使用以构建前端应用。Flutter 和 Dart 共同为开发移动应用提供了无缝的解决方案。",
                                // Russian
                                "Русский": "Flutter — это инструмент, позволяющий разработчикам создавать собственные кроссплатформенные приложения для iOS и Android, используя один язык программирования и кодовую базу. Он устраняет необходимость изучать разные языки для каждой платформы, поскольку использует Dart в качестве основного языка. Flutter включает в себя фреймворк, библиотеку виджетов и SDK для компиляции кода в собственный машинный код для iOS и Android. Dart — это язык программирования, ориентированный на пользовательский интерфейс, разработанный Google и используемый совместно с Flutter для создания front-end-приложений. Вместе Flutter и Dart предоставляют бесшовное решение для разработки мобильных приложений.",
                                // French
                                "Français": "Flutter est un outil qui permet aux développeurs de créer des applications multiplateformes natives pour iOS et Android à l'aide d'un seul langage de programmation et d'une seule base de code. Il élimine le besoin d'apprendre différents langages pour chaque plateforme, car il utilise Dart comme langage principal. Flutter comprend un framework, une bibliothèque de widgets et un SDK pour compiler du code en code machine natif pour iOS et Android. Dart est un langage de programmation axé sur l'interface utilisateur développé par Google et utilisé en conjonction avec Flutter pour créer des applications front-end. Ensemble, Flutter et Dart offrent une solution transparente pour le développement d'applications mobiles.",
                                // Japanese
                                "日本語": "Flutter は、開発者が 1 つのプログラミング言語とコードベースを使用して iOS と Android の両方のネイティブ クロスプラットフォーム アプリを構築できるツールです。主要言語として Dart を使用しているため、プラットフォームごとに異なる言語を学習する必要がありません。Flutter には、コードを iOS と Android のネイティブ マシン コードにコンパイルするためのフレームワーク、ウィジェット ライブラリ、SDK が含まれています。Dart は、Google が開発したユーザー インターフェースに重点を置いたプログラミング言語で、フロントエンド アプリの構築に Flutter と組み合わせて使用​​されます。Flutter と Dart を組み合わせることで、モバイル アプリケーションを開発するためのシームレスなソリューションが実現します。",
                                // Korean
                                "한국인": "Flutter는 개발자가 하나의 프로그래밍 언어와 코드베이스를 사용하여 iOS와 Android 모두에 대한 네이티브 크로스 플랫폼 앱을 빌드할 수 있는 도구입니다. Dart를 기본 언어로 사용하므로 각 플랫폼에 대해 다른 언어를 배울 필요가 없습니다. Flutter에는 프레임워크, 위젯 라이브러리 및 SDK가 포함되어 있어 코드를 iOS 및 Android용 네이티브 머신 코드로 컴파일합니다. Dart는 Google에서 개발한 사용자 인터페이스 중심 프로그래밍 언어로, Flutter와 함께 사용하여 프런트엔드 앱을 빌드합니다. Flutter와 Dart는 함께 모바일 애플리케이션을 개발하기 위한 완벽한 솔루션을 제공합니다.",
                                // Spanish
                                "Español": "Flutter es una herramienta que permite a los desarrolladores crear aplicaciones nativas multiplataforma para iOS y Android utilizando un solo lenguaje de programación y código base. Elimina la necesidad de aprender diferentes lenguajes para cada plataforma, ya que utiliza Dart como lenguaje principal. Flutter incluye un marco, una biblioteca de widgets y un SDK para compilar código en código de máquina nativo para iOS y Android. Dart es un lenguaje de programación centrado en la interfaz de usuario desarrollado por Google y utilizado junto con Flutter para crear aplicaciones front-end. Juntos, Flutter y Dart proporcionan una solución perfecta para desarrollar aplicaciones móviles.",
                                // Hindi
                                "हिंदी": "फ़्लटर एक ऐसा टूल है जो डेवलपर्स को एक प्रोग्रामिंग भाषा और कोडबेस का उपयोग करके iOS और Android दोनों के लिए मूल क्रॉस-प्लेटफ़ॉर्म ऐप बनाने की अनुमति देता है। यह प्रत्येक प्लेटफ़ॉर्म के लिए अलग-अलग भाषाएँ सीखने की आवश्यकता को समाप्त करता है, क्योंकि यह प्राथमिक भाषा के रूप में डार्ट का उपयोग करता है। फ़्लटर में iOS और Android के लिए मूल मशीन कोड में कोड संकलित करने के लिए एक फ़्रेमवर्क, विजेट लाइब्रेरी और SDK शामिल है। डार्ट एक उपयोगकर्ता इंटरफ़ेस-केंद्रित प्रोग्रामिंग भाषा है जिसे Google द्वारा विकसित किया गया है और फ़्लटर के साथ मिलकर फ़्रंट-एंड ऐप बनाने के लिए उपयोग किया जाता है। फ़्लटर और डार्ट एक साथ मिलकर मोबाइल एप्लिकेशन विकसित करने के लिए एक सहज समाधान प्रदान करते हैं।",
                                // Portuguese
                                "Português": "O Flutter é uma ferramenta que permite aos programadores criar aplicações nativas multiplataforma para iOS e Android utilizando uma linguagem de programação e base de código. Elimina a necessidade de aprender diferentes línguas para cada plataforma, uma vez que utiliza o Dart como idioma principal. O Flutter inclui uma estrutura, biblioteca de widgets e SDK para compilar código em código de máquina nativo para iOS e Android. O Dart é uma linguagem de programação focada na interface do utilizador desenvolvida pela Google e utilizada em conjunto com o Flutter para construir aplicações front-end. Juntos, o Flutter e o Dart fornecem uma solução perfeita para o desenvolvimento de aplicações móveis.",
                                // Bengali
                                "বাংলা": "ফ্লাটার হল একটি টুল যা ডেভেলপারদের একটি প্রোগ্রামিং ভাষা এবং কোডবেস ব্যবহার করে iOS এবং Android উভয়ের জন্য নেটিভ ক্রস-প্ল্যাটফর্ম অ্যাপ তৈরি করতে দেয়। এটি প্রতিটি প্ল্যাটফর্মের জন্য বিভিন্ন ভাষা শেখার প্রয়োজনীয়তা দূর করে, কারণ এটি প্রাথমিক ভাষা হিসাবে ডার্ট ব্যবহার করে। আইওএস এবং অ্যান্ড্রয়েডের জন্য নেটিভ মেশিন কোডে কোড কম্পাইল করার জন্য ফ্লটারে একটি ফ্রেমওয়ার্ক, উইজেট লাইব্রেরি এবং SDK অন্তর্ভুক্ত রয়েছে। ডার্ট হল একটি ইউজার ইন্টারফেস-কেন্দ্রিক প্রোগ্রামিং ল্যাঙ্গুয়েজ যা গুগল ডেভেলপ করেছে এবং ফ্রন্ট-এন্ড অ্যাপ তৈরি করতে ফ্লটারের সাথে ব্যবহার করা হয়েছে। একসাথে, Flutter এবং Dart মোবাইল অ্যাপ্লিকেশন বিকাশের জন্য একটি বিরামহীন সমাধান প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "Flutter هي أداة تتيح للمطورين إنشاء تطبيقات متعددة المنصات أصلية لكل من iOS وAndroid باستخدام لغة برمجة وقاعدة أكواد واحدة. وهي تلغي الحاجة إلى تعلم لغات مختلفة لكل منصة، حيث تستخدم Dart كلغة أساسية. تتضمن Flutter إطار عمل ومكتبة أدوات ومجموعة أدوات تطوير برمجيات لتجميع التعليمات البرمجية إلى تعليمات برمجية أصلية للأجهزة التي تعمل بنظامي التشغيل iOS وAndroid. Dart هي لغة برمجة تركز على واجهة المستخدم طورتها Google وتستخدم بالاشتراك مع Flutter لإنشاء تطبيقات الواجهة الأمامية. معًا، توفر Flutter وDart حلاً سلسًا لتطوير تطبيقات الأجهزة المحمولة.",
                                // Persian
                                "فارسی": "Flutter ابزاری است که به توسعه دهندگان این امکان را می دهد تا با استفاده از یک زبان برنامه نویسی و یک پایگاه کد، برنامه های چند پلتفرمی بومی را برای iOS و Android بسازند. نیاز به یادگیری زبان های مختلف برای هر پلتفرم را از بین می برد، زیرا از دارت به عنوان زبان اصلی استفاده می کند. Flutter شامل یک چارچوب، کتابخانه ویجت و SDK برای کامپایل کد در کد ماشین بومی برای iOS و Android است. دارت یک زبان برنامه نویسی متمرکز بر رابط کاربری است که توسط گوگل توسعه یافته و همراه با Flutter برای ساخت اپلیکیشن های فرانت اند استفاده می شود. فلاتر و دارت با هم یک راه حل یکپارچه برای توسعه اپلیکیشن های موبایل ارائه می کنند.",
                            },
                        },
                        // 3 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Understanding the Flutter Architecture",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "Flutter applications are built using a UI as Code approach, where developers create a widget tree by writing code instead of using a visual drag-and-drop editor. Widgets are the building blocks of a Flutter app, with everything in the app being a widget. The concept of a one codebase is crucial in Flutter, allowing developers to create Android and iOS apps from the same project while still accommodating platform differences. Throughout the course, developers will learn how to build apps step-by-step, understanding core widgets and the structure of a Flutter application.",
                                // German
                                "Deutsch": "Flutter-Anwendungen werden mit einem UI-as-Code-Ansatz erstellt, bei dem Entwickler einen Widget-Baum erstellen, indem sie Code schreiben, anstatt einen visuellen Drag-and-Drop-Editor zu verwenden. Widgets sind die Bausteine ​​einer Flutter-App, wobei alles in der App ein Widget ist. Das Konzept einer einzigen Codebasis ist bei Flutter von entscheidender Bedeutung, da es Entwicklern ermöglicht, Android- und iOS-Apps aus demselben Projekt zu erstellen und dennoch Plattformunterschiede zu berücksichtigen. Im Laufe des Kurses lernen Entwickler Schritt für Schritt, wie man Apps erstellt, und lernen die wichtigsten Widgets und die Struktur einer Flutter-Anwendung kennen.",
                                // Chinese
                                "中国人": "Flutter 应用程序采用 UI as Code 方法构建，开发人员通过编写代码而不是使用可视化拖放编辑器来创建小部件树。小部件是 Flutter 应用程序的构建块，应用程序中的所有内容都是小部件。单一代码库的概念在 Flutter 中至关重要，它允许开发人员从同一项目创建 Android 和 iOS 应用程序，同时仍能适应平台差异。在整个课程中，开发人员将学习如何逐步构建应用程序，了解核心小部件和 Flutter 应用程序的结构。",
                                // Russian
                                "Русский": "Приложения Flutter создаются с использованием подхода UI как кода, где разработчики создают дерево виджетов, написав код вместо использования визуального редактора перетаскивания. Виджеты являются строительными блоками приложения Flutter, причем все в приложении является виджетом. Концепция единой кодовой базы имеет решающее значение во Flutter, позволяя разработчикам создавать приложения для Android и iOS из одного проекта, при этом учитывая различия платформ. На протяжении всего курса разработчики научатся создавать приложения шаг за шагом, понимая основные виджеты и структуру приложения Flutter.",
                                // French
                                "Français": "Les applications Flutter sont conçues selon une approche UI as Code, où les développeurs créent une arborescence de widgets en écrivant du code au lieu d'utiliser un éditeur visuel par glisser-déposer. Les widgets sont les éléments de base d'une application Flutter, tout ce qui se trouve dans l'application étant un widget. Le concept d'une base de code unique est crucial dans Flutter, permettant aux développeurs de créer des applications Android et iOS à partir du même projet tout en tenant compte des différences de plate-forme. Tout au long du cours, les développeurs apprendront à créer des applications étape par étape, en comprenant les widgets de base et la structure d'une application Flutter.",
                                // Japanese
                                "日本語": "Flutter アプリケーションは、UI as Code アプローチを使用して構築されます。このアプローチでは、開発者は視覚的なドラッグ アンド ドロップ エディターを使用する代わりに、コードを記述してウィジェット ツリーを作成します。ウィジェットは Flutter アプリの構成要素であり、アプリ内のすべてのものがウィジェットになります。1 つのコードベースという概念は Flutter で非常に重要であり、開発者はプラットフォームの違いに対応しながら、同じプロジェクトから Android アプリと iOS アプリを作成できます。コース全体を通して、開発者はコア ウィジェットと Flutter アプリケーションの構造を理解しながら、アプリを段階的に構築する方法を学びます。",
                                // Korean
                                "한국인": "Flutter 애플리케이션은 개발자가 시각적 드래그 앤 드롭 편집기를 사용하는 대신 코드를 작성하여 위젯 트리를 만드는 UI as Code 접근 방식을 사용하여 빌드됩니다. 위젯은 Flutter 앱의 빌딩 블록이며 앱의 모든 것이 위젯입니다. Flutter에서 하나의 코드베이스라는 개념은 매우 중요하여 개발자가 플랫폼 차이를 수용하면서도 동일한 프로젝트에서 Android 및 iOS 앱을 만들 수 있습니다. 과정 전반에 걸쳐 개발자는 핵심 위젯과 Flutter 애플리케이션의 구조를 이해하면서 앱을 단계별로 빌드하는 방법을 배웁니다.",
                                // Spanish
                                "Español": "Las aplicaciones Flutter se crean utilizando un enfoque de interfaz de usuario como código, donde los desarrolladores crean un árbol de widgets escribiendo código en lugar de usar un editor visual de arrastrar y soltar. Los widgets son los componentes básicos de una aplicación Flutter, y todo en la aplicación es un widget. El concepto de una base de código única es crucial en Flutter, ya que permite a los desarrolladores crear aplicaciones de Android e iOS a partir del mismo proyecto y, al mismo tiempo, adaptarse a las diferencias de la plataforma. A lo largo del curso, los desarrolladores aprenderán a crear aplicaciones paso a paso, comprenderán los widgets principales y la estructura de una aplicación Flutter.",
                                // Hindi
                                "हिंदी": "फ़्लटर एप्लिकेशन को UI as Code दृष्टिकोण का उपयोग करके बनाया जाता है, जहाँ डेवलपर्स विज़ुअल ड्रैग-एंड-ड्रॉप एडिटर का उपयोग करने के बजाय कोड लिखकर विजेट ट्री बनाते हैं। विजेट फ़्लटर ऐप के निर्माण खंड हैं, जिसमें ऐप में सब कुछ विजेट होता है। फ़्लटर में एक कोडबेस की अवधारणा महत्वपूर्ण है, जो डेवलपर्स को प्लेटफ़ॉर्म अंतर को समायोजित करते हुए एक ही प्रोजेक्ट से Android और iOS ऐप बनाने की अनुमति देती है। पूरे कोर्स के दौरान, डेवलपर्स सीखेंगे कि कैसे कदम-दर-कदम ऐप बनाएं, कोर विजेट और फ़्लटर एप्लिकेशन की संरचना को समझें।",
                                // Portuguese
                                "Português": "As aplicações Flutter são criadas utilizando uma abordagem de UI como código, onde os programadores criam uma árvore de widgets escrevendo código em vez de utilizar um editor visual de arrastar e largar. Os widgets são os blocos de construção de uma aplicação Flutter, sendo que tudo o que está na aplicação é um widget. O conceito de uma base de código única é crucial no Flutter, permitindo aos programadores criar aplicações Android e iOS a partir do mesmo projeto, ao mesmo tempo que acomodam as diferenças de plataforma. Ao longo do curso, os programadores aprenderão como construir aplicações passo a passo, compreendendo os widgets principais e a estrutura de uma aplicação Flutter.",
                                // Bengali
                                "বাংলা": "ফ্লাটার অ্যাপ্লিকেশনগুলি একটি UI ব্যবহার করে কোড অ্যাপ্রোচ হিসাবে তৈরি করা হয়, যেখানে বিকাশকারীরা ভিজ্যুয়াল ড্র্যাগ-এন্ড-ড্রপ এডিটর ব্যবহার করার পরিবর্তে কোড লিখে একটি উইজেট ট্রি তৈরি করে। উইজেট হল একটি ফ্লাটার অ্যাপের বিল্ডিং ব্লক, অ্যাপের সবকিছুই একটি উইজেট। একটি কোডবেসের ধারণাটি ফ্লটারে অত্যন্ত গুরুত্বপূর্ণ, যা ডেভেলপারদের প্ল্যাটফর্মের পার্থক্যগুলিকে মিটমাট করে একই প্রকল্প থেকে Android এবং iOS অ্যাপ তৈরি করতে দেয়। পুরো কোর্স জুড়ে, বিকাশকারীরা ধাপে ধাপে অ্যাপ তৈরি করতে, মূল উইজেটগুলি এবং একটি ফ্লাটার অ্যাপ্লিকেশনের কাঠামো বুঝতে শিখবে।",
                                // Arabic
                                "عَرَبِيّ": "يتم بناء تطبيقات Flutter باستخدام نهج واجهة المستخدم ككود، حيث يقوم المطورون بإنشاء شجرة عناصر واجهة مستخدم من خلال كتابة الكود بدلاً من استخدام محرر السحب والإفلات المرئي. تعتبر عناصر واجهة المستخدم هي اللبنات الأساسية لتطبيق Flutter، حيث يكون كل شيء في التطبيق عبارة عن عناصر واجهة مستخدم. يعد مفهوم قاعدة التعليمات البرمجية الواحدة أمرًا بالغ الأهمية في Flutter، مما يسمح للمطورين بإنشاء تطبيقات Android وiOS من نفس المشروع مع مراعاة الاختلافات بين المنصات. طوال الدورة، سيتعلم المطورون كيفية بناء التطبيقات خطوة بخطوة، وفهم عناصر واجهة المستخدم الأساسية وبنية تطبيق Flutter.",
                                // Persian
                                "فارسی": "برنامه های Flutter با استفاده از رویکرد UI as Code ساخته می شوند، جایی که توسعه دهندگان با نوشتن کد به جای استفاده از ویرایشگر بصری کشیدن و رها کردن، یک درخت ویجت ایجاد می کنند. ویجت ها بلوک های سازنده برنامه فلاتر هستند و همه چیز در برنامه یک ویجت است. مفهوم یک کد پایه در Flutter بسیار مهم است و به توسعه دهندگان این امکان را می دهد تا برنامه های اندروید و iOS را از یک پروژه ایجاد کنند و در عین حال تفاوت های پلت فرم را نیز در نظر بگیرند. در طول دوره، توسعه دهندگان یاد می گیرند که چگونه برنامه ها را مرحله به مرحله بسازند، ویجت های اصلی و ساختار یک برنامه Flutter را درک کنند.",
                            },
                        },
                        // 4 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "How Flutter & Dart Code Gets Compiled To Native Apps",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "Flutter apps are built using Dart code that interacts with the Flutter framework or API to create the user interface. The Flutter SDK compiles the Dart code into native code for different platforms, resulting in high-performance apps with optimized code. Unlike React Native, Flutter does not use platform primitives but has its own engine that controls every pixel on the screen, providing more control and flexibility in app development. This allows developers to have good performance and full control over building the user interface in Flutter apps.",
                                // German
                                "Deutsch": "Flutter-Anwendungen werden mit einem UI-as-Code-Ansatz erstellt, bei dem Entwickler einen Widget-Baum erstellen, indem sie Code schreiben, anstatt einen visuellen Drag-and-Drop-Editor zu verwenden. Widgets sind die Bausteine ​​einer Flutter-App, wobei alles in der App ein Widget ist. Das Konzept einer einzigen Codebasis ist bei Flutter von entscheidender Bedeutung, da es Entwicklern ermöglicht, Android- und iOS-Apps aus demselben Projekt zu erstellen und dennoch Plattformunterschiede zu berücksichtigen. Im Laufe des Kurses lernen Entwickler Schritt für Schritt, wie man Apps erstellt, und lernen die wichtigsten Widgets und die Struktur einer Flutter-Anwendung kennen.",
                                // Chinese
                                "中国人": "Flutter 应用程序采用 UI as Code 方法构建，开发人员通过编写代码而不是使用可视化拖放编辑器来创建小部件树。小部件是 Flutter 应用程序的构建块，应用程序中的所有内容都是小部件。单一代码库的概念在 Flutter 中至关重要，它允许开发人员从同一项目创建 Android 和 iOS 应用程序，同时仍能适应平台差异。在整个课程中，开发人员将学习如何逐步构建应用程序，了解核心小部件和 Flutter 应用程序的结构。",
                                // Russian
                                "Русский": "Приложения Flutter создаются с использованием подхода UI как кода, где разработчики создают дерево виджетов, написав код вместо использования визуального редактора перетаскивания. Виджеты являются строительными блоками приложения Flutter, причем все в приложении является виджетом. Концепция единой кодовой базы имеет решающее значение во Flutter, позволяя разработчикам создавать приложения для Android и iOS из одного проекта, при этом учитывая различия платформ. На протяжении всего курса разработчики научатся создавать приложения шаг за шагом, понимая основные виджеты и структуру приложения Flutter.",
                                // French
                                "Français": "Les applications Flutter sont conçues selon une approche UI as Code, où les développeurs créent une arborescence de widgets en écrivant du code au lieu d'utiliser un éditeur visuel par glisser-déposer. Les widgets sont les éléments de base d'une application Flutter, tout ce qui se trouve dans l'application étant un widget. Le concept d'une base de code unique est crucial dans Flutter, permettant aux développeurs de créer des applications Android et iOS à partir du même projet tout en tenant compte des différences de plate-forme. Tout au long du cours, les développeurs apprendront à créer des applications étape par étape, en comprenant les widgets de base et la structure d'une application Flutter.",
                                // Japanese
                                "日本語": "Flutter アプリケーションは、UI as Code アプローチを使用して構築されます。このアプローチでは、開発者は視覚的なドラッグ アンド ドロップ エディターを使用する代わりに、コードを記述してウィジェット ツリーを作成します。ウィジェットは Flutter アプリの構成要素であり、アプリ内のすべてのものがウィジェットになります。1 つのコードベースという概念は Flutter で非常に重要であり、開発者はプラットフォームの違いに対応しながら、同じプロジェクトから Android アプリと iOS アプリを作成できます。コース全体を通して、開発者はコア ウィジェットと Flutter アプリケーションの構造を理解しながら、アプリを段階的に構築する方法を学びます。",
                                // Korean
                                "한국인": "Flutter 애플리케이션은 개발자가 시각적 드래그 앤 드롭 편집기를 사용하는 대신 코드를 작성하여 위젯 트리를 만드는 UI as Code 접근 방식을 사용하여 빌드됩니다. 위젯은 Flutter 앱의 빌딩 블록이며 앱의 모든 것이 위젯입니다. Flutter에서 하나의 코드베이스라는 개념은 매우 중요하여 개발자가 플랫폼 차이를 수용하면서도 동일한 프로젝트에서 Android 및 iOS 앱을 만들 수 있습니다. 과정 전반에 걸쳐 개발자는 핵심 위젯과 Flutter 애플리케이션의 구조를 이해하면서 앱을 단계별로 빌드하는 방법을 배웁니다.",
                                // Spanish
                                "Español": "Las aplicaciones Flutter se crean utilizando un enfoque de interfaz de usuario como código, donde los desarrolladores crean un árbol de widgets escribiendo código en lugar de usar un editor visual de arrastrar y soltar. Los widgets son los componentes básicos de una aplicación Flutter, y todo en la aplicación es un widget. El concepto de una base de código única es crucial en Flutter, ya que permite a los desarrolladores crear aplicaciones de Android e iOS a partir del mismo proyecto y, al mismo tiempo, adaptarse a las diferencias de la plataforma. A lo largo del curso, los desarrolladores aprenderán a crear aplicaciones paso a paso, comprenderán los widgets principales y la estructura de una aplicación Flutter.",
                                // Hindi
                                "हिंदी": "फ़्लटर एप्लिकेशन को UI as Code दृष्टिकोण का उपयोग करके बनाया जाता है, जहाँ डेवलपर्स विज़ुअल ड्रैग-एंड-ड्रॉप एडिटर का उपयोग करने के बजाय कोड लिखकर विजेट ट्री बनाते हैं। विजेट फ़्लटर ऐप के निर्माण खंड हैं, जिसमें ऐप में सब कुछ विजेट होता है। फ़्लटर में एक कोडबेस की अवधारणा महत्वपूर्ण है, जो डेवलपर्स को प्लेटफ़ॉर्म अंतर को समायोजित करते हुए एक ही प्रोजेक्ट से Android और iOS ऐप बनाने की अनुमति देती है। पूरे कोर्स के दौरान, डेवलपर्स सीखेंगे कि कैसे कदम-दर-कदम ऐप बनाएं, कोर विजेट और फ़्लटर एप्लिकेशन की संरचना को समझें।",
                                // Portuguese
                                "Português": "As aplicações Flutter são criadas utilizando uma abordagem de UI como código, onde os programadores criam uma árvore de widgets escrevendo código em vez de utilizar um editor visual de arrastar e largar. Os widgets são os blocos de construção de uma aplicação Flutter, sendo que tudo o que está na aplicação é um widget. O conceito de uma base de código única é crucial no Flutter, permitindo aos programadores criar aplicações Android e iOS a partir do mesmo projeto, ao mesmo tempo que acomodam as diferenças de plataforma. Ao longo do curso, os programadores aprenderão como construir aplicações passo a passo, compreendendo os widgets principais e a estrutura de uma aplicação Flutter.",
                                // Bengali
                                "বাংলা": "ফ্লাটার অ্যাপ্লিকেশনগুলি একটি UI ব্যবহার করে কোড অ্যাপ্রোচ হিসাবে তৈরি করা হয়, যেখানে বিকাশকারীরা ভিজ্যুয়াল ড্র্যাগ-এন্ড-ড্রপ এডিটর ব্যবহার করার পরিবর্তে কোড লিখে একটি উইজেট ট্রি তৈরি করে। উইজেট হল একটি ফ্লাটার অ্যাপের বিল্ডিং ব্লক, অ্যাপের সবকিছুই একটি উইজেট। একটি কোডবেসের ধারণাটি ফ্লটারে অত্যন্ত গুরুত্বপূর্ণ, যা ডেভেলপারদের প্ল্যাটফর্মের পার্থক্যগুলিকে মিটমাট করে একই প্রকল্প থেকে Android এবং iOS অ্যাপ তৈরি করতে দেয়। পুরো কোর্স জুড়ে, বিকাশকারীরা ধাপে ধাপে অ্যাপ তৈরি করতে, মূল উইজেটগুলি এবং একটি ফ্লাটার অ্যাপ্লিকেশনের কাঠামো বুঝতে শিখবে।",
                                // Arabic
                                "عَرَبِيّ": "يتم بناء تطبيقات Flutter باستخدام نهج واجهة المستخدم ككود، حيث يقوم المطورون بإنشاء شجرة عناصر واجهة مستخدم من خلال كتابة الكود بدلاً من استخدام محرر السحب والإفلات المرئي. تعتبر عناصر واجهة المستخدم هي اللبنات الأساسية لتطبيق Flutter، حيث يكون كل شيء في التطبيق عبارة عن عناصر واجهة مستخدم. يعد مفهوم قاعدة التعليمات البرمجية الواحدة أمرًا بالغ الأهمية في Flutter، مما يسمح للمطورين بإنشاء تطبيقات Android وiOS من نفس المشروع مع مراعاة الاختلافات بين المنصات. طوال الدورة، سيتعلم المطورون كيفية بناء التطبيقات خطوة بخطوة، وفهم عناصر واجهة المستخدم الأساسية وبنية تطبيق Flutter.",
                                // Persian
                                "فارسی": "برنامه های Flutter با استفاده از رویکرد UI as Code ساخته می شوند، جایی که توسعه دهندگان با نوشتن کد به جای استفاده از ویرایشگر بصری کشیدن و رها کردن، یک درخت ویجت ایجاد می کنند. ویجت ها بلوک های سازنده برنامه فلاتر هستند و همه چیز در برنامه یک ویجت است. مفهوم یک کد پایه در Flutter بسیار مهم است و به توسعه دهندگان این امکان را می دهد تا برنامه های اندروید و iOS را از یک پروژه ایجاد کنند و در عین حال تفاوت های پلت فرم را نیز در نظر بگیرند. در طول دوره، توسعه دهندگان یاد می گیرند که چگونه برنامه ها را مرحله به مرحله بسازند، ویجت های اصلی و ساختار یک برنامه Flutter را درک کنند.",
                            },
                        },
                        // 5 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Understanding Flutter Versions",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "Flutter is a versioned tool that has gained traction in recent years, with Google driving its development. While Flutter versions change frequently, the core features and APIs remain stable, with updates typically focused on bug fixes, improvements, and new niche features. The course on Flutter remains accurate and up-to-date, with the instructor ensuring that any necessary updates are implemented to reflect changes in the tool. Setting up Flutter and building applications with it is the next step, with the videos showcasing the beta version of Flutter but still providing accurate instructions for development.",
                                // German
                                "Deutsch": "Flutter-Anwendungen werden mit einem UI-as-Code-Ansatz erstellt, bei dem Entwickler einen Widget-Baum erstellen, indem sie Code schreiben, anstatt einen visuellen Drag-and-Drop-Editor zu verwenden. Widgets sind die Bausteine ​​einer Flutter-App, wobei alles in der App ein Widget ist. Das Konzept einer einzigen Codebasis ist bei Flutter von entscheidender Bedeutung, da es Entwicklern ermöglicht, Android- und iOS-Apps aus demselben Projekt zu erstellen und dennoch Plattformunterschiede zu berücksichtigen. Im Laufe des Kurses lernen Entwickler Schritt für Schritt, wie man Apps erstellt, und lernen die wichtigsten Widgets und die Struktur einer Flutter-Anwendung kennen.",
                                // Chinese
                                "中国人": "Flutter 应用程序采用 UI as Code 方法构建，开发人员通过编写代码而不是使用可视化拖放编辑器来创建小部件树。小部件是 Flutter 应用程序的构建块，应用程序中的所有内容都是小部件。单一代码库的概念在 Flutter 中至关重要，它允许开发人员从同一项目创建 Android 和 iOS 应用程序，同时仍能适应平台差异。在整个课程中，开发人员将学习如何逐步构建应用程序，了解核心小部件和 Flutter 应用程序的结构。",
                                // Russian
                                "Русский": "Приложения Flutter создаются с использованием подхода UI как кода, где разработчики создают дерево виджетов, написав код вместо использования визуального редактора перетаскивания. Виджеты являются строительными блоками приложения Flutter, причем все в приложении является виджетом. Концепция единой кодовой базы имеет решающее значение во Flutter, позволяя разработчикам создавать приложения для Android и iOS из одного проекта, при этом учитывая различия платформ. На протяжении всего курса разработчики научатся создавать приложения шаг за шагом, понимая основные виджеты и структуру приложения Flutter.",
                                // French
                                "Français": "Les applications Flutter sont conçues selon une approche UI as Code, où les développeurs créent une arborescence de widgets en écrivant du code au lieu d'utiliser un éditeur visuel par glisser-déposer. Les widgets sont les éléments de base d'une application Flutter, tout ce qui se trouve dans l'application étant un widget. Le concept d'une base de code unique est crucial dans Flutter, permettant aux développeurs de créer des applications Android et iOS à partir du même projet tout en tenant compte des différences de plate-forme. Tout au long du cours, les développeurs apprendront à créer des applications étape par étape, en comprenant les widgets de base et la structure d'une application Flutter.",
                                // Japanese
                                "日本語": "Flutter アプリケーションは、UI as Code アプローチを使用して構築されます。このアプローチでは、開発者は視覚的なドラッグ アンド ドロップ エディターを使用する代わりに、コードを記述してウィジェット ツリーを作成します。ウィジェットは Flutter アプリの構成要素であり、アプリ内のすべてのものがウィジェットになります。1 つのコードベースという概念は Flutter で非常に重要であり、開発者はプラットフォームの違いに対応しながら、同じプロジェクトから Android アプリと iOS アプリを作成できます。コース全体を通して、開発者はコア ウィジェットと Flutter アプリケーションの構造を理解しながら、アプリを段階的に構築する方法を学びます。",
                                // Korean
                                "한국인": "Flutter 애플리케이션은 개발자가 시각적 드래그 앤 드롭 편집기를 사용하는 대신 코드를 작성하여 위젯 트리를 만드는 UI as Code 접근 방식을 사용하여 빌드됩니다. 위젯은 Flutter 앱의 빌딩 블록이며 앱의 모든 것이 위젯입니다. Flutter에서 하나의 코드베이스라는 개념은 매우 중요하여 개발자가 플랫폼 차이를 수용하면서도 동일한 프로젝트에서 Android 및 iOS 앱을 만들 수 있습니다. 과정 전반에 걸쳐 개발자는 핵심 위젯과 Flutter 애플리케이션의 구조를 이해하면서 앱을 단계별로 빌드하는 방법을 배웁니다.",
                                // Spanish
                                "Español": "Las aplicaciones Flutter se crean utilizando un enfoque de interfaz de usuario como código, donde los desarrolladores crean un árbol de widgets escribiendo código en lugar de usar un editor visual de arrastrar y soltar. Los widgets son los componentes básicos de una aplicación Flutter, y todo en la aplicación es un widget. El concepto de una base de código única es crucial en Flutter, ya que permite a los desarrolladores crear aplicaciones de Android e iOS a partir del mismo proyecto y, al mismo tiempo, adaptarse a las diferencias de la plataforma. A lo largo del curso, los desarrolladores aprenderán a crear aplicaciones paso a paso, comprenderán los widgets principales y la estructura de una aplicación Flutter.",
                                // Hindi
                                "हिंदी": "फ़्लटर एप्लिकेशन को UI as Code दृष्टिकोण का उपयोग करके बनाया जाता है, जहाँ डेवलपर्स विज़ुअल ड्रैग-एंड-ड्रॉप एडिटर का उपयोग करने के बजाय कोड लिखकर विजेट ट्री बनाते हैं। विजेट फ़्लटर ऐप के निर्माण खंड हैं, जिसमें ऐप में सब कुछ विजेट होता है। फ़्लटर में एक कोडबेस की अवधारणा महत्वपूर्ण है, जो डेवलपर्स को प्लेटफ़ॉर्म अंतर को समायोजित करते हुए एक ही प्रोजेक्ट से Android और iOS ऐप बनाने की अनुमति देती है। पूरे कोर्स के दौरान, डेवलपर्स सीखेंगे कि कैसे कदम-दर-कदम ऐप बनाएं, कोर विजेट और फ़्लटर एप्लिकेशन की संरचना को समझें।",
                                // Portuguese
                                "Português": "As aplicações Flutter são criadas utilizando uma abordagem de UI como código, onde os programadores criam uma árvore de widgets escrevendo código em vez de utilizar um editor visual de arrastar e largar. Os widgets são os blocos de construção de uma aplicação Flutter, sendo que tudo o que está na aplicação é um widget. O conceito de uma base de código única é crucial no Flutter, permitindo aos programadores criar aplicações Android e iOS a partir do mesmo projeto, ao mesmo tempo que acomodam as diferenças de plataforma. Ao longo do curso, os programadores aprenderão como construir aplicações passo a passo, compreendendo os widgets principais e a estrutura de uma aplicação Flutter.",
                                // Bengali
                                "বাংলা": "ফ্লাটার অ্যাপ্লিকেশনগুলি একটি UI ব্যবহার করে কোড অ্যাপ্রোচ হিসাবে তৈরি করা হয়, যেখানে বিকাশকারীরা ভিজ্যুয়াল ড্র্যাগ-এন্ড-ড্রপ এডিটর ব্যবহার করার পরিবর্তে কোড লিখে একটি উইজেট ট্রি তৈরি করে। উইজেট হল একটি ফ্লাটার অ্যাপের বিল্ডিং ব্লক, অ্যাপের সবকিছুই একটি উইজেট। একটি কোডবেসের ধারণাটি ফ্লটারে অত্যন্ত গুরুত্বপূর্ণ, যা ডেভেলপারদের প্ল্যাটফর্মের পার্থক্যগুলিকে মিটমাট করে একই প্রকল্প থেকে Android এবং iOS অ্যাপ তৈরি করতে দেয়। পুরো কোর্স জুড়ে, বিকাশকারীরা ধাপে ধাপে অ্যাপ তৈরি করতে, মূল উইজেটগুলি এবং একটি ফ্লাটার অ্যাপ্লিকেশনের কাঠামো বুঝতে শিখবে।",
                                // Arabic
                                "عَرَبِيّ": "يتم بناء تطبيقات Flutter باستخدام نهج واجهة المستخدم ككود، حيث يقوم المطورون بإنشاء شجرة عناصر واجهة مستخدم من خلال كتابة الكود بدلاً من استخدام محرر السحب والإفلات المرئي. تعتبر عناصر واجهة المستخدم هي اللبنات الأساسية لتطبيق Flutter، حيث يكون كل شيء في التطبيق عبارة عن عناصر واجهة مستخدم. يعد مفهوم قاعدة التعليمات البرمجية الواحدة أمرًا بالغ الأهمية في Flutter، مما يسمح للمطورين بإنشاء تطبيقات Android وiOS من نفس المشروع مع مراعاة الاختلافات بين المنصات. طوال الدورة، سيتعلم المطورون كيفية بناء التطبيقات خطوة بخطوة، وفهم عناصر واجهة المستخدم الأساسية وبنية تطبيق Flutter.",
                                // Persian
                                "فارسی": "برنامه های Flutter با استفاده از رویکرد UI as Code ساخته می شوند، جایی که توسعه دهندگان با نوشتن کد به جای استفاده از ویرایشگر بصری کشیدن و رها کردن، یک درخت ویجت ایجاد می کنند. ویجت ها بلوک های سازنده برنامه فلاتر هستند و همه چیز در برنامه یک ویجت است. مفهوم یک کد پایه در Flutter بسیار مهم است و به توسعه دهندگان این امکان را می دهد تا برنامه های اندروید و iOS را از یک پروژه ایجاد کنند و در عین حال تفاوت های پلت فرم را نیز در نظر بگیرند. در طول دوره، توسعه دهندگان یاد می گیرند که چگونه برنامه ها را مرحله به مرحله بسازند، ویجت های اصلی و ساختار یک برنامه Flutter را درک کنند.",
                            },
                        },
                        // 6 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Flutter macOS Setup",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor explains how to install Flutter on a Mac system step by step. The process involves downloading Git, downloading Flutter, unzipping the Flutter package, setting up the Flutter tool on the system path, configuring Xcode for iOS app development, and setting up Android Studio for Android app development. The video also covers creating a new Flutter project, running the project on an iOS emulator and an Android emulator, and enhancing the Flutter app with additional features. The instructor provides detailed instructions and recommendations to ensure a successful installation and setup process for both iOS and Android development environments.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Kursleiter Schritt für Schritt, wie man Flutter auf einem Mac-System installiert. Der Vorgang umfasst das Herunterladen von Git, das Herunterladen von Flutter, das Entpacken des Flutter-Pakets, das Einrichten des Flutter-Tools im Systempfad, das Konfigurieren von Xcode für die Entwicklung von iOS-Apps und das Einrichten von Android Studio für die Entwicklung von Android-Apps. Das Video behandelt auch das Erstellen eines neuen Flutter-Projekts, das Ausführen des Projekts auf einem iOS-Emulator und einem Android-Emulator sowie das Erweitern der Flutter-App mit zusätzlichen Funktionen. Der Kursleiter gibt detaillierte Anweisungen und Empfehlungen, um einen erfolgreichen Installations- und Einrichtungsprozess sowohl für iOS- als auch für Android-Entwicklungsumgebungen sicherzustellen.",
                                // Chinese
                                "中国人": "在本视频中，讲师将逐步讲解如何在 Mac 系统上安装 Flutter。该过程包括下载 Git、下载 Flutter、解压 Flutter 包、在系统路径上设置 Flutter 工具、配置 Xcode 以进行 iOS 应用开发以及设置 Android Studio 以进行 Android 应用开发。视频还介绍了如何创建新的 Flutter 项目、在 iOS 模拟器和 Android 模拟器上运行项目以及如何使用附加功能增强 Flutter 应用。讲师提供了详细的说明和建议，以确保在 iOS 和 Android 开发环境中成功安装和设置。",
                                // Russian
                                "Русский": "В этом видео инструктор объясняет, как установить Flutter на Mac-систему шаг за шагом. Процесс включает загрузку Git, загрузку Flutter, распаковку пакета Flutter, настройку инструмента Flutter в системном пути, настройку Xcode для разработки приложений iOS и настройку Android Studio для разработки приложений Android. Видео также охватывает создание нового проекта Flutter, запуск проекта на эмуляторе iOS и эмуляторе Android, а также расширение приложения Flutter дополнительными функциями. Инструктор дает подробные инструкции и рекомендации, чтобы обеспечить успешный процесс установки и настройки для сред разработки iOS и Android.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur explique comment installer Flutter sur un système Mac étape par étape. Le processus implique le téléchargement de Git, le téléchargement de Flutter, la décompression du package Flutter, la configuration de l'outil Flutter sur le chemin système, la configuration de Xcode pour le développement d'applications iOS et la configuration d'Android Studio pour le développement d'applications Android. La vidéo couvre également la création d'un nouveau projet Flutter, l'exécution du projet sur un émulateur iOS et un émulateur Android, et l'amélioration de l'application Flutter avec des fonctionnalités supplémentaires. L'instructeur fournit des instructions et des recommandations détaillées pour garantir un processus d'installation et de configuration réussi pour les environnements de développement iOS et Android.",
                                // Japanese
                                "日本語": "このビデオでは、インストラクターが Mac システムに Flutter をインストールする方法を段階的に説明します。プロセスには、Git のダウンロード、Flutter のダウンロード、Flutter パッケージの解凍、システム パスでの Flutter ツールの設定、iOS アプリ開発用の Xcode の構成、Android アプリ開発用の Android Studio の設定が含まれます。また、このビデオでは、新しい Flutter プロジェクトの作成、iOS エミュレーターと Android エミュレーターでのプロジェクトの実行、追加機能による Flutter アプリの強化についても説明します。インストラクターは、iOS と Android の両方の開発環境でインストールとセットアップのプロセスを成功させるための詳細な手順と推奨事項を提供します。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 Mac 시스템에 Flutter를 설치하는 방법을 단계별로 설명합니다. 이 프로세스에는 Git 다운로드, Flutter 다운로드, Flutter 패키지 압축 해제, 시스템 경로에 Flutter 도구 설정, iOS 앱 개발을 위한 Xcode 구성, Android 앱 개발을 위한 Android Studio 설정이 포함됩니다. 이 비디오에서는 새 Flutter 프로젝트 생성, iOS 에뮬레이터와 Android 에뮬레이터에서 프로젝트 실행, 추가 기능으로 Flutter 앱 개선에 대해서도 다룹니다. 강사는 iOS 및 Android 개발 환경 모두에서 성공적인 설치 및 설정 프로세스를 보장하기 위한 자세한 지침과 권장 사항을 제공합니다.",
                                // Spanish
                                "Español": "En este video, el instructor explica cómo instalar Flutter en un sistema Mac paso a paso. El proceso implica descargar Git, descargar Flutter, descomprimir el paquete Flutter, configurar la herramienta Flutter en la ruta del sistema, configurar Xcode para el desarrollo de aplicaciones iOS y configurar Android Studio para el desarrollo de aplicaciones Android. El video también cubre la creación de un nuevo proyecto Flutter, la ejecución del proyecto en un emulador iOS y un emulador Android, y la mejora de la aplicación Flutter con funciones adicionales. El instructor proporciona instrucciones y recomendaciones detalladas para garantizar un proceso de instalación y configuración exitoso para entornos de desarrollo iOS y Android.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक बताते हैं कि मैक सिस्टम पर फ़्लटर को चरण दर चरण कैसे इंस्टॉल किया जाए। इस प्रक्रिया में Git डाउनलोड करना, फ़्लटर डाउनलोड करना, फ़्लटर पैकेज को अनज़िप करना, सिस्टम पथ पर फ़्लटर टूल सेट करना, iOS ऐप डेवलपमेंट के लिए Xcode कॉन्फ़िगर करना और Android ऐप डेवलपमेंट के लिए Android Studio सेट करना शामिल है। वीडियो में एक नया फ़्लटर प्रोजेक्ट बनाना, iOS एमुलेटर और Android एमुलेटर पर प्रोजेक्ट चलाना और फ़्लटर ऐप को अतिरिक्त सुविधाओं के साथ बढ़ाना भी शामिल है। प्रशिक्षक iOS और Android डेवलपमेंट वातावरण दोनों के लिए एक सफल इंस्टॉलेशन और सेटअप प्रक्रिया सुनिश्चित करने के लिए विस्तृत निर्देश और सिफारिशें प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor explica passo a passo como instalar o Flutter num sistema Mac. O processo envolve descarregar o Git, descarregar o Flutter, descompactar o pacote Flutter, configurar a ferramenta Flutter no caminho do sistema, configurar o Xcode para o desenvolvimento de aplicações iOS e configurar o Android Studio para o desenvolvimento de aplicações Android. O vídeo aborda ainda a criação de um novo projeto Flutter, a execução do projeto num emulador iOS e num emulador Android e a melhoria da aplicação Flutter com funcionalidades adicionais. O instrutor fornece instruções e recomendações detalhadas para garantir um processo de instalação e configuração bem-sucedido para ambientes de desenvolvimento iOS e Android.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক ব্যাখ্যা করেছেন কিভাবে একটি ম্যাক সিস্টেমে ধাপে ধাপে ফ্লাটার ইনস্টল করতে হয়। প্রক্রিয়াটির মধ্যে রয়েছে গিট ডাউনলোড করা, ফ্লটার ডাউনলোড করা, ফ্লটার প্যাকেজটি আনজিপ করা, সিস্টেম পাথে ফ্লাটার টুল সেট আপ করা, iOS অ্যাপ ডেভেলপমেন্টের জন্য এক্সকোড কনফিগার করা এবং অ্যান্ড্রয়েড অ্যাপ ডেভেলপমেন্টের জন্য অ্যান্ড্রয়েড স্টুডিও সেট আপ করা। ভিডিওটিতে একটি নতুন ফ্লাটার প্রজেক্ট তৈরি করা, একটি iOS এমুলেটর এবং একটি অ্যান্ড্রয়েড এমুলেটরে প্রজেক্ট চালানো এবং অতিরিক্ত বৈশিষ্ট্য সহ ফ্লাটার অ্যাপ উন্নত করা অন্তর্ভুক্ত রয়েছে। আইওএস এবং অ্যান্ড্রয়েড ডেভেলপমেন্ট উভয় পরিবেশের জন্য একটি সফল ইনস্টলেশন এবং সেটআপ প্রক্রিয়া নিশ্চিত করতে প্রশিক্ষক বিস্তারিত নির্দেশাবলী এবং সুপারিশ প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المدرب كيفية تثبيت Flutter على نظام Mac خطوة بخطوة. تتضمن العملية تنزيل Git وتنزيل Flutter وفك ضغط حزمة Flutter وإعداد أداة Flutter على مسار النظام وتكوين Xcode لتطوير تطبيقات iOS وإعداد Android Studio لتطوير تطبيقات Android. يغطي الفيديو أيضًا إنشاء مشروع Flutter جديد وتشغيل المشروع على محاكي iOS ومحاكي Android وتحسين تطبيق Flutter بميزات إضافية. يقدم المدرب تعليمات وتوصيات مفصلة لضمان عملية تثبيت وإعداد ناجحة لكل من بيئات تطوير iOS وAndroid.",
                                // Persian
                                "فارسی": "در این ویدیو مدرس نحوه نصب فلاتر بر روی سیستم مک را مرحله به مرحله توضیح می دهد. این فرآیند شامل دانلود Git، دانلود Flutter، باز کردن بسته Flutter، راه‌اندازی ابزار Flutter در مسیر سیستم، پیکربندی Xcode برای توسعه برنامه iOS و راه‌اندازی Android Studio برای توسعه برنامه اندروید است. این ویدیو همچنین ایجاد یک پروژه جدید Flutter، اجرای پروژه بر روی شبیه‌ساز iOS و شبیه‌ساز اندروید و بهبود برنامه Flutter با ویژگی‌های اضافی را پوشش می‌دهد. مربی دستورالعمل ها و توصیه های دقیقی را برای اطمینان از موفقیت آمیز بودن فرآیند نصب و راه اندازی برای محیط های توسعه iOS و Android ارائه می دهد.",
                            },
                        },
                        // 7 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "macOS Development Environment",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor explains that while Android Studio is a fully-fledged IDE for Flutter development, they prefer using Visual Studio Code. They guide viewers through installing Visual Studio Code, adding the Flutter and Dart extensions, and customizing the IDE for Flutter development. The instructor demonstrates how to manipulate a Flutter app's code, such as changing counter functionality, and uses hot reload to instantly see changes. They emphasize the benefits of working with Flutter, Dart, and Visual Studio Code throughout the course, providing insights and tips for effective development. The video concludes by hinting at exploring Windows setup while focusing on Mac users for the course's continuation.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Kursleiter, dass Android Studio zwar eine vollwertige IDE für die Flutter-Entwicklung ist, er jedoch lieber Visual Studio Code verwendet. Er führt die Zuschauer durch die Installation von Visual Studio Code, das Hinzufügen der Flutter- und Dart-Erweiterungen und das Anpassen der IDE für die Flutter-Entwicklung. Der Kursleiter zeigt, wie man den Code einer Flutter-App manipuliert, z. B. die Zählerfunktionalität ändert, und verwendet Hot Reload, um Änderungen sofort anzuzeigen. Er betont im gesamten Kurs die Vorteile der Arbeit mit Flutter, Dart und Visual Studio Code und bietet Einblicke und Tipps für eine effektive Entwicklung. Das Video schließt mit einem Hinweis auf die Erkundung der Windows-Einrichtung, während der Schwerpunkt im weiteren Verlauf des Kurses auf Mac-Benutzer gerichtet ist.",
                                // Chinese
                                "中国人": "在本视频中，讲师解释说，虽然 Android Studio 是用于 Flutter 开发的完整 IDE，但他们更喜欢使用 Visual Studio Code。他们指导观众安装 Visual Studio Code、添加 Flutter 和 Dart 扩展以及自定义用于 Flutter 开发的 IDE。讲师演示了如何操作 Flutter 应用的代码，例如更改计数器功能，并使用热重载来立即查看更改。他们在整个课程中强调使用 Flutter、Dart 和 Visual Studio Code 的好处，并提供有效开发的见解和技巧。视频最后暗示了探索 Windows 设置，同时将重点放在 Mac 用户身上，以延续课程。",
                                // Russian
                                "Русский": "В этом видео инструктор объясняет, что хотя Android Studio является полноценной IDE для разработки Flutter, они предпочитают использовать Visual Studio Code. Они проводят зрителей через установку Visual Studio Code, добавление расширений Flutter и Dart и настройку IDE для разработки Flutter. Инструктор демонстрирует, как манипулировать кодом приложения Flutter, например, изменять функциональность счетчика, и использует горячую перезагрузку, чтобы мгновенно увидеть изменения. Они подчеркивают преимущества работы с Flutter, Dart и Visual Studio Code на протяжении всего курса, предоставляя идеи и советы по эффективной разработке. Видео завершается намеком на изучение настройки Windows, при этом фокусируясь на пользователях Mac для продолжения курса.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur explique que même si Android Studio est un IDE à part entière pour le développement Flutter, ils préfèrent utiliser Visual Studio Code. Ils guident les spectateurs dans l'installation de Visual Studio Code, l'ajout des extensions Flutter et Dart et la personnalisation de l'IDE pour le développement Flutter. L'instructeur montre comment manipuler le code d'une application Flutter, comme modifier la fonctionnalité de compteur, et utilise le rechargement à chaud pour voir instantanément les modifications. Ils soulignent les avantages de travailler avec Flutter, Dart et Visual Studio Code tout au long du cours, en fournissant des informations et des conseils pour un développement efficace. La vidéo se termine en faisant allusion à l'exploration de la configuration Windows tout en se concentrant sur les utilisateurs Mac pour la suite du cours.",
                                // Japanese
                                "日本語": "この動画では、Android Studio は Flutter 開発用の本格的な IDE であるものの、Visual Studio Code の使用を好むと講師が説明しています。また、Visual Studio Code のインストール、Flutter および Dart 拡張機能の追加、Flutter 開発用の IDE のカスタマイズについて視聴者に説明します。講師は、カウンター機能の変更など、Flutter アプリのコード操作方法を示し、ホット リロードを使用して変更を即座に確認します。コース全体を通して Flutter、Dart、Visual Studio Code を使用する利点を強調し、効果的な開発のための洞察とヒントを提供します。動画の最後には、コースの続きとして Mac ユーザーに焦点を当てながら、Windows のセットアップについて触れています。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 Android Studio가 Flutter 개발을 위한 본격적인 IDE이지만 Visual Studio Code를 사용하는 것을 선호한다고 설명합니다. 그들은 시청자에게 Visual Studio Code를 설치하고, Flutter와 Dart 확장 프로그램을 추가하고, Flutter 개발을 위해 IDE를 사용자 지정하는 방법을 안내합니다. 강사는 카운터 기능을 변경하는 것과 같이 Flutter 앱의 코드를 조작하는 방법을 보여주고, 핫 리로드를 사용하여 변경 사항을 즉시 확인합니다. 그들은 코스 전반에 걸쳐 Flutter, Dart 및 Visual Studio Code로 작업하는 것의 이점을 강조하고 효과적인 개발을 위한 통찰력과 팁을 제공합니다. 이 비디오는 코스의 지속을 위해 Mac 사용자에게 초점을 맞추면서 Windows 설정을 살펴보는 것을 암시하면서 끝납니다.",
                                // Spanish
                                "Español": "En este video, el instructor explica que, si bien Android Studio es un IDE completo para el desarrollo de Flutter, prefieren usar Visual Studio Code. Guía a los espectadores a través de la instalación de Visual Studio Code, la adición de las extensiones Flutter y Dart y la personalización del IDE para el desarrollo de Flutter. El instructor demuestra cómo manipular el código de una aplicación Flutter, como cambiar la funcionalidad del contador, y usa la recarga activa para ver los cambios al instante. Destaca los beneficios de trabajar con Flutter, Dart y Visual Studio Code a lo largo del curso, y brinda información y sugerencias para un desarrollo eficaz. El video concluye con una sugerencia sobre la exploración de la configuración de Windows mientras se centra en los usuarios de Mac para la continuación del curso.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक बताते हैं कि जबकि एंड्रॉइड स्टूडियो फ़्लटर विकास के लिए एक पूर्ण विकसित IDE है, वे विज़ुअल स्टूडियो कोड का उपयोग करना पसंद करते हैं। वे विज़ुअल स्टूडियो कोड को इंस्टॉल करने, फ़्लटर और डार्ट एक्सटेंशन जोड़ने और फ़्लटर विकास के लिए IDE को कस्टमाइज़ करने के माध्यम से दर्शकों का मार्गदर्शन करते हैं। प्रशिक्षक फ़्लटर ऐप के कोड में हेरफेर करने का तरीका दिखाता है, जैसे काउंटर कार्यक्षमता को बदलना, और परिवर्तनों को तुरंत देखने के लिए हॉट रीलोड का उपयोग करना। वे पूरे कोर्स में फ़्लटर, डार्ट और विज़ुअल स्टूडियो कोड के साथ काम करने के लाभों पर ज़ोर देते हैं, प्रभावी विकास के लिए अंतर्दृष्टि और सुझाव प्रदान करते हैं। वीडियो पाठ्यक्रम की निरंतरता के लिए मैक उपयोगकर्ताओं पर ध्यान केंद्रित करते हुए विंडोज सेटअप की खोज करने का संकेत देकर समाप्त होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor explica que, apesar de o Android Studio ser um IDE completo para desenvolvimento em Flutter, preferem utilizar o Visual Studio Code. Orientam os visualizadores na instalação do Visual Studio Code, na adição das extensões Flutter e Dart e na personalização do IDE para o desenvolvimento do Flutter. O instrutor demonstra como manipular o código de uma aplicação Flutter, como alterar a funcionalidade do contador, e utiliza o hot reload para ver as alterações instantaneamente. Enfatizam os benefícios de trabalhar com Flutter, Dart e Visual Studio Code ao longo do curso, fornecendo insights e dicas para um desenvolvimento eficaz. O vídeo termina sugerindo explorar a configuração do Windows enquanto se foca nos utilizadores de Mac para a continuação do curso.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক ব্যাখ্যা করেছেন যে যখন অ্যান্ড্রয়েড স্টুডিও ফ্লাটার ডেভেলপমেন্টের জন্য একটি সম্পূর্ণ আইডিই, তারা ভিজ্যুয়াল স্টুডিও কোড ব্যবহার করতে পছন্দ করে। তারা ভিজ্যুয়াল স্টুডিও কোড ইনস্টল করার মাধ্যমে, ফ্লাটার এবং ডার্ট এক্সটেনশন যোগ করে এবং ফ্লটার ডেভেলপমেন্টের জন্য IDE কাস্টমাইজ করার মাধ্যমে দর্শকদের গাইড করে। প্রশিক্ষক দেখান কিভাবে একটি ফ্লাটার অ্যাপের কোড ম্যানিপুলেট করা যায়, যেমন কাউন্টার কার্যকারিতা পরিবর্তন করা এবং তাৎক্ষণিকভাবে পরিবর্তনগুলি দেখতে হট রিলোড ব্যবহার করে। তারা পুরো কোর্স জুড়ে ফ্লটার, ডার্ট এবং ভিজ্যুয়াল স্টুডিও কোডের সাথে কাজ করার সুবিধাগুলির উপর জোর দেয়, কার্যকর বিকাশের জন্য অন্তর্দৃষ্টি এবং টিপস প্রদান করে। কোর্সের ধারাবাহিকতার জন্য ম্যাক ব্যবহারকারীদের উপর ফোকাস করার সময় উইন্ডোজ সেটআপ অন্বেষণ করার ইঙ্গিত দিয়ে ভিডিওটি শেষ হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المدرب أنه على الرغم من أن Android Studio عبارة عن بيئة تطوير متكاملة كاملة لتطوير Flutter، إلا أنه يفضل استخدام Visual Studio Code. يوجهون المشاهدين خلال تثبيت Visual Studio Code، وإضافة ملحقات Flutter وDart، وتخصيص بيئة التطوير المتكاملة لتطوير Flutter. يوضح المدرب كيفية التعامل مع كود تطبيق Flutter، مثل تغيير وظيفة العداد، ويستخدم إعادة التحميل السريع لرؤية التغييرات على الفور. يؤكدون على فوائد العمل مع Flutter وDart وVisual Studio Code طوال الدورة، ويقدمون رؤى ونصائح للتطوير الفعال. يختتم الفيديو بالتلميح إلى استكشاف إعداد Windows مع التركيز على مستخدمي Mac لاستمرار الدورة.",
                                // Persian
                                "فارسی": "در این ویدیو، مدرس توضیح می دهد که در حالی که Android Studio یک IDE کامل برای توسعه Flutter است، آنها ترجیح می دهند از Visual Studio Code استفاده کنند. آنها بینندگان را از طریق نصب Visual Studio Code، افزودن پسوندهای Flutter و Dart و سفارشی کردن IDE برای توسعه Flutter راهنمایی می کنند. مربی نشان می دهد که چگونه می توان کد یک برنامه Flutter را دستکاری کرد، مانند تغییر عملکرد پیشخوان، و از بارگذاری مجدد داغ برای مشاهده فوری تغییرات استفاده می کند. آنها بر مزایای کار با Flutter، Dart و Visual Studio Code در طول دوره تاکید می کنند و بینش و نکاتی را برای توسعه موثر ارائه می دهند. این ویدئو با اشاره به کاوش در تنظیمات ویندوز و در عین حال تمرکز بر کاربران مک برای ادامه دوره به پایان می رسد.",
                            },
                        },
                        // 8 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Flutter Windows Setup",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video tutorial provides a comprehensive guide on setting up Flutter on Windows, following installation steps for Mac OS. The instructor emphasizes the importance of following the official setup instructions provided on flutter.dev, particularly for Windows users. The tutorial covers the installation of essential tools, including Windows PowerShell and Git for Windows, required for configuring Flutter. Detailed steps are provided for installing Git and selecting the appropriate options during the installation process. Additionally, the tutorial covers downloading the Flutter SDK and extracting the files to a preferred directory, further discussing the configuration of environment variables to set up Flutter globally on the system. The tutorial concludes with guidance on creating a Flutter project, running the app on a virtual device in Android Studio, and alternatively using the command prompt to build and run the app without relying on Android Studio. The instructor emphasizes the importance of following setup procedures meticulously to ensure a successful Flutter development environment.",
                                // German
                                "Deutsch": "Das Video-Tutorial bietet eine umfassende Anleitung zum Einrichten von Flutter unter Windows und befolgt die Installationsschritte für Mac OS. Der Kursleiter betont, wie wichtig es ist, die offiziellen Einrichtungsanweisungen auf flutter.dev zu befolgen, insbesondere für Windows-Benutzer. Das Tutorial behandelt die Installation wichtiger Tools, darunter Windows PowerShell und Git für Windows, die zum Konfigurieren von Flutter erforderlich sind. Es werden detaillierte Schritte zum Installieren von Git und zum Auswählen der entsprechenden Optionen während des Installationsvorgangs bereitgestellt. Darüber hinaus behandelt das Tutorial das Herunterladen des Flutter SDK und das Extrahieren der Dateien in ein bevorzugtes Verzeichnis. Außerdem wird die Konfiguration von Umgebungsvariablen erläutert, um Flutter global auf dem System einzurichten. Das Tutorial schließt mit Anleitungen zum Erstellen eines Flutter-Projekts, zum Ausführen der App auf einem virtuellen Gerät in Android Studio und alternativ zum Verwenden der Eingabeaufforderung zum Erstellen und Ausführen der App ohne Abhängigkeit von Android Studio. Der Kursleiter betont, wie wichtig es ist, die Einrichtungsverfahren sorgfältig zu befolgen, um eine erfolgreiche Flutter-Entwicklungsumgebung sicherzustellen.",
                                // Chinese
                                "中国人": "视频教程提供了在 Windows 上设置 Flutter 的全面指南，遵循 Mac OS 的安装步骤。讲师强调遵循 flutter.dev 上提供的官方设置说明的重要性，特别是对于 Windows 用户。本教程介绍了配置 Flutter 所需的基本工具的安装，包括 Windows PowerShell 和适用于 Windows 的 Git。提供了安装 Git 和在安装过程中选择适当选项的详细步骤。此外，本教程还介绍了下载 Flutter SDK 并将文件提取到首选目录，进一步讨论了在系统上全局设置 Flutter 的环境变量配置。本教程最后指导您创建 Flutter 项目、在 Android Studio 中的虚拟设备上运行应用程序，以及使用命令提示符在不依赖 Android Studio 的情况下构建和运行应用程序。讲师强调了严格遵循设置程序以确保成功实现 Flutter 开发环境的重要性。",
                                // Russian
                                "Русский": "Видеоурок содержит подробное руководство по настройке Flutter на Windows, следуя шагам установки для Mac OS. Инструктор подчеркивает важность следования официальным инструкциям по настройке, предоставленным на flutter.dev, особенно для пользователей Windows. В руководстве рассматривается установка основных инструментов, включая Windows PowerShell и Git для Windows, необходимых для настройки Flutter. Подробные шаги приведены для установки Git и выбора соответствующих параметров в процессе установки. Кроме того, в руководстве рассматривается загрузка Flutter SDK и извлечение файлов в предпочтительный каталог, а также обсуждается конфигурация переменных среды для глобальной настройки Flutter в системе. В заключение руководства приводится руководство по созданию проекта Flutter, запуску приложения на виртуальном устройстве в Android Studio и альтернативному использованию командной строки для сборки и запуска приложения без использования Android Studio. Инструктор подчеркивает важность тщательного следования процедурам настройки, чтобы обеспечить успешную среду разработки Flutter.",
                                // French
                                "Français": "Le didacticiel vidéo fournit un guide complet sur la configuration de Flutter sur Windows, en suivant les étapes d'installation pour Mac OS. L'instructeur souligne l'importance de suivre les instructions d'installation officielles fournies sur flutter.dev, en particulier pour les utilisateurs Windows. Le didacticiel couvre l'installation des outils essentiels, notamment Windows PowerShell et Git pour Windows, nécessaires à la configuration de Flutter. Des étapes détaillées sont fournies pour l'installation de Git et la sélection des options appropriées pendant le processus d'installation. En outre, le didacticiel couvre le téléchargement du SDK Flutter et l'extraction des fichiers dans un répertoire préféré, en discutant plus en détail de la configuration des variables d'environnement pour configurer Flutter globalement sur le système. Le didacticiel se termine par des conseils sur la création d'un projet Flutter, l'exécution de l'application sur un appareil virtuel dans Android Studio et l'utilisation alternative de l'invite de commande pour créer et exécuter l'application sans s'appuyer sur Android Studio. L'instructeur souligne l'importance de suivre méticuleusement les procédures de configuration pour garantir un environnement de développement Flutter réussi.",
                                // Japanese
                                "日本語": "ビデオチュートリアルでは、Mac OS のインストール手順に従い、Windows で Flutter を設定するための包括的なガイドを提供します。講師は、特に Windows ユーザーの場合、flutter.dev で提供されている公式のセットアップ手順に従うことの重要性を強調しています。チュートリアルでは、Windows PowerShell や Git for Windows など、Flutter を構成するために必要な重要なツールのインストールについて説明します。Git をインストールし、インストールプロセス中に適切なオプションを選択するための詳細な手順が提供されます。さらに、チュートリアルでは、Flutter SDK をダウンロードしてファイルを任意のディレクトリに抽出し、システムでグローバルに Flutter を設定するための環境変数の構成についてさらに説明します。チュートリアルの最後には、Flutter プロジェクトの作成、Android Studio の仮想デバイスでのアプリの実行、または Android Studio に依存せずにコマンドプロンプトを使用してアプリをビルドおよび実行するためのガイダンスが提供されます。講師は、Flutter 開発環境を成功させるために、セットアップ手順に細心の注意を払って従うことの重要性を強調しています。",
                                // Korean
                                "한국인": "비디오 튜토리얼은 Mac OS의 설치 단계에 따라 Windows에서 Flutter를 설정하는 방법에 대한 포괄적인 가이드를 제공합니다. 강사는 특히 Windows 사용자의 경우 flutter.dev에 제공된 공식 설정 지침을 따르는 것의 중요성을 강조합니다. 이 튜토리얼은 Flutter를 구성하는 데 필요한 Windows PowerShell 및 Git for Windows를 포함한 필수 도구의 설치를 다룹니다. 설치 프로세스 중에 Git을 설치하고 적절한 옵션을 선택하는 방법에 대한 자세한 단계가 제공됩니다. 또한 이 튜토리얼은 Flutter SDK를 다운로드하고 파일을 원하는 디렉토리로 추출하는 방법을 다루며, 시스템에서 Flutter를 전역적으로 설정하기 위한 환경 변수 구성에 대해 자세히 설명합니다. 이 튜토리얼은 Flutter 프로젝트를 만들고 Android Studio에서 가상 장치에서 앱을 실행하고 Android Studio에 의존하지 않고 명령 프롬프트를 사용하여 앱을 빌드하고 실행하는 방법에 대한 지침으로 마무리됩니다. 강사는 성공적인 Flutter 개발 환경을 보장하기 위해 설정 절차를 세심하게 따르는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "El videotutorial ofrece una guía completa sobre cómo configurar Flutter en Windows, siguiendo los pasos de instalación para Mac OS. El instructor enfatiza la importancia de seguir las instrucciones de configuración oficiales que se proporcionan en flutter.dev, en particular para los usuarios de Windows. El tutorial cubre la instalación de herramientas esenciales, como Windows PowerShell y Git para Windows, necesarias para configurar Flutter. Se proporcionan pasos detallados para instalar Git y seleccionar las opciones adecuadas durante el proceso de instalación. Además, el tutorial cubre la descarga del SDK de Flutter y la extracción de los archivos a un directorio preferido, y analiza más a fondo la configuración de las variables de entorno para configurar Flutter de forma global en el sistema. El tutorial concluye con una guía sobre cómo crear un proyecto de Flutter, ejecutar la aplicación en un dispositivo virtual en Android Studio y, como alternativa, usar el símbolo del sistema para compilar y ejecutar la aplicación sin depender de Android Studio. El instructor enfatiza la importancia de seguir meticulosamente los procedimientos de configuración para garantizar un entorno de desarrollo de Flutter exitoso.",
                                // Hindi
                                "हिंदी": "वीडियो ट्यूटोरियल विंडोज पर फ़्लटर को सेट करने, मैक ओएस के लिए इंस्टॉलेशन चरणों का पालन करने के बारे में एक व्यापक गाइड प्रदान करता है। प्रशिक्षक विशेष रूप से विंडोज उपयोगकर्ताओं के लिए flutter.dev पर दिए गए आधिकारिक सेटअप निर्देशों का पालन करने के महत्व पर जोर देता है। ट्यूटोरियल फ़्लटर को कॉन्फ़िगर करने के लिए आवश्यक Windows PowerShell और Git for Windows सहित आवश्यक टूल की स्थापना को कवर करता है। Git को इंस्टॉल करने और इंस्टॉलेशन प्रक्रिया के दौरान उपयुक्त विकल्पों का चयन करने के लिए विस्तृत चरण प्रदान किए गए हैं। इसके अतिरिक्त, ट्यूटोरियल फ़्लटर SDK को डाउनलोड करने और फ़ाइलों को एक पसंदीदा निर्देशिका में निकालने, सिस्टम पर फ़्लटर को वैश्विक रूप से सेट करने के लिए पर्यावरण चर के कॉन्फ़िगरेशन पर आगे चर्चा करने को कवर करता है। ट्यूटोरियल फ़्लटर प्रोजेक्ट बनाने, एंड्रॉइड स्टूडियो में वर्चुअल डिवाइस पर ऐप चलाने और वैकल्पिक रूप से एंड्रॉइड स्टूडियो पर निर्भर किए बिना ऐप बनाने और चलाने के लिए कमांड प्रॉम्प्ट का उपयोग करने के मार्गदर्शन के साथ समाप्त होता है। प्रशिक्षक एक सफल फ़्लटर डेवलपमेंट एनवायरनमेंट सुनिश्चित करने के लिए सेटअप प्रक्रियाओं का सावधानीपूर्वक पालन करने के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "O tutorial em vídeo fornece um guia completo sobre como configurar o Flutter no Windows, seguindo os passos de instalação para Mac OS. O instrutor realça a importância de seguir as instruções oficiais de configuração fornecidas no flutter.dev, principalmente para utilizadores do Windows. O tutorial aborda a instalação de ferramentas essenciais, incluindo o Windows PowerShell e o Git para Windows, necessárias para configurar o Flutter. São fornecidas etapas detalhadas para instalar o Git e selecionar as opções adequadas durante o processo de instalação. Além disso, o tutorial aborda o download do Flutter SDK e a extração dos ficheiros para um diretório preferido, discutindo ainda a configuração de variáveis ​​de ambiente para configurar o Flutter globalmente no sistema. O tutorial termina com orientações sobre como criar um projeto Flutter, executar a aplicação num dispositivo virtual no Android Studio e, em alternativa, utilizar a linha de comandos para criar e executar a aplicação sem depender do Android Studio. O instrutor sublinha a importância de seguir meticulosamente os procedimentos de configuração para garantir um ambiente de desenvolvimento Flutter bem-sucedido.",
                                // Bengali
                                "বাংলা": "ভিডিও টিউটোরিয়ালটি Mac OS-এর জন্য ইনস্টলেশনের ধাপগুলি অনুসরণ করে Windows-এ Flutter সেট আপ করার বিষয়ে একটি ব্যাপক নির্দেশিকা প্রদান করে। প্রশিক্ষক flutter.dev-এ প্রদত্ত অফিসিয়াল সেটআপ নির্দেশাবলী অনুসরণ করার গুরুত্বের ওপর জোর দেন, বিশেষ করে Windows ব্যবহারকারীদের জন্য। টিউটোরিয়ালটি ফ্লটার কনফিগার করার জন্য প্রয়োজনীয় Windows PowerShell এবং Windows এর জন্য Git সহ প্রয়োজনীয় সরঞ্জামগুলির ইনস্টলেশন কভার করে। Git ইনস্টল করার জন্য এবং ইনস্টলেশন প্রক্রিয়া চলাকালীন উপযুক্ত বিকল্পগুলি নির্বাচন করার জন্য বিশদ পদক্ষেপগুলি সরবরাহ করা হয়েছে। উপরন্তু, টিউটোরিয়ালটি ফ্লাটার SDK ডাউনলোড করা এবং ফাইলগুলিকে একটি পছন্দের ডিরেক্টরিতে নিষ্কাশন করা, সিস্টেমে বিশ্বব্যাপী ফ্লাটার সেট আপ করার জন্য পরিবেশ ভেরিয়েবলের কনফিগারেশন নিয়ে আরও আলোচনা করে। টিউটোরিয়ালটি একটি ফ্লাটার প্রজেক্ট তৈরি করা, অ্যান্ড্রয়েড স্টুডিওতে একটি ভার্চুয়াল ডিভাইসে অ্যাপটি চালানো এবং বিকল্পভাবে অ্যান্ড্রয়েড স্টুডিওর উপর নির্ভর না করে অ্যাপটি তৈরি এবং চালানোর জন্য কমান্ড প্রম্পট ব্যবহার করার নির্দেশনা দিয়ে শেষ হয়েছে। প্রশিক্ষক একটি সফল ফ্লাটার ডেভেলপমেন্ট এনভায়রনমেন্ট নিশ্চিত করতে সূক্ষ্মভাবে সেটআপ পদ্ধতি অনুসরণ করার গুরুত্বের উপর জোর দেন।",
                                // Arabic
                                "عَرَبِيّ": "يقدم البرنامج التعليمي بالفيديو دليلاً شاملاً حول إعداد Flutter على Windows، باتباع خطوات التثبيت لنظام التشغيل Mac OS. ويؤكد المدرب على أهمية اتباع تعليمات الإعداد الرسمية المقدمة على flutter.dev، وخاصة لمستخدمي Windows. ويغطي البرنامج التعليمي تثبيت الأدوات الأساسية، بما في ذلك Windows PowerShell وGit لنظام Windows، المطلوبة لتكوين Flutter. ويتم توفير خطوات مفصلة لتثبيت Git وتحديد الخيارات المناسبة أثناء عملية التثبيت. بالإضافة إلى ذلك، يغطي البرنامج التعليمي تنزيل مجموعة أدوات Flutter واستخراج الملفات إلى دليل مفضل، ومناقشة تكوين متغيرات البيئة لإعداد Flutter عالميًا على النظام. ويختتم البرنامج التعليمي بإرشادات حول إنشاء مشروع Flutter، وتشغيل التطبيق على جهاز افتراضي في Android Studio، أو بدلاً من ذلك استخدام موجه الأوامر لبناء التطبيق وتشغيله دون الاعتماد على Android Studio. ويؤكد المدرب على أهمية اتباع إجراءات الإعداد بدقة لضمان بيئة تطوير Flutter ناجحة.",
                                // Persian
                                "فارسی": "آموزش ویدیویی راهنمای جامعی در مورد راه اندازی Flutter در ویندوز، به دنبال مراحل نصب برای سیستم عامل مک ارائه می دهد. مدرس بر اهمیت پیروی از دستورالعمل های راه اندازی رسمی ارائه شده در flutter.dev، به ویژه برای کاربران ویندوز تأکید می کند. این آموزش نصب ابزارهای ضروری از جمله Windows PowerShell و Git برای ویندوز را که برای پیکربندی Flutter لازم است، پوشش می‌دهد. مراحل دقیق برای نصب Git و انتخاب گزینه های مناسب در طول مراحل نصب ارائه شده است. علاوه بر این، این آموزش دانلود Flutter SDK و استخراج فایل‌ها در فهرست دلخواه را پوشش می‌دهد، و در مورد پیکربندی متغیرهای محیطی برای راه‌اندازی Flutter به صورت سراسری در سیستم بحث می‌کند. این آموزش با راهنمایی در مورد ایجاد یک پروژه Flutter، اجرای برنامه بر روی یک دستگاه مجازی در اندروید استودیو و همچنین استفاده از خط فرمان برای ساخت و اجرای برنامه بدون اتکا به Android Studio به پایان می رسد. مدرس بر اهمیت پیروی دقیق از مراحل راه اندازی برای اطمینان از یک محیط توسعه موفق Flutter تأکید می کند.",
                            },
                        },
                        // 9 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Windows Development Environment",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video tutorial introduces Visual Studio Code (VS Code) as the preferred editor for Flutter development, recommending its free IDE with excellent Flutter support. Viewers are guided on downloading and installing VS Code, adding necessary extensions such as the official Flutter extension and Dart extension to enhance functionality. Additionally, the tutorial mentions installing the optional 'Material Icon' theme for visual enhancements. Detailed instructions are provided on accessing and modifying Flutter code within the project folder, implementing changes to the code to increase the counter by two in the app. The tutorial emphasizes using the 'flutter run' process for hot reloading and full rebuilding of the app. Upon successfully implementing and testing the code changes, the tutorial concludes, marking the completion of the Windows setup for further exploration into Flutter development.",
                                // German
                                "Deutsch": "Das Video-Tutorial stellt Visual Studio Code (VS Code) als bevorzugten Editor für die Flutter-Entwicklung vor und empfiehlt die kostenlose IDE mit hervorragender Flutter-Unterstützung. Die Zuschauer werden durch das Herunterladen und Installieren von VS Code geführt und fügen notwendige Erweiterungen wie die offizielle Flutter-Erweiterung und die Dart-Erweiterung hinzu, um die Funktionalität zu verbessern. Darüber hinaus erwähnt das Tutorial die Installation des optionalen Designs „Material Icon“ für visuelle Verbesserungen. Es werden detaillierte Anweisungen zum Zugreifen auf und Ändern von Flutter-Code im Projektordner bereitgestellt, sowie zum Implementieren von Codeänderungen, um den Zähler in der App um zwei zu erhöhen. Das Tutorial betont die Verwendung des „Flutter Run“-Prozesses zum Hot Reloading und vollständigen Neuaufbau der App. Nach erfolgreicher Implementierung und Prüfung der Codeänderungen endet das Tutorial und markiert den Abschluss der Windows-Einrichtung für die weitere Erkundung der Flutter-Entwicklung.",
                                // Chinese
                                "中国人": "视频教程介绍了 Visual Studio Code (VS Code) 作为 Flutter 开发的首选编辑器，并推荐了其免费 IDE，该 IDE 对 Flutter 提供了出色的支持。教程指导观众下载和安装 VS Code，添加必要的扩展（如官方 Flutter 扩展和 Dart 扩展）以增强功能。此外，教程还提到了安装可选的“Material Icon”主题以增强视觉效果。教程提供了有关访问和修改项目文件夹中的 Flutter 代码、对代码进行更改以将应用程序中的计数器增加两个的详细说明。教程强调使用“flutter run”过程进行热重载和完全重建应用程序。成功实施和测试代码更改后，教程结束，标志着 Windows 设置已完成，可以进一步探索 Flutter 开发。",
                                // Russian
                                "Русский": "Видеоурок знакомит с Visual Studio Code (VS Code) как с предпочтительным редактором для разработки Flutter, рекомендуя его бесплатную IDE с превосходной поддержкой Flutter. Зрителям даются указания по загрузке и установке VS Code, добавлению необходимых расширений, таких как официальное расширение Flutter и расширение Dart, для улучшения функциональности. Кроме того, в уроке упоминается установка дополнительной темы «Material Icon» для визуальных улучшений. Предоставляются подробные инструкции по доступу и изменению кода Flutter в папке проекта, внедрению изменений в код для увеличения счетчика на два в приложении. В уроке подчеркивается использование процесса «flutter run» для горячей перезагрузки и полной перестройки приложения. После успешной реализации и тестирования изменений кода урок завершается, отмечая завершение настройки Windows для дальнейшего изучения разработки Flutter.",
                                // French
                                "Français": "Le didacticiel vidéo présente Visual Studio Code (VS Code) comme l'éditeur préféré pour le développement Flutter, en recommandant son IDE gratuit avec une excellente prise en charge de Flutter. Les spectateurs sont guidés pour télécharger et installer VS Code, en ajoutant les extensions nécessaires telles que l'extension officielle Flutter et l'extension Dart pour améliorer les fonctionnalités. De plus, le didacticiel mentionne l'installation du thème optionnel « Material Icon » pour des améliorations visuelles. Des instructions détaillées sont fournies sur l'accès et la modification du code Flutter dans le dossier du projet, la mise en œuvre des modifications du code pour augmenter le compteur de deux dans l'application. Le didacticiel met l'accent sur l'utilisation du processus « Flutter Run » pour le rechargement à chaud et la reconstruction complète de l'application. Une fois les modifications de code implémentées et testées avec succès, le didacticiel se termine, marquant l'achèvement de la configuration de Windows pour une exploration plus approfondie du développement de Flutter.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、Flutter 開発の推奨エディタとして Visual Studio Code (VS Code) を紹介し、優れた Flutter サポートを備えた無料の IDE を推奨しています。視聴者は、VS Code のダウンロードとインストール、機能強化のための公式 Flutter 拡張機能や Dart 拡張機能などの必要な拡張機能の追加についてガイドされます。さらに、このチュートリアルでは、視覚的な強化のためにオプションの「マテリアル アイコン」テーマをインストールする方法についても触れています。プロジェクト フォルダ内の Flutter コードにアクセスして変更する方法、アプリのカウンターを 2 つ増やすコード変更の実装方法については、詳細な手順が提供されています。このチュートリアルでは、ホット リロードとアプリの完全な再構築に「flutter run」プロセスを使用することを強調しています。コード変更の実装とテストに成功すると、チュートリアルは終了し、Flutter 開発をさらに探求するための Windows セットアップが完了します。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼은 Flutter 개발을 위한 기본 편집기로 Visual Studio Code(VS Code)를 소개하고, Flutter를 훌륭하게 지원하는 무료 IDE를 추천합니다. 시청자는 VS Code를 다운로드하고 설치하고, 공식 Flutter 확장 프로그램 및 Dart 확장 프로그램과 같은 필요한 확장 프로그램을 추가하여 기능을 향상시키는 방법을 안내받습니다. 또한, 이 튜토리얼은 시각적 향상을 위해 선택적 'Material Icon' 테마를 설치하는 방법을 언급합니다. 프로젝트 폴더 내에서 Flutter 코드에 액세스하고 수정하고, 앱에서 카운터를 두 개 늘리기 위해 코드를 변경하는 방법에 대한 자세한 지침이 제공됩니다. 이 튜토리얼은 핫 리로딩 및 앱 전체 재구성을 위해 'flutter run' 프로세스를 사용하는 것을 강조합니다. 코드 변경 사항을 성공적으로 구현하고 테스트한 후, 튜토리얼은 Flutter 개발을 더 자세히 탐색하기 위한 Windows 설치가 완료되었음을 표시하며 끝납니다.",
                                // Spanish
                                "Español": "El videotutorial presenta Visual Studio Code (VS Code) como el editor preferido para el desarrollo de Flutter, y recomienda su IDE gratuito con excelente compatibilidad con Flutter. Se guía a los espectadores para descargar e instalar VS Code, y agregar las extensiones necesarias, como la extensión oficial de Flutter y la extensión de Dart, para mejorar la funcionalidad. Además, el tutorial menciona la instalación del tema opcional 'Material Icon' para mejoras visuales. Se brindan instrucciones detalladas sobre cómo acceder y modificar el código de Flutter dentro de la carpeta del proyecto, e implementar cambios en el código para aumentar el contador en dos en la aplicación. El tutorial enfatiza el uso del proceso 'flutter run' para la recarga en caliente y la reconstrucción completa de la aplicación. Luego de implementar y probar con éxito los cambios de código, el tutorial concluye, marcando la finalización de la configuración de Windows para una mayor exploración del desarrollo de Flutter.",
                                // Hindi
                                "हिंदी": "वीडियो ट्यूटोरियल फ़्लटर डेवलपमेंट के लिए पसंदीदा एडिटर के रूप में विज़ुअल स्टूडियो कोड (VS कोड) का परिचय देता है, जो फ़्लटर के बेहतरीन समर्थन के साथ इसके मुफ़्त IDE की अनुशंसा करता है। दर्शकों को VS कोड डाउनलोड करने और इंस्टॉल करने, कार्यक्षमता बढ़ाने के लिए आधिकारिक फ़्लटर एक्सटेंशन और डार्ट एक्सटेंशन जैसे आवश्यक एक्सटेंशन जोड़ने के बारे में मार्गदर्शन दिया जाता है। इसके अतिरिक्त, ट्यूटोरियल में विज़ुअल एन्हांसमेंट के लिए वैकल्पिक 'मटेरियल आइकन' थीम इंस्टॉल करने का उल्लेख किया गया है। प्रोजेक्ट फ़ोल्डर के भीतर फ़्लटर कोड तक पहुँचने और उसे संशोधित करने, ऐप में काउंटर को दो से बढ़ाने के लिए कोड में परिवर्तन लागू करने के बारे में विस्तृत निर्देश दिए गए हैं। ट्यूटोरियल हॉट रीलोडिंग और ऐप के पूर्ण पुनर्निर्माण के लिए 'फ़्लटर रन' प्रक्रिया का उपयोग करने पर जोर देता है। कोड परिवर्तनों को सफलतापूर्वक लागू करने और उनका परीक्षण करने के बाद, ट्यूटोरियल समाप्त होता है, फ़्लटर डेवलपमेंट में आगे की खोज के लिए विंडोज सेटअप के पूरा होने को चिह्नित करता है।",
                                // Portuguese
                                "Português": "O tutorial em vídeo apresenta o Visual Studio Code (VS Code) como o editor preferencial para o desenvolvimento do Flutter, recomendando o seu IDE gratuito com um excelente suporte para o Flutter. Os visualizadores são orientados sobre como descarregar e instalar o VS Code, adicionando extensões necessárias, como a extensão oficial Flutter e a extensão Dart para melhorar a funcionalidade. Além disso, o tutorial menciona a instalação do tema opcional ‘Material Icon’ para melhorias visuais. São fornecidas instruções detalhadas sobre como aceder e modificar o código Flutter na pasta do projeto, implementando alterações no código para aumentar o contador em dois na aplicação. O tutorial enfatiza a utilização do processo 'flutter run' para recarga a quente e reconstrução completa da aplicação. Após a implementação e teste bem-sucedidos das alterações de código, o tutorial é concluído, marcando a conclusão da configuração do Windows para exploração adicional no desenvolvimento do Flutter.",
                                // Bengali
                                "বাংলা": "ভিডিও টিউটোরিয়ালটি ভিজ্যুয়াল স্টুডিও কোড (ভিএস কোড) কে ফ্লটার ডেভেলপমেন্টের জন্য পছন্দের সম্পাদক হিসেবে উপস্থাপন করে, চমৎকার ফ্লাটার সমর্থন সহ এটির বিনামূল্যে IDE সুপারিশ করে। ভিএস কোড ডাউনলোড এবং ইনস্টল করার বিষয়ে দর্শকদের নির্দেশনা দেওয়া হয়, কার্যকারিতা বাড়াতে অফিসিয়াল ফ্লাটার এক্সটেনশন এবং ডার্ট এক্সটেনশনের মতো প্রয়োজনীয় এক্সটেনশন যোগ করা হয়। অতিরিক্তভাবে, টিউটোরিয়ালটি ভিজ্যুয়াল উন্নতির জন্য ঐচ্ছিক 'মেটেরিয়াল আইকন' থিম ইনস্টল করার কথা উল্লেখ করে। প্রজেক্ট ফোল্ডারের মধ্যে ফ্লাটার কোড অ্যাক্সেস এবং পরিবর্তন করার বিষয়ে বিস্তারিত নির্দেশাবলী দেওয়া হয়েছে, অ্যাপে কাউন্টারকে দুই দ্বারা বাড়ানোর জন্য কোডে পরিবর্তনগুলি প্রয়োগ করা হয়েছে। টিউটোরিয়ালটি হট রিলোডিং এবং অ্যাপটির সম্পূর্ণ পুনর্নির্মাণের জন্য 'ফ্লাটার রান' প্রক্রিয়া ব্যবহার করার উপর জোর দেয়। কোড পরিবর্তনগুলি সফলভাবে বাস্তবায়ন এবং পরীক্ষা করার পরে, টিউটোরিয়ালটি শেষ হয়, ফ্লটার ডেভেলপমেন্টে আরও অনুসন্ধানের জন্য উইন্ডোজ সেটআপের সমাপ্তি চিহ্নিত করে।",
                                // Arabic
                                "عَرَبِيّ": "يقدم البرنامج التعليمي بالفيديو Visual Studio Code (VS Code) باعتباره المحرر المفضل لتطوير Flutter، ويوصي ببيئته المتكاملة المجانية مع دعم Flutter الممتاز. يتم توجيه المشاهدين حول تنزيل VS Code وتثبيته، وإضافة الامتدادات الضرورية مثل امتداد Flutter الرسمي وامتداد Dart لتحسين الوظائف. بالإضافة إلى ذلك، يذكر البرنامج التعليمي تثبيت السمة الاختيارية 'Material Icon' لتحسينات بصرية. يتم توفير تعليمات مفصلة حول الوصول إلى كود Flutter وتعديله داخل مجلد المشروع، وتنفيذ التغييرات على الكود لزيادة العداد بمقدار اثنين في التطبيق. يؤكد البرنامج التعليمي على استخدام عملية 'تشغيل Flutter' لإعادة التحميل السريع وإعادة بناء التطبيق بالكامل. بعد تنفيذ واختبار تغييرات الكود بنجاح، ينتهي البرنامج التعليمي، مما يشير إلى اكتمال إعداد Windows لمزيد من الاستكشاف في تطوير Flutter.",
                                // Persian
                                "فارسی": "این آموزش ویدیویی کد ویژوال استودیو (VS Code) را به عنوان ویرایشگر ترجیحی برای توسعه Flutter معرفی می کند و IDE رایگان آن را با پشتیبانی عالی Flutter توصیه می کند. بینندگان برای دانلود و نصب کد VS راهنمایی می‌شوند و افزونه‌های لازم مانند پسوند رسمی Flutter و پسوند Dart را برای بهبود عملکرد اضافه می‌کنند. علاوه بر این، در این آموزش نصب تم اختیاری 'Material Icon' برای بهبود بصری ذکر شده است. دستورالعمل‌های مفصلی در مورد دسترسی و اصلاح کد فلاتر در پوشه پروژه، اعمال تغییرات در کد برای افزایش شمارنده دو برابر در برنامه ارائه شده است. این آموزش بر استفاده از فرآیند 'فلاتر اجرا' برای بارگذاری مجدد داغ و بازسازی کامل برنامه تاکید دارد. پس از اجرای موفقیت آمیز و آزمایش تغییرات کد، این آموزش به پایان می رسد و نشان دهنده تکمیل راه اندازی ویندوز برای کاوش بیشتر در توسعه Flutter است.",
                            },
                        },
                        // 10 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Flutter & Material Design",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor discusses the default use of material design system in Flutter applications, emphasizing its creation by Google and high customizability for both Android and iOS devices. The tutorial highlights the presence of Apple-styled widgets in the Flutter framework, offering flexibility to developers in choosing between material design and iOS-style app appearances. The instructor outlines plans to demonstrate building apps with material design aesthetics, setting up custom looks, and utilizing Cupertino widgets for achieving iOS-style designs. Viewers are assured of comprehensive coverage on app design options, including deviations from material design to provide insights on building diverse applications.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Kursleiter die standardmäßige Verwendung des Materialdesignsystems in Flutter-Anwendungen und betont dabei, dass es von Google entwickelt wurde und sich sowohl für Android- als auch für iOS-Geräte sehr gut anpassen lässt. Das Tutorial hebt die Präsenz von Widgets im Apple-Stil im Flutter-Framework hervor und bietet Entwicklern die Flexibilität, zwischen dem Materialdesign und dem App-Erscheinungsbild im iOS-Stil zu wählen. Der Kursleiter skizziert Pläne, um das Erstellen von Apps mit Materialdesign-Ästhetik, das Einrichten benutzerdefinierter Looks und die Verwendung von Cupertino-Widgets zum Erreichen von Designs im iOS-Stil zu demonstrieren. Den Zuschauern wird eine umfassende Abdeckung der App-Designoptionen garantiert, einschließlich Abweichungen vom Materialdesign, um Einblicke in das Erstellen unterschiedlicher Anwendungen zu geben.",
                                // Chinese
                                "中国人": "在本视频中，讲师讨论了 Flutter 应用程序中 Material Design 系统的默认使用，强调了 Google 的创建以及 Android 和 iOS 设备的高度可定制性。本教程重点介绍了 Flutter 框架中 Apple 风格的小部件，为开发人员提供了在 Material Design 和 iOS 风格的应用外观之间进行选择的灵活性。讲师概述了计划，演示如何构建具有 Material Design 美学的应用程序、设置自定义外观以及利用 Cupertino 小部件实现 iOS 风格的设计。观众可以全面了解应用程序设计选项，包括与 Material Design 的偏差，以提供有关构建不同应用程序的见解。",
                                // Russian
                                "Русский": "В этом видео инструктор обсуждает использование системы Material Design по умолчанию в приложениях Flutter, подчеркивая ее создание Google и высокую настраиваемость как для устройств Android, так и для iOS. В руководстве подчеркивается наличие виджетов в стиле Apple в фреймворке Flutter, что дает разработчикам гибкость в выборе между Material Design и внешним видом приложений в стиле iOS. Инструктор излагает планы по демонстрации создания приложений с эстетикой Material Design, настройке пользовательских образов и использованию виджетов Cupertino для достижения дизайна в стиле iOS. Зрителям гарантируется всестороннее освещение вариантов дизайна приложений, включая отклонения от Material Design, чтобы предоставить представление о создании разнообразных приложений.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur discute de l'utilisation par défaut du système Material Design dans les applications Flutter, en mettant l'accent sur sa création par Google et sa grande personnalisation pour les appareils Android et iOS. Le didacticiel met en évidence la présence de widgets de style Apple dans le framework Flutter, offrant aux développeurs une flexibilité dans le choix entre la conception matérielle et les apparences d'applications de style iOS. L'instructeur décrit les plans pour démontrer la création d'applications avec l'esthétique Material Design, la configuration d'apparences personnalisées et l'utilisation de widgets Cupertino pour obtenir des conceptions de style iOS. Les spectateurs sont assurés d'une couverture complète des options de conception d'applications, y compris les écarts par rapport à la conception matérielle pour fournir des informations sur la création d'applications diverses.",
                                // Japanese
                                "日本語": "このビデオでは、講師が Flutter アプリケーションでのマテリアル デザイン システムのデフォルト使用について説明し、Google による作成と Android および iOS デバイスの両方での高度なカスタマイズ性を強調しています。チュートリアルでは、Flutter フレームワークでの Apple スタイルのウィジェットの存在を強調し、開発者がマテリアル デザインと iOS スタイルのアプリの外観を柔軟に選択できるようにします。講師は、マテリアル デザインの美学を備えたアプリの構築、カスタム外観の設定、iOS スタイルのデザインを実現するための Cupertino ウィジェットの利用を実演する計画の概要を説明します。視聴者は、マテリアル デザインからの逸脱を含むアプリ設計オプションを包括的にカバーし、多様なアプリケーションの構築に関する洞察を得ることができます。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 Flutter 애플리케이션에서 기본적으로 사용되는 Material Design 시스템을 설명하며, Google에서 만든 Material Design 시스템과 Android 및 iOS 기기에 대한 높은 사용자 정의 가능성을 강조합니다. 이 튜토리얼은 Flutter 프레임워크에서 Apple 스타일 위젯의 존재를 강조하여 개발자가 Material Design과 iOS 스타일 앱 모양 중에서 선택할 때 유연성을 제공합니다. 강사는 Material Design 미학으로 앱을 빌드하고, 사용자 정의 모양을 설정하고, iOS 스타일 디자인을 구현하기 위해 Cupertino 위젯을 활용하는 방법을 보여주는 계획을 설명합니다. 시청자는 다양한 애플리케이션을 빌드하는 데 대한 통찰력을 제공하기 위해 Material Design에서 벗어난 것을 포함하여 앱 디자인 옵션에 대한 포괄적인 내용을 확신합니다.",
                                // Spanish
                                "Español": "En este video, el instructor analiza el uso predeterminado del sistema de diseño de materiales en las aplicaciones de Flutter, haciendo hincapié en su creación por parte de Google y su alta capacidad de personalización para dispositivos Android e iOS. El tutorial destaca la presencia de widgets con estilo Apple en el marco de Flutter, lo que ofrece flexibilidad a los desarrolladores para elegir entre el diseño de materiales y las apariencias de las aplicaciones con estilo iOS. El instructor describe los planes para demostrar la creación de aplicaciones con la estética de diseño de materiales, la configuración de apariencias personalizadas y el uso de widgets de Cupertino para lograr diseños con estilo iOS. Los espectadores tienen la garantía de una cobertura integral de las opciones de diseño de aplicaciones, incluidas las desviaciones del diseño de materiales para brindar información sobre la creación de diversas aplicaciones.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक फ़्लटर अनुप्रयोगों में मटेरियल डिज़ाइन सिस्टम के डिफ़ॉल्ट उपयोग पर चर्चा करता है, Google द्वारा इसके निर्माण और Android और iOS दोनों डिवाइस के लिए उच्च अनुकूलन क्षमता पर जोर देता है। ट्यूटोरियल फ़्लटर फ़्रेमवर्क में Apple-शैली के विजेट की उपस्थिति पर प्रकाश डालता है, जो डेवलपर्स को मटेरियल डिज़ाइन और iOS-शैली के ऐप दिखावट के बीच चयन करने में लचीलापन प्रदान करता है। प्रशिक्षक मटेरियल डिज़ाइन सौंदर्यशास्त्र के साथ ऐप बनाने, कस्टम लुक सेट करने और iOS-शैली के डिज़ाइन प्राप्त करने के लिए क्यूपर्टिनो विजेट का उपयोग करने की योजनाओं की रूपरेखा तैयार करता है। दर्शकों को ऐप डिज़ाइन विकल्पों पर व्यापक कवरेज का आश्वासन दिया जाता है, जिसमें विविध एप्लिकेशन बनाने पर अंतर्दृष्टि प्रदान करने के लिए मटेरियल डिज़ाइन से विचलन शामिल हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor discute a utilização padrão do sistema de design de materiais nas aplicações Flutter, enfatizando a sua criação pela Google e a alta personalização para dispositivos Android e iOS. O tutorial destaca a presença de widgets ao estilo Apple na estrutura Flutter, oferecendo flexibilidade aos programadores na escolha entre o design de materiais e as aparências das aplicações ao estilo iOS. O instrutor descreve planos para demonstrar a construção de aplicações com estética de material design, configuração de aparência personalizada e utilização de widgets Cupertino para obter designs no estilo iOS. Os espectadores têm a garantia de uma cobertura abrangente sobre as opções de design de aplicações, incluindo desvios do material design para fornecer insights sobre a construção de diversas aplicações.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক ফ্লাটার অ্যাপ্লিকেশনে ম্যাটেরিয়াল ডিজাইন সিস্টেমের ডিফল্ট ব্যবহার নিয়ে আলোচনা করেছেন, Google এর দ্বারা এটি তৈরি করা এবং Android এবং iOS উভয় ডিভাইসের জন্য উচ্চ কাস্টমাইজযোগ্যতার উপর জোর দিয়েছেন। টিউটোরিয়ালটি ফ্লাটার ফ্রেমওয়ার্কে অ্যাপল-স্টাইলযুক্ত উইজেটগুলির উপস্থিতি হাইলাইট করে, যা উপাদান ডিজাইন এবং iOS-স্টাইল অ্যাপ উপস্থিতির মধ্যে বেছে নেওয়ার ক্ষেত্রে বিকাশকারীদের নমনীয়তা প্রদান করে। প্রশিক্ষক আইওএস-স্টাইলের ডিজাইনগুলি অর্জনের জন্য ম্যাটেরিয়াল ডিজাইনের নান্দনিকতা, কাস্টম লুক সেট আপ এবং কিউপারটিনো উইজেটগুলি ব্যবহার করে অ্যাপ তৈরির প্রদর্শনের পরিকল্পনার রূপরেখা দিয়েছেন। দর্শকরা অ্যাপ ডিজাইনের বিকল্পগুলিতে ব্যাপক কভারেজের বিষয়ে আশ্বস্ত হয়, যার মধ্যে বিভিন্ন অ্যাপ্লিকেশন তৈরির জন্য অন্তর্দৃষ্টি প্রদানের জন্য উপাদান ডিজাইন থেকে বিচ্যুতি রয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المدرب الاستخدام الافتراضي لنظام التصميم المادي في تطبيقات Flutter، مع التركيز على إنشائه بواسطة Google وإمكانية التخصيص العالية لكل من أجهزة Android وiOS. يسلط البرنامج التعليمي الضوء على وجود عناصر واجهة مستخدم على غرار Apple في إطار عمل Flutter، مما يوفر المرونة للمطورين في الاختيار بين التصميم المادي ومظهر التطبيق على غرار iOS. يحدد المدرب خططًا لتوضيح بناء التطبيقات بجماليات التصميم المادي، وإعداد مظاهر مخصصة، واستخدام عناصر واجهة مستخدم Cupertino لتحقيق تصميمات على غرار iOS. يضمن للمشاهدين تغطية شاملة لخيارات تصميم التطبيق، بما في ذلك الانحرافات عن التصميم المادي لتقديم رؤى حول بناء تطبيقات متنوعة.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس در مورد استفاده پیش‌فرض از سیستم طراحی متریال در اپلیکیشن‌های فلاتر بحث می‌کند و بر ایجاد آن توسط گوگل و قابلیت شخصی‌سازی بالا برای هر دو دستگاه اندروید و iOS تاکید می‌کند. این آموزش حضور ویجت‌های به سبک اپل را در چارچوب Flutter برجسته می‌کند و به توسعه‌دهندگان در انتخاب بین طراحی متریال و ظاهر برنامه‌های به سبک iOS انعطاف‌پذیری ارائه می‌دهد. این مربی برنامه‌هایی را برای نمایش برنامه‌های کاربردی با زیبایی‌شناسی طراحی متریال، تنظیم ظاهری سفارشی و استفاده از ویجت‌های کوپرتینویی برای دستیابی به طرح‌های به سبک iOS بیان می‌کند. بینندگان از پوشش جامع گزینه‌های طراحی اپلیکیشن، از جمله انحراف از طراحی متریال برای ارائه بینش در مورد ساخت برنامه‌های متنوع، اطمینان دارند.",
                            },
                        },
                        // 11 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Flutter Alternatives",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor discusses Flutter as a valuable tool for building cross-platform mobile apps, emphasizing its advantages over React Native and Ionic alternatives. Flutter, developed by Google, offers the creation of compiled native apps with high performance and pixel-level control, while React Native compiles to platform UI components and Ionic wraps web apps within native apps. The video delves into the programming languages used by each approach, highlighting Flutter's utilization of Dart for fully compiled native apps. Additionally, the instructor compares the customization potential and development processes of Flutter, React Native, and Ionic, providing insights into the differences in app rendering and performance. Viewers are encouraged to explore further resources for a detailed comparison of the three platforms to make informed choices based on their specific project requirements.",
                                // German
                                "Deutsch": "In diesem Video erörtert der Kursleiter Flutter als wertvolles Tool zum Erstellen plattformübergreifender mobiler Apps und betont seine Vorteile gegenüber den Alternativen React Native und Ionic. Flutter, entwickelt von Google, ermöglicht die Erstellung kompilierter nativer Apps mit hoher Leistung und pixelgenauer Steuerung, während React Native in Plattform-UI-Komponenten kompiliert und Ionic Web-Apps in native Apps einbindet. Das Video befasst sich eingehend mit den von jedem Ansatz verwendeten Programmiersprachen und hebt Flutters Verwendung von Dart für vollständig kompilierte native Apps hervor. Darüber hinaus vergleicht der Kursleiter das Anpassungspotenzial und die Entwicklungsprozesse von Flutter, React Native und Ionic und bietet Einblicke in die Unterschiede bei der App-Darstellung und -Leistung. Die Zuschauer werden ermutigt, weitere Ressourcen für einen detaillierten Vergleich der drei Plattformen zu erkunden, um fundierte Entscheidungen basierend auf ihren spezifischen Projektanforderungen zu treffen.",
                                // Chinese
                                "中国人": "在本视频中，讲师讨论了 Flutter 作为构建跨平台移动应用的宝贵工具，并强调了它相对于 React Native 和 Ionic 替代品的优势。Flutter 由 Google 开发，可以创建具有高性能和像素级控制的编译原生应用，而 React Native 可以编译为平台 UI 组件，Ionic 可以将 Web 应用包装在原生应用中。该视频深入探讨了每种方法使用的编程语言，重点介绍了 Flutter 对完全编译的原生应用的 Dart 的使用。此外，讲师还比较了 Flutter、React Native 和 Ionic 的定制潜力和开发过程，深入了解了应用渲染和性能方面的差异。鼓励观众探索更多资源，详细比较这三个平台，以便根据其特定的项目需求做出明智的选择。",
                                // Russian
                                "Русский": "В этом видео инструктор обсуждает Flutter как ценный инструмент для создания кроссплатформенных мобильных приложений, подчеркивая его преимущества перед альтернативами React Native и Ionic. Flutter, разработанный Google, предлагает создание скомпилированных нативных приложений с высокой производительностью и контролем на уровне пикселей, в то время как React Native компилирует в компоненты пользовательского интерфейса платформы, а Ionic оборачивает веб-приложения в нативные приложения. Видео углубляется в языки программирования, используемые каждым подходом, подчеркивая использование Flutter Dart для полностью скомпилированных нативных приложений. Кроме того, инструктор сравнивает потенциал настройки и процессы разработки Flutter, React Native и Ionic, предоставляя информацию о различиях в рендеринге и производительности приложений. Зрителям рекомендуется изучить дополнительные ресурсы для подробного сравнения трех платформ, чтобы сделать обоснованный выбор на основе требований их конкретного проекта.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur présente Flutter comme un outil précieux pour la création d'applications mobiles multiplateformes, en soulignant ses avantages par rapport aux alternatives React Native et Ionic. Flutter, développé par Google, permet la création d'applications natives compilées avec des performances élevées et un contrôle au niveau des pixels, tandis que React Native compile les composants d'interface utilisateur de la plateforme et Ionic encapsule les applications Web dans des applications natives. La vidéo se penche sur les langages de programmation utilisés par chaque approche, en soulignant l'utilisation de Dart par Flutter pour des applications natives entièrement compilées. De plus, l'instructeur compare le potentiel de personnalisation et les processus de développement de Flutter, React Native et Ionic, en fournissant des informations sur les différences de rendu et de performances des applications. Les spectateurs sont encouragés à explorer d'autres ressources pour une comparaison détaillée des trois plates-formes afin de faire des choix éclairés en fonction des exigences spécifiques de leur projet.",
                                // Japanese
                                "日本語": "このビデオでは、講師がクロスプラットフォームのモバイル アプリを構築するための貴重なツールとしての Flutter について説明し、React Native や Ionic の代替手段に対する利点を強調しています。Google が開発した Flutter は、高性能でピクセル レベルの制御を備えたコンパイル済みネイティブ アプリの作成を提供します。一方、React Native はプラットフォームの UI コンポーネントにコンパイルし、Ionic はネイティブ アプリ内で Web アプリをラップします。このビデオでは、各アプローチで使用されるプログラミング言語について詳しく説明し、完全にコンパイルされたネイティブ アプリに Flutter が Dart を利用していることを強調しています。さらに、講師は Flutter、React Native、Ionic のカスタマイズの可能性と開発プロセスを比較し、アプリのレンダリングとパフォーマンスの違いについての洞察を提供します。視聴者は、特定のプロジェクト要件に基づいて情報に基づいた選択を行うために、3 つのプラットフォームの詳細な比較に関するリソースをさらに調べることをお勧めします。",
                                // Korean
                                "한국인": "이 영상에서 강사는 Flutter를 크로스 플랫폼 모바일 앱을 구축하는 데 유용한 도구로 설명하며, React Native 및 Ionic 대안에 비해 어떤 이점이 있는지 강조합니다. Google에서 개발한 Flutter는 고성능 및 픽셀 수준 제어를 통해 컴파일된 네이티브 앱을 만들 수 있는 반면, React Native는 플랫폼 UI 구성 요소로 컴파일하고 Ionic은 네이티브 앱 내에서 웹 앱을 래핑합니다. 이 영상은 각 접근 방식에서 사용하는 프로그래밍 언어를 자세히 살펴보며, Flutter가 완전히 컴파일된 네이티브 앱을 위해 Dart를 활용하는 방식을 강조합니다. 또한 강사는 Flutter, React Native 및 Ionic의 사용자 정의 가능성과 개발 프로세스를 비교하여 앱 렌더링 및 성능의 차이점에 대한 통찰력을 제공합니다. 시청자는 세 플랫폼을 자세히 비교하는 추가 리소스를 탐색하여 특정 프로젝트 요구 사항에 따라 정보에 입각한 선택을 하는 것이 좋습니다.",
                                // Spanish
                                "Español": "En este video, el instructor analiza Flutter como una herramienta valiosa para crear aplicaciones móviles multiplataforma, y ​​destaca sus ventajas sobre las alternativas React Native e Ionic. Flutter, desarrollado por Google, ofrece la creación de aplicaciones nativas compiladas con alto rendimiento y control a nivel de píxel, mientras que React Native compila en componentes de interfaz de usuario de la plataforma e Ionic envuelve las aplicaciones web dentro de las aplicaciones nativas. El video profundiza en los lenguajes de programación utilizados por cada enfoque, destacando el uso de Dart por parte de Flutter para aplicaciones nativas completamente compiladas. Además, el instructor compara el potencial de personalización y los procesos de desarrollo de Flutter, React Native e Ionic, y brinda información sobre las diferencias en la representación y el rendimiento de las aplicaciones. Se anima a los espectadores a explorar más recursos para obtener una comparación detallada de las tres plataformas para tomar decisiones informadas en función de los requisitos específicos de su proyecto.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक क्रॉस-प्लेटफ़ॉर्म मोबाइल ऐप बनाने के लिए फ़्लटर को एक मूल्यवान उपकरण के रूप में चर्चा करता है, और रिएक्ट नेटिव और आयनिक विकल्पों पर इसके लाभों पर ज़ोर देता है। Google द्वारा विकसित फ़्लटर, उच्च प्रदर्शन और पिक्सेल-स्तरीय नियंत्रण के साथ संकलित मूल ऐप के निर्माण की पेशकश करता है, जबकि रिएक्ट नेटिव प्लेटफ़ॉर्म UI घटकों को संकलित करता है और आयनिक मूल ऐप के भीतर वेब ऐप को लपेटता है। वीडियो प्रत्येक दृष्टिकोण द्वारा उपयोग की जाने वाली प्रोग्रामिंग भाषाओं में गहराई से जाता है, जो फ़्लटर के पूरी तरह से संकलित मूल ऐप के लिए डार्ट के उपयोग को उजागर करता है। इसके अतिरिक्त, प्रशिक्षक फ़्लटर, रिएक्ट नेटिव और आयनिक की अनुकूलन क्षमता और विकास प्रक्रियाओं की तुलना करता है, जो ऐप रेंडरिंग और प्रदर्शन में अंतर के बारे में जानकारी प्रदान करता है। दर्शकों को अपनी विशिष्ट परियोजना आवश्यकताओं के आधार पर सूचित विकल्प बनाने के लिए तीन प्लेटफ़ॉर्म की विस्तृत तुलना के लिए आगे के संसाधनों का पता लगाने के लिए प्रोत्साहित किया जाता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor discute o Flutter como uma ferramenta valiosa para a construção de aplicações móveis multiplataforma, enfatizando as suas vantagens em relação às alternativas React Native e Ionic. O Flutter, desenvolvido pela Google, oferece a criação de aplicações nativas compiladas com alto desempenho e controlo ao nível do pixel, enquanto o React Native compila para componentes de UI da plataforma e o Ionic envolve aplicações web em aplicações nativas. O vídeo investiga as linguagens de programação utilizadas por cada abordagem, destacando a utilização do Dart pelo Flutter para aplicações nativas totalmente compiladas. Além disso, o instrutor compara o potencial de personalização e os processos de desenvolvimento do Flutter, React Native e Ionic, fornecendo informações sobre as diferenças na renderização e no desempenho da aplicação. Os espectadores são encorajados a explorar mais recursos para uma comparação detalhada das três plataformas para fazer escolhas informadas com base nos requisitos específicos do projeto.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক ফ্লটারকে ক্রস-প্ল্যাটফর্ম মোবাইল অ্যাপ তৈরির জন্য একটি মূল্যবান হাতিয়ার হিসেবে আলোচনা করেছেন, রিঅ্যাক্ট নেটিভ এবং আয়নিক বিকল্পগুলির উপর এর সুবিধার উপর জোর দিয়েছেন। ফ্লাটার, Google দ্বারা বিকাশিত, উচ্চ কার্যক্ষমতা এবং পিক্সেল-স্তরের নিয়ন্ত্রণ সহ কম্পাইল করা নেটিভ অ্যাপ তৈরির প্রস্তাব দেয়, যখন রিঅ্যাক্ট নেটিভ প্ল্যাটফর্ম UI উপাদানগুলিতে কম্পাইল করে এবং নেটিভ অ্যাপগুলির মধ্যে আইওনিক ওয়েব অ্যাপগুলিকে মোড়ানো করে। ভিডিওটি সম্পূর্ণরূপে সংকলিত নেটিভ অ্যাপগুলির জন্য ডার্টের ফ্লাটারের ব্যবহারকে হাইলাইট করে প্রতিটি পদ্ধতির দ্বারা ব্যবহৃত প্রোগ্রামিং ভাষাগুলির মধ্যে বর্ণনা করে। উপরন্তু, প্রশিক্ষক ফ্লটার, রিঅ্যাক্ট নেটিভ, এবং আয়নিকের কাস্টমাইজেশন সম্ভাব্যতা এবং বিকাশ প্রক্রিয়ার তুলনা করে, অ্যাপ রেন্ডারিং এবং পারফরম্যান্সের পার্থক্যগুলির অন্তর্দৃষ্টি প্রদান করে। দর্শকদের তাদের নির্দিষ্ট প্রকল্পের প্রয়োজনীয়তার উপর ভিত্তি করে অবগত পছন্দ করার জন্য তিনটি প্ল্যাটফর্মের বিশদ তুলনার জন্য আরও সংস্থানগুলি অন্বেষণ করতে উত্সাহিত করা হয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المدرب Flutter كأداة قيمة لبناء تطبيقات جوال متعددة المنصات، مع التركيز على مزاياها مقارنة ببدائل React Native وIonic. يوفر Flutter، الذي طورته Google، إنشاء تطبيقات أصلية مجمعة ذات أداء عالٍ وتحكم على مستوى البكسل، بينما يقوم React Native بالتجميع إلى مكونات واجهة مستخدم المنصة ويقوم Ionic بتغليف تطبيقات الويب داخل التطبيقات الأصلية. يتعمق الفيديو في لغات البرمجة المستخدمة في كل نهج، مع تسليط الضوء على استخدام Flutter لـ Dart للتطبيقات الأصلية المجمعة بالكامل. بالإضافة إلى ذلك، يقارن المدرب بين إمكانات التخصيص وعمليات التطوير لـ Flutter وReact Native وIonic، مما يوفر رؤى حول الاختلافات في عرض التطبيقات والأداء. يتم تشجيع المشاهدين على استكشاف المزيد من الموارد لإجراء مقارنة مفصلة بين المنصات الثلاثة لاتخاذ خيارات مستنيرة بناءً على متطلبات مشروعهم المحددة.",
                                // Persian
                                "فارسی": "در این ویدیو، مدرس Flutter را به عنوان یک ابزار ارزشمند برای ساخت اپلیکیشن های موبایلی چند پلتفرمی مورد بحث قرار می دهد و بر مزایای آن نسبت به جایگزین های React Native و Ionic تاکید می کند. Flutter که توسط Google توسعه داده شده است، ایجاد برنامه های بومی کامپایل شده با عملکرد بالا و کنترل سطح پیکسل را ارائه می دهد، در حالی که React Native در اجزای رابط کاربری پلتفرم کامپایل می شود و Ionic برنامه های وب را در برنامه های بومی قرار می دهد. این ویدیو به زبان های برنامه نویسی مورد استفاده در هر رویکرد می پردازد و استفاده فلاتر از دارت را برای برنامه های بومی کاملاً کامپایل شده برجسته می کند. علاوه بر این، مربی پتانسیل سفارشی‌سازی و فرآیندهای توسعه Flutter، React Native و Ionic را با هم مقایسه می‌کند و بینش‌هایی را در مورد تفاوت‌های ارائه و عملکرد برنامه ارائه می‌دهد. بینندگان تشویق می شوند تا منابع بیشتری را برای مقایسه دقیق سه پلتفرم بررسی کنند تا بر اساس نیازهای پروژه خاص خود، انتخاب های آگاهانه داشته باشند.",
                            },
                        },
                        // 12 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "Course Outline",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor outlines the upcoming modules and topics covered in the Flutter course. The course will delve into critical basics of Flutter, including core widgets, building user interfaces, and debugging processes. Further sections focus on widget styling, customizations, and enhancing app logic to create more realistic applications. The course structure emphasizes hands-on learning through the creation of multiple full apps across different course sections, enabling a more interactive and engaging learning experience. Participants will progress through modules on responsive design, state management, user input handling, web connectivity, animations, and device feature integration. Additionally, the course explores running native device code in Flutter apps and concludes with guidance on app publishing and future steps in app development, providing a comprehensive framework to develop successful Flutter applications with confidence.",
                                // German
                                "Deutsch": "In diesem Video umreißt der Kursleiter die kommenden Module und Themen des Flutter-Kurses. Der Kurs befasst sich mit den wichtigsten Grundlagen von Flutter, darunter Kern-Widgets, das Erstellen von Benutzeroberflächen und Debugging-Prozesse. Weitere Abschnitte konzentrieren sich auf Widget-Styling, Anpassungen und die Verbesserung der App-Logik, um realistischere Anwendungen zu erstellen. Die Kursstruktur betont praktisches Lernen durch die Erstellung mehrerer vollständiger Apps in verschiedenen Kursabschnitten, was ein interaktiveres und spannenderes Lernerlebnis ermöglicht. Die Teilnehmer durchlaufen Module zu Responsive Design, Statusverwaltung, Benutzereingabeverarbeitung, Webkonnektivität, Animationen und Gerätefunktionsintegration. Darüber hinaus untersucht der Kurs das Ausführen von nativem Gerätecode in Flutter-Apps und schließt mit Anleitungen zur App-Veröffentlichung und zukünftigen Schritten der App-Entwicklung ab. Damit wird ein umfassender Rahmen für die selbstbewusste Entwicklung erfolgreicher Flutter-Anwendungen bereitgestellt.",
                                // Chinese
                                "中国人": "在本视频中，讲师概述了 Flutter 课程中即将推出的模块和主题。本课程将深入探讨 Flutter 的关键基础知识，包括核心小部件、构建用户界面和调试过程。后续部分将重点介绍小部件样式、自定义以及增强应用逻辑以创建更逼真的应用程序。课程结构强调通过跨不同课程部分创建多个完整应用程序来进行动手学习，从而实现更具互动性和吸引力的学习体验。参与者将逐步学习响应式设计、状态管理、用户输入处理、网络连接、动画和设备功能集成等模块。此外，本课程还探讨了如何在 Flutter 应用中运行本机设备代码，并最后提供有关应用发布和应用开发未来步骤的指导，从而提供全面的框架，以便自信地开发成功的 Flutter 应用。",
                                // Russian
                                "Русский": "В этом видео инструктор описывает предстоящие модули и темы, охватываемые курсом Flutter. Курс будет углубляться в критические основы Flutter, включая основные виджеты, создание пользовательских интерфейсов и процессы отладки. Дальнейшие разделы посвящены стилю виджетов, настройкам и улучшению логики приложений для создания более реалистичных приложений. Структура курса делает упор на практическое обучение посредством создания нескольких полных приложений в разных разделах курса, что обеспечивает более интерактивный и увлекательный опыт обучения. Участники пройдут через модули по адаптивному дизайну, управлению состоянием, обработке пользовательского ввода, веб-подключению, анимации и интеграции функций устройств. Кроме того, курс исследует запуск собственного кода устройства в приложениях Flutter и завершается руководством по публикации приложений и будущим шагам в разработке приложений, предоставляя комплексную основу для уверенной разработки успешных приложений Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur décrit les modules et sujets à venir abordés dans le cours Flutter. Le cours se penchera sur les bases essentielles de Flutter, notamment les widgets de base, la création d'interfaces utilisateur et les processus de débogage. D'autres sections se concentrent sur le style des widgets, les personnalisations et l'amélioration de la logique d'application pour créer des applications plus réalistes. La structure du cours met l'accent sur l'apprentissage pratique grâce à la création de plusieurs applications complètes dans différentes sections du cours, permettant une expérience d'apprentissage plus interactive et engageante. Les participants progresseront à travers des modules sur la conception réactive, la gestion des états, la gestion des entrées utilisateur, la connectivité Web, les animations et l'intégration des fonctionnalités des appareils. De plus, le cours explore l'exécution du code natif des appareils dans les applications Flutter et se termine par des conseils sur la publication d'applications et les étapes futures du développement d'applications, fournissant un cadre complet pour développer des applications Flutter réussies en toute confiance.",
                                // Japanese
                                "日本語": "このビデオでは、インストラクターが Flutter コースで取り上げる今後のモジュールとトピックの概要を説明します。このコースでは、コア ウィジェット、ユーザー インターフェースの構築、デバッグ プロセスなど、Flutter の重要な基礎について掘り下げます。以降のセクションでは、ウィジェットのスタイル設定、カスタマイズ、アプリ ロジックの強化に焦点を当て、よりリアルなアプリケーションを作成します。コース構成では、さまざまなコース セクションで複数の完全なアプリを作成することによる実践的な学習を重視しており、よりインタラクティブで魅力的な学習体験が実現します。参加者は、レスポンシブ デザイン、状態管理、ユーザー入力処理、Web 接続、アニメーション、デバイス機能の統合に関するモジュールを学習します。さらに、このコースでは、Flutter アプリでのネイティブ デバイス コードの実行について説明し、最後にアプリの公開とアプリ開発の今後の手順に関するガイダンスを提供します。これにより、自信を持って成功する Flutter アプリケーションを開発するための包括的なフレームワークが提供されます。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 Flutter 과정에서 다루는 다가올 모듈과 주제를 설명합니다. 이 과정에서는 핵심 위젯, 사용자 인터페이스 구축, 디버깅 프로세스를 포함한 Flutter의 중요한 기본 사항을 탐구합니다. 추가 섹션에서는 위젯 스타일링, 사용자 정의, 더욱 현실적인 애플리케이션을 만들기 위한 앱 로직 향상에 중점을 둡니다. 과정 구조는 다양한 과정 섹션에서 여러 전체 앱을 만드는 실습 학습을 강조하여 더욱 상호 작용적이고 매력적인 학습 경험을 제공합니다. 참가자는 반응형 디자인, 상태 관리, 사용자 입력 처리, 웹 연결, 애니메이션, 기기 기능 통합에 대한 모듈을 진행합니다. 또한 이 과정에서는 Flutter 앱에서 네이티브 기기 코드를 실행하는 방법을 살펴보고 앱 게시 및 앱 개발의 향후 단계에 대한 지침으로 마무리하여 자신감을 가지고 성공적인 Flutter 애플리케이션을 개발할 수 있는 포괄적인 프레임워크를 제공합니다.",
                                // Spanish
                                "Español": "En este video, el instructor describe los próximos módulos y temas que se cubrirán en el curso de Flutter. El curso profundizará en los conceptos básicos fundamentales de Flutter, incluidos los widgets principales, la creación de interfaces de usuario y los procesos de depuración. Las secciones posteriores se centran en el estilo de los widgets, las personalizaciones y la mejora de la lógica de la aplicación para crear aplicaciones más realistas. La estructura del curso enfatiza el aprendizaje práctico a través de la creación de múltiples aplicaciones completas en diferentes secciones del curso, lo que permite una experiencia de aprendizaje más interactiva y atractiva. Los participantes avanzarán a través de módulos sobre diseño responsivo, administración de estados, manejo de entradas de usuario, conectividad web, animaciones e integración de funciones del dispositivo. Además, el curso explora la ejecución de código nativo de dispositivos en aplicaciones de Flutter y concluye con una guía sobre la publicación de aplicaciones y los pasos futuros en el desarrollo de aplicaciones, lo que proporciona un marco integral para desarrollar aplicaciones Flutter exitosas con confianza.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक फ़्लटर कोर्स में शामिल आगामी मॉड्यूल और विषयों की रूपरेखा प्रस्तुत करता है। यह कोर्स फ़्लटर की महत्वपूर्ण बुनियादी बातों पर चर्चा करेगा, जिसमें मुख्य विजेट, उपयोगकर्ता इंटरफ़ेस बनाना और डिबगिंग प्रक्रियाएँ शामिल हैं। आगे के अनुभाग विजेट स्टाइलिंग, अनुकूलन और अधिक यथार्थवादी एप्लिकेशन बनाने के लिए ऐप लॉजिक को बढ़ाने पर ध्यान केंद्रित करते हैं। पाठ्यक्रम संरचना विभिन्न पाठ्यक्रम अनुभागों में कई पूर्ण ऐप के निर्माण के माध्यम से व्यावहारिक सीखने पर जोर देती है, जिससे अधिक इंटरैक्टिव और आकर्षक सीखने का अनुभव संभव होता है। प्रतिभागी उत्तरदायी डिज़ाइन, स्थिति प्रबंधन, उपयोगकर्ता इनपुट हैंडलिंग, वेब कनेक्टिविटी, एनिमेशन और डिवाइस फ़ीचर एकीकरण पर मॉड्यूल के माध्यम से आगे बढ़ेंगे। इसके अतिरिक्त, पाठ्यक्रम फ़्लटर ऐप में मूल डिवाइस कोड चलाने की खोज करता है और ऐप प्रकाशन और ऐप विकास में भविष्य के चरणों पर मार्गदर्शन के साथ समाप्त होता है, जो आत्मविश्वास के साथ सफल फ़्लटर एप्लिकेशन विकसित करने के लिए एक व्यापक रूपरेखा प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor descreve os próximos módulos e tópicos abordados no curso Flutter. O curso irá aprofundar os fundamentos básicos do Flutter, incluindo widgets principais, construção de interfaces de utilizador e processos de depuração. Outras secções centram-se no estilo do widget, nas personalizações e no melhoramento da lógica da aplicação para criar aplicações mais realistas. A estrutura do curso enfatiza a aprendizagem prática através da criação de várias aplicações completas em diferentes secções do curso, permitindo uma experiência de aprendizagem mais interativa e envolvente. Os participantes irão progredir através de módulos sobre design responsivo, gestão de estado, manipulação de entradas do utilizador, conectividade web, animações e integração de recursos de dispositivos. Além disso, o curso explora a execução de código de dispositivo nativo em aplicações Flutter e conclui com orientações sobre a publicação de aplicações e as etapas futuras no desenvolvimento de aplicações, fornecendo uma estrutura abrangente para desenvolver aplicações Flutter bem-sucedidas com confiança.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক ফ্লাটার কোর্সে কভার করা আসন্ন মডিউল এবং বিষয়গুলির রূপরেখা দিয়েছেন৷ কোর্সটি মূল উইজেট, ইউজার ইন্টারফেস তৈরি এবং ডিবাগিং প্রক্রিয়া সহ ফ্লটারের সমালোচনামূলক মৌলিক বিষয়গুলি নিয়ে আলোচনা করবে। পরবর্তী বিভাগগুলি আরও বাস্তবসম্মত অ্যাপ্লিকেশন তৈরি করার জন্য উইজেট স্টাইলিং, কাস্টমাইজেশন এবং অ্যাপের যুক্তিকে উন্নত করার উপর ফোকাস করে। কোর্সের কাঠামো বিভিন্ন কোর্স বিভাগে একাধিক পূর্ণ অ্যাপ তৈরির মাধ্যমে হাতে-কলমে শেখার উপর জোর দেয়, আরও ইন্টারেক্টিভ এবং আকর্ষক শেখার অভিজ্ঞতা সক্ষম করে। অংশগ্রহণকারীরা প্রতিক্রিয়াশীল ডিজাইন, স্টেট ম্যানেজমেন্ট, ইউজার ইনপুট হ্যান্ডলিং, ওয়েব কানেক্টিভিটি, অ্যানিমেশন এবং ডিভাইস ফিচার ইন্টিগ্রেশনের মডিউলের মাধ্যমে অগ্রগতি করবে। অতিরিক্তভাবে, কোর্সটি ফ্লাটার অ্যাপে চলমান নেটিভ ডিভাইস কোড অন্বেষণ করে এবং অ্যাপ প্রকাশনা এবং অ্যাপ ডেভেলপমেন্টের ভবিষ্যত পদক্ষেপের নির্দেশিকা দিয়ে শেষ হয়, আত্মবিশ্বাসের সাথে সফল ফ্লাটার অ্যাপ্লিকেশন বিকাশের জন্য একটি ব্যাপক কাঠামো প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المدرب الوحدات والموضوعات القادمة التي سيتم تناولها في دورة Flutter. ستتناول الدورة أساسيات Flutter المهمة، بما في ذلك عناصر واجهة المستخدم الأساسية، وبناء واجهات المستخدم، وعمليات تصحيح الأخطاء. تركز الأقسام الأخرى على تصميم عناصر واجهة المستخدم، والتخصيصات، وتحسين منطق التطبيق لإنشاء تطبيقات أكثر واقعية. يؤكد هيكل الدورة على التعلم العملي من خلال إنشاء تطبيقات كاملة متعددة عبر أقسام الدورة المختلفة، مما يتيح تجربة تعليمية أكثر تفاعلية وجاذبية. سيتقدم المشاركون من خلال وحدات حول التصميم المستجيب، وإدارة الحالة، ومعالجة إدخال المستخدم، والاتصال بالويب، والرسوم المتحركة، ودمج ميزات الجهاز. بالإضافة إلى ذلك، تستكشف الدورة تشغيل كود الجهاز الأصلي في تطبيقات Flutter وتختتم بإرشادات حول نشر التطبيق والخطوات المستقبلية في تطوير التطبيق، مما يوفر إطارًا شاملاً لتطوير تطبيقات Flutter الناجحة بثقة.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس ماژول ها و موضوعات آینده تحت پوشش دوره فلاتر را تشریح می کند. این دوره به اصول اساسی Flutter، از جمله ابزارک های اصلی، ساخت رابط های کاربری و فرآیندهای اشکال زدایی می پردازد. بخش‌های بیشتر بر استایل ویجت‌ها، سفارشی‌سازی‌ها و تقویت منطق برنامه برای ایجاد برنامه‌های واقعی‌تر تمرکز دارند. ساختار دوره بر یادگیری عملی از طریق ایجاد چندین برنامه کامل در بخش‌های مختلف دوره تأکید می‌کند و تجربه یادگیری تعاملی و جذاب‌تری را ممکن می‌سازد. شرکت‌کنندگان از طریق ماژول‌های طراحی واکنش‌گرا، مدیریت وضعیت، مدیریت ورودی کاربر، اتصال به وب، انیمیشن‌ها و یکپارچه‌سازی ویژگی‌های دستگاه پیشرفت خواهند کرد. علاوه بر این، این دوره به بررسی اجرای کد دستگاه بومی در برنامه‌های Flutter می‌پردازد و با راهنمایی در مورد انتشار برنامه و گام‌های آتی در توسعه برنامه به پایان می‌رسد و چارچوبی جامع برای توسعه برنامه‌های Flutter موفق با اطمینان ارائه می‌دهد.",
                            },
                        },
                        // 13 [Video Number]
                        {
                            "SectionName": "Introduction",
                            "VideoName": "How To Get The Most Out Of The Course",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video emphasizes the importance of actively participating in the course by watching the videos, coding along, doing exercises, quizzes, and building apps. It encourages students to compare their code with the instructor's, use course resources such as source code and slides, and actively engage in the Q&A section. The video highlights the value of problem-solving, both for personal projects and helping others, as a way to improve understanding and become a better developer.",
                                // German
                                "Deutsch": "Das Video betont, wie wichtig es ist, aktiv am Kurs teilzunehmen, indem man sich die Videos ansieht, mitprogrammiert, Übungen und Tests macht und Apps erstellt. Es ermutigt die Studenten, ihren Code mit dem des Dozenten zu vergleichen, Kursressourcen wie Quellcode und Folien zu verwenden und sich aktiv am Q&A-Abschnitt zu beteiligen. Das Video betont, wie wichtig es ist, Probleme sowohl für persönliche Projekte als auch für die Hilfe für andere zu lösen, um das Verständnis zu verbessern und ein besserer Entwickler zu werden.",
                                // Chinese
                                "中国人": "该视频强调了积极参与课程的重要性，包括观看视频、跟着一起编码、做练习、做测验和构建应用程序。它鼓励学生将自己的代码与讲师的代码进行比较，使用源代码和幻灯片等课程资源，并积极参与问答环节。该视频强调了解决问题的价值，无论是对于个人项目还是帮助他人，都是一种提高理解并成为更好的开发人员的方式。",
                                // Russian
                                "Русский": "Видео подчеркивает важность активного участия в курсе путем просмотра видео, написания кода, выполнения упражнений, тестов и создания приложений. Оно побуждает студентов сравнивать свой код с кодом инструктора, использовать ресурсы курса, такие как исходный код и слайды, и активно участвовать в разделе вопросов и ответов. Видео подчеркивает ценность решения проблем, как для личных проектов, так и для помощи другим, как способ улучшить понимание и стать лучшим разработчиком.",
                                // French
                                "Français": "La vidéo souligne l'importance de participer activement au cours en regardant les vidéos, en codant, en faisant des exercices, des quiz et en créant des applications. Elle encourage les étudiants à comparer leur code avec celui de l'instructeur, à utiliser les ressources du cours telles que le code source et les diapositives, et à participer activement à la section questions-réponses. La vidéo met en évidence l'importance de la résolution de problèmes, tant pour les projets personnels que pour aider les autres, comme moyen d'améliorer la compréhension et de devenir un meilleur développeur.",
                                // Japanese
                                "日本語": "このビデオでは、ビデオを視聴し、一緒にコーディングし、演習やクイズに取り組み、アプリを構築することで、コースに積極的に参加することの重要性を強調しています。受講者が自分のコードを講師のコードと比較したり、ソース コードやスライドなどのコース リソースを使用したり、Q&A セクションに積極的に参加したりすることを奨励しています。このビデオでは、理解を深め、より優れた開発者になるための方法として、個人プロジェクトと他者への支援の両方で問題解決の価値を強調しています。",
                                // Korean
                                "한국인": "이 영상은 영상을 시청하고, 코딩을 따라하고, 연습문제를 풀고, 퀴즈를 풀고, 앱을 빌드함으로써 과정에 적극적으로 참여하는 것의 중요성을 강조합니다. 학생들이 강사의 코드와 자신의 코드를 비교하고, 소스 코드와 슬라이드와 같은 과정 리소스를 사용하고, Q&A 섹션에 적극적으로 참여하도록 장려합니다. 이 영상은 개인 프로젝트와 다른 사람을 돕는 것 모두에서 문제 해결의 가치를 강조하여 이해를 높이고 더 나은 개발자가 되는 방법을 보여줍니다.",
                                // Spanish
                                "Español": "El video enfatiza la importancia de participar activamente en el curso mirando los videos, codificando, haciendo ejercicios, cuestionarios y creando aplicaciones. Anima a los estudiantes a comparar su código con el del instructor, usar los recursos del curso, como el código fuente y las diapositivas, y participar activamente en la sección de preguntas y respuestas. El video destaca el valor de la resolución de problemas, tanto para proyectos personales como para ayudar a otros, como una forma de mejorar la comprensión y convertirse en un mejor desarrollador.",
                                // Hindi
                                "हिंदी": "वीडियो में वीडियो देखकर, कोडिंग करके, अभ्यास करके, प्रश्नोत्तरी करके और ऐप बनाकर पाठ्यक्रम में सक्रिय रूप से भाग लेने के महत्व पर जोर दिया गया है। यह छात्रों को अपने कोड की तुलना प्रशिक्षक के कोड से करने, स्रोत कोड और स्लाइड जैसे पाठ्यक्रम संसाधनों का उपयोग करने और प्रश्नोत्तर अनुभाग में सक्रिय रूप से भाग लेने के लिए प्रोत्साहित करता है। वीडियो व्यक्तिगत परियोजनाओं और दूसरों की मदद करने दोनों के लिए समस्या-समाधान के महत्व को उजागर करता है, जो समझ को बेहतर बनाने और बेहतर डेवलपर बनने का एक तरीका है।",
                                // Portuguese
                                "Português": "O vídeo realça a importância de participar ativamente no curso, assistindo aos vídeos, codificando, fazendo exercícios, questionários e criando aplicações. Incentiva os alunos a comparar o seu código com o do instrutor, a utilizar recursos do curso, como o código-fonte e os diapositivos, e a participar ativamente na secção de perguntas e respostas. O vídeo destaca o valor da resolução de problemas, tanto para projetos pessoais como para ajudar os outros, como forma de melhorar a compreensão e tornar-se um melhor programador.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ভিডিও দেখে, কোডিং করে, ব্যায়াম করে, কুইজ করে এবং অ্যাপ তৈরি করে কোর্সে সক্রিয়ভাবে অংশগ্রহণ করার গুরুত্বের ওপর জোর দেয়৷ এটি শিক্ষার্থীদের তাদের কোডকে প্রশিক্ষকের সাথে তুলনা করতে, উত্স কোড এবং স্লাইডের মতো কোর্স সংস্থানগুলি ব্যবহার করতে এবং প্রশ্নোত্তর বিভাগে সক্রিয়ভাবে জড়িত হতে উত্সাহিত করে৷ ভিডিওটি ব্যক্তিগত প্রকল্পের জন্য এবং অন্যদের সাহায্য করার জন্য, বোঝার উন্নতি করার এবং আরও ভাল বিকাশকারী হওয়ার উপায় হিসাবে সমস্যা সমাধানের মূল্য হাইলাইট করে৷",
                                // Arabic
                                "عَرَبِيّ": "يؤكد الفيديو على أهمية المشاركة الفعالة في الدورة من خلال مشاهدة مقاطع الفيديو، والكتابة البرمجية، وإجراء التمارين، والاختبارات، وإنشاء التطبيقات. كما يشجع الطلاب على مقارنة أكوادهم بكودات المدرب، واستخدام موارد الدورة مثل أكواد المصدر والشرائح، والمشاركة بنشاط في قسم الأسئلة والأجوبة. ويسلط الفيديو الضوء على قيمة حل المشكلات، سواء للمشاريع الشخصية أو مساعدة الآخرين، كوسيلة لتحسين الفهم والتحول إلى مطور أفضل.",
                                // Persian
                                "فارسی": "این ویدئو بر اهمیت شرکت فعال در دوره با تماشای فیلم ها، کدنویسی همراه، انجام تمرینات، آزمون ها و ساخت اپلیکیشن تاکید می کند. این دانش آموزان را تشویق می کند تا کد خود را با معلم مقایسه کنند، از منابع دوره مانند کد منبع و اسلایدها استفاده کنند و فعالانه در بخش پرسش و پاسخ شرکت کنند. این ویدئو ارزش حل مسئله را، هم برای پروژه های شخصی و هم برای کمک به دیگران، به عنوان راهی برای بهبود درک و تبدیل شدن به یک توسعه دهنده بهتر برجسته می کند.",
                            },
                        },
                    ]
                },
                // Section 2 : Flutter Basics [QUIZ APP]
                {
                    "SectionName": "Flutter Basics [QUIZ APP]",
                    "Videos": [
                        // 14 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Module Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor introduces Flutter and its basics in a detailed module, encouraging viewers to watch in pieces, code along, and utilize provided resources. The module covers how a Flutter app starts and works, working with widgets, building custom widgets, reacting to user events, understanding stateless and stateful widgets, Dart fundamentals, and building a concrete Flutter app while focusing on functionality and features rather than layout and styling. Throughout the course, viewers will build more beautiful applications, write code across multiple files, create widgets, manage data, style elements, and explore core Dart and Flutter features.",
                                // German
                                "Deutsch": "In diesem Video stellt der Kursleiter Flutter und seine Grundlagen in einem ausführlichen Modul vor und ermutigt die Zuschauer, sich das Video Stück für Stück anzusehen, mitzuprogrammieren und die bereitgestellten Ressourcen zu nutzen. Das Modul behandelt, wie eine Flutter-App startet und funktioniert, wie man mit Widgets arbeitet, benutzerdefinierte Widgets erstellt, auf Benutzerereignisse reagiert, zustandslose und zustandsbehaftete Widgets versteht, Dart-Grundlagen und wie man eine konkrete Flutter-App erstellt, wobei der Schwerpunkt eher auf Funktionalität und Features als auf Layout und Stil liegt. Im Laufe des Kurses werden die Zuschauer schönere Anwendungen erstellen, Code über mehrere Dateien hinweg schreiben, Widgets erstellen, Daten verwalten, Elemente formatieren und die Kernfunktionen von Dart und Flutter erkunden.",
                                // Chinese
                                "中国人": "在本视频中，讲师以详细的模块形式介绍了 Flutter 及其基础知识，鼓励观众分段观看、跟着代码学习并利用提供的资源。该模块涵盖了 Flutter 应用的启动和工作方式、使用小部件、构建自定义小部件、响应用户事件、理解无状态和有状态小部件、Dart 基础知识以及构建具体的 Flutter 应用，同时专注于功能和特性而不是布局和样式。在整个课程中，观众将构建更美观的应用程序、跨多个文件编写代码、创建小部件、管理数据、设置元素样式以及探索核心 Dart 和 Flutter 功能。",
                                // Russian
                                "Русский": "В этом видео инструктор знакомит с Flutter и его основами в подробном модуле, побуждая зрителей смотреть по частям, кодировать и использовать предоставленные ресурсы. Модуль охватывает, как приложение Flutter запускается и работает, работу с виджетами, создание пользовательских виджетов, реакцию на пользовательские события, понимание виджетов без состояния и с состоянием, основы Dart и создание конкретного приложения Flutter, уделяя особое внимание функциональности и функциям, а не макету и стилю. На протяжении всего курса зрители будут создавать более красивые приложения, писать код в нескольких файлах, создавать виджеты, управлять данными, стилизовать элементы и изучать основные функции Dart и Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur présente Flutter et ses bases dans un module détaillé, encourageant les spectateurs à regarder par morceaux, à coder et à utiliser les ressources fournies. Le module couvre le démarrage et le fonctionnement d'une application Flutter, l'utilisation de widgets, la création de widgets personnalisés, la réaction aux événements utilisateur, la compréhension des widgets sans état et avec état, les principes fondamentaux de Dart et la création d'une application Flutter concrète tout en se concentrant sur les fonctionnalités et les caractéristiques plutôt que sur la mise en page et le style. Tout au long du cours, les spectateurs créeront des applications plus esthétiques, écriront du code sur plusieurs fichiers, créeront des widgets, géreront des données, styliseront des éléments et exploreront les fonctionnalités de base de Dart et Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、インストラクターが詳細なモジュールで Flutter とその基本を紹介し、視聴者が少しずつ視聴し、一緒にコードを書き、提供されたリソースを活用することを推奨しています。このモジュールでは、Flutter アプリの起動と動作、ウィジェットの操作、カスタム ウィジェットの作成、ユーザー イベントへの反応、ステートレス ウィジェットとステートフル ウィジェットの理解、Dart の基礎、レイアウトやスタイルではなく機能と特徴に焦点を当てた具体的な Flutter アプリの構築について説明します。コース全体を通して、視聴者はより美しいアプリケーションを構築し、複数のファイルにまたがってコードを記述し、ウィジェットを作成し、データを管理し、要素のスタイルを設定し、コア Dart および Flutter 機能を探索します。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 자세한 모듈에서 Flutter와 그 기본 사항을 소개하고, 시청자가 단편적으로 시청하고, 코드를 따라 작성하고, 제공된 리소스를 활용하도록 권장합니다. 이 모듈은 Flutter 앱이 시작되고 작동하는 방법, 위젯 작업, 사용자 지정 위젯 빌드, 사용자 이벤트에 대한 반응, 상태 없는 위젯과 상태 있는 위젯 이해, Dart 기본 사항, 레이아웃과 스타일보다는 기능과 특징에 초점을 맞춘 구체적인 Flutter 앱 빌드를 다룹니다. 과정 전반에 걸쳐 시청자는 더 아름다운 애플리케이션을 빌드하고, 여러 파일에 코드를 작성하고, 위젯을 만들고, 데이터를 관리하고, 요소의 스타일을 지정하고, 핵심 Dart 및 Flutter 기능을 탐색합니다.",
                                // Spanish
                                "Español": "En este video, el instructor presenta Flutter y sus conceptos básicos en un módulo detallado, animando a los espectadores a mirar fragmentos, codificar junto con el video y utilizar los recursos proporcionados. El módulo cubre cómo se inicia y funciona una aplicación Flutter, cómo trabajar con widgets, cómo crear widgets personalizados, cómo reaccionar a los eventos del usuario, cómo entender los widgets con y sin estado, los aspectos básicos de Dart y cómo crear una aplicación Flutter concreta mientras se enfoca en la funcionalidad y las características en lugar del diseño y el estilo. A lo largo del curso, los espectadores crearán aplicaciones más atractivas, escribirán código en varios archivos, crearán widgets, administrarán datos, darán estilo a los elementos y explorarán las características principales de Dart y Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक विस्तृत मॉड्यूल में फ़्लटर और इसकी मूल बातें पेश करता है, दर्शकों को टुकड़ों में देखने, कोड करने और उपलब्ध संसाधनों का उपयोग करने के लिए प्रोत्साहित करता है। मॉड्यूल में बताया गया है कि फ़्लटर ऐप कैसे शुरू होता है और काम करता है, विजेट के साथ काम करना, कस्टम विजेट बनाना, उपयोगकर्ता ईवेंट पर प्रतिक्रिया करना, स्टेटलेस और स्टेटफुल विजेट को समझना, डार्ट की बुनियादी बातें और लेआउट और स्टाइलिंग के बजाय कार्यक्षमता और सुविधाओं पर ध्यान केंद्रित करते हुए एक ठोस फ़्लटर ऐप बनाना। पूरे कोर्स के दौरान, दर्शक अधिक सुंदर एप्लिकेशन बनाएंगे, कई फ़ाइलों में कोड लिखेंगे, विजेट बनाएंगे, डेटा प्रबंधित करेंगे, तत्वों को स्टाइल करेंगे और डार्ट और फ़्लटर की मुख्य विशेषताओं का पता लगाएंगे।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor apresenta o Flutter e os seus fundamentos num módulo detalhado, incentivando os espectadores a assistir por partes, codificar e utilizar os recursos fornecidos. O módulo aborda como uma aplicação Flutter inicia e funciona, trabalhar com widgets, construir widgets personalizados, reagir a eventos do utilizador, compreender widgets sem estado e com estado, fundamentos do Dart e construir uma aplicação Flutter concreta enquanto se concentra na funcionalidade e nas características , em vez de no layout e estilo . Ao longo do curso, os espectadores irão criar aplicações mais bonitas, escrever código em vários ficheiros, criar widgets, gerir dados, estilizar elementos e explorar as principais características do Dart e do Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক একটি বিশদ মডিউলে ফ্লাটার এবং এর মূল বিষয়গুলি উপস্থাপন করেছেন, দর্শকদেরকে টুকরো টুকরো দেখতে, কোড সহ, এবং প্রদত্ত সংস্থানগুলি ব্যবহার করতে উত্সাহিত করে৷ মডিউলটি কভার করে যে কীভাবে একটি ফ্লাটার অ্যাপ শুরু হয় এবং কাজ করে, উইজেটগুলির সাথে কাজ করা, কাস্টম উইজেট তৈরি করা, ব্যবহারকারীর ইভেন্টগুলিতে প্রতিক্রিয়া জানানো, স্টেটলেস এবং স্টেটফুল উইজেটগুলি বোঝা, ডার্টের মৌলিক বিষয়গুলি বোঝা এবং একটি কংক্রিট ফ্লাটার অ্যাপ তৈরি করা যেখানে লেআউট এবং স্টাইলিংয়ের পরিবর্তে কার্যকারিতা এবং বৈশিষ্ট্যগুলিতে ফোকাস করা হয়। . পুরো কোর্স জুড়ে, দর্শকরা আরও সুন্দর অ্যাপ্লিকেশন তৈরি করবে, একাধিক ফাইল জুড়ে কোড লিখবে, উইজেট তৈরি করবে, ডেটা, স্টাইল উপাদানগুলি পরিচালনা করবে এবং মূল ডার্ট এবং ফ্লাটার বৈশিষ্ট্যগুলি অন্বেষণ করবে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يقدم المدرب Flutter وأساسياته في وحدة مفصلة، ​​ويشجع المشاهدين على المشاهدة على شكل أجزاء، والبرمجة، والاستفادة من الموارد المقدمة. تغطي الوحدة كيفية بدء تشغيل تطبيق Flutter وكيفية عمله، والعمل مع عناصر واجهة المستخدم، وبناء عناصر واجهة مستخدم مخصصة، والتفاعل مع أحداث المستخدم، وفهم عناصر واجهة المستخدم عديمة الحالة والغير مرتبطة بجنس، وأساسيات Dart، وبناء تطبيق Flutter ملموس مع التركيز على الوظائف والميزات بدلاً من التخطيط والتصميم. طوال الدورة، سيبني المشاهدون تطبيقات أكثر جمالاً، ويكتبون التعليمات البرمجية عبر ملفات متعددة، وينشئون عناصر واجهة مستخدم، ويديرون البيانات، ويصممون العناصر، ويستكشفون ميزات Dart وFlutter الأساسية.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس فلاتر و اصول اولیه آن را در یک ماژول دقیق معرفی می کند و بینندگان را تشویق می کند تا به صورت تکه تکه، کدنویسی کنند و از منابع ارائه شده استفاده کنند. این ماژول نحوه شروع و کار یک برنامه Flutter، کار با ویجت‌ها، ساخت ویجت‌های سفارشی، واکنش به رویدادهای کاربر، درک ویجت‌های بدون حالت و حالت، اصول Dart و ساختن یک برنامه Flutter ملموس را پوشش می‌دهد، در حالی که به جای طرح‌بندی و استایل، بر روی عملکرد و ویژگی‌ها تمرکز می‌کند. . در طول دوره، بینندگان برنامه‌های زیباتری می‌سازند، کد را در چندین فایل می‌نویسند، ابزارک‌ها را ایجاد می‌کنند، داده‌ها را مدیریت می‌کنند، عناصر سبک را مدیریت می‌کنند و ویژگی‌های اصلی Dart و Flutter را بررسی می‌کنند.",
                            },
                        },
                        // 15 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Creating a New Project",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor guides viewers on creating a new Flutter project using the terminal and Flutter command, highlighting the importance of naming conventions and directory navigation. The video then demonstrates how to set up and launch an Android emulator to test the Flutter app, explaining the process of creating a virtual device in Android Studio. Further, the video covers running the Flutter app on the emulator using Visual Studio Code, debugging features, and controlling the app execution in the emulator. The video concludes with a preview of the Flutter app running on the emulator and a preview of future topics to be discussed in the course.",
                                // German
                                "Deutsch": "In diesem Video führt der Kursleiter die Zuschauer durch die Erstellung eines neuen Flutter-Projekts mithilfe des Terminals und des Flutter-Befehls und betont dabei die Bedeutung von Namenskonventionen und Verzeichnisnavigation. Anschließend zeigt das Video, wie ein Android-Emulator zum Testen der Flutter-App eingerichtet und gestartet wird, und erklärt den Prozess der Erstellung eines virtuellen Geräts in Android Studio. Darüber hinaus behandelt das Video das Ausführen der Flutter-App auf dem Emulator mithilfe von Visual Studio Code, Debugging-Funktionen und die Steuerung der App-Ausführung im Emulator. Das Video endet mit einer Vorschau der auf dem Emulator ausgeführten Flutter-App und einer Vorschau auf zukünftige Themen, die im Kurs besprochen werden.",
                                // Chinese
                                "中国人": "在本视频中，讲师将指导观众使用终端和 Flutter 命令创建新的 Flutter 项目，并强调命名约定和目录导航的重要性。然后，视频演示了如何设置和启动 Android 模拟器来测试 Flutter 应用，并解释了在 Android Studio 中创建虚拟设备的过程。此外，视频还介绍了如何使用 Visual Studio Code 在模拟器上运行 Flutter 应用、调试功能以及在模拟器中控制应用的执行。视频最后预览了在模拟器上运行的 Flutter 应用，并预览了课程中将要讨论的未来主题。",
                                // Russian
                                "Русский": "В этом видео инструктор помогает зрителям создать новый проект Flutter с помощью терминала и команды Flutter, подчеркивая важность соглашений об именовании и навигации по каталогам. Затем в видео демонстрируется, как настроить и запустить эмулятор Android для тестирования приложения Flutter, объясняя процесс создания виртуального устройства в Android Studio. Кроме того, в видео рассматривается запуск приложения Flutter на эмуляторе с помощью Visual Studio Code, функции отладки и управление выполнением приложения в эмуляторе. Видео завершается предварительным просмотром приложения Flutter, запущенного на эмуляторе, и предварительным просмотром будущих тем, которые будут обсуждаться в курсе.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur guide les spectateurs dans la création d'un nouveau projet Flutter à l'aide du terminal et de la commande Flutter, en soulignant l'importance des conventions de dénomination et de la navigation dans les répertoires. La vidéo montre ensuite comment configurer et lancer un émulateur Android pour tester l'application Flutter, en expliquant le processus de création d'un appareil virtuel dans Android Studio. En outre, la vidéo couvre l'exécution de l'application Flutter sur l'émulateur à l'aide de Visual Studio Code, le débogage des fonctionnalités et le contrôle de l'exécution de l'application dans l'émulateur. La vidéo se termine par un aperçu de l'application Flutter exécutée sur l'émulateur et un aperçu des futurs sujets à aborder dans le cours.",
                                // Japanese
                                "日本語": "このビデオでは、インストラクターがターミナルと Flutter コマンドを使用して新しい Flutter プロジェクトを作成する方法を視聴者に指導し、命名規則とディレクトリ ナビゲーションの重要性を強調しています。次に、Android エミュレーターを設定して起動し、Flutter アプリをテストする方法を示し、Android Studio で仮想デバイスを作成するプロセスについて説明します。さらに、このビデオでは、Visual Studio Code を使用してエミュレーターで Flutter アプリを実行する方法、デバッグ機能、エミュレーターでのアプリ実行の制御についても説明します。ビデオの最後には、エミュレーターで実行されている Flutter アプリのプレビューと、コースで今後取り上げるトピックのプレビューが紹介されます。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 시청자에게 터미널과 Flutter 명령을 사용하여 새 Flutter 프로젝트를 만드는 방법을 안내하며, 명명 규칙과 디렉터리 탐색의 중요성을 강조합니다. 그런 다음 비디오는 Flutter 앱을 테스트하기 위해 Android 에뮬레이터를 설정하고 시작하는 방법을 보여주며 Android Studio에서 가상 기기를 만드는 프로세스를 설명합니다. 또한 비디오는 Visual Studio Code를 사용하여 에뮬레이터에서 Flutter 앱을 실행하고, 디버깅 기능을 사용하고, 에뮬레이터에서 앱 실행을 제어하는 ​​방법을 다룹니다. 비디오는 에뮬레이터에서 실행되는 Flutter 앱의 미리보기와 과정에서 논의될 향후 주제에 대한 미리보기로 끝납니다.",
                                // Spanish
                                "Español": "En este video, el instructor guía a los espectadores en la creación de un nuevo proyecto de Flutter mediante la terminal y el comando Flutter, destacando la importancia de las convenciones de nombres y la navegación por directorios. Luego, el video demuestra cómo configurar e iniciar un emulador de Android para probar la aplicación Flutter, explicando el proceso de creación de un dispositivo virtual en Android Studio. Además, el video cubre la ejecución de la aplicación Flutter en el emulador mediante Visual Studio Code, la depuración de funciones y el control de la ejecución de la aplicación en el emulador. El video concluye con una vista previa de la aplicación Flutter ejecutándose en el emulador y una vista previa de los temas futuros que se tratarán en el curso.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक दर्शकों को टर्मिनल और फ़्लटर कमांड का उपयोग करके एक नया फ़्लटर प्रोजेक्ट बनाने के बारे में मार्गदर्शन करता है, नामकरण सम्मेलनों और निर्देशिका नेविगेशन के महत्व पर प्रकाश डालता है। फिर वीडियो में फ़्लटर ऐप का परीक्षण करने के लिए एंड्रॉइड एमुलेटर को सेट अप और लॉन्च करने का तरीका दिखाया गया है, जिसमें एंड्रॉइड स्टूडियो में वर्चुअल डिवाइस बनाने की प्रक्रिया को समझाया गया है। इसके अलावा, वीडियो में विज़ुअल स्टूडियो कोड का उपयोग करके एमुलेटर पर फ़्लटर ऐप चलाना, सुविधाओं को डीबग करना और एमुलेटर में ऐप निष्पादन को नियंत्रित करना शामिल है। वीडियो एमुलेटर पर चल रहे फ़्लटर ऐप के पूर्वावलोकन और पाठ्यक्रम में चर्चा किए जाने वाले भविष्य के विषयों के पूर्वावलोकन के साथ समाप्त होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor orienta os espectadores na criação de um novo projeto Flutter utilizando o terminal e o comando Flutter, destacando a importância das convenções de nomenclatura e da navegação em diretórios. O vídeo demonstra como configurar e iniciar um emulador Android para testar a aplicação Flutter, explicando o processo de criação de um dispositivo virtual no Android Studio. Além disso, o vídeo aborda a execução da aplicação Flutter no emulador utilizando o Visual Studio Code, as capacidades de depuração e o controlo da execução da aplicação no emulador. O vídeo termina com uma pré-visualização da aplicação Flutter a correr no emulador e uma pré-visualização dos tópicos futuros a serem discutidos no curso.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক দর্শকদের টার্মিনাল এবং ফ্লাটার কমান্ড ব্যবহার করে একটি নতুন ফ্লাটার প্রজেক্ট তৈরি করার বিষয়ে গাইড করছেন, নামকরণের নিয়ম এবং ডিরেক্টরি নেভিগেশনের গুরুত্ব তুলে ধরে। ভিডিওটি তারপর দেখায় যে কীভাবে অ্যান্ড্রয়েড স্টুডিওতে ভার্চুয়াল ডিভাইস তৈরির প্রক্রিয়া ব্যাখ্যা করে ফ্লটার অ্যাপটি পরীক্ষা করার জন্য একটি অ্যান্ড্রয়েড এমুলেটর সেট আপ এবং লঞ্চ করতে হয়। আরও, ভিডিওটিতে ভিজ্যুয়াল স্টুডিও কোড ব্যবহার করে এমুলেটরে ফ্লটার অ্যাপ চালানো, বৈশিষ্ট্যগুলি ডিবাগ করা এবং এমুলেটরে অ্যাপ এক্সিকিউশন নিয়ন্ত্রণ করা রয়েছে। এমুলেটরে চলমান ফ্লাটার অ্যাপের একটি পূর্বরূপ এবং কোর্সে আলোচনা করা ভবিষ্যতের বিষয়গুলির একটি পূর্বরূপ দিয়ে ভিডিওটি শেষ হয়েছে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يرشد المدرب المشاهدين إلى كيفية إنشاء مشروع Flutter جديد باستخدام المحطة الطرفية وأوامر Flutter، مع تسليط الضوء على أهمية اتفاقيات التسمية والتنقل بين المجلدات. ثم يوضح الفيديو كيفية إعداد محاكي Android وتشغيله لاختبار تطبيق Flutter، ويشرح عملية إنشاء جهاز افتراضي في Android Studio. علاوة على ذلك، يغطي الفيديو تشغيل تطبيق Flutter على المحاكي باستخدام Visual Studio Code، وميزات تصحيح الأخطاء، والتحكم في تنفيذ التطبيق في المحاكي. ويختتم الفيديو بمعاينة لتطبيق Flutter قيد التشغيل على المحاكي ومعاينة للموضوعات المستقبلية التي سيتم مناقشتها في الدورة.",
                                // Persian
                                "فارسی": "در این ویدئو، مربی بینندگان را در ایجاد یک پروژه فلاتر جدید با استفاده از ترمینال و دستور فلاتر راهنمایی می کند و اهمیت نامگذاری قراردادها و پیمایش دایرکتوری را برجسته می کند. سپس این ویدیو نحوه راه اندازی و راه اندازی شبیه ساز اندروید را برای آزمایش برنامه Flutter نشان می دهد و روند ایجاد یک دستگاه مجازی در Android Studio را توضیح می دهد. علاوه بر این، ویدیو اجرای برنامه Flutter بر روی شبیه ساز با استفاده از کد ویژوال استودیو، ویژگی های اشکال زدایی و کنترل اجرای برنامه در شبیه ساز را پوشش می دهد. این ویدئو با پیش نمایشی از برنامه Flutter که بر روی شبیه ساز اجرا می شود و پیش نمایشی از موضوعات آینده که در دوره مورد بحث قرار می گیرد، به پایان می رسد.",
                            },
                        },
                        // 16 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "An Overview of the Generated Files & Folders",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor provides a detailed explanation of the various folders and files within a Flutter project, emphasizing that most folders are for configuration and don't need manual changes. The instructor reviews folders such as 'lib' (for coding in Dart), 'test' (for writing automated tests), and 'pubspec.yaml' (for managing project dependencies). The video clarifies that certain files, like 'pubspec.lock' and '.iml', are managed automatically by the Flutter SDK and should not be modified. Additionally, the video mentions the significance of the README file for project documentation but stresses that its content can be ignored for the scope of the project. Overall, the critical takeaway is the importance of focusing on the 'lib' folder for code development, understanding how to work with 'pubspec.yaml' for managing dependencies, and disregarding other folders and files within the Flutter project.",
                                // German
                                "Deutsch": "In diesem Video gibt der Kursleiter eine detaillierte Erklärung der verschiedenen Ordner und Dateien in einem Flutter-Projekt und betont, dass die meisten Ordner zur Konfiguration dienen und keine manuellen Änderungen erfordern. Der Kursleiter überprüft Ordner wie „lib“ (zum Codieren in Dart), „test“ (zum Schreiben automatisierter Tests) und „pubspec.yaml“ (zum Verwalten von Projektabhängigkeiten). Das Video verdeutlicht, dass bestimmte Dateien wie „pubspec.lock“ und „.iml“ automatisch vom Flutter SDK verwaltet werden und nicht geändert werden sollten. Darüber hinaus erwähnt das Video die Bedeutung der README-Datei für die Projektdokumentation, betont jedoch, dass ihr Inhalt für den Umfang des Projekts ignoriert werden kann. Insgesamt ist die wichtigste Erkenntnis, dass es wichtig ist, sich bei der Codeentwicklung auf den Ordner „lib“ zu konzentrieren, zu verstehen, wie man mit „pubspec.yaml“ zum Verwalten von Abhängigkeiten arbeitet, und andere Ordner und Dateien innerhalb des Flutter-Projekts zu ignorieren.",
                                // Chinese
                                "中国人": "在本视频中，讲师详细解释了 Flutter 项目中的各种文件夹和文件，强调大多数文件夹用于配置，不需要手动更改。讲师回顾了“lib”（用于 Dart 编码）、“test”（用于编写自动测试）和“pubspec.yaml”（用于管理项目依赖项）等文件夹。视频澄清了某些文件（如“pubspec.lock”和“.iml”）由 Flutter SDK 自动管理，不应修改。此外，视频提到了 README 文件对于项目文档的重要性，但强调其内容对于项目范围而言可以忽略。总的来说，关键的收获是专注于代码开发的“lib”文件夹的重要性，了解如何使用“pubspec.yaml”来管理依赖项，并忽略 Flutter 项目中的其他文件夹和文件。",
                                // Russian
                                "Русский": "В этом видео инструктор подробно объясняет различные папки и файлы в проекте Flutter, подчеркивая, что большинство папок предназначены для конфигурации и не требуют ручных изменений. Инструктор рассматривает такие папки, как «lib» (для кодирования в Dart), «test» (для написания автоматизированных тестов) и «pubspec.yaml» (для управления зависимостями проекта). Видео разъясняет, что некоторые файлы, такие как «pubspec.lock» и «.iml», автоматически управляются Flutter SDK и не должны изменяться. Кроме того, в видео упоминается важность файла README для проектной документации, но подчеркивается, что его содержимое можно игнорировать в рамках проекта. В целом, критически важным выводом является важность сосредоточения на папке «lib» для разработки кода, понимания того, как работать с «pubspec.yaml» для управления зависимостями, и игнорирования других папок и файлов в проекте Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur fournit une explication détaillée des différents dossiers et fichiers d'un projet Flutter, en soulignant que la plupart des dossiers sont destinés à la configuration et ne nécessitent pas de modifications manuelles. L'instructeur passe en revue des dossiers tels que « lib » (pour le codage dans Dart), « test » (pour l'écriture de tests automatisés) et « pubspec.yaml » (pour la gestion des dépendances du projet). La vidéo précise que certains fichiers, comme « pubspec.lock » et « .iml », sont gérés automatiquement par le SDK Flutter et ne doivent pas être modifiés. De plus, la vidéo mentionne l'importance du fichier README pour la documentation du projet, mais souligne que son contenu peut être ignoré dans le cadre du projet. Dans l'ensemble, le point essentiel à retenir est l'importance de se concentrer sur le dossier « lib » pour le développement de code, de comprendre comment travailler avec « pubspec.yaml » pour la gestion des dépendances et de ne pas tenir compte des autres dossiers et fichiers du projet Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、講師が Flutter プロジェクト内のさまざまなフォルダーとファイルについて詳しく説明し、ほとんどのフォルダーは構成用であり、手動で変更する必要がないことを強調しています。講師は、「lib」（Dart でのコーディング用）、「test」（自動テストの作成用）、「pubspec.yaml」（プロジェクトの依存関係の管理用）などのフォルダーを確認します。ビデオでは、「pubspec.lock」や「.iml」などの特定のファイルは Flutter SDK によって自動的に管理されるため、変更してはならないことを明確にしています。さらに、ビデオでは、プロジェクトのドキュメントに関する README ファイルの重要性について言及していますが、その内容はプロジェクトの範囲では無視できることを強調しています。全体として、重要なポイントは、コード開発では「lib」フォルダーに焦点を当て、依存関係の管理には「pubspec.yaml」の操作方法を理解し、Flutter プロジェクト内の他のフォルダーやファイルは無視することの重要性です。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 Flutter 프로젝트 내의 다양한 폴더와 파일에 대한 자세한 설명을 제공하며, 대부분 폴더는 구성을 위한 것이며 수동으로 변경할 필요가 없다는 점을 강조합니다. 강사는 'lib'(Dart로 코딩하기 위한), 'test'(자동화된 테스트를 작성하기 위한), 'pubspec.yaml'(프로젝트 종속성을 관리하기 위한)과 같은 폴더를 검토합니다. 이 비디오는 'pubspec.lock' 및 '.iml'과 같은 특정 파일은 Flutter SDK에서 자동으로 관리되며 수정해서는 안 된다는 점을 명확히 밝힙니다. 또한 이 비디오는 프로젝트 문서에 대한 README 파일의 중요성을 언급하지만, 그 내용은 프로젝트 범위에서 무시할 수 있다는 점을 강조합니다. 전반적으로 중요한 요점은 코드 개발을 위해 'lib' 폴더에 집중하고, 종속성을 관리하기 위해 'pubspec.yaml'을 사용하는 방법을 이해하고, Flutter 프로젝트 내의 다른 폴더와 파일은 무시하는 것이 중요하다는 것입니다.",
                                // Spanish
                                "Español": "En este video, el instructor brinda una explicación detallada de las distintas carpetas y archivos dentro de un proyecto de Flutter, y enfatiza que la mayoría de las carpetas son para configuración y no necesitan cambios manuales. El instructor revisa carpetas como 'lib' (para codificar en Dart), 'test' (para escribir pruebas automatizadas) y 'pubspec.yaml' (para administrar dependencias del proyecto). El video aclara que ciertos archivos, como 'pubspec.lock' y '.iml', son administrados automáticamente por el SDK de Flutter y no deben modificarse. Además, el video menciona la importancia del archivo README para la documentación del proyecto, pero enfatiza que su contenido puede ignorarse para el alcance del proyecto. En general, la conclusión fundamental es la importancia de centrarse en la carpeta 'lib' para el desarrollo de código, comprender cómo trabajar con 'pubspec.yaml' para administrar dependencias e ignorar otras carpetas y archivos dentro del proyecto de Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक फ़्लटर प्रोजेक्ट के भीतर विभिन्न फ़ोल्डरों और फ़ाइलों के बारे में विस्तृत विवरण प्रदान करता है, जिसमें इस बात पर ज़ोर दिया जाता है कि ज़्यादातर फ़ोल्डर कॉन्फ़िगरेशन के लिए हैं और उन्हें मैन्युअल रूप से बदलने की ज़रूरत नहीं है। प्रशिक्षक 'lib' (डार्ट में कोडिंग के लिए), 'test' (स्वचालित परीक्षण लिखने के लिए), और 'pubspec.yaml' (प्रोजेक्ट निर्भरताओं को प्रबंधित करने के लिए) जैसे फ़ोल्डरों की समीक्षा करता है। वीडियो स्पष्ट करता है कि कुछ फ़ाइलें, जैसे 'pubspec.lock' और '.iml', फ़्लटर SDK द्वारा स्वचालित रूप से प्रबंधित की जाती हैं और उन्हें संशोधित नहीं किया जाना चाहिए। इसके अतिरिक्त, वीडियो प्रोजेक्ट डॉक्यूमेंटेशन के लिए README फ़ाइल के महत्व का उल्लेख करता है लेकिन इस बात पर ज़ोर देता है कि प्रोजेक्ट के दायरे के लिए इसकी सामग्री को अनदेखा किया जा सकता है। कुल मिलाकर, महत्वपूर्ण बात यह है कि कोड डेवलपमेंट के लिए 'lib' फ़ोल्डर पर ध्यान केंद्रित करना, निर्भरताओं को प्रबंधित करने के लिए 'pubspec.yaml' के साथ काम करना समझना और फ़्लटर प्रोजेक्ट के भीतर अन्य फ़ोल्डरों और फ़ाइलों को अनदेखा करना महत्वपूर्ण है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor fornece uma explicação detalhada das várias pastas e ficheiros de um projeto Flutter, salientando que a maioria das pastas é para configuração e não necessita de alterações manuais. O instrutor revê pastas como 'lib' (para codificação em Dart), 'test' (para escrever testes automatizados) e 'pubspec.yaml' (para gerir as dependências do projeto). O vídeo esclarece que determinados ficheiros, como o ‘pubspec.lock’ e o ‘. iml’, são geridos automaticamente pelo Flutter SDK e não devem ser modificados. Além disso, o vídeo refere a importância do ficheiro README para a documentação do projeto, mas realça que o seu conteúdo pode ser ignorado no âmbito do projeto. No geral, a conclusão crítica é a importância de nos focarmos na pasta ‘lib’ para o desenvolvimento de código, perceber como trabalhar com ‘pubspec.yaml’ para gerir dependências e desconsiderar outras pastas e ficheiros dentro do projeto Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক একটি ফ্লটার প্রকল্পের মধ্যে বিভিন্ন ফোল্ডার এবং ফাইলগুলির একটি বিশদ ব্যাখ্যা প্রদান করে, জোর দিয়ে যে বেশিরভাগ ফোল্ডারগুলি কনফিগারেশনের জন্য এবং ম্যানুয়াল পরিবর্তনের প্রয়োজন নেই৷ প্রশিক্ষক 'lib' (ডার্টে কোডিংয়ের জন্য), 'টেস্ট' (স্বয়ংক্রিয় পরীক্ষা লেখার জন্য), এবং 'pubspec.yaml' (প্রকল্প নির্ভরতা পরিচালনার জন্য) এর মতো ফোল্ডারগুলি পর্যালোচনা করেন। ভিডিওটি স্পষ্ট করে যে কিছু নির্দিষ্ট ফাইল, যেমন 'pubspec.lock' এবং '.iml', ফ্লটার SDK দ্বারা স্বয়ংক্রিয়ভাবে পরিচালিত হয় এবং সংশোধন করা উচিত নয়৷ উপরন্তু, ভিডিওটি প্রকল্প ডকুমেন্টেশনের জন্য README ফাইলের তাৎপর্য উল্লেখ করে কিন্তু জোর দেয় যে প্রকল্পের সুযোগের জন্য এর বিষয়বস্তু উপেক্ষা করা যেতে পারে। সামগ্রিকভাবে, কোড ডেভেলপমেন্টের জন্য 'lib' ফোল্ডারে ফোকাস করার গুরুত্ব, নির্ভরতা পরিচালনার জন্য 'pubspec.yaml'-এর সাথে কীভাবে কাজ করতে হয় তা বোঝা এবং ফ্লাটার প্রকল্পের মধ্যে অন্যান্য ফোল্ডার এবং ফাইলগুলিকে উপেক্ষা করা গুরুত্বপূর্ণ।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يقدم المدرب شرحًا تفصيليًا للمجلدات والملفات المختلفة داخل مشروع Flutter، مؤكدًا أن معظم المجلدات مخصصة للتكوين ولا تحتاج إلى تغييرات يدوية. يستعرض المدرب مجلدات مثل 'lib' (للترميز في Dart)، و'test' (لكتابة الاختبارات الآلية)، و'pubspec.yaml' (لإدارة تبعيات المشروع). يوضح الفيديو أن بعض الملفات، مثل 'pubspec.lock' و'.iml'، تتم إدارتها تلقائيًا بواسطة Flutter SDK ولا ينبغي تعديلها. بالإضافة إلى ذلك، يذكر الفيديو أهمية ملف README لوثائق المشروع ولكنه يؤكد على أنه يمكن تجاهل محتواه لنطاق المشروع. بشكل عام، فإن النتيجة الحاسمة هي أهمية التركيز على مجلد 'lib' لتطوير التعليمات البرمجية، وفهم كيفية العمل مع 'pubspec.yaml' لإدارة التبعيات، وتجاهل المجلدات والملفات الأخرى داخل مشروع Flutter.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس توضیحات مفصلی در مورد پوشه ها و فایل های مختلف در پروژه فلاتر ارائه می دهد و تاکید می کند که اکثر پوشه ها برای پیکربندی هستند و نیازی به تغییرات دستی ندارند. مدرس پوشه هایی مانند 'lib' (برای کدنویسی در دارت)، 'test' (برای نوشتن تست های خودکار) و 'pubspec.yaml' (برای مدیریت وابستگی های پروژه) را بررسی می کند. این ویدیو روشن می‌کند که فایل‌های خاصی مانند «pubspec.lock» و «.iml» به‌طور خودکار توسط Flutter SDK مدیریت می‌شوند و نباید اصلاح شوند. علاوه بر این، این ویدئو به اهمیت فایل README برای مستندات پروژه اشاره می کند، اما تاکید می کند که محتوای آن را می توان برای محدوده پروژه نادیده گرفت. به طور کلی، نکته مهم اهمیت تمرکز بر روی پوشه 'lib' برای توسعه کد، درک نحوه کار با 'pubspec.yaml' برای مدیریت وابستگی ها، و نادیده گرفتن پوشه ها و فایل های دیگر در پروژه Flutter است.",
                            },
                        },
                        // 17 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Analyzing the Default App",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor delves into the main.dart file in the lib folder of a Flutter project, emphasizing its role in rendering the application on the screen. The instructor explains the concept of widgets in Flutter as the building blocks of the user interface and explores how the main.dart file creates the application output through widgets. The instructor highlights the importance of understanding how Flutter works by creating a complete app from scratch rather than providing step-by-step instructions, aiming for viewers to grasp the underlying code structure and functionalities. By deleting the existing code in main.dart and starting fresh, the instructor prioritizes hands-on learning to ensure viewers can independently build a variety of Flutter apps.",
                                // German
                                "Deutsch": "In diesem Video befasst sich der Kursleiter mit der Datei main.dart im Ordner lib eines Flutter-Projekts und betont ihre Rolle bei der Darstellung der Anwendung auf dem Bildschirm. Der Kursleiter erklärt das Konzept von Widgets in Flutter als Bausteine ​​der Benutzeroberfläche und untersucht, wie die Datei main.dart die Anwendungsausgabe durch Widgets erstellt. Der Kursleiter betont, wie wichtig es ist, zu verstehen, wie Flutter funktioniert, indem er eine komplette App von Grund auf neu erstellt, anstatt Schritt-für-Schritt-Anleitungen zu geben, damit die Zuschauer die zugrundeliegende Codestruktur und -funktionen verstehen. Indem der Kursleiter den vorhandenen Code in main.dart löscht und von vorne beginnt, priorisiert er das praktische Lernen, um sicherzustellen, dass die Zuschauer selbstständig eine Vielzahl von Flutter-Apps erstellen können.",
                                // Chinese
                                "中国人": "在本视频中，讲师深入研究了 Flutter 项目的 lib 文件夹中的 main.dart 文件，强调了它在屏幕上呈现应用程序方面的作用。讲师解释了 Flutter 中作为用户界面构建块的 widget 概念，并探讨了 main.dart 文件如何通过 widget 创建应用程序输出。讲师强调了了解 Flutter 工作原理的重要性，方法是从头开始创建一个完整的应用程序，而不是提供分步说明，旨在让观众掌握底层代码结构和功能。通过删除 main.dart 中的现有代码并重新开始，讲师优先考虑动手学习，以确保观众可以独立构建各种 Flutter 应用程序。",
                                // Russian
                                "Русский": "В этом видео инструктор разбирает файл main.dart в папке lib проекта Flutter, подчеркивая его роль в отображении приложения на экране. Инструктор объясняет концепцию виджетов во Flutter как строительных блоков пользовательского интерфейса и исследует, как файл main.dart создает вывод приложения через виджеты. Инструктор подчеркивает важность понимания того, как работает Flutter, создавая полное приложение с нуля, а не предоставляя пошаговые инструкции, стремясь к тому, чтобы зрители поняли базовую структуру кода и функциональные возможности. Удаляя существующий код в main.dart и начиная с чистого листа, инструктор отдает приоритет практическому обучению, чтобы зрители могли самостоятельно создавать различные приложения Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur explore le fichier main.dart dans le dossier lib d'un projet Flutter, en insistant sur son rôle dans le rendu de l'application à l'écran. L'instructeur explique le concept de widgets dans Flutter en tant qu'éléments de base de l'interface utilisateur et explore la manière dont le fichier main.dart crée la sortie de l'application via des widgets. L'instructeur souligne l'importance de comprendre le fonctionnement de Flutter en créant une application complète à partir de zéro plutôt qu'en fournissant des instructions étape par étape, dans le but de permettre aux utilisateurs de saisir la structure du code sous-jacent et les fonctionnalités. En supprimant le code existant dans main.dart et en recommençant à zéro, l'instructeur donne la priorité à l'apprentissage pratique pour garantir que les utilisateurs peuvent créer de manière indépendante une variété d'applications Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、講師が Flutter プロジェクトの lib フォルダーにある main.dart ファイルについて詳しく解説し、画面上でアプリケーションをレンダリングする際の役割を強調しています。講師は、ユーザー インターフェースの構成要素としての Flutter のウィジェットの概念を説明し、main.dart ファイルがウィジェットを通じてアプリケーション出力を作成する仕組みを探ります。講師は、視聴者が基礎となるコード構造と機能を把握できるように、段階的な手順を示すのではなく、最初から完全なアプリを作成することで、Flutter の仕組みを理解することの重要性を強調しています。講師は、main.dart の既存のコードを削除して最初からやり直すことで、実践的な学習を優先し、視聴者がさまざまな Flutter アプリを独自に構築できるようにします。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 Flutter 프로젝트의 lib 폴더에 있는 main.dart 파일을 파헤쳐 화면에 애플리케이션을 렌더링하는 데 있어서의 역할을 강조합니다. 강사는 사용자 인터페이스의 빌딩 블록으로서 Flutter의 위젯 개념을 설명하고 main.dart 파일이 위젯을 통해 애플리케이션 출력을 만드는 방법을 살펴봅니다. 강사는 단계별 지침을 제공하는 대신 처음부터 완전한 앱을 만들어 Flutter가 작동하는 방식을 이해하는 것의 중요성을 강조하여 시청자가 기본 코드 구조와 기능을 파악하도록 합니다. 강사는 main.dart의 기존 코드를 삭제하고 처음부터 시작하여 시청자가 다양한 Flutter 앱을 독립적으로 빌드할 수 있도록 실습 학습을 우선시합니다.",
                                // Spanish
                                "Español": "En este video, el instructor analiza en profundidad el archivo main.dart en la carpeta lib de un proyecto de Flutter y destaca su función en la representación de la aplicación en la pantalla. El instructor explica el concepto de widgets en Flutter como los componentes básicos de la interfaz de usuario y explora cómo el archivo main.dart crea la salida de la aplicación a través de widgets. El instructor destaca la importancia de comprender cómo funciona Flutter creando una aplicación completa desde cero en lugar de brindar instrucciones paso a paso, con el objetivo de que los espectadores comprendan la estructura y las funcionalidades del código subyacente. Al eliminar el código existente en main.dart y comenzar de nuevo, el instructor prioriza el aprendizaje práctico para garantizar que los espectadores puedan crear de forma independiente una variedad de aplicaciones de Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक फ़्लटर प्रोजेक्ट के lib फ़ोल्डर में main.dart फ़ाइल के बारे में विस्तार से बताता है, स्क्रीन पर एप्लिकेशन को प्रस्तुत करने में इसकी भूमिका पर ज़ोर देता है। प्रशिक्षक फ़्लटर में विजेट की अवधारणा को उपयोगकर्ता इंटरफ़ेस के निर्माण खंडों के रूप में समझाता है और यह पता लगाता है कि कैसे main.dart फ़ाइल विजेट के माध्यम से एप्लिकेशन आउटपुट बनाती है। प्रशिक्षक फ़्लटर के काम करने के तरीके को समझने के महत्व पर प्रकाश डालता है, चरण-दर-चरण निर्देश प्रदान करने के बजाय स्क्रैच से एक संपूर्ण ऐप बनाकर, दर्शकों को अंतर्निहित कोड संरचना और कार्यक्षमताओं को समझने का लक्ष्य देता है। main.dart में मौजूदा कोड को हटाकर और नए सिरे से शुरू करके, प्रशिक्षक दर्शकों को स्वतंत्र रूप से फ़्लटर के कई ऐप बनाने के लिए हाथों-हाथ सीखने को प्राथमिकता देता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor aprofunda o ficheiro main.dart da pasta lib de um projeto Flutter, enfatizando o seu papel na renderização da aplicação no ecrã. O formador explica o conceito de widgets no Flutter como os blocos de construção da interface do utilizador e explora como o ficheiro main.dart cria a saída da aplicação através de widgets. O instrutor destaca a importância de compreender como o Flutter funciona, criando uma aplicação completa a partir do zero, em vez de fornecer instruções passo a passo, visando que os visualizadores compreendam a estrutura e as funcionalidades do código subjacente. Ao eliminar o código existente em main.dart e começar do zero, o instrutor prioriza a aprendizagem prática para garantir que os espectadores podem criar de forma independente uma variedade de aplicações Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক একটি ফ্লাটার প্রোজেক্টের lib ফোল্ডারে main.dart ফাইলে প্রবেশ করেন, স্ক্রিনে অ্যাপ্লিকেশন রেন্ডার করার ক্ষেত্রে তার ভূমিকার উপর জোর দেন। প্রশিক্ষক ইউজার ইন্টারফেসের বিল্ডিং ব্লক হিসাবে ফ্লটারে উইজেটের ধারণা ব্যাখ্যা করেন এবং কিভাবে main.dart ফাইল উইজেটের মাধ্যমে অ্যাপ্লিকেশন আউটপুট তৈরি করে তা অন্বেষণ করেন। প্রশিক্ষক ধাপে ধাপে নির্দেশনা প্রদানের পরিবর্তে স্ক্র্যাচ থেকে একটি সম্পূর্ণ অ্যাপ তৈরি করে ফ্লটার কীভাবে কাজ করে তা বোঝার গুরুত্ব তুলে ধরেন, দর্শকদের অন্তর্নিহিত কোড কাঠামো এবং কার্যকারিতাগুলি বোঝার লক্ষ্যে। main.dart-এ বিদ্যমান কোড মুছে ফেলার মাধ্যমে এবং নতুন করে শুরু করার মাধ্যমে, দর্শকরা যাতে স্বাধীনভাবে বিভিন্ন ধরনের Flutter অ্যাপ তৈরি করতে পারে তা নিশ্চিত করার জন্য প্রশিক্ষক হ্যান্ডস-অন শেখার অগ্রাধিকার দেন।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتعمق المدرب في ملف main.dart في مجلد lib في مشروع Flutter، مع التركيز على دوره في عرض التطبيق على الشاشة. يشرح المدرب مفهوم الأدوات في Flutter باعتبارها اللبنات الأساسية لواجهة المستخدم ويستكشف كيف يقوم ملف main.dart بإنشاء مخرجات التطبيق من خلال الأدوات. يسلط المدرب الضوء على أهمية فهم كيفية عمل Flutter من خلال إنشاء تطبيق كامل من الصفر بدلاً من تقديم تعليمات خطوة بخطوة، بهدف تمكين المشاهدين من فهم بنية الكود الأساسية والوظائف. من خلال حذف الكود الموجود في main.dart والبدء من جديد، يعطي المدرب الأولوية للتعلم العملي لضمان قدرة المشاهدين على إنشاء مجموعة متنوعة من تطبيقات Flutter بشكل مستقل.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس فایل main.dart را در پوشه lib یک پروژه فلاتر بررسی می کند و بر نقش آن در رندر کردن برنامه روی صفحه تاکید می کند. مدرس مفهوم ویجت ها را در Flutter به عنوان بلوک های سازنده رابط کاربری توضیح می دهد و بررسی می کند که چگونه فایل main.dart خروجی برنامه را از طریق ویجت ها ایجاد می کند. مدرس اهمیت درک نحوه عملکرد Flutter را با ایجاد یک برنامه کامل از ابتدا به جای ارائه دستورالعمل های گام به گام، با هدف درک ساختار کد و عملکردهای زیربنایی توسط بینندگان، برجسته می کند. با حذف کد موجود در main.dart و شروع تازه، مربی یادگیری عملی را در اولویت قرار می دهد تا اطمینان حاصل شود که بینندگان می توانند به طور مستقل انواع برنامه های Flutter را بسازند.",
                            },
                        },
                        // 18 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Dart Basics",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker starts by explaining programming and Dart fundamentals before rebuilding an app from scratch. He covers functions, arguments, types, and returns in Dart, using examples to demonstrate how to add numbers and handle different data types like integers and doubles. He emphasizes the importance of using types to write cleaner and better code, and shows how to call functions and handle return types. The video serves as a beginner-friendly introduction to Dart programming concepts and syntax.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Sprecher zunächst die Grundlagen der Programmierung und von Dart, bevor er eine App von Grund auf neu erstellt. Er behandelt Funktionen, Argumente, Typen und Rückgaben in Dart und zeigt anhand von Beispielen, wie Zahlen addiert und verschiedene Datentypen wie Ganzzahlen und Doppelte verarbeitet werden. Er betont, wie wichtig es ist, Typen zu verwenden, um saubereren und besseren Code zu schreiben, und zeigt, wie Funktionen aufgerufen und Rückgabetypen verarbeitet werden. Das Video dient als anfängerfreundliche Einführung in die Konzepte und Syntax der Dart-Programmierung.",
                                // Chinese
                                "中国人": "在此视频中，演讲者首先会讲解编程和 Dart 基础知识，然后从头开始重建应用。他介绍了 Dart 中的函数、参数、类型和返回值，并使用示例演示了如何添加数字以及如何处理不同的数据类型（例如整数和双精度数）。他强调了使用类型编写更简洁、更好的代码的重要性，并展示了如何调用函数和处理返回类型。该视频是 Dart 编程概念和语法的入门视频，适合初学者观看。",
                                // Russian
                                "Русский": "В этом видео докладчик начинает с объяснения основ программирования и Dart, прежде чем перестраивать приложение с нуля. Он охватывает функции, аргументы, типы и возвраты в Dart, используя примеры, чтобы продемонстрировать, как складывать числа и обрабатывать различные типы данных, такие как целые и двойные. Он подчеркивает важность использования типов для написания более чистого и лучшего кода и показывает, как вызывать функции и обрабатывать возвращаемые типы. Видео служит понятным для новичков введением в концепции и синтаксис программирования Dart.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant commence par expliquer la programmation et les principes fondamentaux de Dart avant de reconstruire une application à partir de zéro. Il aborde les fonctions, les arguments, les types et les retours dans Dart, en utilisant des exemples pour montrer comment additionner des nombres et gérer différents types de données comme les entiers et les doubles. Il souligne l'importance d'utiliser des types pour écrire un code plus propre et de meilleure qualité, et montre comment appeler des fonctions et gérer les types de retour. La vidéo sert d'introduction aux concepts et à la syntaxe de programmation Dart pour les débutants.",
                                // Japanese
                                "日本語": "このビデオでは、講演者はアプリをゼロから再構築する前に、プログラミングと Dart の基礎について説明しています。Dart の関数、引数、型、戻り値について説明し、例を使用して数値の追加方法や、整数や倍精度浮動小数点数などのさまざまなデータ型の処理方法を説明します。型を使用してよりクリーンで優れたコードを書くことが重要であることを強調し、関数の呼び出し方法や戻り値の型の処理方法を示します。このビデオは、初心者に優しい Dart プログラミングの概念と構文の紹介として役立ちます。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 앱을 처음부터 다시 빌드하기 전에 프로그래밍과 Dart 기본 사항을 설명하면서 시작합니다. 그는 Dart의 함수, 인수, 유형 및 반환을 다루며, 예를 들어 숫자를 더하고 정수 및 double과 같은 다양한 데이터 유형을 처리하는 방법을 보여줍니다. 그는 더 깔끔하고 더 나은 코드를 작성하기 위해 유형을 사용하는 것의 중요성을 강조하고 함수를 호출하고 반환 유형을 처리하는 방법을 보여줍니다. 이 영상은 Dart 프로그래밍 개념과 구문에 대한 초보자 친화적인 소개 역할을 합니다.",
                                // Spanish
                                "Español": "En este video, el orador comienza explicando los conceptos básicos de programación y Dart antes de reconstruir una aplicación desde cero. Abarca funciones, argumentos, tipos y retornos en Dart, y utiliza ejemplos para demostrar cómo sumar números y manejar diferentes tipos de datos, como números enteros y dobles. Destaca la importancia de usar tipos para escribir un código más limpio y mejor, y muestra cómo llamar a funciones y manejar tipos de retorno. El video sirve como una introducción para principiantes a los conceptos y la sintaxis de programación de Dart.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता किसी ऐप को स्क्रैच से फिर से बनाने से पहले प्रोग्रामिंग और डार्ट की बुनियादी बातों को समझाते हुए शुरू करता है। वह डार्ट में फ़ंक्शन, तर्क, प्रकार और रिटर्न को कवर करता है, उदाहरणों का उपयोग करके यह प्रदर्शित करता है कि संख्याओं को कैसे जोड़ा जाए और पूर्णांक और डबल्स जैसे विभिन्न डेटा प्रकारों को कैसे संभाला जाए। वह क्लीनर और बेहतर कोड लिखने के लिए प्रकारों का उपयोग करने के महत्व पर जोर देता है, और दिखाता है कि फ़ंक्शन को कैसे कॉल किया जाए और रिटर्न प्रकारों को कैसे संभाला जाए। वीडियो डार्ट प्रोग्रामिंग अवधारणाओं और सिंटैक्स के लिए शुरुआती अनुकूल परिचय के रूप में कार्य करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador começa por explicar a programação e os fundamentos do Dart antes de reconstruir uma aplicação a partir do zero. Aborda funções, argumentos, tipos e retornos no Dart, utilizando exemplos para demonstrar como adicionar números e lidar com diferentes tipos de dados, como números inteiros e duplos. Realça a importância de usar tipos para escrever código mais limpo e melhor e mostra como chamar funções e lidar com tipos de retorno. O vídeo serve como uma introdução para principiantes aos conceitos e sintaxe de programação do Dart.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার স্ক্র্যাচ থেকে একটি অ্যাপ পুনর্নির্মাণের আগে প্রোগ্রামিং এবং ডার্টের মৌলিক বিষয়গুলি ব্যাখ্যা করে শুরু করেন। তিনি ডার্টে ফাংশন, আর্গুমেন্ট, প্রকার এবং রিটার্ন কভার করেন, উদাহরণ ব্যবহার করে দেখানোর জন্য কিভাবে সংখ্যা যোগ করা যায় এবং পূর্ণসংখ্যা এবং ডাবলের মতো বিভিন্ন ডেটা টাইপ পরিচালনা করে। তিনি ক্লিনার এবং আরও ভাল কোড লেখার জন্য প্রকারগুলি ব্যবহার করার গুরুত্বের উপর জোর দেন এবং কীভাবে ফাংশন কল করতে হয় এবং রিটার্ন টাইপগুলি পরিচালনা করতে হয় তা দেখান। ভিডিওটি ডার্ট প্রোগ্রামিং ধারণা এবং সিনট্যাক্সের একটি শিক্ষানবিস-বন্ধুত্বপূর্ণ ভূমিকা হিসেবে কাজ করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يبدأ المتحدث بشرح أساسيات البرمجة وDart قبل إعادة بناء التطبيق من الصفر. ويتناول الوظائف والحجج والأنواع والإرجاعات في Dart، مستخدمًا أمثلة لتوضيح كيفية إضافة الأرقام والتعامل مع أنواع البيانات المختلفة مثل الأعداد الصحيحة والأعداد الثنائية. ويؤكد على أهمية استخدام الأنواع لكتابة كود أنظف وأفضل، ويوضح كيفية استدعاء الوظائف والتعامل مع أنواع الإرجاع. يعمل الفيديو كمقدمة سهلة للمبتدئين لمفاهيم برمجة Dart وقواعدها.",
                                // Persian
                                "فارسی": "در این ویدیو، سخنران با توضیح برنامه نویسی و اصول Dart قبل از بازسازی یک برنامه از ابتدا شروع می کند. او توابع، آرگومان‌ها، انواع و برگردانده‌ها را در دارت پوشش می‌دهد و از مثال‌هایی برای نشان دادن نحوه اضافه کردن اعداد و مدیریت انواع داده‌های مختلف مانند اعداد صحیح و دوبل استفاده می‌کند. او بر اهمیت استفاده از انواع برای نوشتن کدهای تمیزتر و بهتر تاکید می کند و نحوه فراخوانی توابع و مدیریت انواع برگشتی را نشان می دهد. این ویدیو به عنوان مقدمه ای برای مبتدیان برای مفاهیم و نحو برنامه نویسی دارت عمل می کند.",
                            },
                        },
                        // 19 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "More Dart Basics",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video discusses two important features in programming - variables and object-oriented programming in Dart. Variables are used to store data in memory for later use, and can be created using the var keyword or by specifying the data type. Objects are data structures with information that reflect real-world entities, and can be created using classes in Dart. Classes serve as blueprints for creating objects, with properties representing data within the object. The video demonstrates creating objects and accessing their properties using the dot notation. Classes are a fundamental feature in Dart and play a key role in object-oriented programming.",
                                // German
                                "Deutsch": "Das Video behandelt zwei wichtige Funktionen der Programmierung – Variablen und objektorientierte Programmierung in Dart. Variablen werden verwendet, um Daten für die spätere Verwendung im Speicher zu speichern, und können mit dem Schlüsselwort var oder durch Angabe des Datentyps erstellt werden. Objekte sind Datenstrukturen mit Informationen, die reale Entitäten widerspiegeln, und können mit Klassen in Dart erstellt werden. Klassen dienen als Blaupausen zum Erstellen von Objekten, wobei Eigenschaften Daten innerhalb des Objekts darstellen. Das Video zeigt das Erstellen von Objekten und den Zugriff auf ihre Eigenschaften mithilfe der Punktnotation. Klassen sind eine grundlegende Funktion in Dart und spielen eine Schlüsselrolle in der objektorientierten Programmierung.",
                                // Chinese
                                "中国人": "视频讨论了编程中的两个重要特性——Dart 中的变量和面向对象编程。变量用于将数据存储在内存中以供日后使用，可以使用 var 关键字或指定数据类型来创建。对象是具有反映现实世界实体信息的数据结构，可以使用 Dart 中的类来创建。类是创建对象的蓝图，其属性表示对象内的数据。视频演示了如何使用点符号创建对象并访问其属性。类是 Dart 中的一个基本特性，在面向对象编程中起着关键作用。",
                                // Russian
                                "Русский": "В видео обсуждаются две важные функции программирования — переменные и объектно-ориентированное программирование в Dart. Переменные используются для хранения данных в памяти для последующего использования и могут быть созданы с помощью ключевого слова var или путем указания типа данных. Объекты — это структуры данных с информацией, отражающей сущности реального мира, и могут быть созданы с помощью классов в Dart. Классы служат чертежами для создания объектов, а свойства представляют данные внутри объекта. Видео демонстрирует создание объектов и доступ к их свойствам с помощью точечной нотации. Классы являются фундаментальной функцией Dart и играют ключевую роль в объектно-ориентированном программировании.",
                                // French
                                "Français": "La vidéo présente deux fonctionnalités importantes de la programmation : les variables et la programmation orientée objet dans Dart. Les variables sont utilisées pour stocker des données en mémoire pour une utilisation ultérieure et peuvent être créées à l'aide du mot-clé var ou en spécifiant le type de données. Les objets sont des structures de données contenant des informations qui reflètent des entités du monde réel et peuvent être créés à l'aide de classes dans Dart. Les classes servent de modèles pour la création d'objets, avec des propriétés représentant des données au sein de l'objet. La vidéo montre comment créer des objets et accéder à leurs propriétés à l'aide de la notation par points. Les classes sont une fonctionnalité fondamentale de Dart et jouent un rôle clé dans la programmation orientée objet.",
                                // Japanese
                                "日本語": "このビデオでは、プログラミングにおける 2 つの重要な機能、つまり Dart の変数とオブジェクト指向プログラミングについて説明します。変数は、後で使用するためにメモリにデータを格納するために使用され、var キーワードを使用するか、データ型を指定して作成できます。オブジェクトは、現実世界のエンティティを反映する情報を含むデータ構造で、Dart のクラスを使用して作成できます。クラスはオブジェクトを作成するための設計図として機能し、プロパティはオブジェクト内のデータを表します。ビデオでは、ドット表記を使用してオブジェクトを作成し、そのプロパティにアクセスする方法を示します。クラスは Dart の基本的な機能であり、オブジェクト指向プログラミングで重要な役割を果たします。",
                                // Korean
                                "한국인": "이 비디오에서는 프로그래밍의 두 가지 중요한 기능인 변수와 Dart의 객체 지향 프로그래밍에 대해 설명합니다. 변수는 나중에 사용하기 위해 메모리에 데이터를 저장하는 데 사용되며 var 키워드를 사용하거나 데이터 유형을 지정하여 만들 수 있습니다. 객체는 실제 엔터티를 반영하는 정보가 있는 데이터 구조이며 Dart의 클래스를 사용하여 만들 수 있습니다. 클래스는 객체를 만드는 청사진 역할을 하며, 객체 내의 데이터를 나타내는 속성이 있습니다. 이 비디오에서는 점 표기법을 사용하여 객체를 만들고 해당 속성에 액세스하는 방법을 보여줍니다. 클래스는 Dart의 기본 기능이며 객체 지향 프로그래밍에서 핵심적인 역할을 합니다.",
                                // Spanish
                                "Español": "El vídeo analiza dos características importantes de la programación: las variables y la programación orientada a objetos en Dart. Las variables se utilizan para almacenar datos en la memoria para su uso posterior y se pueden crear utilizando la palabra clave var o especificando el tipo de datos. Los objetos son estructuras de datos con información que reflejan entidades del mundo real y se pueden crear utilizando clases en Dart. Las clases sirven como planos para crear objetos, con propiedades que representan datos dentro del objeto. El vídeo demuestra cómo crear objetos y acceder a sus propiedades utilizando la notación de puntos. Las clases son una característica fundamental en Dart y desempeñan un papel clave en la programación orientada a objetos.",
                                // Hindi
                                "हिंदी": "वीडियो प्रोग्रामिंग में दो महत्वपूर्ण विशेषताओं पर चर्चा करता है - डार्ट में चर और ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग। चर का उपयोग बाद में उपयोग के लिए मेमोरी में डेटा संग्रहीत करने के लिए किया जाता है, और इसे var कीवर्ड का उपयोग करके या डेटा प्रकार निर्दिष्ट करके बनाया जा सकता है। ऑब्जेक्ट ऐसी डेटा संरचनाएँ हैं जिनमें ऐसी जानकारी होती है जो वास्तविक दुनिया की संस्थाओं को दर्शाती है, और इसे डार्ट में कक्षाओं का उपयोग करके बनाया जा सकता है। ऑब्जेक्ट बनाने के लिए कक्षाएँ ब्लूप्रिंट के रूप में काम करती हैं, जिसमें गुण ऑब्जेक्ट के भीतर डेटा का प्रतिनिधित्व करते हैं। वीडियो डॉट नोटेशन का उपयोग करके ऑब्जेक्ट बनाने और उनके गुणों तक पहुँचने का प्रदर्शन करता है। डार्ट में कक्षाएँ एक मूलभूत विशेषता हैं और ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग में एक महत्वपूर्ण भूमिका निभाती हैं।",
                                // Portuguese
                                "Português": "O vídeo discute duas características importantes na programação - variáveis ​​e programação orientada a objetos no Dart. As variáveis ​​são utilizadas para armazenar dados na memória para utilização posterior e podem ser criadas utilizando a palavra-chave var ou especificando o tipo de dados. Os objetos são estruturas de dados com informação que reflete entidades do mundo real e podem ser criados através de classes no Dart. As classes servem como modelos para a criação de objetos, sendo que as propriedades representam dados dentro do objeto. O vídeo demonstra a criação de objetos e o acesso às suas propriedades utilizando a notação de pontos. As classes são uma característica fundamental no Dart e desempenham um papel fundamental na programação orientada a objectos.",
                                // Bengali
                                "বাংলা": "ভিডিওটিতে প্রোগ্রামিংয়ের দুটি গুরুত্বপূর্ণ বৈশিষ্ট্য নিয়ে আলোচনা করা হয়েছে - ডার্টে ভেরিয়েবল এবং অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং। ভেরিয়েবলগুলি পরে ব্যবহারের জন্য মেমরিতে ডেটা সংরক্ষণ করতে ব্যবহৃত হয় এবং var কীওয়ার্ড ব্যবহার করে বা ডেটা টাইপ নির্দিষ্ট করে তৈরি করা যেতে পারে। অবজেক্ট হল ডেটা স্ট্রাকচার যার তথ্য রয়েছে যা বাস্তব-বিশ্বের সত্তাকে প্রতিফলিত করে এবং ডার্টে ক্লাস ব্যবহার করে তৈরি করা যেতে পারে। ক্লাস অবজেক্ট তৈরির জন্য ব্লুপ্রিন্ট হিসাবে কাজ করে, বস্তুর মধ্যে ডেটা প্রতিনিধিত্বকারী বৈশিষ্ট্য সহ। ভিডিওটি ডট নোটেশন ব্যবহার করে অবজেক্ট তৈরি এবং তাদের বৈশিষ্ট্যগুলি অ্যাক্সেস করার প্রদর্শন করে। ক্লাসগুলি ডার্টের একটি মৌলিক বৈশিষ্ট্য এবং অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিংয়ে একটি মূল ভূমিকা পালন করে।",
                                // Arabic
                                "عَرَبِيّ": "يناقش الفيديو ميزتين مهمتين في البرمجة - المتغيرات والبرمجة الموجهة للكائنات في Dart. تُستخدم المتغيرات لتخزين البيانات في الذاكرة لاستخدامها لاحقًا، ويمكن إنشاؤها باستخدام الكلمة الأساسية var أو عن طريق تحديد نوع البيانات. الكائنات هي هياكل بيانات تحتوي على معلومات تعكس كيانات العالم الحقيقي، ويمكن إنشاؤها باستخدام الفئات في Dart. تعمل الفئات كمخططات لإنشاء الكائنات، مع خصائص تمثل البيانات داخل الكائن. يوضح الفيديو إنشاء الكائنات والوصول إلى خصائصها باستخدام تدوين النقاط. تعد الفئات ميزة أساسية في Dart وتلعب دورًا رئيسيًا في البرمجة الموجهة للكائنات.",
                                // Persian
                                "فارسی": "این ویدئو دو ویژگی مهم در برنامه نویسی را مورد بحث قرار می دهد - متغیرها و برنامه نویسی شی گرا در دارت. متغیرها برای ذخیره داده ها در حافظه برای استفاده بعدی استفاده می شوند و می توانند با استفاده از کلمه کلیدی var یا با تعیین نوع داده ایجاد شوند. اشیاء ساختارهای داده ای با اطلاعاتی هستند که موجودیت های دنیای واقعی را منعکس می کنند و می توانند با استفاده از کلاس های دارت ایجاد شوند. کلاس ها به عنوان طرح اولیه برای ایجاد اشیا عمل می کنند، با ویژگی هایی که داده ها را در داخل شی نشان می دهند. این ویدئو ایجاد اشیاء و دسترسی به خواص آنها را با استفاده از نماد نقطه نشان می دهد. کلاس ها یک ویژگی اساسی در دارت هستند و نقش کلیدی در برنامه نویسی شی گرا دارند.",
                            },
                        },
                        // 20 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Building an App From Scratch",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter explains the importance of widgets in Flutter and how every Flutter app is built using widgets. They demonstrate the process of creating a MyApp class that extends the StatelessWidget class provided by Flutter. The video covers the inheritance concept, importing classes from the Flutter framework using the import keyword, and implementing the build method within the class. The MaterialApp widget is used to set up the core widget for the app, with named arguments such as home being utilized to display a Text widget with the message 'Hello'. The video emphasizes the use of widgets as the UI building blocks in Flutter and highlights the role of classes and methods in creating functional components for the app.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Moderator die Bedeutung von Widgets in Flutter und wie jede Flutter-App mithilfe von Widgets erstellt wird. Er demonstriert den Prozess der Erstellung einer MyApp-Klasse, die die von Flutter bereitgestellte StatelessWidget-Klasse erweitert. Das Video behandelt das Vererbungskonzept, das Importieren von Klassen aus dem Flutter-Framework mithilfe des Schlüsselworts „import“ und das Implementieren der Build-Methode innerhalb der Klasse. Das MaterialApp-Widget wird verwendet, um das Kern-Widget für die App einzurichten, wobei benannte Argumente wie „home“ verwendet werden, um ein Text-Widget mit der Nachricht „Hallo“ anzuzeigen. Das Video betont die Verwendung von Widgets als UI-Bausteine ​​in Flutter und hebt die Rolle von Klassen und Methoden beim Erstellen funktionaler Komponenten für die App hervor.",
                                // Chinese
                                "中国人": "在本视频中，演示者解释了 Flutter 中小部件的重要性以及如何使用小部件构建每个 Flutter 应用。他们演示了创建 MyApp 类的过程，该类扩展了 Flutter 提供的 StatelessWidget 类。视频介绍了继承概念、使用 import 关键字从 Flutter 框架导入类以及在类中实现 build 方法。MaterialApp 小部件用于设置应用的核心小部件，并使用命名参数（例如 home）来显示带有消息“Hello”的 Text 小部件。视频强调了小部件作为 Flutter 中的 UI 构建块的使用，并强调了类和方法在为应用创建功能组件中的作用。",
                                // Russian
                                "Русский": "В этом видео докладчик объясняет важность виджетов во Flutter и то, как каждое приложение Flutter создается с помощью виджетов. Они демонстрируют процесс создания класса MyApp, который расширяет класс StatelessWidget, предоставляемый Flutter. Видео охватывает концепцию наследования, импорт классов из фреймворка Flutter с помощью ключевого слова import и реализацию метода сборки в классе. Виджет MaterialApp используется для настройки основного виджета для приложения, а именованные аргументы, такие как home, используются для отображения виджета Text с сообщением «Hello». Видео подчеркивает использование виджетов в качестве строительных блоков пользовательского интерфейса во Flutter и подчеркивает роль классов и методов в создании функциональных компонентов для приложения.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur explique l'importance des widgets dans Flutter et comment chaque application Flutter est construite à l'aide de widgets. Il montre le processus de création d'une classe MyApp qui étend la classe StatelessWidget fournie par Flutter. La vidéo couvre le concept d'héritage, l'importation de classes à partir du framework Flutter à l'aide du mot-clé import et l'implémentation de la méthode build dans la classe. Le widget MaterialApp est utilisé pour configurer le widget principal de l'application, avec des arguments nommés tels que home utilisés pour afficher un widget Texte avec le message « Bonjour ». La vidéo met l'accent sur l'utilisation des widgets comme éléments de base de l'interface utilisateur dans Flutter et met en évidence le rôle des classes et des méthodes dans la création de composants fonctionnels pour l'application.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが Flutter におけるウィジェットの重要性と、すべての Flutter アプリがウィジェットを使用して構築される仕組みについて説明しています。Flutter が提供する StatelessWidget クラスを拡張する MyApp クラスの作成プロセスを示します。ビデオでは、継承の概念、import キーワードを使用した Flutter フレームワークからのクラスのインポート、クラス内での build メソッドの実装について説明します。MaterialApp ウィジェットは、アプリのコア ウィジェットを設定するために使用され、home などの名前付き引数は、'Hello' というメッセージを含む Text ウィジェットを表示するために使用されています。ビデオでは、ウィジェットを Flutter の UI ビルディング ブロックとして使用することを強調し、アプリの機能コンポーネントを作成するクラスとメソッドの役割を強調しています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter에서 위젯의 중요성과 모든 Flutter 앱이 위젯을 사용하여 빌드되는 방식을 설명합니다. 그들은 Flutter에서 제공하는 StatelessWidget 클래스를 확장하는 MyApp 클래스를 만드는 과정을 보여줍니다. 이 영상은 상속 개념, import 키워드를 사용하여 Flutter 프레임워크에서 클래스 가져오기, 클래스 내에서 build 메서드 구현을 다룹니다. MaterialApp 위젯은 앱의 핵심 위젯을 설정하는 데 사용되며, home과 같은 명명된 인수를 사용하여 'Hello'라는 메시지가 있는 텍스트 위젯을 표시합니다. 이 영상은 Flutter에서 위젯을 UI 빌딩 블록으로 사용하는 것을 강조하고 앱의 기능적 구성 요소를 만드는 데 있어 클래스와 메서드의 역할을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el presentador explica la importancia de los widgets en Flutter y cómo cada aplicación de Flutter se crea utilizando widgets. Demuestra el proceso de creación de una clase MyApp que extiende la clase StatelessWidget proporcionada por Flutter. El video cubre el concepto de herencia, la importación de clases desde el marco de Flutter utilizando la palabra clave import y la implementación del método de compilación dentro de la clase. El widget MaterialApp se utiliza para configurar el widget principal para la aplicación, con argumentos nombrados como home que se utilizan para mostrar un widget de texto con el mensaje 'Hola'. El video enfatiza el uso de widgets como bloques de construcción de la interfaz de usuario en Flutter y destaca el papel de las clases y los métodos en la creación de componentes funcionales para la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर में विजेट के महत्व और फ़्लटर ऐप को विजेट का उपयोग करके कैसे बनाया जाता है, इस बारे में बताता है। वे MyApp क्लास बनाने की प्रक्रिया का प्रदर्शन करते हैं जो फ़्लटर द्वारा प्रदान किए गए StatelessWidget क्लास का विस्तार करता है। वीडियो में इनहेरिटेंस कॉन्सेप्ट, import कीवर्ड का उपयोग करके फ़्लटर फ़्रेमवर्क से क्लास आयात करना और क्लास के भीतर बिल्ड विधि को लागू करना शामिल है। मटेरियलऐप विजेट का उपयोग ऐप के लिए कोर विजेट सेट अप करने के लिए किया जाता है, जिसमें होम जैसे नामित तर्कों का उपयोग 'हैलो' संदेश के साथ टेक्स्ट विजेट प्रदर्शित करने के लिए किया जाता है। वीडियो फ़्लटर में UI बिल्डिंग ब्लॉक के रूप में विजेट के उपयोग पर ज़ोर देता है और ऐप के लिए कार्यात्मक घटक बनाने में कक्षाओं और विधियों की भूमिका पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador explica a importância dos widgets no Flutter e como cada aplicação Flutter é construída com recurso a widgets. Demonstram o processo de criação de uma classe MyApp que estende a classe StatelessWidget fornecida pelo Flutter. O vídeo aborda o conceito de herança, importando classes da estrutura Flutter utilizando a palavra-chave import e implementando o método build dentro da classe. O widget MaterialApp é utilizado para configurar o widget principal da aplicação, sendo utilizados argumentos nomeados como home para exibir um widget de texto com a mensagem ‘Olá’. O vídeo enfatiza a utilização de widgets como blocos de construção da UI no Flutter e destaca a função das classes e métodos na criação de componentes funcionais para a aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক ফ্লটারে উইজেটের গুরুত্ব ব্যাখ্যা করেছেন এবং কীভাবে প্রতিটি ফ্লাটার অ্যাপ উইজেট ব্যবহার করে তৈরি করা হয়। তারা একটি MyApp ক্লাস তৈরির প্রক্রিয়া প্রদর্শন করে যা Flutter দ্বারা প্রদত্ত স্টেটলেস উইজেট ক্লাসকে প্রসারিত করে। ভিডিওটিতে উত্তরাধিকার ধারণা, আমদানি কীওয়ার্ড ব্যবহার করে ফ্লটার ফ্রেমওয়ার্ক থেকে ক্লাস আমদানি করা এবং ক্লাসের মধ্যে বিল্ড পদ্ধতি প্রয়োগ করা রয়েছে। MaterialApp উইজেট অ্যাপটির মূল উইজেট সেট আপ করতে ব্যবহৃত হয়, নামযুক্ত আর্গুমেন্ট যেমন হোম ব্যবহার করা হয় 'হ্যালো' বার্তা সহ একটি টেক্সট উইজেট প্রদর্শন করতে। ভিডিওটি ফ্লটারে UI বিল্ডিং ব্লক হিসাবে উইজেটগুলির ব্যবহারের উপর জোর দেয় এবং অ্যাপের জন্য কার্যকরী উপাদান তৈরিতে ক্লাস এবং পদ্ধতির ভূমিকা হাইলাইট করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح مقدم العرض أهمية الأدوات في Flutter وكيف يتم بناء كل تطبيق Flutter باستخدام الأدوات. كما يوضح عملية إنشاء فئة MyApp التي تمتد إلى فئة StatelessWidget التي يوفرها Flutter. ويغطي الفيديو مفهوم الميراث، واستيراد الفئات من إطار عمل Flutter باستخدام كلمة import الأساسية، وتنفيذ طريقة البناء داخل الفئة. تُستخدم أداة MaterialApp لإعداد الأداة الأساسية للتطبيق، مع استخدام الوسائط المسماة مثل home لعرض أداة نصية مع الرسالة 'Hello'. ويؤكد الفيديو على استخدام الأدوات باعتبارها كتل بناء واجهة المستخدم في Flutter ويسلط الضوء على دور الفئات والطرق في إنشاء مكونات وظيفية للتطبيق.",
                                // Persian
                                "فارسی": "در این ویدیو، مجری اهمیت ویجت ها در فلاتر و نحوه ساخت هر اپلیکیشن فلاتر با استفاده از ویجت ها را توضیح می دهد. آنها روند ایجاد یک کلاس MyApp را نشان می دهند که کلاس StatelessWidget ارائه شده توسط Flutter را گسترش می دهد. این ویدیو مفهوم وراثت، وارد کردن کلاس ها از چارچوب Flutter با استفاده از کلمه کلیدی import و پیاده سازی متد ساخت در کلاس را پوشش می دهد. ویجت MaterialApp برای تنظیم ابزارک اصلی برای برنامه استفاده می شود، با آرگومان های نامگذاری شده مانند خانه برای نمایش یک ویجت متنی با پیام 'Hello' استفاده می شود. این ویدیو بر استفاده از ویجت ها به عنوان بلوک های سازنده رابط کاربری در Flutter تاکید می کند و نقش کلاس ها و روش ها را در ایجاد اجزای کاربردی برای برنامه برجسته می کند.",
                            },
                        },
                        // 21 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Running the App on an Emulator",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video explains the process of displaying content on the screen using Flutter by utilizing the runApp function from material.dart. It demonstrates how runApp takes a widget tree, creates widget objects, and calls the build method to render the application on the screen. The video emphasizes the importance of passing the core widget (MyApp) to runApp in order to initiate the app rendering process. By executing runApp with the MyApp widget, the video showcases how the basic 'hello' message can be displayed on the screen without the need to manage pixel rendering or app lifecycle. The demonstration concludes with the successful rendering of the basic application on an Android emulator, highlighting the functionality of creating widgets and running the app through runApp.",
                                // German
                                "Deutsch": "Dieses Video erklärt den Prozess der Anzeige von Inhalten auf dem Bildschirm mit Flutter unter Verwendung der Funktion runApp von material.dart. Es zeigt, wie runApp einen Widget-Baum nimmt, Widget-Objekte erstellt und die Build-Methode aufruft, um die Anwendung auf dem Bildschirm darzustellen. Das Video betont, wie wichtig es ist, das Kern-Widget (MyApp) an runApp zu übergeben, um den App-Rendering-Prozess zu starten. Durch die Ausführung von runApp mit dem MyApp-Widget zeigt das Video, wie die grundlegende „Hallo“-Nachricht auf dem Bildschirm angezeigt werden kann, ohne dass Pixel-Rendering oder App-Lebenszyklus verwaltet werden müssen. Die Demonstration endet mit dem erfolgreichen Rendering der Basisanwendung auf einem Android-Emulator und hebt die Funktionalität der Widget-Erstellung und des Ausführens der App über runApp hervor.",
                                // Chinese
                                "中国人": "该视频解释了如何使用 Flutter 利用material.dart 中的 runApp 函数在屏幕上显示内容。它演示了 runApp 如何获取 widget 树、创建 widget 对象以及调用 build 方法在屏幕上呈现应用程序。该视频强调了将核心 widget (MyApp) 传递给 runApp 以启动应用程序渲染过程的重要性。通过使用 MyApp widget 执行 runApp，该视频展示了如何在屏幕上显示基本的“hello”消息，而无需管理像素渲染或应用程序生命周期。演示以在 Android 模拟器上成功渲染基本应用程序结束，突出了创建 widget 和通过 runApp 运行应用程序的功能。",
                                // Russian
                                "Русский": "В этом видео объясняется процесс отображения контента на экране с помощью Flutter с использованием функции runApp из material.dart. Демонстрируется, как runApp берет дерево виджетов, создает объекты виджетов и вызывает метод сборки для визуализации приложения на экране. В видео подчеркивается важность передачи основного виджета (MyApp) в runApp для инициирования процесса визуализации приложения. Выполняя runApp с виджетом MyApp, в видео демонстрируется, как базовое сообщение «hello» может быть отображено на экране без необходимости управления пиксельным рендерингом или жизненным циклом приложения. Демонстрация завершается успешным рендерингом базового приложения на эмуляторе Android, подчеркивая функциональность создания виджетов и запуска приложения через runApp.",
                                // French
                                "Français": "Cette vidéo explique le processus d'affichage de contenu à l'écran à l'aide de Flutter en utilisant la fonction runApp de material.dart. Elle montre comment runApp prend une arborescence de widgets, crée des objets widget et appelle la méthode build pour restituer l'application à l'écran. La vidéo souligne l'importance de transmettre le widget principal (MyApp) à runApp afin de lancer le processus de rendu de l'application. En exécutant runApp avec le widget MyApp, la vidéo montre comment le message « hello » de base peut être affiché à l'écran sans avoir à gérer le rendu des pixels ou le cycle de vie de l'application. La démonstration se termine par le rendu réussi de l'application de base sur un émulateur Android, mettant en évidence la fonctionnalité de création de widgets et d'exécution de l'application via runApp.",
                                // Japanese
                                "日本語": "このビデオでは、material.dart の runApp 関数を利用して、Flutter で画面にコンテンツを表示するプロセスについて説明します。runApp がウィジェット ツリーを取得し、ウィジェット オブジェクトを作成し、ビルド メソッドを呼び出してアプリケーションを画面にレンダリングする方法を示します。ビデオでは、アプリのレンダリング プロセスを開始するために、コア ウィジェット (MyApp) を runApp に渡すことの重要性を強調しています。MyApp ウィジェットを使用して runApp を実行することで、ピクセル レンダリングやアプリのライフサイクルを管理することなく、基本的な「hello」メッセージを画面に表示する方法を示します。デモは、Android エミュレーターで基本的なアプリケーションが正常にレンダリングされて終了し、ウィジェットを作成し、runApp を介してアプリを実行する機能を強調しています。",
                                // Korean
                                "한국인": "이 비디오는 material.dart의 runApp 함수를 활용하여 Flutter를 사용하여 화면에 콘텐츠를 표시하는 프로세스를 설명합니다. runApp이 위젯 트리를 가져오고, 위젯 객체를 만들고, build 메서드를 호출하여 화면에 애플리케이션을 렌더링하는 방법을 보여줍니다. 이 비디오는 앱 렌더링 프로세스를 시작하기 위해 핵심 위젯(MyApp)을 runApp에 전달하는 것의 중요성을 강조합니다. MyApp 위젯으로 runApp을 실행하여 픽셀 렌더링이나 앱 라이프사이클을 관리할 필요 없이 기본적인 'hello' 메시지를 화면에 표시하는 방법을 보여줍니다. 이 데모는 Android 에뮬레이터에서 기본 애플리케이션을 성공적으로 렌더링하는 것으로 마무리되며, 위젯을 만들고 runApp을 통해 앱을 실행하는 기능을 강조합니다.",
                                // Spanish
                                "Español": "Este video explica el proceso de visualización de contenido en la pantalla usando Flutter utilizando la función runApp de material.dart. Demuestra cómo runApp toma un árbol de widgets, crea objetos de widgets y llama al método de compilación para renderizar la aplicación en la pantalla. El video enfatiza la importancia de pasar el widget principal (MyApp) a runApp para iniciar el proceso de renderización de la aplicación. Al ejecutar runApp con el widget MyApp, el video muestra cómo se puede mostrar el mensaje básico 'hello' en la pantalla sin la necesidad de administrar la renderización de píxeles o el ciclo de vida de la aplicación. La demostración concluye con la renderización exitosa de la aplicación básica en un emulador de Android, destacando la funcionalidad de crear widgets y ejecutar la aplicación a través de runApp.",
                                // Hindi
                                "हिंदी": "यह वीडियो मटेरियल.डार्ट से runApp फ़ंक्शन का उपयोग करके फ़्लटर का उपयोग करके स्क्रीन पर सामग्री प्रदर्शित करने की प्रक्रिया को समझाता है। यह दर्शाता है कि कैसे runApp एक विजेट ट्री लेता है, विजेट ऑब्जेक्ट बनाता है, और स्क्रीन पर एप्लिकेशन को रेंडर करने के लिए बिल्ड विधि को कॉल करता है। वीडियो ऐप रेंडरिंग प्रक्रिया शुरू करने के लिए रनऐप को कोर विजेट (MyApp) पास करने के महत्व पर जोर देता है। MyApp विजेट के साथ runApp को निष्पादित करके, वीडियो दिखाता है कि पिक्सेल रेंडरिंग या ऐप लाइफ़साइकिल को प्रबंधित करने की आवश्यकता के बिना स्क्रीन पर मूल 'हैलो' संदेश कैसे प्रदर्शित किया जा सकता है। प्रदर्शन एंड्रॉइड एमुलेटर पर मूल एप्लिकेशन के सफल रेंडरिंग के साथ समाप्त होता है, जिसमें विजेट बनाने और runApp के माध्यम से ऐप चलाने की कार्यक्षमता पर प्रकाश डाला गया है।",
                                // Portuguese
                                "Português": "Este vídeo explica o processo de exibição de conteúdo no ecrã utilizando o Flutter, utilizando a função runApp do material.dart. Demonstra como o runApp recebe uma árvore de widgets, cria objetos de widget e chama o método build para renderizar a aplicação no ecrã. O vídeo enfatiza a importância de passar o widget principal (MyApp) para runApp para iniciar o processo de renderização da aplicação. Ao executar o runApp com o widget MyApp, o vídeo mostra como a mensagem básica de “olá” pode ser apresentada no ecrã sem a necessidade de gerir a renderização de pixéis ou o ciclo de vida da aplicação. A demonstração termina com a renderização bem-sucedida da aplicação básica num emulador Android, destacando a funcionalidade de criação de widgets e execução da aplicação através do runApp.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি material.dart থেকে runApp ফাংশন ব্যবহার করে Flutter ব্যবহার করে স্ক্রিনে বিষয়বস্তু প্রদর্শনের প্রক্রিয়া ব্যাখ্যা করে। এটি দেখায় কিভাবে রানঅ্যাপ একটি উইজেট ট্রি নেয়, উইজেট অবজেক্ট তৈরি করে এবং স্ক্রিনে অ্যাপ্লিকেশন রেন্ডার করার জন্য বিল্ড পদ্ধতিতে কল করে। ভিডিওটি অ্যাপ রেন্ডারিং প্রক্রিয়া শুরু করার জন্য রানঅ্যাপে মূল উইজেট (MyApp) পাস করার গুরুত্বের উপর জোর দেয়। MyApp উইজেট দিয়ে রানঅ্যাপ চালানোর মাধ্যমে, ভিডিওটি দেখায় কিভাবে পিক্সেল রেন্ডারিং বা অ্যাপ লাইফসাইকেল পরিচালনা করার প্রয়োজন ছাড়াই স্ক্রীনে মৌলিক 'হ্যালো' বার্তা প্রদর্শিত হতে পারে। একটি অ্যান্ড্রয়েড এমুলেটরে মৌলিক অ্যাপ্লিকেশনটির সফল রেন্ডারিংয়ের মাধ্যমে প্রদর্শনীটি শেষ হয়, উইজেট তৈরির কার্যকারিতা এবং রানঅ্যাপের মাধ্যমে অ্যাপটি চালানোর বৈশিষ্ট্য তুলে ধরে।",
                                // Arabic
                                "عَرَبِيّ": "يوضح هذا الفيديو عملية عرض المحتوى على الشاشة باستخدام Flutter من خلال الاستفادة من وظيفة runApp من material.dart. ويوضح كيف يأخذ runApp شجرة عناصر واجهة المستخدم وينشئ كائنات عناصر واجهة المستخدم ويستدعي طريقة البناء لعرض التطبيق على الشاشة. ويؤكد الفيديو على أهمية تمرير عنصر واجهة المستخدم الأساسي (MyApp) إلى runApp لبدء عملية عرض التطبيق. ومن خلال تنفيذ runApp باستخدام عنصر واجهة المستخدم MyApp، يوضح الفيديو كيف يمكن عرض رسالة 'hello' الأساسية على الشاشة دون الحاجة إلى إدارة عرض البكسل أو دورة حياة التطبيق. ويختتم العرض التوضيحي بعرض ناجح للتطبيق الأساسي على محاكي Android، مع تسليط الضوء على وظيفة إنشاء عناصر واجهة المستخدم وتشغيل التطبيق من خلال runApp.",
                                // Persian
                                "فارسی": "این ویدئو روند نمایش محتوا روی صفحه با استفاده از Flutter را با استفاده از تابع runApp از material.dart توضیح می دهد. نشان می‌دهد که چگونه runApp یک درخت ویجت را می‌گیرد، اشیاء ویجت را ایجاد می‌کند، و متد ساخت را فراخوانی می‌کند تا برنامه را روی صفحه نمایش دهد. این ویدئو بر اهمیت ارسال ویجت اصلی (MyApp) به runApp به منظور شروع فرآیند رندر برنامه تاکید می کند. با اجرای runApp با ویجت MyApp، این ویدئو نشان می‌دهد که چگونه پیام اصلی 'سلام' بدون نیاز به مدیریت رندر پیکسل یا چرخه عمر برنامه روی صفحه نمایش داده می‌شود. این نمایش با رندر موفقیت آمیز برنامه اصلی در شبیه ساز اندروید به پایان می رسد و عملکرد ایجاد ویجت ها و اجرای برنامه از طریق runApp را برجسته می کند.",
                            },
                        },
                        // 22 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Class Constructors & Named Arguments",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video explains the concept of constructors and named arguments in Dart by using examples of a person class and the text widget in Flutter. The presenter demonstrates how constructors define default values for class properties and how named arguments can be used to assign values by name rather than position. The video emphasizes the convenience and flexibility of using named arguments, especially for functions with multiple parameters, as they make it easier to assign values and mix the order of arguments. The video also touches on the @required annotation to enforce the provision of values for named arguments, as well as showcasing a shortcut in Dart where constructors can be simplified by directly assigning values to class properties without defining a constructor body.",
                                // German
                                "Deutsch": "Dieses Video erklärt das Konzept von Konstruktoren und benannten Argumenten in Dart anhand von Beispielen einer Personenklasse und des Text-Widgets in Flutter. Der Moderator demonstriert, wie Konstruktoren Standardwerte für Klasseneigenschaften definieren und wie benannte Argumente verwendet werden können, um Werte nach Namen statt nach Position zuzuweisen. Das Video betont die Bequemlichkeit und Flexibilität der Verwendung benannter Argumente, insbesondere für Funktionen mit mehreren Parametern, da sie die Zuweisung von Werten und das Mischen der Reihenfolge der Argumente erleichtern. Das Video geht auch auf die @required-Annotation ein, um die Bereitstellung von Werten für benannte Argumente zu erzwingen, und zeigt eine Abkürzung in Dart, bei der Konstruktoren vereinfacht werden können, indem Klasseneigenschaften direkt Werte zugewiesen werden, ohne einen Konstruktorkörper zu definieren.",
                                // Chinese
                                "中国人": "本视频使用 Flutter 中的 person 类和文本小部件作为示例，解释了 Dart 中构造函数和命名参数的概念。演示者演示了构造函数如何为类属性定义默认值，以及如何使用命名参数按名称而不是位置分配值。该视频强调了使用命名参数的便利性和灵活性，尤其是对于具有多个参数的函数，因为它们可以更轻松地分配值和混合参数的顺序。该视频还涉及 @required 注释以强制提供命名参数的值，并展示了 Dart 中的一种快捷方式，其中可以通过直接将值分配给类属性而无需定义构造函数主体来简化构造函数。",
                                // Russian
                                "Русский": "В этом видео объясняется концепция конструкторов и именованных аргументов в Dart на примере класса person и текстового виджета Flutter. Докладчик демонстрирует, как конструкторы определяют значения по умолчанию для свойств класса и как именованные аргументы могут использоваться для назначения значений по имени, а не по положению. В видео подчеркивается удобство и гибкость использования именованных аргументов, особенно для функций с несколькими параметрами, поскольку они упрощают назначение значений и смешивание порядка аргументов. В видео также затрагивается аннотация @required для принудительного предоставления значений для именованных аргументов, а также демонстрируется сокращение в Dart, где конструкторы можно упростить, напрямую назначая значения свойствам класса без определения тела конструктора.",
                                // French
                                "Français": "Cette vidéo explique le concept de constructeurs et d'arguments nommés dans Dart en utilisant des exemples d'une classe de personne et du widget de texte dans Flutter. Le présentateur montre comment les constructeurs définissent les valeurs par défaut des propriétés de classe et comment les arguments nommés peuvent être utilisés pour attribuer des valeurs par nom plutôt que par position. La vidéo met l'accent sur la commodité et la flexibilité de l'utilisation d'arguments nommés, en particulier pour les fonctions avec plusieurs paramètres, car ils facilitent l'attribution de valeurs et le mélange de l'ordre des arguments. La vidéo aborde également l'annotation @required pour imposer la fourniture de valeurs pour les arguments nommés, ainsi que la présentation d'un raccourci dans Dart où les constructeurs peuvent être simplifiés en attribuant directement des valeurs aux propriétés de classe sans définir de corps de constructeur.",
                                // Japanese
                                "日本語": "このビデオでは、Dart のコンストラクタと名前付き引数の概念について、人物クラスと Flutter のテキスト ウィジェットの例を使用して説明します。プレゼンターは、コンストラクタがクラス プロパティのデフォルト値を定義する方法と、名前付き引数を使用して位置ではなく名前で値を割り当てる方法を示します。このビデオでは、特に複数のパラメータを持つ関数で名前付き引数を使用すると値の割り当てや引数の順序の混在が容易になるため、名前付き引数を使用することの利便性と柔軟性を強調しています。また、このビデオでは、名前付き引数に値を提供することを強制する @required アノテーションについても触れ、コンストラクタ本体を定義せずにクラス プロパティに直接値を割り当てることでコンストラクタを簡素化できる Dart のショートカットを紹介します。",
                                // Korean
                                "한국인": "이 비디오는 Flutter의 person 클래스와 텍스트 위젯의 예를 사용하여 Dart의 생성자와 명명된 인수의 개념을 설명합니다. 발표자는 생성자가 클래스 속성에 대한 기본값을 정의하는 방법과 명명된 인수를 사용하여 위치가 아닌 이름으로 값을 할당하는 방법을 보여줍니다. 이 비디오는 특히 여러 매개변수가 있는 함수의 경우 명명된 인수를 사용하는 편의성과 유연성을 강조합니다. 명명된 인수를 사용하면 값을 할당하고 인수 순서를 혼합하기가 더 쉬워지기 때문입니다. 이 비디오는 또한 명명된 인수에 대한 값 제공을 강제하는 @required 주석에 대해 다루고 생성자 본문을 정의하지 않고 클래스 속성에 직접 값을 할당하여 생성자를 간소화할 수 있는 Dart의 단축키를 보여줍니다.",
                                // Spanish
                                "Español": "Este video explica el concepto de constructores y argumentos nombrados en Dart mediante el uso de ejemplos de una clase de persona y el widget de texto en Flutter. El presentador demuestra cómo los constructores definen valores predeterminados para las propiedades de clase y cómo se pueden usar argumentos nombrados para asignar valores por nombre en lugar de por posición. El video enfatiza la conveniencia y flexibilidad de usar argumentos nombrados, especialmente para funciones con múltiples parámetros, ya que facilitan la asignación de valores y la combinación del orden de los argumentos. El video también aborda la anotación @required para hacer cumplir la provisión de valores para argumentos nombrados, además de mostrar un atajo en Dart donde los constructores se pueden simplificar asignando valores directamente a las propiedades de clase sin definir un cuerpo de constructor.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर में एक व्यक्ति वर्ग और टेक्स्ट विजेट के उदाहरणों का उपयोग करके डार्ट में कंस्ट्रक्टर और नामित तर्कों की अवधारणा को समझाता है। प्रस्तुतकर्ता प्रदर्शित करता है कि कंस्ट्रक्टर वर्ग गुणों के लिए डिफ़ॉल्ट मान कैसे परिभाषित करते हैं और नामित तर्कों का उपयोग स्थिति के बजाय नाम से मान निर्दिष्ट करने के लिए कैसे किया जा सकता है। वीडियो नामित तर्कों का उपयोग करने की सुविधा और लचीलेपन पर जोर देता है, विशेष रूप से कई मापदंडों वाले फ़ंक्शन के लिए, क्योंकि वे मान निर्दिष्ट करना और तर्कों के क्रम को मिलाना आसान बनाते हैं। वीडियो नामित तर्कों के लिए मानों के प्रावधान को लागू करने के लिए @required एनोटेशन को भी छूता है, साथ ही डार्ट में एक शॉर्टकट भी दिखाता है जहाँ कंस्ट्रक्टर को कंस्ट्रक्टर बॉडी को परिभाषित किए बिना सीधे वर्ग गुणों को मान निर्दिष्ट करके सरल बनाया जा सकता है।",
                                // Portuguese
                                "Português": "Este vídeo explica o conceito de construtores e argumentos nomeados no Dart utilizando exemplos de uma classe de pessoa e o widget de texto no Flutter. O apresentador demonstra como os construtores definem valores padrão para as propriedades da classe e como os argumentos nomeados podem ser utilizados para atribuir valores por nome em vez de posição. O vídeo enfatiza a conveniência e flexibilidade da utilização de argumentos nomeados, especialmente para funções com múltiplos parâmetros, uma vez que facilitam a atribuição de valores e a mistura da ordem dos argumentos. O vídeo também aborda a anotação @required para impor o fornecimento de valores para argumentos nomeados, além de mostrar um atalho no Dart onde os construtores podem ser simplificados atribuindo valores diretamente às propriedades da classe sem definir um corpo de construtor.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি একজন ব্যক্তি শ্রেণীর উদাহরণ এবং ফ্লাটারে পাঠ্য উইজেট ব্যবহার করে ডার্ট-এ কনস্ট্রাক্টর এবং নামযুক্ত আর্গুমেন্টের ধারণা ব্যাখ্যা করে। উপস্থাপক প্রদর্শন করে যে কীভাবে কনস্ট্রাক্টররা ক্লাসের বৈশিষ্ট্যগুলির জন্য ডিফল্ট মানগুলি সংজ্ঞায়িত করে এবং কীভাবে নামযুক্ত আর্গুমেন্টগুলি অবস্থানের পরিবর্তে নামের দ্বারা মান নির্ধারণ করতে ব্যবহার করা যেতে পারে। ভিডিওটি নামযুক্ত আর্গুমেন্টগুলি ব্যবহার করার সুবিধা এবং নমনীয়তার উপর জোর দেয়, বিশেষ করে একাধিক প্যারামিটার সহ ফাংশনের জন্য, কারণ তারা মান নির্ধারণ করা এবং আর্গুমেন্টের ক্রম মিশ্রিত করা সহজ করে তোলে। ভিডিওটি নামযুক্ত আর্গুমেন্টের জন্য মানগুলির বিধান কার্যকর করার জন্য @প্রয়োজনীয় টীকাটিকেও স্পর্শ করে, সেইসাথে ডার্ট-এ একটি শর্টকাট প্রদর্শন করে যেখানে কনস্ট্রাক্টর বডি সংজ্ঞায়িত না করেই সরাসরি শ্রেণি বৈশিষ্ট্যগুলিতে মান নির্ধারণ করে কনস্ট্রাক্টরদের সরলীকরণ করা যেতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "يوضح هذا الفيديو مفهوم المنشئين والحجج المسماة في Dart باستخدام أمثلة لفئة الشخص وأداة النص في Flutter. يوضح مقدم العرض كيف تحدد المنشئين القيم الافتراضية لخصائص الفئة وكيف يمكن استخدام الحجج المسماة لتعيين القيم حسب الاسم وليس الموضع. ويؤكد الفيديو على الراحة والمرونة في استخدام الحجج المسماة، وخاصة للوظائف ذات المعلمات المتعددة، حيث إنها تسهل تعيين القيم وخلط ترتيب الحجج. ويتطرق الفيديو أيضًا إلى الشرح التوضيحي @required لفرض توفير القيم للحجج المسماة، بالإضافة إلى عرض اختصار في Dart حيث يمكن تبسيط المنشئين عن طريق تعيين القيم مباشرة لخصائص الفئة دون تحديد نص المنشئ.",
                                // Persian
                                "فارسی": "این ویدئو مفهوم سازنده و آرگومان های نامگذاری شده در دارت را با استفاده از مثال هایی از یک کلاس person و ویجت متن در Flutter توضیح می دهد. ارائه‌دهنده نشان می‌دهد که سازنده‌ها چگونه مقادیر پیش‌فرض را برای خصوصیات کلاس تعریف می‌کنند و چگونه می‌توان از آرگومان‌های نام‌گذاری‌شده برای تخصیص مقادیر با نام به جای موقعیت استفاده کرد. این ویدیو بر راحتی و انعطاف پذیری استفاده از آرگومان های نامگذاری شده، به ویژه برای توابع با پارامترهای متعدد تأکید می کند، زیرا آنها تخصیص مقادیر و ترکیب ترتیب آرگومان ها را آسان تر می کنند. این ویدئو همچنین روی حاشیه‌نویسی @required برای اعمال مقادیر برای آرگومان‌های نام‌گذاری شده و همچنین نمایش میانبری در دارت که سازنده‌ها را می‌توان با اختصاص مستقیم مقادیر به ویژگی‌های کلاس بدون تعریف بدنه سازنده، ساده کرد.",
                            },
                        },
                        // 23 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "First Summary & Additional Syntax",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explains the fundamental concepts of building a Flutter application using widgets and the Dart language. The presenter emphasizes the importance of the main function in the main.dart file, which triggers the runApp function provided by the Flutter team from the material.dart package. The video delves into the significance of extending stateless widget or stateful widget for creating widgets, which require the implementation of a build method to render content on the screen. Named arguments are highlighted as a method for assigning values to widget parameters, with the demonstration showcasing the instantiation of classes by adding parentheses. The @Override decorator is introduced as a stylistic practice to indicate deliberate method overriding, and the shorthand syntax for functions with one expression is explained, offering a concise way to execute code. The video concludes with a focus on creating more aesthetically pleasing applications by leveraging these core principles in Flutter development.",
                                // German
                                "Deutsch": "Das Video erklärt die grundlegenden Konzepte zum Erstellen einer Flutter-Anwendung mit Widgets und der Sprache Dart. Der Moderator betont die Bedeutung der Hauptfunktion in der Datei main.dart, die die vom Flutter-Team aus dem Paket material.dart bereitgestellte Funktion runApp auslöst. Das Video befasst sich mit der Bedeutung der Erweiterung von Stateless-Widgets oder Stateful-Widgets zum Erstellen von Widgets, die die Implementierung einer Build-Methode zum Rendern von Inhalten auf dem Bildschirm erfordern. Benannte Argumente werden als Methode zum Zuweisen von Werten zu Widget-Parametern hervorgehoben, wobei die Demonstration die Instanziierung von Klassen durch Hinzufügen von Klammern zeigt. Der @Override-Dekorator wird als stilistische Praxis eingeführt, um absichtliches Überschreiben von Methoden anzuzeigen, und die Kurzsyntax für Funktionen mit einem Ausdruck wird erklärt, was eine prägnante Möglichkeit zum Ausführen von Code bietet. Das Video endet mit einem Fokus auf das Erstellen ästhetisch ansprechenderer Anwendungen durch Nutzung dieser Kernprinzipien der Flutter-Entwicklung.",
                                // Chinese
                                "中国人": "视频解释了使用 widget 和 Dart 语言构建 Flutter 应用程序的基本概念。演示者强调了 main.dart 文件中 main 函数的重要性，该函数触发 Flutter 团队从material.dart 包中提供的 runApp 函数。视频深入探讨了扩展无状态 widget 或有状态 widget 对于创建 widget 的重要性，这需要实现 build 方法才能在屏幕上呈现内容。命名参数被突出显示为向 widget 参数分配值的方法，演示通过添加括号展示了类的实例化。@Override 装饰器被引入作为一种风格实践来表示刻意的方法覆盖，并解释了具有一个表达式的函数的简写语法，提供了一种简洁的代码执行方式。视频最后重点介绍了如何在 Flutter 开发中利用这些核心原则来创建更美观的应用程序。",
                                // Russian
                                "Русский": "В видео объясняются основные концепции создания приложения Flutter с использованием виджетов и языка Dart. Докладчик подчеркивает важность функции main в файле main.dart, которая запускает функцию runApp, предоставленную командой Flutter из пакета material.dart. В видео подробно рассматривается важность расширения виджета без сохранения состояния или виджета с сохранением состояния для создания виджетов, которым требуется реализация метода сборки для отображения контента на экране. Именованные аргументы выделены как метод назначения значений параметрам виджета, а демонстрация демонстрирует создание экземпляров классов путем добавления скобок. Декоратор @Override представлен как стилистическая практика для указания преднамеренного переопределения метода, а также объясняется сокращенный синтаксис для функций с одним выражением, предлагающий краткий способ выполнения кода. Видео завершается акцентом на создании более эстетически привлекательных приложений с использованием этих основных принципов в разработке Flutter.",
                                // French
                                "Français": "La vidéo explique les concepts fondamentaux de la création d'une application Flutter à l'aide de widgets et du langage Dart. Le présentateur souligne l'importance de la fonction main dans le fichier main.dart, qui déclenche la fonction runApp fournie par l'équipe Flutter à partir du package material.dart. La vidéo se penche sur l'importance de l'extension d'un widget sans état ou d'un widget avec état pour la création de widgets, qui nécessitent l'implémentation d'une méthode de construction pour afficher le contenu à l'écran. Les arguments nommés sont mis en évidence comme une méthode d'attribution de valeurs aux paramètres des widgets, la démonstration présentant l'instanciation de classes en ajoutant des parenthèses. Le décorateur @Override est présenté comme une pratique stylistique pour indiquer le remplacement délibéré d'une méthode, et la syntaxe abrégée des fonctions avec une expression est expliquée, offrant une manière concise d'exécuter du code. La vidéo se termine par une attention particulière portée à la création d'applications plus esthétiques en tirant parti de ces principes fondamentaux du développement Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、ウィジェットと Dart 言語を使用して Flutter アプリケーションを構築する基本的な概念について説明します。プレゼンターは、main.dart ファイルの main 関数の重要性を強調しています。この関数は、material.dart パッケージから Flutter チームによって提供される runApp 関数をトリガーします。ビデオでは、画面にコンテンツをレンダリングするためのビルド メソッドの実装を必要とするウィジェットを作成するために、ステートレス ウィジェットまたはステートフル ウィジェットを拡張することの重要性について詳しく説明します。名前付き引数は、ウィジェット パラメーターに値を割り当てる方法として強調され、デモでは括弧を追加してクラスをインスタンス化する方法が紹介されています。意図的なメソッドのオーバーライドを示すスタイル上の慣例として @Override デコレータが導入され、1 つの式を持つ関数の省略構文が説明され、簡潔なコード実行方法が提供されます。ビデオの最後では、Flutter 開発のこれらの基本原則を活用して、より見た目に美しいアプリケーションを作成することに焦点を当てています。",
                                // Korean
                                "한국인": "이 비디오에서는 위젯과 Dart 언어를 사용하여 Flutter 애플리케이션을 빌드하는 기본 개념을 설명합니다. 발표자는 Flutter 팀이 material.dart 패키지에서 제공하는 runApp 함수를 트리거하는 main.dart 파일의 main 함수의 중요성을 강조합니다. 이 비디오에서는 화면에 콘텐츠를 렌더링하기 위해 빌드 메서드를 구현해야 하는 위젯을 만들기 위해 상태 없는 위젯 또는 상태 있는 위젯을 확장하는 것의 중요성을 깊이 있게 다룹니다. 명명된 인수는 위젯 매개변수에 값을 할당하는 메서드로 강조 표시되며, 데모에서는 괄호를 추가하여 클래스를 인스턴스화하는 방법을 보여줍니다. @Override 데코레이터는 의도적인 메서드 오버라이딩을 나타내는 스타일적 관행으로 소개되고, 한 표현식을 사용하는 함수의 단축 구문을 설명하여 코드를 실행하는 간결한 방법을 제공합니다. 이 비디오는 Flutter 개발에서 이러한 핵심 원칙을 활용하여 더욱 미적으로 만족스러운 애플리케이션을 만드는 데 중점을 두고 마무리됩니다.",
                                // Spanish
                                "Español": "El video explica los conceptos fundamentales de la creación de una aplicación Flutter utilizando widgets y el lenguaje Dart. El presentador enfatiza la importancia de la función principal en el archivo main.dart, que activa la función runApp proporcionada por el equipo de Flutter desde el paquete material.dart. El video profundiza en la importancia de extender un widget sin estado o un widget con estado para crear widgets, que requieren la implementación de un método de creación para representar el contenido en la pantalla. Los argumentos nombrados se destacan como un método para asignar valores a los parámetros del widget, y la demostración muestra la instanciación de clases agregando paréntesis. El decorador @Override se presenta como una práctica estilística para indicar la anulación deliberada de un método, y se explica la sintaxis abreviada para funciones con una expresión, lo que ofrece una forma concisa de ejecutar código. El video concluye con un enfoque en la creación de aplicaciones estéticamente más agradables aprovechando estos principios básicos en el desarrollo de Flutter.",
                                // Hindi
                                "हिंदी": "वीडियो विजेट और डार्ट भाषा का उपयोग करके फ़्लटर एप्लिकेशन बनाने की मूलभूत अवधारणाओं को समझाता है। प्रस्तुतकर्ता main.dart फ़ाइल में मुख्य फ़ंक्शन के महत्व पर ज़ोर देता है, जो फ़्लटर टीम द्वारा material.dart पैकेज से प्रदान किए गए runApp फ़ंक्शन को ट्रिगर करता है। वीडियो विजेट बनाने के लिए स्टेटलेस विजेट या स्टेटफुल विजेट को विस्तारित करने के महत्व पर गहराई से चर्चा करता है, जिसके लिए स्क्रीन पर सामग्री प्रस्तुत करने के लिए बिल्ड विधि के कार्यान्वयन की आवश्यकता होती है। नामित तर्कों को विजेट मापदंडों को मान निर्दिष्ट करने की विधि के रूप में हाइलाइट किया गया है, जिसमें कोष्ठक जोड़कर कक्षाओं के इंस्टेंटिएशन को प्रदर्शित किया गया है। @Override डेकोरेटर को जानबूझकर विधि ओवरराइडिंग को इंगित करने के लिए एक शैलीगत अभ्यास के रूप में पेश किया गया है, और एक अभिव्यक्ति वाले फ़ंक्शन के लिए शॉर्टहैंड सिंटैक्स को समझाया गया है, जो कोड निष्पादित करने का एक संक्षिप्त तरीका प्रदान करता है। वीडियो फ़्लटर विकास में इन मूल सिद्धांतों का लाभ उठाकर अधिक सौंदर्यपूर्ण रूप से मनभावन एप्लिकेशन बनाने पर ध्यान केंद्रित करने के साथ समाप्त होता है।",
                                // Portuguese
                                "Português": "O vídeo explica os conceitos fundamentais de construção de uma aplicação Flutter utilizando widgets e a linguagem Dart. O apresentador realça a importância da função main no ficheiro main.dart, que despoleta a função runApp fornecida pela equipa Flutter do pacote material.dart. O vídeo investiga a importância de estender widgets sem estado ou widgets com estado para a criação de widgets, que exigem a implementação de um método de construção para renderizar conteúdo no ecrã. Os argumentos nomeados são destacados como um método para atribuir valores aos parâmetros do widget, com a demonstração a mostrar a instanciação de classes adicionando parênteses. O decorador @Override é apresentado como uma prática estilística para indicar a substituição deliberada de métodos, e a sintaxe abreviada para funções com uma expressão é explicada, oferecendo uma forma concisa de executar código. O vídeo termina com o foco na criação de aplicações esteticamente mais agradáveis, aproveitando estes princípios básicos no desenvolvimento do Flutter.",
                                // Bengali
                                "বাংলা": "ভিডিওটি উইজেট এবং ডার্ট ভাষা ব্যবহার করে একটি ফ্লাটার অ্যাপ্লিকেশন তৈরির মৌলিক ধারণাগুলি ব্যাখ্যা করে৷ উপস্থাপক main.dart ফাইলে প্রধান ফাংশনের গুরুত্বের উপর জোর দেন, যা material.dart প্যাকেজ থেকে Flutter টিম দ্বারা প্রদত্ত runApp ফাংশনকে ট্রিগার করে। ভিডিওটি উইজেট তৈরির জন্য স্টেটলেস উইজেট বা স্টেটফুল উইজেট সম্প্রসারিত করার তাত্পর্য নিয়ে আলোচনা করে, যার জন্য স্ক্রিনে বিষয়বস্তু রেন্ডার করার জন্য একটি বিল্ড পদ্ধতি প্রয়োগ করা প্রয়োজন। নামযুক্ত আর্গুমেন্টগুলিকে উইজেট প্যারামিটারে মান নির্ধারণের পদ্ধতি হিসাবে হাইলাইট করা হয়েছে, প্রদর্শনীটি বন্ধনী যুক্ত করে ক্লাসের ইনস্ট্যান্টিয়েশন প্রদর্শন করে। @ওভাররাইড ডেকোরেটরটি ইচ্ছাকৃত পদ্ধতি ওভাররাইডিং নির্দেশ করার জন্য একটি স্টাইলিস্টিক অনুশীলন হিসাবে চালু করা হয়েছে, এবং একটি অভিব্যক্তি সহ ফাংশনের জন্য সংক্ষিপ্ত বাক্য গঠন ব্যাখ্যা করা হয়েছে, কোড চালানোর একটি সংক্ষিপ্ত উপায় প্রস্তাব করে। ফ্লটার ডেভেলপমেন্টে এই মূল নীতিগুলিকে কাজে লাগিয়ে আরও নান্দনিকভাবে আনন্দদায়ক অ্যাপ্লিকেশন তৈরি করার উপর ফোকাস দিয়ে ভিডিওটি শেষ হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "يشرح الفيديو المفاهيم الأساسية لبناء تطبيق Flutter باستخدام عناصر واجهة المستخدم ولغة Dart. ويؤكد مقدم العرض على أهمية الوظيفة الرئيسية في ملف main.dart، والتي تقوم بتشغيل وظيفة runApp التي يوفرها فريق Flutter من حزمة material.dart. ويتعمق الفيديو في أهمية توسيع عناصر واجهة المستخدم عديمة الجنسية أو عناصر واجهة المستخدم ذات الحالة لإنشاء عناصر واجهة المستخدم، والتي تتطلب تنفيذ طريقة بناء لعرض المحتوى على الشاشة. يتم تسليط الضوء على الوسائط المسماة كطريقة لتعيين القيم لمعلمات عناصر واجهة المستخدم، مع عرض توضيحي لتجسيد الفئات عن طريق إضافة أقواس. يتم تقديم مُزين @Override كممارسة أسلوبية للإشارة إلى تجاوز الطريقة المتعمد، ويتم شرح بناء الجملة المختصرة للوظائف ذات تعبير واحد، مما يوفر طريقة موجزة لتنفيذ التعليمات البرمجية. ويختتم الفيديو بالتركيز على إنشاء تطبيقات أكثر إرضاءً من الناحية الجمالية من خلال الاستفادة من هذه المبادئ الأساسية في تطوير Flutter.",
                                // Persian
                                "فارسی": "این ویدئو مفاهیم اساسی ساخت اپلیکیشن فلاتر با استفاده از ابزارک ها و زبان دارت را توضیح می دهد. ارائه دهنده بر اهمیت تابع اصلی در فایل main.dart تاکید می کند، که تابع runApp ارائه شده توسط تیم Flutter از بسته material.dart را فعال می کند. این ویدئو به اهمیت گسترش ویجت بدون حالت یا ویجت حالت دار برای ایجاد ویجت ها می پردازد، که نیازمند اجرای یک روش ساخت برای ارائه محتوا بر روی صفحه است. آرگومان های نامگذاری شده به عنوان روشی برای تخصیص مقادیر به پارامترهای ویجت برجسته می شوند، با نمایش نمونه سازی کلاس ها با افزودن پرانتز. دکوراتور @Override به‌عنوان یک عمل سبکی برای نشان دادن نادیده گرفتن روش عمدی معرفی شده است، و نحو مختصر برای توابع با یک عبارت توضیح داده شده است، و روشی مختصر برای اجرای کد ارائه می‌دهد. این ویدئو با تمرکز بر ایجاد برنامه های کاربردی زیباتر با استفاده از این اصول اصلی در توسعه Flutter به پایان می رسد.",
                            },
                        },
                        // 24 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Building a Widget Tree",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video discusses the importance of styling in a Flutter application and introduces the Scaffold widget from the material.dart package, which helps in creating a structured UI design. The presenter demonstrates how to configure basic page styling using the Scaffold widget, including adding an AppBar with a title and a body for the main content area. The video highlights the usage of named arguments within widgets, such as setting a title for the AppBar using the Text widget. The presenter also provides a tip on adding trailing commas for improved code readability and autoformatting. By incorporating these elements, the video shows how to enhance the appearance of the Flutter app with proper styling and structure, culminating in a more aesthetically pleasing user interface.",
                                // German
                                "Deutsch": "Das Video erörtert die Bedeutung des Stylings in einer Flutter-Anwendung und stellt das Scaffold-Widget aus dem Paket material.dart vor, das bei der Erstellung eines strukturierten UI-Designs hilft. Der Moderator demonstriert, wie man mit dem Scaffold-Widget das grundlegende Seiten-Styling konfiguriert, einschließlich des Hinzufügens einer AppBar mit einem Titel und einem Textkörper für den Hauptinhaltsbereich. Das Video hebt die Verwendung benannter Argumente innerhalb von Widgets hervor, z. B. das Festlegen eines Titels für die AppBar mithilfe des Text-Widgets. Der Moderator gibt auch einen Tipp zum Hinzufügen von abschließenden Kommas für eine bessere Lesbarkeit des Codes und zur automatischen Formatierung. Durch die Einbindung dieser Elemente zeigt das Video, wie man das Erscheinungsbild der Flutter-App mit dem richtigen Styling und der richtigen Struktur verbessert, was zu einer ästhetisch ansprechenderen Benutzeroberfläche führt.",
                                // Chinese
                                "中国人": "该视频讨论了 Flutter 应用程序中样式的重要性，并介绍了来自material.dart 包的 Scaffold 小部件，它有助于创建结构化的 UI 设计。演示者演示了如何使用 Scaffold 小部件配置基本页面样式，包括添加带有标题和正文的 AppBar 作为主要内容区域。该视频重点介绍了小部件中命名参数的用法，例如使用 Text 小部件为 AppBar 设置标题。演示者还提供了添加尾随逗号以提高代码可读性和自动格式化的技巧。通过整合这些元素，该视频展示了如何使用适当的样式和结构增强 Flutter 应用程序的外观，最终打造出更美观的用户界面。",
                                // Russian
                                "Русский": "В видео обсуждается важность стилизации в приложении Flutter и представлен виджет Scaffold из пакета material.dart, который помогает в создании структурированного дизайна пользовательского интерфейса. Докладчик демонстрирует, как настроить базовый стиль страницы с помощью виджета Scaffold, включая добавление AppBar с заголовком и телом для основной области контента. В видео подчеркивается использование именованных аргументов в виджетах, например, установка заголовка для AppBar с помощью виджета Text. Докладчик также дает совет по добавлению запятых в конце для улучшения читаемости кода и автоматического форматирования. Включая эти элементы, видео показывает, как улучшить внешний вид приложения Flutter с помощью правильного стиля и структуры, что приводит к более эстетически приятному пользовательскому интерфейсу.",
                                // French
                                "Français": "La vidéo aborde l'importance du style dans une application Flutter et présente le widget Scaffold du package material.dart, qui permet de créer une conception d'interface utilisateur structurée. Le présentateur montre comment configurer le style de page de base à l'aide du widget Scaffold, notamment en ajoutant une AppBar avec un titre et un corps pour la zone de contenu principale. La vidéo met en évidence l'utilisation d'arguments nommés dans les widgets, comme la définition d'un titre pour l'AppBar à l'aide du widget Texte. Le présentateur fournit également une astuce sur l'ajout de virgules de fin pour améliorer la lisibilité du code et la mise en forme automatique. En incorporant ces éléments, la vidéo montre comment améliorer l'apparence de l'application Flutter avec un style et une structure appropriés, aboutissant à une interface utilisateur plus esthétique.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter アプリケーションでのスタイル設定の重要性について説明し、構造化された UI デザインの作成に役立つ、material.dart パッケージの Scaffold ウィジェットを紹介します。プレゼンターは、タイトルとメイン コンテンツ領域の本文を含む AppBar の追加など、Scaffold ウィジェットを使用して基本的なページ スタイルを設定する方法を示します。ビデオでは、ウィジェット内の名前付き引数の使用法 (Text ウィジェットを使用して AppBar のタイトルを設定するなど) について説明します。また、プレゼンターは、コードの読みやすさと自動フォーマットを向上させるために末尾にコンマを追加するヒントも提供します。これらの要素を組み込むことで、適切なスタイル設定と構造で Flutter アプリの外観を向上させ、より美しいユーザー インターフェイスを実現する方法をビデオで示します。",
                                // Korean
                                "한국인": "이 비디오에서는 Flutter 애플리케이션에서 스타일링의 중요성에 대해 설명하고, 구조화된 UI 디자인을 만드는 데 도움이 되는 material.dart 패키지의 Scaffold 위젯을 소개합니다. 발표자는 Scaffold 위젯을 사용하여 기본 페이지 스타일링을 구성하는 방법을 보여줍니다. 여기에는 제목과 본문이 있는 AppBar를 메인 콘텐츠 영역에 추가하는 것이 포함됩니다. 이 비디오에서는 Text 위젯을 사용하여 AppBar의 제목을 설정하는 것과 같이 위젯 내에서 명명된 인수를 사용하는 방법을 강조합니다. 발표자는 또한 코드 가독성을 개선하고 자동 서식을 지정하기 위해 끝에 쉼표를 추가하는 방법에 대한 팁을 제공합니다. 이러한 요소를 통합하여 이 비디오에서는 적절한 스타일링과 구조로 Flutter 앱의 모양을 개선하는 방법을 보여주며, 더욱 미적으로 만족스러운 사용자 인터페이스로 마무리합니다.",
                                // Spanish
                                "Español": "El video analiza la importancia del estilo en una aplicación Flutter y presenta el widget Scaffold del paquete material.dart, que ayuda a crear un diseño de interfaz de usuario estructurado. El presentador demuestra cómo configurar el estilo básico de la página utilizando el widget Scaffold, lo que incluye agregar una AppBar con un título y un cuerpo para el área de contenido principal. El video destaca el uso de argumentos con nombre dentro de los widgets, como configurar un título para la AppBar utilizando el widget Text. El presentador también brinda un consejo sobre cómo agregar comas finales para mejorar la legibilidad del código y el formato automático. Al incorporar estos elementos, el video muestra cómo mejorar la apariencia de la aplicación Flutter con el estilo y la estructura adecuados, lo que culmina en una interfaz de usuario estéticamente más agradable.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर एप्लिकेशन में स्टाइलिंग के महत्व पर चर्चा करता है और material.dart पैकेज से स्कैफ़ोल्ड विजेट पेश करता है, जो एक संरचित UI डिज़ाइन बनाने में मदद करता है। प्रस्तुतकर्ता स्कैफ़ोल्ड विजेट का उपयोग करके मूल पृष्ठ स्टाइलिंग को कॉन्फ़िगर करने का तरीका प्रदर्शित करता है, जिसमें मुख्य सामग्री क्षेत्र के लिए शीर्षक और बॉडी के साथ ऐपबार जोड़ना शामिल है। वीडियो विजेट के भीतर नामित तर्कों के उपयोग पर प्रकाश डालता है, जैसे कि टेक्स्ट विजेट का उपयोग करके ऐपबार के लिए शीर्षक सेट करना। प्रस्तुतकर्ता बेहतर कोड पठनीयता और ऑटोफ़ॉर्मेटिंग के लिए अनुगामी अल्पविराम जोड़ने पर एक टिप भी प्रदान करता है। इन तत्वों को शामिल करके, वीडियो दिखाता है कि उचित स्टाइलिंग और संरचना के साथ फ़्लटर ऐप की उपस्थिति को कैसे बढ़ाया जाए, जिससे अधिक सौंदर्यपूर्ण रूप से मनभावन उपयोगकर्ता इंटरफ़ेस प्राप्त हो।",
                                // Portuguese
                                "Português": "O vídeo discute a importância do estilo numa aplicação Flutter e apresenta o widget Scaffold do pacote material.dart, que ajuda na criação de um design de UI estruturado. O apresentador demonstra como configurar o estilo básico da página utilizando o widget Scaffold, incluindo a adição de uma AppBar com um título e um corpo para a área de conteúdo principal. O vídeo destaca a utilização de argumentos nomeados nos widgets, como por exemplo, definir um título para a AppBar utilizando o widget Texto. O apresentador também fornece uma dica sobre como adicionar vírgulas finais para melhorar a legibilidade do código e a formatação automática. Ao incorporar estes elementos, o vídeo mostra como melhorar a aparência da aplicação Flutter com o estilo e a estrutura adequados, culminando numa interface de utilizador esteticamente mais agradável.",
                                // Bengali
                                "বাংলা": "ভিডিওটি একটি ফ্লাটার অ্যাপ্লিকেশনে স্টাইলিং এর গুরুত্ব নিয়ে আলোচনা করে এবং material.dart প্যাকেজ থেকে স্ক্যাফোল্ড উইজেট প্রবর্তন করে, যা একটি কাঠামোগত UI ডিজাইন তৈরি করতে সাহায্য করে। উপস্থাপক দেখান কিভাবে স্ক্যাফোল্ড উইজেট ব্যবহার করে মৌলিক পৃষ্ঠার স্টাইলিং কনফিগার করতে হয়, যার মধ্যে একটি শিরোনাম সহ একটি AppBar যোগ করা এবং প্রধান বিষয়বস্তু এলাকার জন্য একটি বডি যোগ করা। ভিডিওটি উইজেটের মধ্যে নামযুক্ত আর্গুমেন্টের ব্যবহার হাইলাইট করে, যেমন টেক্সট উইজেট ব্যবহার করে অ্যাপবারের জন্য একটি শিরোনাম সেট করা। উপস্থাপক উন্নত কোড পঠনযোগ্যতা এবং স্বয়ংক্রিয় বিন্যাসের জন্য ট্রেলিং কমা যোগ করার জন্য একটি টিপও প্রদান করে। এই উপাদানগুলিকে একত্রিত করে, ভিডিওটি দেখায় যে কীভাবে সঠিক স্টাইলিং এবং কাঠামোর সাথে ফ্লাটার অ্যাপের চেহারা উন্নত করা যায়, এটি আরও নান্দনিকভাবে আনন্দদায়ক ব্যবহারকারী ইন্টারফেসে পরিণত হয়।",
                                // Arabic
                                "عَرَبِيّ": "يناقش الفيديو أهمية التصميم في تطبيق Flutter ويقدم عنصر واجهة المستخدم Scaffold من حزمة material.dart، والذي يساعد في إنشاء تصميم واجهة مستخدم منظم. يوضح مقدم العرض كيفية تكوين تصميم الصفحة الأساسي باستخدام عنصر واجهة المستخدم Scaffold، بما في ذلك إضافة AppBar بعنوان ونص لمنطقة المحتوى الرئيسية. يسلط الفيديو الضوء على استخدام الوسائط المسماة داخل عناصر واجهة المستخدم، مثل تعيين عنوان لـ AppBar باستخدام عنصر واجهة المستخدم Text. يقدم مقدم العرض أيضًا نصيحة حول إضافة فواصل لاحقة لتحسين قابلية قراءة الكود والتنسيق التلقائي. من خلال دمج هذه العناصر، يوضح الفيديو كيفية تحسين مظهر تطبيق Flutter بالتصميم والبنية المناسبين، مما يؤدي إلى واجهة مستخدم أكثر إرضاءً من الناحية الجمالية.",
                                // Persian
                                "فارسی": "این ویدئو در مورد اهمیت یک ظاهر طراحی شده در یک برنامه Flutter بحث می کند و ویجت Scaffold را از بسته material.dart معرفی می کند که به ایجاد یک طراحی UI ساختاریافته کمک می کند. ارائه دهنده نحوه پیکربندی استایل صفحه اصلی را با استفاده از ویجت Scaffold نشان می دهد، از جمله افزودن یک AppBar با عنوان و بدنه برای ناحیه محتوای اصلی. این ویدئو استفاده از آرگومان‌های نام‌گذاری‌شده در ویجت‌ها را برجسته می‌کند، مانند تنظیم عنوانی برای AppBar با استفاده از ابزارک Text. ارائه دهنده همچنین نکته ای در مورد افزودن کاماهای انتهایی برای بهبود خوانایی کد و قالب بندی خودکار ارائه می دهد. با ترکیب این عناصر، این ویدئو نشان می‌دهد که چگونه می‌توان ظاهر اپلیکیشن Flutter را با استایل و ساختار مناسب بهبود بخشید و به یک رابط کاربری زیباتر از نظر زیبایی‌شناختی ختم می‌شود.",
                            },
                        },
                        // 25 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Visible (Input _ Output) & Invisible (Layout _ Control) Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video discusses the process of building a simple personality quiz application in Flutter by expanding on the current application that only displays default text. The presenter aims to create a quiz where users answer questions to determine their personality traits. However, a challenge arises when trying to add multiple widgets to the body section of the app, which can only take one widget. The video emphasizes the different types of widgets in Flutter, including visible widgets like buttons and text, and invisible widgets like row, column, and ListView that help with layout and structuring content. The focus is on utilizing these widgets to set up the quiz app with a question and answer buttons for user interaction.",
                                // German
                                "Deutsch": "Das Video erläutert den Prozess der Erstellung einer einfachen Persönlichkeitstest-Anwendung in Flutter, indem die aktuelle Anwendung erweitert wird, die nur Standardtext anzeigt. Der Moderator möchte einen Test erstellen, bei dem Benutzer Fragen beantworten, um ihre Persönlichkeitsmerkmale zu bestimmen. Eine Herausforderung entsteht jedoch, wenn versucht wird, mehrere Widgets zum Hauptteil der App hinzuzufügen, der nur ein Widget aufnehmen kann. Das Video betont die verschiedenen Arten von Widgets in Flutter, darunter sichtbare Widgets wie Schaltflächen und Text sowie unsichtbare Widgets wie Zeilen-, Spalten- und ListView-Widgets, die beim Layout und der Strukturierung von Inhalten helfen. Der Schwerpunkt liegt auf der Verwendung dieser Widgets, um die Quiz-App mit Frage- und Antwortschaltflächen für die Benutzerinteraktion einzurichten.",
                                // Chinese
                                "中国人": "该视频讨论了在 Flutter 中构建简单个性测验应用程序的过程，该过程通过扩展当前仅显示默认文本的应用程序来实现。演示者旨在创建一个测验，让用户回答问题以确定他们的个性特征。但是，当尝试向应用程序的主体部分添加多个小部件时，就会出现挑战，因为主体部分只能容纳一个小部件。该视频强调了 Flutter 中不同类型的小部件，包括按钮和文本等可见小部件，以及有助于布局和构建内容的不可见小部件，如行、列和 ListView。重点是利用这些小部件来设置带有问题和答案按钮的测验应用程序，以供用户交互。",
                                // Russian
                                "Русский": "В видео обсуждается процесс создания простого приложения для проверки личности во Flutter путем расширения текущего приложения, которое отображает только текст по умолчанию. Докладчик стремится создать тест, в котором пользователи отвечают на вопросы, чтобы определить свои черты личности. Однако возникает проблема при попытке добавить несколько виджетов в основную часть приложения, которая может принять только один виджет. В видео подчеркивается различные типы виджетов во Flutter, включая видимые виджеты, такие как кнопки и текст, и невидимые виджеты, такие как строка, столбец и ListView, которые помогают с макетом и структурированием контента. Основное внимание уделяется использованию этих виджетов для настройки приложения для проверки с кнопками вопросов и ответов для взаимодействия с пользователем.",
                                // French
                                "Français": "La vidéo présente le processus de création d'une application de quiz de personnalité simple dans Flutter en développant l'application actuelle qui n'affiche que du texte par défaut. Le présentateur vise à créer un quiz dans lequel les utilisateurs répondent à des questions pour déterminer leurs traits de personnalité. Cependant, un défi se pose lorsque l'on essaie d'ajouter plusieurs widgets à la section corps de l'application, qui ne peut en accueillir qu'un seul. La vidéo met l'accent sur les différents types de widgets dans Flutter, notamment les widgets visibles comme les boutons et le texte, et les widgets invisibles comme les lignes, les colonnes et ListView qui aident à la mise en page et à la structuration du contenu. L'accent est mis sur l'utilisation de ces widgets pour configurer l'application de quiz avec des boutons de questions et de réponses pour l'interaction de l'utilisateur.",
                                // Japanese
                                "日本語": "このビデオでは、デフォルトのテキストのみを表示する現在のアプリケーションを拡張して、Flutter でシンプルな性格診断クイズ アプリケーションを構築するプロセスについて説明します。プレゼンターは、ユーザーが質問に答えて性格特性を判断するクイズを作成することを目指しています。ただし、アプリの body セクションにウィジェットを複数追加しようとすると、ウィジェットを 1 つしか追加できないという問題が発生します。このビデオでは、ボタンやテキストなどの表示ウィジェットや、レイアウトやコンテンツの構造化に役立つ行、列、ListView などの非表示ウィジェットなど、Flutter のさまざまな種類のウィジェットを強調しています。これらのウィジェットを利用して、ユーザー インタラクション用の質問ボタンと回答ボタンを備えたクイズ アプリを設定することに焦点を当てています。",
                                // Korean
                                "한국인": "이 비디오에서는 기본 텍스트만 표시하는 현재 애플리케이션을 확장하여 Flutter에서 간단한 성격 퀴즈 애플리케이션을 빌드하는 과정에 대해 설명합니다. 발표자는 사용자가 질문에 답하여 성격 특성을 파악하는 퀴즈를 만드는 것을 목표로 합니다. 그러나 앱의 본문 섹션에 여러 위젯을 추가하려고 하면 하나의 위젯만 사용할 수 있으므로 문제가 발생합니다. 이 비디오에서는 버튼 및 텍스트와 같은 표시되는 위젯과 레이아웃 및 콘텐츠 구조화에 도움이 되는 행, 열 및 ListView와 같은 표시되지 않는 위젯을 포함하여 Flutter의 다양한 유형의 위젯을 강조합니다. 초점은 이러한 위젯을 사용하여 사용자 상호 작용을 위한 질문 및 답변 버튼이 있는 퀴즈 앱을 설정하는 것입니다.",
                                // Spanish
                                "Español": "El video analiza el proceso de creación de una aplicación de cuestionario de personalidad simple en Flutter, ampliando la aplicación actual que solo muestra texto predeterminado. El presentador tiene como objetivo crear un cuestionario en el que los usuarios respondan preguntas para determinar sus rasgos de personalidad. Sin embargo, surge un desafío al intentar agregar varios widgets a la sección del cuerpo de la aplicación, que solo puede aceptar un widget. El video enfatiza los diferentes tipos de widgets en Flutter, incluidos los widgets visibles como botones y texto, y los widgets invisibles como fila, columna y ListView que ayudan con el diseño y la estructuración del contenido. El enfoque está en utilizar estos widgets para configurar la aplicación de cuestionario con botones de preguntas y respuestas para la interacción del usuario.",
                                // Hindi
                                "हिंदी": "वीडियो में फ़्लटर में एक सरल व्यक्तित्व प्रश्नोत्तरी एप्लिकेशन बनाने की प्रक्रिया पर चर्चा की गई है, जिसमें वर्तमान एप्लिकेशन का विस्तार किया गया है जो केवल डिफ़ॉल्ट टेक्स्ट प्रदर्शित करता है। प्रस्तुतकर्ता का लक्ष्य एक प्रश्नोत्तरी बनाना है जहाँ उपयोगकर्ता अपने व्यक्तित्व लक्षणों को निर्धारित करने के लिए प्रश्नों का उत्तर देते हैं। हालाँकि, ऐप के बॉडी सेक्शन में कई विजेट जोड़ने की कोशिश करते समय एक चुनौती आती है, जो केवल एक विजेट ले सकता है। वीडियो फ़्लटर में विभिन्न प्रकार के विजेट पर जोर देता है, जिसमें बटन और टेक्स्ट जैसे दृश्यमान विजेट और पंक्ति, कॉलम और सूची दृश्य जैसे अदृश्य विजेट शामिल हैं जो लेआउट और संरचना सामग्री में मदद करते हैं। उपयोगकर्ता इंटरैक्शन के लिए प्रश्न और उत्तर बटन के साथ प्रश्नोत्तरी ऐप सेट करने के लिए इन विजेट का उपयोग करने पर ध्यान केंद्रित किया गया है।",
                                // Portuguese
                                "Português": "O vídeo discute o processo de construção de uma aplicação simples de teste de personalidade no Flutter, expandindo a aplicação atual que exibe apenas texto padrão. O apresentador pretende criar um quiz onde os utilizadores respondam a perguntas para determinar os seus traços de personalidade. No entanto, surge um desafio ao tentar adicionar vários widgets à secção corporal da aplicação, que só pode acomodar um widget. O vídeo enfatiza os diferentes tipos de widgets no Flutter, incluindo widgets visíveis, como botões e texto, e widgets invisíveis, como linha, coluna e ListView, que ajudam no layout e na estruturação do conteúdo. O foco está na utilização destes widgets para configurar a aplicação de teste com botões de perguntas e respostas para interação do utilizador.",
                                // Bengali
                                "বাংলা": "ভিডিওটি বর্তমান অ্যাপ্লিকেশনটিতে বিস্তৃত করে ফ্লটারে একটি সাধারণ ব্যক্তিত্বের কুইজ অ্যাপ্লিকেশন তৈরির প্রক্রিয়া নিয়ে আলোচনা করে যা শুধুমাত্র ডিফল্ট পাঠ্য প্রদর্শন করে। উপস্থাপকের লক্ষ্য একটি কুইজ তৈরি করা যেখানে ব্যবহারকারীরা তাদের ব্যক্তিত্বের বৈশিষ্ট্য নির্ধারণের জন্য প্রশ্নের উত্তর দেয়। যাইহোক, অ্যাপের বডি বিভাগে একাধিক উইজেট যোগ করার চেষ্টা করার সময় একটি চ্যালেঞ্জ দেখা দেয়, যা শুধুমাত্র একটি উইজেট নিতে পারে। ভিডিওটি ফ্লটারে বিভিন্ন ধরণের উইজেটগুলির উপর জোর দেয়, যার মধ্যে রয়েছে বোতাম এবং পাঠ্যের মতো দৃশ্যমান উইজেট এবং সারি, কলাম এবং লিস্টভিউয়ের মতো অদৃশ্য উইজেট যা লেআউট এবং কাঠামোগত বিষয়বস্তুতে সহায়তা করে। ব্যবহারকারীর ইন্টারঅ্যাকশনের জন্য একটি প্রশ্ন ও উত্তর বোতাম সহ কুইজ অ্যাপ সেট আপ করতে এই উইজেটগুলি ব্যবহার করার উপর ফোকাস করা হয়।",
                                // Arabic
                                "عَرَبِيّ": "يناقش الفيديو عملية إنشاء تطبيق اختبار شخصية بسيط في Flutter من خلال التوسع في التطبيق الحالي الذي يعرض النص الافتراضي فقط. يهدف مقدم العرض إلى إنشاء اختبار يجيب فيه المستخدمون على الأسئلة لتحديد سمات شخصيتهم. ومع ذلك، ينشأ التحدي عند محاولة إضافة عناصر واجهة مستخدم متعددة إلى قسم النص في التطبيق، والذي لا يمكنه استيعاب سوى عنصر واجهة مستخدم واحد. يشدد الفيديو على الأنواع المختلفة من عناصر واجهة المستخدم في Flutter، بما في ذلك عناصر واجهة المستخدم المرئية مثل الأزرار والنص، وعناصر واجهة المستخدم غير المرئية مثل الصف والعمود وقائمة العرض التي تساعد في تخطيط المحتوى وهيكلته. ينصب التركيز على الاستفادة من هذه العناصر لإعداد تطبيق الاختبار بأزرار الأسئلة والأجوبة للتفاعل مع المستخدم.",
                                // Persian
                                "فارسی": "این ویدئو روند ساخت یک برنامه آزمون شخصیتی ساده در Flutter را با گسترش برنامه فعلی که فقط متن پیش فرض را نمایش می دهد، مورد بحث قرار می دهد. هدف ارائه دهنده ایجاد مسابقه ای است که در آن کاربران برای تعیین ویژگی های شخصیتی خود به سوالات پاسخ می دهند. با این حال، هنگام تلاش برای افزودن چندین ویجت به بخش بدنه برنامه، که فقط یک ویجت را می‌گیرد، چالشی پیش می‌آید. این ویدئو بر انواع مختلف ویجت‌ها در Flutter تاکید می‌کند، از جمله ویجت‌های قابل مشاهده مانند دکمه‌ها و متن، و ویجت‌های نامرئی مانند ردیف، ستون و ListView که به چیدمان و ساختار محتوا کمک می‌کنند. تمرکز بر روی استفاده از این ویجت ها برای راه اندازی برنامه مسابقه با دکمه های پرسش و پاسخ برای تعامل با کاربر است.",
                            },
                        },
                        // 26 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Adding Layout Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explores the creation of a personality quiz application in Flutter by utilizing the Column widget to structure the layout. The presenter demonstrates the usage of the Column widget to arrange widgets in a vertical column, including a Text widget for displaying questions and RaisedButton widgets for answer buttons. An explanation is provided on the concept of lists in Dart programming, with an introduction to generic types denoted by angled brackets. The video highlights the usage of RaisedButton widgets for buttons, despite possible deprecation in newer Flutter versions, recommending the use of ElevatedButton as an alternative. The importance of setting the onPressed function for button functionality is emphasized, and null values are temporarily used to avoid errors. The video also touches on code formatting techniques for readability and hints at future styling enhancements while focusing on widget arrangement using Column and Row widgets in Flutter development.",
                                // German
                                "Deutsch": "Das Video untersucht die Erstellung einer Persönlichkeitstest-Anwendung in Flutter unter Verwendung des Column-Widgets zur Strukturierung des Layouts. Der Moderator demonstriert die Verwendung des Column-Widgets zum Anordnen von Widgets in einer vertikalen Spalte, darunter ein Text-Widget zum Anzeigen von Fragen und RaisedButton-Widgets für Antwortschaltflächen. Es wird eine Erklärung zum Konzept von Listen in der Dart-Programmierung bereitgestellt, mit einer Einführung in generische Typen, die durch spitze Klammern gekennzeichnet sind. Das Video hebt die Verwendung von RaisedButton-Widgets für Schaltflächen hervor, trotz möglicher Veralterung in neueren Flutter-Versionen, und empfiehlt die Verwendung von ElevatedButton als Alternative. Die Wichtigkeit des Festlegens der Funktion onPressed für die Schaltflächenfunktionalität wird hervorgehoben, und es werden vorübergehend Nullwerte verwendet, um Fehler zu vermeiden. Das Video geht auch auf Codeformatierungstechniken zur besseren Lesbarkeit ein und gibt Hinweise auf zukünftige Stilverbesserungen, wobei der Schwerpunkt auf der Widget-Anordnung mithilfe von Column- und Row-Widgets in der Flutter-Entwicklung liegt.",
                                // Chinese
                                "中国人": "该视频探讨了如何使用 Column 小部件来构建布局，从而在 Flutter 中创建个性测验应用程序。演示者演示了如何使用 Column 小部件在垂直列中排列小部件，包括用于显示问题的 Text 小部件和用于回答按钮的 RaisedButton 小部件。视频解释了 Dart 编程中的列表概念，并介绍了用尖括号表示的泛型类型。视频重点介绍了按钮的 RaisedButton 小部件的使用，尽管在较新的 Flutter 版本中可能会弃用，但建议使用 ElevatedButton 作为替代方案。视频强调了设置 onPressed 函数以实现按钮功能的重要性，并暂时使用空值以避免错误。视频还涉及代码格式化技术以提高可读性，并暗示了未来的样式增强功能，同时重点介绍了在 Flutter 开发中使用 Column 和 Row 小部件进行小部件排列。",
                                // Russian
                                "Русский": "В видео рассматривается создание приложения для персонального теста во Flutter с использованием виджета Column для структурирования макета. Докладчик демонстрирует использование виджета Column для размещения виджетов в вертикальном столбце, включая виджет Text для отображения вопросов и виджеты RaisedButton для кнопок ответа. Дается объяснение концепции списков в программировании Dart с введением в универсальные типы, обозначенные угловыми скобками. В видео подчеркивается использование виджетов RaisedButton для кнопок, несмотря на возможное устаревание в новых версиях Flutter, и рекомендуется использовать ElevatedButton в качестве альтернативы. Подчеркивается важность установки функции onPressed для функциональности кнопок, а также временно используются нулевые значения, чтобы избежать ошибок. В видео также затрагиваются методы форматирования кода для удобства чтения и намекаются на будущие улучшения стиля, при этом основное внимание уделяется размещению виджетов с использованием виджетов Column и Row в разработке Flutter.",
                                // French
                                "Français": "La vidéo explore la création d'une application de quiz de personnalité dans Flutter en utilisant le widget Column pour structurer la mise en page. Le présentateur démontre l'utilisation du widget Column pour organiser les widgets dans une colonne verticale, y compris un widget Text pour afficher les questions et des widgets RaisedButton pour les boutons de réponse. Une explication est fournie sur le concept de listes dans la programmation Dart, avec une introduction aux types génériques indiqués par des crochets angulaires. La vidéo met en évidence l'utilisation des widgets RaisedButton pour les boutons, malgré une possible dépréciation dans les versions plus récentes de Flutter, recommandant l'utilisation de ElevatedButton comme alternative. L'importance de définir la fonction onPressed pour la fonctionnalité des boutons est soulignée et les valeurs null sont temporairement utilisées pour éviter les erreurs. La vidéo aborde également les techniques de formatage du code pour la lisibilité et fait allusion aux futures améliorations de style tout en se concentrant sur l'agencement des widgets à l'aide des widgets Column et Row dans le développement Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、Column ウィジェットを使用してレイアウトを構築し、Flutter で性格診断クイズ アプリケーションを作成する方法を説明します。プレゼンターは、質問を表示するための Text ウィジェットや回答ボタン用の RaisedButton ウィジェットなど、Column ウィジェットを使用してウィジェットを垂直列に配置する方法を説明します。Dart プログラミングにおけるリストの概念について説明し、山括弧で示されるジェネリック型を紹介します。このビデオでは、ボタンに RaisedButton ウィジェットを使用する方法を強調していますが、新しい Flutter バージョンでは廃止される可能性があるため、代わりに ElevatedButton を使用することを推奨しています。ボタン機能に onPressed 関数を設定することの重要性を強調し、エラーを回避するために一時的に null 値を使用します。このビデオでは、読みやすさのためのコード フォーマット手法についても触れ、Flutter 開発での Column ウィジェットと Row ウィジェットを使用したウィジェット配置に焦点を当てながら、将来のスタイル強化についてのヒントも示しています。",
                                // Korean
                                "한국인": "이 비디오에서는 레이아웃을 구조화하기 위해 Column 위젯을 활용하여 Flutter에서 성격 퀴즈 애플리케이션을 만드는 방법을 살펴봅니다. 발표자는 질문을 표시하기 위한 Text 위젯과 답변 버튼용 RaisedButton 위젯을 포함하여 세로 열에 위젯을 배열하기 위해 Column 위젯을 사용하는 방법을 보여줍니다. 각괄호로 표시된 일반 유형에 대한 소개와 함께 Dart 프로그래밍에서 목록의 개념에 대한 설명이 제공됩니다. 이 비디오에서는 최신 Flutter 버전에서 더 이상 사용되지 않을 수 있음에도 불구하고 버튼에 RaisedButton 위젯을 사용하는 방법을 강조하고 대안으로 ElevatedButton을 사용할 것을 권장합니다. 버튼 기능에 대한 onPressed 함수를 설정하는 것의 중요성을 강조하고 오류를 방지하기 위해 일시적으로 null 값을 사용합니다. 이 비디오에서는 또한 가독성을 위한 코드 서식 지정 기술에 대해 다루고 Flutter 개발에서 Column 및 Row 위젯을 사용하여 위젯 배열에 초점을 맞추면서 향후 스타일 개선 사항에 대한 힌트를 제공합니다.",
                                // Spanish
                                "Español": "El video explora la creación de una aplicación de cuestionario de personalidad en Flutter utilizando el widget Column para estructurar el diseño. El presentador demuestra el uso del widget Column para organizar los widgets en una columna vertical, incluido un widget Text para mostrar preguntas y widgets RaisedButton para botones de respuesta. Se proporciona una explicación sobre el concepto de listas en la programación Dart, con una introducción a los tipos genéricos indicados por corchetes angulares. El video destaca el uso de los widgets RaisedButton para botones, a pesar de su posible desuso en versiones más nuevas de Flutter, y recomienda el uso de ElevatedButton como alternativa. Se enfatiza la importancia de configurar la función onPressed para la funcionalidad de los botones y se utilizan valores nulos temporalmente para evitar errores. El video también aborda las técnicas de formato de código para facilitar la lectura y sugiere futuras mejoras de estilo, mientras se enfoca en la disposición de los widgets utilizando widgets Column y Row en el desarrollo de Flutter.",
                                // Hindi
                                "हिंदी": "वीडियो लेआउट की संरचना के लिए कॉलम विजेट का उपयोग करके फ़्लटर में व्यक्तित्व प्रश्नोत्तरी एप्लिकेशन के निर्माण की खोज करता है। प्रस्तुतकर्ता एक ऊर्ध्वाधर कॉलम में विजेट को व्यवस्थित करने के लिए कॉलम विजेट के उपयोग को प्रदर्शित करता है, जिसमें प्रश्न प्रदर्शित करने के लिए टेक्स्ट विजेट और उत्तर बटन के लिए RaisedButton विजेट शामिल हैं। डार्ट प्रोग्रामिंग में सूचियों की अवधारणा पर एक स्पष्टीकरण प्रदान किया गया है, जिसमें कोणीय कोष्ठकों द्वारा दर्शाए गए सामान्य प्रकारों का परिचय दिया गया है। वीडियो बटन के लिए RaisedButton विजेट के उपयोग पर प्रकाश डालता है, नए फ़्लटर संस्करणों में संभावित अस्वीकृति के बावजूद, एक विकल्प के रूप में ElevatedButton के उपयोग की अनुशंसा करता है। बटन कार्यक्षमता के लिए onPressed फ़ंक्शन सेट करने के महत्व पर जोर दिया गया है, और त्रुटियों से बचने के लिए अस्थायी रूप से शून्य मानों का उपयोग किया जाता है। वीडियो पठनीयता के लिए कोड फ़ॉर्मेटिंग तकनीकों को भी छूता है और फ़्लटर विकास में कॉलम और रो विजेट का उपयोग करके विजेट व्यवस्था पर ध्यान केंद्रित करते हुए भविष्य की स्टाइलिंग संवर्द्धन पर संकेत देता है।",
                                // Portuguese
                                "Português": "O vídeo explora a criação de uma aplicação de teste de personalidade no Flutter utilizando o widget Column para estruturar o layout. O apresentador demonstra a utilização do widget Coluna para organizar widgets numa coluna vertical, incluindo um widget Texto para exibir perguntas e widgets RaisedButton para botões de resposta. É fornecida uma explicação sobre o conceito de listas na programação Dart, com uma introdução aos tipos genéricos indicados por parêntesis rectos. O vídeo destaca a utilização de widgets RaisedButton para botões, apesar da possível descontinuação nas versões mais recentes do Flutter, recomendando a utilização de ElevatedButton como alternativa. A importância de definir a função onPressed para a funcionalidade do botão é enfatizada e os valores nulos são utilizados temporariamente para evitar erros. O vídeo aborda também técnicas de formatação de código para facilitar a leitura e dicas sobre futuras melhorias de estilo, ao mesmo tempo que se concentra na organização de widgets utilizando widgets de coluna e linha no desenvolvimento do Flutter.",
                                // Bengali
                                "বাংলা": "ভিডিওটি লেআউট গঠনের জন্য কলাম উইজেট ব্যবহার করে ফ্লটারে একটি ব্যক্তিত্ব কুইজ অ্যাপ্লিকেশন তৈরির অন্বেষণ করে। উপস্থাপক একটি উল্লম্ব কলামে উইজেটগুলি সাজানোর জন্য কলাম উইজেটের ব্যবহার প্রদর্শন করে, যার মধ্যে প্রশ্ন প্রদর্শনের জন্য একটি পাঠ্য উইজেট এবং উত্তর বোতামগুলির জন্য উত্থাপিত বোতাম উইজেট রয়েছে৷ ডার্ট প্রোগ্রামিং-এ তালিকার ধারণার উপর একটি ব্যাখ্যা প্রদান করা হয়েছে, কোণীয় বন্ধনী দ্বারা চিহ্নিত জেনেরিক প্রকারগুলির একটি ভূমিকা সহ। ভিডিওটি নতুন ফ্লটার সংস্করণে সম্ভাব্য অবচয় সত্ত্বেও বোতামগুলির জন্য RaisedButton উইজেটগুলির ব্যবহার হাইলাইট করে, বিকল্প হিসাবে ElevatedButton ব্যবহার করার সুপারিশ করে৷ বোতাম কার্যকারিতার জন্য onPressed ফাংশন সেট করার গুরুত্বের উপর জোর দেওয়া হয়, এবং ত্রুটি এড়াতে নাল মানগুলি সাময়িকভাবে ব্যবহার করা হয়। ভিডিওটি পঠনযোগ্যতার জন্য কোড ফর্ম্যাটিং কৌশলগুলিকেও স্পর্শ করে এবং ফ্লটার ডেভেলপমেন্টে কলাম এবং সারি উইজেটগুলি ব্যবহার করে উইজেট বিন্যাসের উপর ফোকাস করার সময় ভবিষ্যত স্টাইলিং বর্ধনে ইঙ্গিত দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يستكشف الفيديو إنشاء تطبيق اختبار الشخصية في Flutter من خلال الاستفادة من عنصر واجهة المستخدم Column لتنظيم التخطيط. يوضح مقدم العرض استخدام عنصر واجهة المستخدم Column لترتيب عناصر واجهة المستخدم في عمود رأسي، بما في ذلك عنصر واجهة المستخدم Text لعرض الأسئلة وعناصر واجهة المستخدم RaisedButton لأزرار الإجابة. يتم تقديم شرح لمفهوم القوائم في برمجة Dart، مع مقدمة للأنواع العامة التي يتم الإشارة إليها بواسطة أقواس زاوية. يسلط الفيديو الضوء على استخدام عناصر واجهة المستخدم RaisedButton للأزرار، على الرغم من الإهمال المحتمل في إصدارات Flutter الأحدث، ويوصي باستخدام ElevatedButton كبديل. يتم التأكيد على أهمية تعيين وظيفة onPressed لوظيفة الزر، ويتم استخدام القيم الفارغة مؤقتًا لتجنب الأخطاء. يتطرق الفيديو أيضًا إلى تقنيات تنسيق التعليمات البرمجية لسهولة القراءة ويشير إلى تحسينات التصميم المستقبلية مع التركيز على ترتيب عناصر واجهة المستخدم باستخدام عناصر واجهة المستخدم Column وRow في تطوير Flutter.",
                                // Persian
                                "فارسی": "این ویدیو با استفاده از ویجت Column برای ساختار طرح، ایجاد یک برنامه مسابقه شخصیت در Flutter را بررسی می کند. ارائه دهنده استفاده از ویجت Column را برای چیدمان ویجت ها در یک ستون عمودی نشان می دهد، از جمله ویجت Text برای نمایش سوالات و ویجت های RaisedButton برای دکمه های پاسخ. توضیحی در مورد مفهوم لیست ها در برنامه نویسی دارت، با مقدمه ای بر انواع عمومی که با براکت های زاویه دار نشان داده شده اند، ارائه شده است. این ویدئو استفاده از ویجت‌های RaisedButton را برای دکمه‌ها، علی‌رغم منسوخ شدن احتمالی در نسخه‌های جدیدتر Flutter برجسته می‌کند و استفاده از ElevatedButton را به عنوان جایگزین توصیه می‌کند. اهمیت تنظیم تابع onPressed برای عملکرد دکمه تاکید شده است و مقادیر null به طور موقت برای جلوگیری از خطا استفاده می شود. این ویدئو همچنین به تکنیک‌های قالب‌بندی کد برای خوانایی اشاره می‌کند و به پیشرفت‌های ظاهری آینده اشاره می‌کند و در عین حال بر چیدمان ویجت‌ها با استفاده از ویجت‌های ستون و ردیف در توسعه Flutter تمرکز می‌کند.",
                            },
                        },
                        // 27 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Connecting Functions & Buttons",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video delves into the process of linking button actions to functions in a Flutter application by utilizing the onPressed property. The presenter explains the function of onPressed, which requires a function that returns void, denoted by a parantheses-less syntax to prevent immediate execution. An analogy is presented comparing the concept to pressing a button on a TV remote to turn on the TV, where the function represents turning on the TV and the button press corresponds to onPressed. The video elaborates that passing the function name without parentheses directs onPressed to execute the function upon button press effectively, leading to the successful activation of button interactions when tested in the application. The importance of understanding this syntax and concept for proper function execution in Flutter development is underscored throughout the explanation.",
                                // German
                                "Deutsch": "Dieses Video befasst sich mit dem Prozess der Verknüpfen von Tastenaktionen mit Funktionen in einer Flutter-Anwendung unter Verwendung der Eigenschaft „onPressed“. Der Moderator erläutert die Funktion von „onPressed“, die eine Funktion erfordert, die „void“ zurückgibt, gekennzeichnet durch eine Syntax ohne Klammern, um eine sofortige Ausführung zu verhindern. Es wird eine Analogie präsentiert, in der das Konzept mit dem Drücken einer Taste auf einer TV-Fernbedienung verglichen wird, um den Fernseher einzuschalten, wobei die Funktion das Einschalten des Fernsehers darstellt und der Tastendruck „onPressed“ entspricht. Das Video erläutert, dass die Übergabe des Funktionsnamens ohne Klammern „onPressed“ anweist, die Funktion beim Drücken der Taste effektiv auszuführen, was beim Test in der Anwendung zur erfolgreichen Aktivierung der Tasteninteraktionen führt. Die Bedeutung des Verständnisses dieser Syntax und dieses Konzepts für eine ordnungsgemäße Funktionsausführung in der Flutter-Entwicklung wird in der gesamten Erklärung hervorgehoben.",
                                // Chinese
                                "中国人": "本视频深入探讨了如何使用 onPressed 属性将按钮操作链接到 Flutter 应用程序中的函数。演示者解释了 onPressed 函数，该函数需要一个返回 void 的函数，用无括号语法表示以防止立即执行。视频中将该概念与按下电视遥控器上的按钮打开电视进行了类比，其中函数表示打开电视，按钮按下对应于 onPressed。视频详细说明了传递不带括号的函数名称会指示 onPressed 在按下按钮时有效执行该函数，从而在应用程序中测试时成功激活按钮交互。在整个解释过程中，强调了理解此语法和概念对于在 Flutter 开发中正确执行函数的重要性。",
                                // Russian
                                "Русский": "В этом видео рассматривается процесс связывания действий кнопок с функциями в приложении Flutter с использованием свойства onPressed. Докладчик объясняет функцию onPressed, которая требует функцию, возвращающую void, обозначенную синтаксисом без скобок, чтобы предотвратить немедленное выполнение. Представлена ​​аналогия, сравнивающая концепцию с нажатием кнопки на пульте дистанционного управления телевизора для включения телевизора, где функция представляет включение телевизора, а нажатие кнопки соответствует onPressed. В видео подробно объясняется, что передача имени функции без скобок заставляет onPressed эффективно выполнять функцию при нажатии кнопки, что приводит к успешной активации взаимодействия кнопок при тестировании в приложении. Важность понимания этого синтаксиса и концепции для правильного выполнения функции при разработке Flutter подчеркивается на протяжении всего объяснения.",
                                // French
                                "Français": "Cette vidéo aborde le processus de liaison des actions des boutons aux fonctions d'une application Flutter en utilisant la propriété onPressed. Le présentateur explique la fonction de onPressed, qui nécessite une fonction qui renvoie void, indiquée par une syntaxe sans parenthèses pour empêcher l'exécution immédiate. Une analogie est présentée en comparant le concept à celui d'appuyer sur un bouton de la télécommande d'un téléviseur pour allumer le téléviseur, où la fonction représente l'allumage du téléviseur et l'appui sur le bouton correspond à onPressed. La vidéo explique que le fait de transmettre le nom de la fonction sans parenthèses ordonne à onPressed d'exécuter efficacement la fonction lors de l'appui sur le bouton, ce qui conduit à l'activation réussie des interactions des boutons lorsqu'elles sont testées dans l'application. L'importance de comprendre cette syntaxe et ce concept pour une exécution correcte des fonctions dans le développement Flutter est soulignée tout au long de l'explication.",
                                // Japanese
                                "日本語": "このビデオでは、onPressed プロパティを利用して、Flutter アプリケーションでボタン アクションを関数にリンクするプロセスを詳しく説明します。プレゼンターは、すぐに実行されないように括弧のない構文で示される void を返す関数を必要とする onPressed の機能について説明します。テレビのリモコンのボタンを押してテレビをオンにする概念と比較したアナロジーが提示されます。ここで、関数はテレビをオンにすることを表し、ボタンの押下は onPressed に対応します。ビデオでは、括弧なしで関数名を渡すと、ボタンが押されたときに onPressed が関数を効果的に実行するように指示され、アプリケーションでテストしたときにボタン操作が正常にアクティブ化されることが詳しく説明されています。Flutter 開発で関数を適切に実行するためにこの構文と概念を理解することの重要性は、説明全体を通して強調されています。",
                                // Korean
                                "한국인": "이 비디오는 onPressed 속성을 활용하여 Flutter 애플리케이션의 함수에 버튼 동작을 연결하는 프로세스를 살펴봅니다. 발표자는 onPressed의 함수를 설명하는데, 이 함수는 즉각적인 실행을 방지하기 위해 괄호 없는 구문으로 표시된 void를 반환하는 함수가 필요합니다. 이 개념을 TV 리모컨의 버튼을 눌러 TV를 켜는 것과 비교하는 비유를 제시합니다. 여기서 함수는 TV를 켜는 것을 나타내고 버튼을 누르는 것은 onPressed에 해당합니다. 이 비디오는 괄호 없이 함수 이름을 전달하면 onPressed가 버튼을 누를 때 함수를 효과적으로 실행하여 애플리케이션에서 테스트할 때 버튼 상호 작용이 성공적으로 활성화된다고 설명합니다. Flutter 개발에서 적절한 함수 실행을 위해 이 구문과 개념을 이해하는 것의 중요성은 설명 전체에서 강조됩니다.",
                                // Spanish
                                "Español": "Este video profundiza en el proceso de vincular acciones de botones a funciones en una aplicación Flutter mediante el uso de la propiedad onPressed. El presentador explica la función de onPressed, que requiere una función que devuelva void, denotado por una sintaxis sin paréntesis para evitar la ejecución inmediata. Se presenta una analogía que compara el concepto con presionar un botón en un control remoto de TV para encender el televisor, donde la función representa encender el televisor y la presión del botón corresponde a onPressed. El video explica que pasar el nombre de la función sin paréntesis le indica a onPressed que ejecute la función al presionar el botón de manera efectiva, lo que lleva a la activación exitosa de las interacciones del botón cuando se prueba en la aplicación. La importancia de comprender esta sintaxis y concepto para la ejecución adecuada de la función en el desarrollo de Flutter se destaca a lo largo de la explicación.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर एप्लिकेशन में ऑनप्रेस्ड प्रॉपर्टी का उपयोग करके बटन क्रियाओं को फ़ंक्शन से जोड़ने की प्रक्रिया में गहराई से जाता है। प्रस्तुतकर्ता ऑनप्रेस्ड के फ़ंक्शन को समझाता है, जिसके लिए एक फ़ंक्शन की आवश्यकता होती है जो शून्य लौटाता है, जिसे तत्काल निष्पादन को रोकने के लिए कोष्ठक-रहित सिंटैक्स द्वारा दर्शाया जाता है। टीवी चालू करने के लिए टीवी रिमोट पर बटन दबाने की अवधारणा की तुलना करते हुए एक सादृश्य प्रस्तुत किया गया है, जहाँ फ़ंक्शन टीवी चालू करने का प्रतिनिधित्व करता है और बटन प्रेस ऑनप्रेस्ड के अनुरूप है। वीडियो विस्तार से बताता है कि फ़ंक्शन नाम को बिना कोष्ठक के पास करने से ऑनप्रेस्ड बटन दबाने पर फ़ंक्शन को प्रभावी ढंग से निष्पादित करने का निर्देश देता है, जिससे एप्लिकेशन में परीक्षण किए जाने पर बटन इंटरैक्शन का सफल सक्रियण होता है। फ़्लटर विकास में उचित फ़ंक्शन निष्पादन के लिए इस सिंटैक्स और अवधारणा को समझने के महत्व को पूरे स्पष्टीकरण में रेखांकित किया गया है।",
                                // Portuguese
                                "Português": "Este vídeo investiga o processo de ligação de ações de botões a funções numa aplicação Flutter utilizando a propriedade onPressed. O apresentador explica a função de onPressed, que requer uma função que devolva void, denotada por uma sintaxe sem parênteses para evitar a execução imediata. É apresentada uma analogia comparando o conceito a pressionar um botão no comando de uma TV para ligar a TV, onde a função representa ligar a TV e o pressionar do botão corresponde a onPressed. O vídeo explica que a passagem do nome da função sem parênteses direciona o onPressed para executar a função ao premir o botão de forma eficaz, levando à ativação bem-sucedida das interações do botão quando testada na aplicação. A importância de compreender esta sintaxe e conceito para a execução adequada de funções no desenvolvimento do Flutter é enfatizada ao longo da explicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি অনপ্রেসড প্রপার্টি ব্যবহার করে একটি ফ্লাটার অ্যাপ্লিকেশনের ফাংশনগুলির সাথে বোতামের ক্রিয়াগুলিকে লিঙ্ক করার প্রক্রিয়ার মধ্যে পড়ে। উপস্থাপক onPressed-এর ফাংশন ব্যাখ্যা করে, যার জন্য একটি ফাংশন প্রয়োজন যা অকার্যকর ফেরত দেয়, অবিলম্বে কার্যকর করা রোধ করতে প্যারান্থেস-কম সিনট্যাক্স দ্বারা চিহ্নিত করা হয়। টিভি চালু করার জন্য একটি টিভি রিমোটে একটি বোতাম টিপানোর সাথে ধারণাটির তুলনা করে একটি উপমা উপস্থাপন করা হয়েছে, যেখানে ফাংশনটি টিভি চালু করার প্রতিনিধিত্ব করে এবং বোতাম টিপটি onPressed এর সাথে মিলে যায়। ভিডিওটি বিশদভাবে বর্ণনা করে যে বন্ধনী ছাড়াই ফাংশন নামটি পাস করার ফলে বোতাম টিপলে কার্যকরীভাবে ফাংশনটি চালানোর জন্য অনপ্রেসড নির্দেশিত হয়, যা অ্যাপ্লিকেশনটিতে পরীক্ষা করার সময় বোতামের ইন্টারঅ্যাকশনের সফল সক্রিয়করণের দিকে পরিচালিত করে। এই সিনট্যাক্স বোঝার গুরুত্ব এবং ফ্লাটার ডেভেলপমেন্টে সঠিক ফাংশন এক্সিকিউশনের জন্য ধারণা পুরো ব্যাখ্যা জুড়ে আন্ডারস্কোর করা হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "يتعمق هذا الفيديو في عملية ربط إجراءات الأزرار بالوظائف في تطبيق Flutter من خلال الاستفادة من خاصية onPressed. يشرح مقدم العرض وظيفة onPressed، والتي تتطلب وظيفة تعيد قيمة void، والتي يتم الإشارة إليها باستخدام صيغة بناء جملة بدون أقواس لمنع التنفيذ الفوري. يتم تقديم تشبيه يقارن المفهوم بالضغط على زر في جهاز التحكم عن بعد الخاص بالتلفزيون لتشغيل التلفزيون، حيث تمثل الوظيفة تشغيل التلفزيون والضغط على الزر يتوافق مع onPressed. يوضح الفيديو أن تمرير اسم الوظيفة بدون أقواس يوجه onPressed لتنفيذ الوظيفة عند الضغط على الزر بشكل فعال، مما يؤدي إلى التنشيط الناجح لتفاعلات الأزرار عند اختبارها في التطبيق. يتم التأكيد على أهمية فهم هذه الصيغة والمفهوم للتنفيذ السليم للوظيفة في تطوير Flutter طوال الشرح.",
                                // Persian
                                "فارسی": "این ویدیو با استفاده از ویژگی onPressed به فرآیند پیوند دادن عملکردهای دکمه به عملکردها در یک برنامه Flutter می پردازد. ارائه‌دهنده عملکرد onPressed را توضیح می‌دهد که به تابعی نیاز دارد که void را برمی‌گرداند، که با یک نحو بدون پرانتز برای جلوگیری از اجرای فوری مشخص می‌شود. تشبیهی ارائه شده است که مفهوم را با فشار دادن دکمه روی کنترل از راه دور تلویزیون برای روشن کردن تلویزیون مقایسه می کند، که در آن عملکرد نشان دهنده روشن کردن تلویزیون و فشار دادن دکمه مربوط به onPressed است. در این ویدیو توضیح داده شده است که با ارسال نام تابع بدون پرانتز، onPressed برای اجرای موثر عملکرد با فشار دادن دکمه، هدایت می‌شود که منجر به فعال‌سازی موفقیت‌آمیز فعل و انفعالات دکمه‌ها هنگام آزمایش در برنامه می‌شود. اهمیت درک این نحو و مفهوم برای اجرای صحیح عملکرد در توسعه فلوتر در سراسر توضیح تاکید شده است.",
                            },
                        },
                        // 26 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Anonymous Functions",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video explores two methods of connecting buttons to functions in a Flutter application. The presenter explains the difference between named functions and anonymous functions, highlighting their distinct use cases. Named functions are ideal for reusable functions called from various parts of the application, while anonymous functions are suitable for one-time use within a specific context. By illustrating the syntax differences, the video showcases how to correctly define and link functions to button interactions, ensuring proper execution upon button press. The importance of using the appropriate function syntax based on the specific application requirements is emphasized, with examples demonstrating successful function execution on button press in the Flutter app.",
                                // German
                                "Deutsch": "In diesem Video werden zwei Methoden zum Verbinden von Schaltflächen mit Funktionen in einer Flutter-Anwendung untersucht. Der Moderator erklärt den Unterschied zwischen benannten und anonymen Funktionen und hebt ihre unterschiedlichen Anwendungsfälle hervor. Benannte Funktionen sind ideal für wiederverwendbare Funktionen, die von verschiedenen Teilen der Anwendung aufgerufen werden, während anonyme Funktionen für die einmalige Verwendung in einem bestimmten Kontext geeignet sind. Durch die Veranschaulichung der Syntaxunterschiede zeigt das Video, wie Funktionen korrekt definiert und mit Schaltflächeninteraktionen verknüpft werden, um eine ordnungsgemäße Ausführung beim Drücken einer Schaltfläche sicherzustellen. Die Bedeutung der Verwendung der geeigneten Funktionssyntax basierend auf den spezifischen Anwendungsanforderungen wird hervorgehoben, wobei Beispiele die erfolgreiche Funktionsausführung beim Drücken einer Schaltfläche in der Flutter-App demonstrieren.",
                                // Chinese
                                "中国人": "本视频探讨了将按钮连接到 Flutter 应用程序中的函数的两种方法。演示者解释了命名函数和匿名函数之间的区别，并强调了它们不同的用例。命名函数非常适合从应用程序的各个部分调用的可重用函数，而匿名函数则适合在特定上下文中一次性使用。通过说明语法差异，视频展示了如何正确定义函数并将其链接到按钮交互，确保按下按钮时正确执行。视频强调了根据特定应用程序要求使用适当的函数语法的重要性，并通过示例展示了在 Flutter 应用程序中按下按钮时成功执行函数。",
                                // Russian
                                "Русский": "В этом видео рассматриваются два метода подключения кнопок к функциям в приложении Flutter. Докладчик объясняет разницу между именованными функциями и анонимными функциями, выделяя их различные варианты использования. Именованные функции идеально подходят для многократно используемых функций, вызываемых из различных частей приложения, в то время как анонимные функции подходят для одноразового использования в определенном контексте. Иллюстрируя различия в синтаксисе, видео демонстрирует, как правильно определять и связывать функции с взаимодействиями кнопок, обеспечивая правильное выполнение при нажатии кнопки. Подчеркивается важность использования соответствующего синтаксиса функций на основе конкретных требований приложения с примерами, демонстрирующими успешное выполнение функции при нажатии кнопки в приложении Flutter.",
                                // French
                                "Français": "Cette vidéo explore deux méthodes de connexion de boutons à des fonctions dans une application Flutter. Le présentateur explique la différence entre les fonctions nommées et les fonctions anonymes, en soulignant leurs cas d'utilisation distincts. Les fonctions nommées sont idéales pour les fonctions réutilisables appelées à partir de différentes parties de l'application, tandis que les fonctions anonymes conviennent à une utilisation unique dans un contexte spécifique. En illustrant les différences de syntaxe, la vidéo montre comment définir et lier correctement les fonctions aux interactions des boutons, garantissant une exécution correcte lors de la pression sur le bouton. L'importance d'utiliser la syntaxe de fonction appropriée en fonction des exigences spécifiques de l'application est soulignée, avec des exemples démontrant l'exécution réussie d'une fonction lors de la pression sur un bouton dans l'application Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter アプリケーションでボタンを関数に接続する 2 つの方法について説明します。プレゼンターは、名前付き関数と匿名関数の違いを説明し、それぞれの使用例を取り上げます。名前付き関数は、アプリケーションのさまざまな部分から呼び出される再利用可能な関数に最適ですが、匿名関数は特定のコンテキスト内で 1 回限りの使用に適しています。このビデオでは、構文の違いを示しながら、関数を正しく定義してボタン操作にリンクし、ボタンを押したときに適切に実行されるようにする方法を紹介しています。特定のアプリケーション要件に基づいて適切な関数構文を使用することの重要性が強調されており、Flutter アプリでボタンを押したときに関数が適切に実行される例が示されています。",
                                // Korean
                                "한국인": "이 영상은 Flutter 애플리케이션에서 버튼을 함수에 연결하는 두 가지 방법을 살펴봅니다. 발표자는 명명된 함수와 익명 함수의 차이점을 설명하면서, 두 함수의 고유한 사용 사례를 강조합니다. 명명된 함수는 애플리케이션의 다양한 부분에서 호출되는 재사용 가능한 함수에 이상적이고, 익명 함수는 특정 컨텍스트 내에서 한 번만 사용하기에 적합합니다. 이 영상은 구문의 차이점을 설명하면서, 함수를 버튼 상호작용에 올바르게 정의하고 연결하는 방법을 보여 주며, 버튼을 누를 때 적절한 실행을 보장합니다. 특정 애플리케이션 요구 사항에 따라 적절한 함수 구문을 사용하는 것의 중요성이 강조되며, 예를 들어 Flutter 앱에서 버튼을 누를 때 함수가 성공적으로 실행되는 것을 보여줍니다.",
                                // Spanish
                                "Español": "Este video explora dos métodos para conectar botones a funciones en una aplicación Flutter. El presentador explica la diferencia entre funciones con nombre y funciones anónimas, destacando sus distintos casos de uso. Las funciones con nombre son ideales para funciones reutilizables llamadas desde varias partes de la aplicación, mientras que las funciones anónimas son adecuadas para un solo uso dentro de un contexto específico. Al ilustrar las diferencias de sintaxis, el video muestra cómo definir y vincular correctamente las funciones a las interacciones de los botones, lo que garantiza una ejecución adecuada al presionar el botón. Se enfatiza la importancia de usar la sintaxis de función adecuada según los requisitos específicos de la aplicación, con ejemplos que demuestran la ejecución exitosa de la función al presionar el botón en la aplicación Flutter.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर एप्लिकेशन में बटन को फ़ंक्शन से जोड़ने के दो तरीकों की खोज करता है। प्रस्तुतकर्ता नामित फ़ंक्शन और अनाम फ़ंक्शन के बीच अंतर को समझाता है, उनके अलग-अलग उपयोग मामलों पर प्रकाश डालता है। नामित फ़ंक्शन एप्लिकेशन के विभिन्न भागों से कॉल किए जाने वाले पुन: प्रयोज्य फ़ंक्शन के लिए आदर्श होते हैं, जबकि अनाम फ़ंक्शन किसी विशिष्ट संदर्भ में एक बार उपयोग के लिए उपयुक्त होते हैं। सिंटैक्स अंतरों को दर्शाकर, वीडियो दिखाता है कि फ़ंक्शन को बटन इंटरैक्शन से सही तरीके से कैसे परिभाषित और लिंक किया जाए, जिससे बटन दबाने पर उचित निष्पादन सुनिश्चित हो सके। फ़्लटर ऐप में बटन दबाने पर सफल फ़ंक्शन निष्पादन को प्रदर्शित करने वाले उदाहरणों के साथ, विशिष्ट एप्लिकेशन आवश्यकताओं के आधार पर उपयुक्त फ़ंक्शन सिंटैक्स का उपयोग करने के महत्व पर ज़ोर दिया गया है।",
                                // Portuguese
                                "Português": "Este vídeo explora dois métodos de ligação de botões a funções numa aplicação Flutter. O apresentador explica a diferença entre funções nomeadas e funções anónimas, destacando os seus casos de utilização distintos. As funções nomeadas são ideais para funções reutilizáveis ​​chamadas a partir de várias partes da aplicação, enquanto as funções anónimas são adequadas para utilização única num contexto específico. Ao ilustrar as diferenças de sintaxe, o vídeo mostra como definir e ligar corretamente as funções às interações dos botões, garantindo a execução adequada ao premir o botão. É enfatizada a importância de utilizar a sintaxe de função apropriada com base nos requisitos específicos da aplicação, com exemplos que demonstram a execução bem-sucedida da função ao premir um botão na aplicação Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি একটি ফ্লাটার অ্যাপ্লিকেশনে ফাংশনের সাথে বোতাম সংযোগ করার দুটি পদ্ধতির অন্বেষণ করে। উপস্থাপক নামযুক্ত ফাংশন এবং বেনামী ফাংশনের মধ্যে পার্থক্য ব্যাখ্যা করে, তাদের স্বতন্ত্র ব্যবহারের ক্ষেত্রে হাইলাইট করে। নামযুক্ত ফাংশনগুলি অ্যাপ্লিকেশনের বিভিন্ন অংশ থেকে কল করা পুনঃব্যবহারযোগ্য ফাংশনগুলির জন্য আদর্শ, যখন বেনামী ফাংশনগুলি একটি নির্দিষ্ট প্রসঙ্গের মধ্যে একবার ব্যবহারের জন্য উপযুক্ত। সিনট্যাক্সের পার্থক্যগুলিকে চিত্রিত করে, ভিডিওটি দেখায় কিভাবে সঠিকভাবে বোতামের ইন্টারঅ্যাকশনের সাথে ফাংশনগুলিকে সংজ্ঞায়িত করা যায় এবং লিঙ্ক করা যায়, বোতাম টিপে সঠিকভাবে কার্যকর করা নিশ্চিত করে৷ নির্দিষ্ট অ্যাপ্লিকেশন প্রয়োজনীয়তার উপর ভিত্তি করে উপযুক্ত ফাংশন সিনট্যাক্স ব্যবহার করার গুরুত্বকে জোর দেওয়া হয়েছে, উদাহরণ সহ Flutter অ্যাপে বোতাম টিপে সফল ফাংশন সঞ্চালন প্রদর্শন করা হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "يستكشف هذا الفيديو طريقتين لربط الأزرار بالوظائف في تطبيق Flutter. يشرح مقدم العرض الفرق بين الوظائف المسماة والوظائف المجهولة، مع تسليط الضوء على حالات الاستخدام المميزة لكل منهما. الوظائف المسماة مثالية للوظائف القابلة لإعادة الاستخدام والتي يتم استدعاؤها من أجزاء مختلفة من التطبيق، في حين أن الوظائف المجهولة مناسبة للاستخدام لمرة واحدة في سياق معين. من خلال توضيح الاختلافات في بناء الجملة، يعرض الفيديو كيفية تعريف الوظائف وربطها بشكل صحيح بتفاعلات الأزرار، مما يضمن التنفيذ السليم عند الضغط على الزر. يتم التأكيد على أهمية استخدام بناء جملة الوظيفة المناسب بناءً على متطلبات التطبيق المحددة، مع أمثلة توضح التنفيذ الناجح للوظيفة عند الضغط على الزر في تطبيق Flutter.",
                                // Persian
                                "فارسی": "این ویدئو دو روش اتصال دکمه ها به عملکردها را در یک برنامه فلاتر بررسی می کند. ارائه دهنده تفاوت بین توابع نامگذاری شده و توابع ناشناس را توضیح می دهد و موارد استفاده متمایز آنها را برجسته می کند. توابع نامگذاری شده برای توابع قابل استفاده مجدد که از قسمت های مختلف برنامه فراخوانی می شوند ایده آل هستند، در حالی که توابع ناشناس برای استفاده یک بار در یک زمینه خاص مناسب هستند. با نشان دادن تفاوت‌های نحوی، این ویدیو نحوه تعریف صحیح و پیوند عملکردها به تعامل دکمه‌ها را نشان می‌دهد، و از اجرای صحیح با فشار دادن دکمه اطمینان می‌دهد. اهمیت استفاده از نحو تابع مناسب بر اساس الزامات برنامه خاص، با مثال‌هایی که اجرای موفقیت‌آمیز عملکرد را با فشار دادن دکمه در برنامه Flutter نشان می‌دهد، تاکید می‌شود.",
                            },
                        },
                        // 27 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Updating Widget Data (Or_ Using StatelessWidget Incorrectly)",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video tutorial demonstrates how to dynamically change and output questions on screen in a mobile app using Dart programming language and Flutter framework. The instructor explains the concept of accessing list elements by index, demonstrates how to dynamically update a variable to change the displayed question, and clarifies the difference between using elementAt and square brackets to access list elements. Additionally, the video covers class-wide variables, the importance of updating state correctly in Flutter, and the necessity of understanding state management in app development. Through practical examples and explanations, viewers are guided through the process of efficiently updating and displaying questions in a mobile application.",
                                // German
                                "Deutsch": "Das Video-Tutorial zeigt, wie Sie mithilfe der Programmiersprache Dart und des Flutter-Frameworks Fragen auf dem Bildschirm in einer mobilen App dynamisch ändern und ausgeben können. Der Kursleiter erläutert das Konzept des Zugriffs auf Listenelemente nach Index, zeigt, wie Sie eine Variable dynamisch aktualisieren, um die angezeigte Frage zu ändern, und verdeutlicht den Unterschied zwischen der Verwendung von elementAt und eckigen Klammern zum Zugriff auf Listenelemente. Darüber hinaus behandelt das Video klassenweite Variablen, die Bedeutung der korrekten Aktualisierung des Status in Flutter und die Notwendigkeit, die Statusverwaltung bei der App-Entwicklung zu verstehen. Anhand praktischer Beispiele und Erklärungen werden die Zuschauer durch den Prozess der effizienten Aktualisierung und Anzeige von Fragen in einer mobilen Anwendung geführt.",
                                // Chinese
                                "中国人": "该视频教程演示了如何使用 Dart 编程语言和 Flutter 框架在移动应用程序中动态更改和输出屏幕上的问题。讲师解释了通过索引访问列表元素的概念，演示了如何动态更新变量以更改显示的问题，并阐明了使用 elementAt 和方括号访问列表元素之间的区别。此外，视频还介绍了类范围的变量、在 Flutter 中正确更新状态的重要性以及了解应用程序开发中状态管理的必要性。通过实际示例和解释，观众可以了解如何在移动应用程序中高效更新和显示问题。",
                                // Russian
                                "Русский": "Видеоурок демонстрирует, как динамически изменять и выводить вопросы на экран в мобильном приложении с помощью языка программирования Dart и фреймворка Flutter. Инструктор объясняет концепцию доступа к элементам списка по индексу, демонстрирует, как динамически обновлять переменную для изменения отображаемого вопроса, и разъясняет разницу между использованием elementAt и квадратных скобок для доступа к элементам списка. Кроме того, видео охватывает переменные класса, важность правильного обновления состояния во Flutter и необходимость понимания управления состоянием при разработке приложений. С помощью практических примеров и объяснений зрители проходят процесс эффективного обновления и отображения вопросов в мобильном приложении.",
                                // French
                                "Français": "Le didacticiel vidéo montre comment modifier et afficher dynamiquement des questions à l'écran dans une application mobile à l'aide du langage de programmation Dart et du framework Flutter. L'instructeur explique le concept d'accès aux éléments de liste par index, montre comment mettre à jour dynamiquement une variable pour modifier la question affichée et clarifie la différence entre l'utilisation d'elementAt et des crochets pour accéder aux éléments de liste. De plus, la vidéo couvre les variables à l'échelle de la classe, l'importance de mettre à jour correctement l'état dans Flutter et la nécessité de comprendre la gestion de l'état dans le développement d'applications. Grâce à des exemples et des explications pratiques, les spectateurs sont guidés tout au long du processus de mise à jour et d'affichage efficaces des questions dans une application mobile.",
                                // Japanese
                                "日本語": "ビデオチュートリアルでは、Dart プログラミング言語と Flutter フレームワークを使用して、モバイルアプリの画面上の質問を動的に変更して出力する方法を説明します。講師は、インデックスでリスト要素にアクセスする概念を説明し、表示される質問を変更するために変数を動的に更新する方法を示し、リスト要素にアクセスするために elementAt と角括弧を使用することの違いを明確にします。さらに、ビデオでは、クラス全体の変数、Flutter で状態を正しく更新することの重要性、アプリ開発における状態管理の理解の必要性についても説明します。実用的な例と説明を通じて、視聴者はモバイルアプリケーションで質問を効率的に更新して表示するプロセスをガイドされます。",
                                // Korean
                                "한국인": "비디오 튜토리얼은 Dart 프로그래밍 언어와 Flutter 프레임워크를 사용하여 모바일 앱에서 화면에 질문을 동적으로 변경하고 출력하는 방법을 보여줍니다. 강사는 인덱스로 목록 요소에 액세스하는 개념을 설명하고, 변수를 동적으로 업데이트하여 표시된 질문을 변경하는 방법을 보여주고, elementAt과 대괄호를 사용하여 목록 요소에 액세스하는 것의 차이점을 명확히 합니다. 또한 비디오는 클래스 전체 변수, Flutter에서 상태를 올바르게 업데이트하는 것의 중요성, 앱 개발에서 상태 관리를 이해하는 것의 필요성을 다룹니다. 시청자는 실제적인 예와 설명을 통해 모바일 애플리케이션에서 질문을 효율적으로 업데이트하고 표시하는 프로세스를 안내받습니다.",
                                // Spanish
                                "Español": "El videotutorial demuestra cómo cambiar y mostrar dinámicamente preguntas en la pantalla en una aplicación móvil usando el lenguaje de programación Dart y el marco Flutter. El instructor explica el concepto de acceder a los elementos de la lista por índice, demuestra cómo actualizar dinámicamente una variable para cambiar la pregunta mostrada y aclara la diferencia entre usar elementAt y corchetes para acceder a los elementos de la lista. Además, el video cubre las variables de toda la clase, la importancia de actualizar el estado correctamente en Flutter y la necesidad de comprender la gestión del estado en el desarrollo de aplicaciones. A través de ejemplos prácticos y explicaciones, se guía a los espectadores a través del proceso de actualización y visualización eficiente de preguntas en una aplicación móvil.",
                                // Hindi
                                "हिंदी": "वीडियो ट्यूटोरियल यह दर्शाता है कि डार्ट प्रोग्रामिंग भाषा और फ़्लटर फ़्रेमवर्क का उपयोग करके मोबाइल ऐप में स्क्रीन पर प्रश्नों को गतिशील रूप से कैसे बदला और आउटपुट किया जाए। प्रशिक्षक इंडेक्स द्वारा सूची तत्वों तक पहुँचने की अवधारणा को समझाता है, प्रदर्शित प्रश्न को बदलने के लिए चर को गतिशील रूप से कैसे अपडेट किया जाए, यह दर्शाता है और सूची तत्वों तक पहुँचने के लिए elementAt और वर्गाकार कोष्ठकों का उपयोग करने के बीच अंतर को स्पष्ट करता है। इसके अतिरिक्त, वीडियो में क्लास-वाइड चर, फ़्लटर में स्थिति को सही ढंग से अपडेट करने का महत्व और ऐप डेवलपमेंट में स्थिति प्रबंधन को समझने की आवश्यकता को शामिल किया गया है। व्यावहारिक उदाहरणों और स्पष्टीकरणों के माध्यम से, दर्शकों को मोबाइल एप्लिकेशन में प्रश्नों को कुशलतापूर्वक अपडेट करने और प्रदर्शित करने की प्रक्रिया के माध्यम से निर्देशित किया जाता है।",
                                // Portuguese
                                "Português": "O tutorial em vídeo demonstra como alterar e gerar perguntas dinamicamente no ecrã numa aplicação móvel utilizando a linguagem de programação Dart e a estrutura Flutter. O formador explica o conceito de acesso aos elementos da lista por índice, demonstra como atualizar dinamicamente uma variável para alterar a questão apresentada e esclarece a diferença entre utilizar o elementAt e os parêntesis rectos para aceder aos elementos da lista. Além disso, o vídeo aborda variáveis ​​de toda a classe, a importância de atualizar o estado corretamente no Flutter e a necessidade de compreender a gestão de estado no desenvolvimento de aplicações. Através de exemplos práticos e explicações, os espectadores são guiados pelo processo de atualização e exibição eficiente de perguntas numa aplicação móvel.",
                                // Bengali
                                "বাংলা": "ভিডিও টিউটোরিয়ালটি প্রদর্শন করে যে কিভাবে ডার্ট প্রোগ্রামিং ভাষা এবং ফ্লাটার ফ্রেমওয়ার্ক ব্যবহার করে একটি মোবাইল অ্যাপে স্ক্রিনে গতিশীলভাবে প্রশ্ন পরিবর্তন করা যায় এবং আউটপুট করা যায়। প্রশিক্ষক সূচী দ্বারা তালিকা উপাদানগুলি অ্যাক্সেস করার ধারণা ব্যাখ্যা করেন, প্রদর্শিত প্রশ্নটি পরিবর্তন করার জন্য একটি ভেরিয়েবলকে কীভাবে গতিশীলভাবে আপডেট করতে হয় তা প্রদর্শন করে এবং তালিকা উপাদানগুলি অ্যাক্সেস করতে elementAt এবং বর্গাকার বন্ধনী ব্যবহারের মধ্যে পার্থক্য স্পষ্ট করে৷ উপরন্তু, ভিডিওটি ক্লাস-ওয়াইড ভেরিয়েবল, ফ্লটারে সঠিকভাবে স্টেট আপডেট করার গুরুত্ব এবং অ্যাপ ডেভেলপমেন্টে স্টেট ম্যানেজমেন্ট বোঝার প্রয়োজনীয়তা কভার করে। ব্যবহারিক উদাহরণ এবং ব্যাখ্যার মাধ্যমে, দর্শকরা একটি মোবাইল অ্যাপ্লিকেশনে প্রশ্নগুলিকে দক্ষতার সাথে আপডেট এবং প্রদর্শনের প্রক্রিয়ার মাধ্যমে পরিচালিত হয়।",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو التعليمي كيفية تغيير الأسئلة وإخراجها ديناميكيًا على الشاشة في تطبيق جوال باستخدام لغة برمجة Dart وإطار عمل Flutter. يشرح المدرب مفهوم الوصول إلى عناصر القائمة عن طريق الفهرس، ويوضح كيفية تحديث متغير ديناميكيًا لتغيير السؤال المعروض، ويوضح الفرق بين استخدام elementAt والأقواس المربعة للوصول إلى عناصر القائمة. بالإضافة إلى ذلك، يغطي الفيديو المتغيرات على مستوى الفصل، وأهمية تحديث الحالة بشكل صحيح في Flutter، وضرورة فهم إدارة الحالة في تطوير التطبيقات. من خلال الأمثلة والشروحات العملية، يتم توجيه المشاهدين خلال عملية تحديث الأسئلة وعرضها بكفاءة في تطبيق جوال.",
                                // Persian
                                "فارسی": "این آموزش ویدیویی نحوه تغییر پویا و خروجی سوالات روی صفحه نمایش را در یک برنامه تلفن همراه با استفاده از زبان برنامه نویسی دارت و چارچوب فلاتر نشان می دهد. مدرس مفهوم دسترسی به عناصر لیست بر اساس شاخص را توضیح می دهد، نحوه به روز رسانی پویا یک متغیر برای تغییر سوال نمایش داده شده را نشان می دهد، و تفاوت بین استفاده از elementAt و براکت مربع برای دسترسی به عناصر لیست را روشن می کند. علاوه بر این، این ویدئو متغیرهای کل کلاس، اهمیت به‌روزرسانی وضعیت صحیح در Flutter و لزوم درک مدیریت وضعیت در توسعه برنامه را پوشش می‌دهد. از طریق مثال‌ها و توضیحات عملی، بینندگان از طریق فرآیند به‌روزرسانی و نمایش سؤالات در یک برنامه تلفن همراه راهنمایی می‌شوند.",
                            },
                        },
                        // 28 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Updating Correctly with Stateful Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video tutorial explains the concept of state in app development using Dart and the Flutter framework. It distinguishes between app-wide and widget-specific state, highlighting the importance of managing data within the application. The instructor demonstrates the transition from a stateless widget to a stateful widget, explaining the role of state in maintaining persistent data while the widget itself can be recreated. The tutorial covers the implementation of set state function to trigger UI updates based on changes in data, emphasizing the need for explicit state management for efficient app performance. Viewers are guided through the conversion process and shown how to correctly structure stateful widgets to handle dynamic data changes in the user interface.",
                                // German
                                "Deutsch": "Das Video-Tutorial erläutert das Konzept des Status in der App-Entwicklung mit Dart und dem Flutter-Framework. Es unterscheidet zwischen app-weitem und widgetspezifischem Status und unterstreicht die Bedeutung der Datenverwaltung innerhalb der Anwendung. Der Kursleiter demonstriert den Übergang von einem zustandslosen Widget zu einem zustandsbehafteten Widget und erklärt die Rolle des Status bei der Aufrechterhaltung persistenter Daten, während das Widget selbst neu erstellt werden kann. Das Tutorial behandelt die Implementierung der Funktion „Zustand festlegen“, um UI-Updates basierend auf Datenänderungen auszulösen, und betont die Notwendigkeit einer expliziten Statusverwaltung für eine effiziente App-Leistung. Die Zuschauer werden durch den Konvertierungsprozess geführt und erfahren, wie zustandsbehaftete Widgets richtig strukturiert werden, um dynamische Datenänderungen in der Benutzeroberfläche zu verarbeiten.",
                                // Chinese
                                "中国人": "视频教程解释了使用 Dart 和 Flutter 框架进行应用开发时的状态概念。它区分了应用范围和特定于小部件的状态，强调了在应用程序内管理数据的重要性。讲师演示了从无状态小部件到有状态小部件的转换，解释了状态在维护持久数据（而小部件本身可以重新创建）方面的作用。本教程介绍了设置状态函数的实现，以根据数据变化触发 UI 更新，强调了显式状态管理对高效应用性能的需求。观众将获得转换过程的指导，并了解如何正确构建有状态小部件以处理用户界面中的动态数据变化。",
                                // Russian
                                "Русский": "Видеоурок объясняет концепцию состояния в разработке приложений с использованием Dart и фреймворка Flutter. Он различает состояние всего приложения и состояние, специфичное для виджета, подчеркивая важность управления данными в приложении. Инструктор демонстрирует переход от виджета без состояния к виджету с состоянием, объясняя роль состояния в поддержании постоянных данных, в то время как сам виджет может быть воссоздан. В уроке рассматривается реализация функции установки состояния для запуска обновлений пользовательского интерфейса на основе изменений данных, подчеркивая необходимость явного управления состоянием для эффективной работы приложения. Зрители проходят через процесс преобразования и показывают, как правильно структурировать виджеты с состоянием для обработки динамических изменений данных в пользовательском интерфейсе.",
                                // French
                                "Français": "Le didacticiel vidéo explique le concept d'état dans le développement d'applications à l'aide de Dart et du framework Flutter. Il fait la distinction entre l'état de l'application et l'état spécifique au widget, soulignant l'importance de la gestion des données au sein de l'application. L'instructeur démontre la transition d'un widget sans état à un widget avec état, expliquant le rôle de l'état dans le maintien des données persistantes tandis que le widget lui-même peut être recréé. Le didacticiel couvre l'implémentation de la fonction set state pour déclencher des mises à jour de l'interface utilisateur en fonction des modifications des données, en soulignant la nécessité d'une gestion explicite de l'état pour des performances d'application efficaces. Les spectateurs sont guidés tout au long du processus de conversion et apprennent à structurer correctement les widgets avec état pour gérer les modifications de données dynamiques dans l'interface utilisateur.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、Dart と Flutter フレームワークを使用したアプリ開発における状態の概念について説明します。アプリ全体の状態とウィジェット固有の状態を区別し、アプリケーション内でデータを管理することの重要性を強調します。インストラクターは、状態のないウィジェットから状態のあるウィジェットへの移行を実演し、ウィジェット自体を再作成しながら永続的なデータを維持する状態の役割について説明します。チュートリアルでは、データの変更に基づいて UI 更新をトリガーする状態設定関数の実装について説明し、効率的なアプリパフォーマンスのための明示的な状態管理の必要性を強調します。視聴者は、変換プロセスをガイドされ、ユーザーインターフェイスの動的なデータ変更を処理するために状態のあるウィジェットを正しく構築する方法を示します。",
                                // Korean
                                "한국인": "비디오 튜토리얼은 Dart와 Flutter 프레임워크를 사용하여 앱 개발에서 상태의 개념을 설명합니다. 앱 전체 상태와 위젯별 상태를 구분하여 애플리케이션 내에서 데이터를 관리하는 것의 중요성을 강조합니다. 강사는 상태 없는 위젯에서 상태 있는 위젯으로의 전환을 보여주며 위젯 자체를 재생성하는 동안 지속적인 데이터를 유지하는 데 있어 상태의 역할을 설명합니다. 이 튜토리얼은 데이터 변경에 따라 UI 업데이트를 트리거하는 상태 설정 함수의 구현을 다루며 효율적인 앱 성능을 위한 명시적 상태 관리의 필요성을 강조합니다. 시청자는 변환 프로세스를 안내받고 사용자 인터페이스에서 동적 데이터 변경을 처리하기 위해 상태 있는 위젯을 올바르게 구성하는 방법을 보여줍니다.",
                                // Spanish
                                "Español": "El videotutorial explica el concepto de estado en el desarrollo de aplicaciones con Dart y el marco Flutter. Distingue entre el estado de toda la aplicación y el estado específico del widget, destacando la importancia de administrar los datos dentro de la aplicación. El instructor demuestra la transición de un widget sin estado a un widget con estado, explicando el papel del estado en el mantenimiento de datos persistentes mientras se puede recrear el widget en sí. El tutorial cubre la implementación de la función de estado establecido para activar actualizaciones de la interfaz de usuario en función de los cambios en los datos, enfatizando la necesidad de una gestión explícita del estado para un rendimiento eficiente de la aplicación. Los espectadores son guiados a través del proceso de conversión y se les muestra cómo estructurar correctamente los widgets con estado para manejar cambios de datos dinámicos en la interfaz de usuario.",
                                // Hindi
                                "हिंदी": "वीडियो ट्यूटोरियल डार्ट और फ़्लटर फ़्रेमवर्क का उपयोग करके ऐप डेवलपमेंट में स्टेट की अवधारणा को समझाता है। यह ऐप-वाइड और विजेट-विशिष्ट स्टेट के बीच अंतर करता है, जो एप्लिकेशन के भीतर डेटा को प्रबंधित करने के महत्व पर प्रकाश डालता है। प्रशिक्षक स्टेटलेस विजेट से स्टेटफुल विजेट में संक्रमण का प्रदर्शन करता है, जो विजेट को फिर से बनाए जाने के दौरान लगातार डेटा को बनाए रखने में स्टेट की भूमिका को समझाता है। ट्यूटोरियल डेटा में परिवर्तन के आधार पर UI अपडेट को ट्रिगर करने के लिए सेट स्टेट फ़ंक्शन के कार्यान्वयन को कवर करता है, जो कुशल ऐप प्रदर्शन के लिए स्पष्ट स्टेट प्रबंधन की आवश्यकता पर जोर देता है। दर्शकों को रूपांतरण प्रक्रिया के माध्यम से निर्देशित किया जाता है और दिखाया जाता है कि उपयोगकर्ता इंटरफ़ेस में गतिशील डेटा परिवर्तनों को संभालने के लिए स्टेटफुल विजेट को सही ढंग से कैसे संरचित किया जाए।",
                                // Portuguese
                                "Português": "O tutorial em vídeo explica o conceito de estado no desenvolvimento de aplicações utilizando o Dart e a framework Flutter. Distingue entre o estado de toda a aplicação e o estado específico do widget, destacando a importância da gestão de dados dentro da aplicação. O instrutor demonstra a transição de um widget sem estado para um widget com estado, explicando a função do estado na manutenção de dados persistentes enquanto o próprio widget pode ser recriado. O tutorial aborda a implementação da função set state para acionar atualizações da UI com base em alterações nos dados, enfatizando a necessidade de gestão explícita do estado para um desempenho eficiente da aplicação. Os visualizadores são guiados através do processo de conversão e mostram como estruturar corretamente widgets com estado para lidar com alterações dinâmicas de dados na interface do utilizador.",
                                // Bengali
                                "বাংলা": "ভিডিও টিউটোরিয়ালটি ডার্ট এবং ফ্লাটার ফ্রেমওয়ার্ক ব্যবহার করে অ্যাপ বিকাশে রাষ্ট্রের ধারণা ব্যাখ্যা করে। এটি অ্যাপ-ওয়াইড এবং উইজেট-নির্দিষ্ট অবস্থার মধ্যে পার্থক্য করে, অ্যাপ্লিকেশনের মধ্যে ডেটা পরিচালনার গুরুত্ব তুলে ধরে। প্রশিক্ষক একটি স্টেটলেস উইজেট থেকে স্টেটফুল উইজেটে রূপান্তর প্রদর্শন করে, যখন উইজেটটি নিজেই পুনরায় তৈরি করা যায় তখন স্থায়ী ডেটা বজায় রাখার ক্ষেত্রে রাষ্ট্রের ভূমিকা ব্যাখ্যা করে। টিউটোরিয়ালটি ডেটার পরিবর্তনের উপর ভিত্তি করে UI আপডেটগুলিকে ট্রিগার করার জন্য সেট স্টেট ফাংশনের বাস্তবায়নকে কভার করে, দক্ষ অ্যাপ পারফরম্যান্সের জন্য সুস্পষ্ট রাষ্ট্র পরিচালনার প্রয়োজনীয়তার উপর জোর দেয়। দর্শকদের রূপান্তর প্রক্রিয়ার মাধ্যমে নির্দেশিত করা হয় এবং দেখানো হয় কীভাবে সঠিকভাবে স্টেটফুল উইজেটগুলিকে ইউজার ইন্টারফেসে গতিশীল ডেটা পরিবর্তনগুলি পরিচালনা করতে হয়।",
                                // Arabic
                                "عَرَبِيّ": "يشرح البرنامج التعليمي بالفيديو مفهوم الحالة في تطوير التطبيقات باستخدام Dart وإطار عمل Flutter. ويميز بين الحالة على مستوى التطبيق والحالة الخاصة بالأداة، مع تسليط الضوء على أهمية إدارة البيانات داخل التطبيق. ويوضح المدرب الانتقال من أداة عديمة الحالة إلى أداة بحالة، موضحًا دور الحالة في الحفاظ على البيانات المستمرة بينما يمكن إعادة إنشاء الأداة نفسها. ويغطي البرنامج التعليمي تنفيذ وظيفة تعيين الحالة لتشغيل تحديثات واجهة المستخدم بناءً على التغييرات في البيانات، مع التأكيد على الحاجة إلى إدارة الحالة الصريحة لأداء التطبيق بكفاءة. ويتم توجيه المشاهدين خلال عملية التحويل وإظهار كيفية هيكلة الأدوات ذات الحالة بشكل صحيح للتعامل مع تغييرات البيانات الديناميكية في واجهة المستخدم.",
                                // Persian
                                "فارسی": "این آموزش تصویری مفهوم حالت در توسعه اپلیکیشن را با استفاده از دارت و فریم ورک فلاتر توضیح می دهد. این حالت بین حالت گسترده برنامه و ویجت خاص تمایز قائل می شود و اهمیت مدیریت داده ها در برنامه را برجسته می کند. مربی انتقال از یک ویجت بدون حالت به یک ویجت حالت دار را نشان می دهد و نقش حالت را در حفظ داده های پایدار توضیح می دهد در حالی که خود ویجت می تواند دوباره ایجاد شود. این آموزش اجرای تابع حالت تنظیم را برای راه‌اندازی به‌روزرسانی‌های رابط کاربری بر اساس تغییرات داده‌ها، با تأکید بر نیاز به مدیریت وضعیت صریح برای عملکرد کارآمد برنامه، پوشش می‌دهد. بینندگان از طریق فرآیند تبدیل هدایت می شوند و نشان داده می شود که چگونه ویجت های حالت دار را به درستی ساختار دهند تا تغییرات دینامیک داده در رابط کاربری را مدیریت کنند.",
                            },
                        },
                        // 29 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "A Brief Look Under The Hood",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video provides insights into the functionality of the set state function in Flutter when executed within a stateful widget. Set state prompts Flutter to re-render the user interface by calling the build method of the specific widget where set state is used, rather than updating the entire app interface. The tutorial explains the efficiency of Flutter's mechanisms in selectively identifying and redrawing only the elements that have changed in the UI, optimizing performance by avoiding complete UI redraws. It emphasizes the importance of set state in triggering UI updates for specific widget components based on changes in data, highlighting the significance of calling build to reflect these updates in the app interface. The instructor indicates a forthcoming detailed exploration into Flutter's internal workings throughout the course to enhance understanding of UI rendering processes.",
                                // German
                                "Deutsch": "Das Video bietet Einblicke in die Funktionsweise der Set-State-Funktion in Flutter, wenn sie in einem Stateful-Widget ausgeführt wird. Set State veranlasst Flutter, die Benutzeroberfläche neu zu rendern, indem die Build-Methode des spezifischen Widgets aufgerufen wird, in dem Set State verwendet wird, anstatt die gesamte App-Oberfläche zu aktualisieren. Das Tutorial erklärt die Effizienz der Flutter-Mechanismen beim selektiven Identifizieren und Neuzeichnen nur der Elemente, die sich in der Benutzeroberfläche geändert haben, und optimiert die Leistung durch Vermeidung vollständiger Neuzeichnungen der Benutzeroberfläche. Es betont die Bedeutung von Set State beim Auslösen von UI-Updates für bestimmte Widget-Komponenten basierend auf Datenänderungen und hebt die Bedeutung des Aufrufs von Build hervor, um diese Updates in der App-Oberfläche widerzuspiegeln. Der Kursleiter weist auf eine bevorstehende detaillierte Untersuchung der internen Funktionsweise von Flutter im Laufe des Kurses hin, um das Verständnis der UI-Rendering-Prozesse zu verbessern.",
                                // Chinese
                                "中国人": "该视频深入了解了 Flutter 中 set state 函数在有状态窗口小部件中执行时的功能。set state 通过调用使用 set state 的特定窗口小部件的 build 方法来提示 Flutter 重新渲染用户界面，而不是更新整个应用程序界面。本教程解释了 Flutter 机制在选择性识别和重新绘制 UI 中已更改元素方面的效率，通过避免完全重绘 UI 来优化性能。它强调了 set state 在根据数据变化触发特定窗口小部件组件的 UI 更新方面的重要性，突出了调用 build 以在应用程序界面中反映这些更新的重要性。讲师表示，将在整个课程中详细探索 Flutter 的内部工作原理，以增强对 UI 渲染过程的理解。",
                                // Russian
                                "Русский": "Видео дает представление о функциональности функции set state во Flutter при выполнении в виджете с сохранением состояния. Set state побуждает Flutter повторно отрисовывать пользовательский интерфейс, вызывая метод build определенного виджета, где используется set state, а не обновляя весь интерфейс приложения. В руководстве объясняется эффективность механизмов Flutter в выборочном определении и перерисовке только тех элементов, которые изменились в пользовательском интерфейсе, оптимизируя производительность за счет избежания полной перерисовки пользовательского интерфейса. В нем подчеркивается важность set state в запуске обновлений пользовательского интерфейса для определенных компонентов виджета на основе изменений в данных, подчеркивая важность вызова build для отражения этих обновлений в интерфейсе приложения. Преподаватель указывает на предстоящее подробное исследование внутренней работы Flutter на протяжении всего курса, чтобы улучшить понимание процессов рендеринга пользовательского интерфейса.",
                                // French
                                "Français": "La vidéo donne un aperçu de la fonctionnalité de la fonction set state dans Flutter lorsqu'elle est exécutée dans un widget avec état. Set state invite Flutter à restituer l'interface utilisateur en appelant la méthode build du widget spécifique où set state est utilisé, plutôt que de mettre à jour l'intégralité de l'interface de l'application. Le didacticiel explique l'efficacité des mécanismes de Flutter pour identifier et redessiner de manière sélective uniquement les éléments qui ont changé dans l'interface utilisateur, optimisant ainsi les performances en évitant les redessins complets de l'interface utilisateur. Il souligne l'importance de set state pour déclencher des mises à jour de l'interface utilisateur pour des composants de widget spécifiques en fonction des modifications des données, soulignant l'importance d'appeler build pour refléter ces mises à jour dans l'interface de l'application. L'instructeur indique une exploration détaillée à venir du fonctionnement interne de Flutter tout au long du cours pour améliorer la compréhension des processus de rendu de l'interface utilisateur.",
                                // Japanese
                                "日本語": "このビデオでは、ステートフル ウィジェット内で実行されたときの Flutter の状態設定関数の機能について詳しく説明します。状態設定は、アプリ インターフェース全体を更新するのではなく、状態設定が使用されている特定のウィジェットのビルド メソッドを呼び出して、Flutter にユーザー インターフェースの再レンダリングを指示します。このチュートリアルでは、UI で変更された要素のみを選択的に識別して再描画し、UI 全体の再描画を回避することでパフォーマンスを最適化する Flutter のメカニズムの効率について説明します。データの変更に基づいて特定のウィジェット コンポーネントの UI 更新をトリガーする際の状態設定の重要性を強調し、ビルドを呼び出してこれらの更新をアプリ インターフェースに反映することの重要性を強調します。講師は、UI レンダリング プロセスの理解を深めるために、コース全体を通して Flutter の内部動作を詳細に調査することを示唆しています。",
                                // Korean
                                "한국인": "이 비디오는 상태 저장 위젯 내에서 실행될 때 Flutter에서 상태 설정 함수의 기능에 대한 통찰력을 제공합니다. 상태 설정은 Flutter가 전체 앱 인터페이스를 업데이트하는 대신 상태 설정이 사용된 특정 위젯의 빌드 메서드를 호출하여 사용자 인터페이스를 다시 렌더링하도록 합니다. 이 튜토리얼은 UI에서 변경된 요소만 선택적으로 식별하여 다시 그리는 Flutter 메커니즘의 효율성을 설명하며, 완전한 UI 다시 그리기를 피함으로써 성능을 최적화합니다. 데이터 변경에 따라 특정 위젯 구성 요소에 대한 UI 업데이트를 트리거하는 데 상태 설정의 중요성을 강조하고, 앱 인터페이스에 이러한 업데이트를 반영하기 위해 빌드를 호출하는 것의 중요성을 강조합니다. 강사는 UI 렌더링 프로세스에 대한 이해를 높이기 위해 코스 전체에서 Flutter의 내부 작동 방식에 대한 자세한 탐색을 제공할 것이라고 말합니다.",
                                // Spanish
                                "Español": "El video brinda información sobre la funcionalidad de la función de estado establecido en Flutter cuando se ejecuta dentro de un widget con estado. El estado establecido solicita a Flutter que vuelva a renderizar la interfaz de usuario llamando al método de compilación del widget específico donde se usa el estado establecido, en lugar de actualizar toda la interfaz de la aplicación. El tutorial explica la eficiencia de los mecanismos de Flutter para identificar y volver a dibujar de manera selectiva solo los elementos que han cambiado en la interfaz de usuario, lo que optimiza el rendimiento al evitar redibujar completamente la interfaz de usuario. Destaca la importancia del estado establecido para activar actualizaciones de la interfaz de usuario para componentes de widgets específicos en función de los cambios en los datos, y destaca la importancia de llamar a la compilación para reflejar estas actualizaciones en la interfaz de la aplicación. El instructor indica una próxima exploración detallada del funcionamiento interno de Flutter a lo largo del curso para mejorar la comprensión de los procesos de renderizado de la interfaz de usuario.",
                                // Hindi
                                "हिंदी": "वीडियो स्टेटफुल विजेट के भीतर निष्पादित होने पर फ़्लटर में सेट स्टेट फ़ंक्शन की कार्यक्षमता के बारे में जानकारी प्रदान करता है। सेट स्टेट फ़्लटर को पूरे ऐप इंटरफ़ेस को अपडेट करने के बजाय, उस विशिष्ट विजेट के बिल्ड मेथड को कॉल करके यूज़र इंटरफ़ेस को फिर से रेंडर करने के लिए प्रेरित करता है जहाँ सेट स्टेट का उपयोग किया जाता है। ट्यूटोरियल फ़्लटर के तंत्र की दक्षता को चुनिंदा रूप से पहचानने और केवल उन तत्वों को फिर से बनाने में बताता है जो UI में बदल गए हैं, पूर्ण UI रीड्रा से बचकर प्रदर्शन को अनुकूलित करते हैं। यह डेटा में परिवर्तन के आधार पर विशिष्ट विजेट घटकों के लिए UI अपडेट को ट्रिगर करने में सेट स्टेट के महत्व पर जोर देता है, ऐप इंटरफ़ेस में इन अपडेट को प्रतिबिंबित करने के लिए बिल्ड को कॉल करने के महत्व पर प्रकाश डालता है। प्रशिक्षक UI रेंडरिंग प्रक्रियाओं की समझ को बढ़ाने के लिए पूरे पाठ्यक्रम में फ़्लटर के आंतरिक कामकाज में आगामी विस्तृत अन्वेषण का संकेत देता है।",
                                // Portuguese
                                "Português": "O vídeo fornece informações sobre a funcionalidade da função set state no Flutter quando executada num widget com estado. Definir estado solicita que o Flutter renderize novamente a interface do utilizador chamando o método de construção do widget específico onde o estado definido é utilizado, em vez de atualizar toda a interface da aplicação. O tutorial explica a eficiência dos motores do Flutter em identificar e redesenhar seletivamente apenas os elementos que foram alterados na UI, otimizando o desempenho ao evitar redesenhos completos da UI. Realça a importância do estado definido no acionamento de atualizações de UI para componentes de widgets específicos com base em alterações nos dados, destacando a importância de chamar build para refletir estas atualizações na interface da aplicação. O instrutor indica uma futura exploração detalhada do funcionamento interno do Flutter ao longo do curso para melhorar a compreensão dos processos de renderização da IU.",
                                // Bengali
                                "বাংলা": "ভিডিওটি একটি স্টেটফুল উইজেটের মধ্যে কার্যকর করার সময় ফ্লটারে সেট স্টেট ফাংশনের কার্যকারিতার অন্তর্দৃষ্টি প্রদান করে। সেট স্টেট সম্পূর্ণ অ্যাপ ইন্টারফেস আপডেট না করে নির্দিষ্ট উইজেটের বিল্ড মেথড যেখানে সেট স্টেট ব্যবহার করা হয় সেখানে কল করে ইউজার ইন্টারফেসকে পুনরায় রেন্ডার করার জন্য ফ্লটার প্রম্পট করে। টিউটোরিয়ালটি শুধুমাত্র UI-তে পরিবর্তিত উপাদানগুলিকে বেছে বেছে শনাক্তকরণ এবং পুনরায় অঙ্কন করার ক্ষেত্রে Flutter-এর প্রক্রিয়ার কার্যকারিতা ব্যাখ্যা করে, সম্পূর্ণ UI পুনরায় আঁকা এড়িয়ে কর্মক্ষমতা অপ্টিমাইজ করে। এটি ডেটার পরিবর্তনের উপর ভিত্তি করে নির্দিষ্ট উইজেট উপাদানগুলির জন্য UI আপডেটগুলি ট্রিগার করার ক্ষেত্রে সেট স্টেটের গুরুত্বের উপর জোর দেয়, অ্যাপ ইন্টারফেসে এই আপডেটগুলিকে প্রতিফলিত করতে কলিং বিল্ডের তাত্পর্য হাইলাইট করে৷ প্রশিক্ষক UI রেন্ডারিং প্রক্রিয়াগুলি বোঝার জন্য পুরো কোর্স জুড়ে Flutter-এর অভ্যন্তরীণ কাজের একটি আসন্ন বিশদ অনুসন্ধান নির্দেশ করে।",
                                // Arabic
                                "عَرَبِيّ": "يقدم الفيديو نظرة ثاقبة على وظائف وظيفة الحالة المحددة في Flutter عند تنفيذها داخل عنصر واجهة مستخدم بحالة. تطالب الحالة المحددة Flutter بإعادة عرض واجهة المستخدم من خلال استدعاء طريقة البناء للعنصر المحدد حيث يتم استخدام الحالة المحددة، بدلاً من تحديث واجهة التطبيق بالكامل. يشرح البرنامج التعليمي كفاءة آليات Flutter في تحديد وإعادة رسم العناصر التي تغيرت في واجهة المستخدم بشكل انتقائي، وتحسين الأداء من خلال تجنب إعادة رسم واجهة المستخدم بالكامل. ويؤكد على أهمية الحالة المحددة في تشغيل تحديثات واجهة المستخدم لمكونات عنصر واجهة مستخدم محددة بناءً على التغييرات في البيانات، مع تسليط الضوء على أهمية استدعاء البناء لعكس هذه التحديثات في واجهة التطبيق. يشير المدرب إلى استكشاف تفصيلي قادم للعمل الداخلي لـ Flutter طوال الدورة لتعزيز فهم عمليات عرض واجهة المستخدم.",
                                // Persian
                                "فارسی": "این ویدئو بینشی در مورد عملکرد تابع حالت تنظیم در فلاتر در هنگام اجرا در یک ویجت حالت دار ارائه می دهد. حالت تنظیم از Flutter می‌خواهد تا با فراخوانی روش ساخت ویجت خاصی که در آن از حالت تنظیم استفاده می‌شود، به جای به‌روزرسانی کل رابط برنامه، رابط کاربری را دوباره رندر کند. این آموزش کارایی مکانیسم‌های فلاتر را در شناسایی انتخابی و ترسیم مجدد تنها عناصری که در رابط کاربری تغییر کرده‌اند، توضیح می‌دهد و با اجتناب از ترسیم مجدد کامل UI، عملکرد را بهینه می‌کند. این بر اهمیت وضعیت تنظیم در راه‌اندازی به‌روزرسانی‌های رابط کاربری برای اجزای ویجت خاص بر اساس تغییرات داده‌ها تأکید می‌کند، و اهمیت فراخوانی ساختن برای انعکاس این به‌روزرسانی‌ها در رابط برنامه را برجسته می‌کند. مدرس یک کاوش دقیق آتی را در عملکرد داخلی Flutter در طول دوره نشان می دهد تا درک فرآیندهای رندر UI را افزایش دهد.",
                            },
                        },
                        // 30 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Using Private Properties",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video discusses the concept of protecting classes and their properties/methods in Dart programming by using leading underscores to denote privacy. Specifically, the tutorial demonstrates how to make a class, such as MyAppState, private so that it can only be accessed and manipulated within the same file where it is defined. This practice ensures that certain components of the code, like question index or answerQuestion function, are restricted from external use, preventing potential bugs or inconsistencies in the application. The instructor explains that while this change may seem cosmetic, the underscore syntax in Dart distinguishes public from private elements, enforcing data encapsulation within the file where they are declared. By utilizing underscores in naming conventions, developers can enhance code organization and maintain strict control over the accessibility of class components.",
                                // German
                                "Deutsch": "Das Video erörtert das Konzept des Schutzes von Klassen und ihren Eigenschaften/Methoden in der Dart-Programmierung durch die Verwendung von führenden Unterstrichen zur Kennzeichnung der Privatsphäre. Insbesondere zeigt das Tutorial, wie man eine Klasse wie MyAppState privat macht, sodass sie nur innerhalb derselben Datei aufgerufen und bearbeitet werden kann, in der sie definiert ist. Diese Vorgehensweise stellt sicher, dass bestimmte Komponenten des Codes, wie der Fragenindex oder die Funktion „AnswerQuestion“, nicht extern verwendet werden können, wodurch potenzielle Fehler oder Inkonsistenzen in der Anwendung vermieden werden. Der Kursleiter erklärt, dass diese Änderung zwar nur kosmetisch erscheinen mag, die Unterstrichsyntax in Dart jedoch öffentliche von privaten Elementen unterscheidet und die Datenkapselung innerhalb der Datei erzwingt, in der sie deklariert werden. Durch die Verwendung von Unterstrichen in Namenskonventionen können Entwickler die Codeorganisation verbessern und die Zugänglichkeit von Klassenkomponenten streng kontrollieren.",
                                // Chinese
                                "中国人": "该视频讨论了在 Dart 编程中通过使用前导下划线表示隐私来保护类及其属性/方法的概念。具体来说，本教程演示了如何将类（例如 MyAppState）设为私有，以便只能在定义它的同一文件中访问和操作它。这种做法可确保代码的某些组件（如问题索引或 answerQuestion 函数）被限制在外部使用，从而防止应用程序中出现潜在的错误或不一致。讲师解释说，虽然这种变化可能看起来是表面的，但 Dart 中的下划线语法将公共元素与私有元素区分开来，在声明它们的文件中强制数据封装。通过在命名约定中使用下划线，开发人员可以增强代码组织并严格控制类组件的可访问性。",
                                // Russian
                                "Русский": "В видео обсуждается концепция защиты классов и их свойств/методов в программировании Dart с использованием начальных подчеркиваний для обозначения конфиденциальности. В частности, в руководстве показано, как сделать класс, например MyAppState, закрытым, чтобы к нему можно было получить доступ и управлять им только в том же файле, где он определен. Такая практика гарантирует, что определенные компоненты кода, например question index или answerQuestion function, ограничены от внешнего использования, предотвращая потенциальные ошибки или несоответствия в приложении. Инструктор объясняет, что, хотя это изменение может показаться косметическим, синтаксис подчеркивания в Dart отличает публичные элементы от частных, обеспечивая инкапсуляцию данных в файле, где они объявлены. Используя подчеркивания в соглашениях об именовании, разработчики могут улучшить организацию кода и поддерживать строгий контроль над доступностью компонентов класса.",
                                // French
                                "Français": "La vidéo aborde le concept de protection des classes et de leurs propriétés/méthodes dans la programmation Dart en utilisant des traits de soulignement au début pour indiquer la confidentialité. Plus précisément, le didacticiel montre comment rendre une classe, telle que MyAppState, privée afin qu'elle ne puisse être consultée et manipulée que dans le même fichier où elle est définie. Cette pratique garantit que certains composants du code, comme l'index des questions ou la fonction answerQuestion, sont interdits d'utilisation externe, ce qui évite les bogues ou les incohérences potentielles dans l'application. L'instructeur explique que même si ce changement peut sembler cosmétique, la syntaxe de soulignement dans Dart distingue les éléments publics des éléments privés, imposant l'encapsulation des données dans le fichier où ils sont déclarés. En utilisant des traits de soulignement dans les conventions de dénomination, les développeurs peuvent améliorer l'organisation du code et maintenir un contrôle strict sur l'accessibilité des composants de classe.",
                                // Japanese
                                "日本語": "このビデオでは、先頭のアンダースコアを使用してプライバシーを示すことにより、Dart プログラミングでクラスとそのプロパティ/メソッドを保護するという概念について説明します。具体的には、MyAppState などのクラスをプライベートにして、それが定義されている同じファイル内でのみアクセスおよび操作できるようにする方法を説明します。この方法により、質問インデックスや answerQuestion 関数などのコードの特定のコンポーネントが外部からの使用を制限され、アプリケーションで潜在的なバグや不整合が発生するのを防ぐことができます。インストラクターは、この変更は表面的なものに見えるかもしれませんが、Dart のアンダースコア構文はパブリック要素とプライベート要素を区別し、宣言されているファイル内でデータのカプセル化を強制すると説明しています。命名規則でアンダースコアを利用することで、開発者はコード編成を強化し、クラス コンポーネントのアクセシビリティを厳密に制御できます。",
                                // Korean
                                "한국인": "이 비디오에서는 Dart 프로그래밍에서 선행 밑줄을 사용하여 개인 정보를 표시하여 클래스와 해당 속성/메서드를 보호하는 개념에 대해 설명합니다. 특히 이 튜토리얼에서는 MyAppState와 같은 클래스를 비공개로 만들어 정의된 동일한 파일 내에서만 액세스하고 조작할 수 있도록 하는 방법을 보여줍니다. 이 연습은 질문 인덱스나 answerQuestion 함수와 같은 코드의 특정 구성 요소가 외부에서 사용되는 것을 제한하여 애플리케이션에서 잠재적인 버그나 불일치를 방지합니다. 강사는 이러한 변경이 미용적으로 보일 수 있지만 Dart의 밑줄 구문은 공개 요소와 비공개 요소를 구별하여 선언된 파일 내에서 데이터 캡슐화를 적용한다고 설명합니다. 개발자는 명명 규칙에서 밑줄을 사용하여 코드 구성을 개선하고 클래스 구성 요소의 접근성을 엄격하게 제어할 수 있습니다.",
                                // Spanish
                                "Español": "El video analiza el concepto de protección de clases y sus propiedades/métodos en la programación Dart mediante el uso de guiones bajos iniciales para indicar privacidad. Específicamente, el tutorial demuestra cómo hacer que una clase, como MyAppState, sea privada para que solo se pueda acceder a ella y manipularla dentro del mismo archivo en el que está definida. Esta práctica garantiza que ciertos componentes del código, como el índice de preguntas o la función answerQuestion, estén restringidos al uso externo, lo que evita posibles errores o inconsistencias en la aplicación. El instructor explica que, si bien este cambio puede parecer cosmético, la sintaxis de guiones bajos en Dart distingue los elementos públicos de los privados, lo que impone la encapsulación de datos dentro del archivo en el que se declaran. Al utilizar guiones bajos en las convenciones de nombres, los desarrolladores pueden mejorar la organización del código y mantener un control estricto sobre la accesibilidad de los componentes de la clase.",
                                // Hindi
                                "हिंदी": "वीडियो गोपनीयता को दर्शाने के लिए अग्रणी अंडरस्कोर का उपयोग करके डार्ट प्रोग्रामिंग में कक्षाओं और उनके गुणों/विधियों की सुरक्षा की अवधारणा पर चर्चा करता है। विशेष रूप से, ट्यूटोरियल दर्शाता है कि MyAppState जैसे किसी वर्ग को निजी कैसे बनाया जाए ताकि इसे केवल उसी फ़ाइल के भीतर एक्सेस और मैनिपुलेट किया जा सके जहाँ इसे परिभाषित किया गया है। यह अभ्यास सुनिश्चित करता है कि कोड के कुछ घटक, जैसे प्रश्न सूचकांक या उत्तर प्रश्न फ़ंक्शन, बाहरी उपयोग से प्रतिबंधित हैं, जिससे एप्लिकेशन में संभावित बग या विसंगतियों को रोका जा सके। प्रशिक्षक बताते हैं कि हालांकि यह परिवर्तन दिखावटी लग सकता है, डार्ट में अंडरस्कोर सिंटैक्स सार्वजनिक और निजी तत्वों को अलग करता है, फ़ाइल के भीतर डेटा एनकैप्सुलेशन को लागू करता है जहाँ उन्हें घोषित किया जाता है। नामकरण सम्मेलनों में अंडरस्कोर का उपयोग करके, डेवलपर्स कोड संगठन को बढ़ा सकते हैं और क्लास घटकों की पहुँच पर सख्त नियंत्रण बनाए रख सकते हैं।",
                                // Portuguese
                                "Português": "O vídeo discute o conceito de proteção de classes e as suas propriedades/métodos na programação Dart utilizando sublinhados iniciais para denotar privacidade. Especificamente, o tutorial demonstra como tornar uma classe, como MyAppState, privada para que só possa ser acedida e manipulada dentro do mesmo ficheiro onde está definida. Esta prática garante que determinados componentes do código, como o índice de perguntas ou a função answerQuestion, estão restritos ao uso externo, evitando possíveis bugs ou inconsistências na aplicação. O instrutor explica que embora esta mudança possa parecer cosmética, a sintaxe de sublinhado no Dart distingue os elementos públicos dos privados, reforçando o encapsulamento dos dados dentro do ficheiro onde são declarados. Ao utilizar sublinhados nas convenções de nomenclatura, os programadores podem melhorar a organização do código e manter um controlo rigoroso sobre a acessibilidade dos componentes da classe.",
                                // Bengali
                                "বাংলা": "ভিডিওটি গোপনীয়তা বোঝাতে অগ্রণী আন্ডারস্কোর ব্যবহার করে ডার্ট প্রোগ্রামিং-এ ক্লাস এবং তাদের বৈশিষ্ট্য/পদ্ধতি রক্ষার ধারণা নিয়ে আলোচনা করে। বিশেষভাবে, টিউটোরিয়ালটি দেখায় কিভাবে একটি ক্লাস, যেমন MyAppState, প্রাইভেট করা যায় যাতে এটি শুধুমাত্র একই ফাইলের মধ্যে যেখানে এটি সংজ্ঞায়িত করা হয়েছে সেখানে অ্যাক্সেস এবং ম্যানিপুলেট করা যায়। এই অনুশীলনটি নিশ্চিত করে যে কোডের কিছু উপাদান যেমন প্রশ্ন সূচী বা উত্তরপ্রশ্ন ফাংশন, বাহ্যিক ব্যবহার থেকে সীমাবদ্ধ, অ্যাপ্লিকেশনটিতে সম্ভাব্য বাগ বা অসঙ্গতি প্রতিরোধ করে। প্রশিক্ষক ব্যাখ্যা করেছেন যে যদিও এই পরিবর্তনটি প্রসাধনী বলে মনে হতে পারে, ডার্টের আন্ডারস্কোর সিনট্যাক্স জনসাধারণকে ব্যক্তিগত উপাদান থেকে আলাদা করে, যেখানে সেগুলি ঘোষণা করা হয়েছে সেই ফাইলের মধ্যে ডেটা এনক্যাপসুলেশন প্রয়োগ করে। নামকরণের নিয়মে আন্ডারস্কোর ব্যবহার করে, বিকাশকারীরা কোড সংগঠনকে উন্নত করতে পারে এবং শ্রেণি উপাদানগুলির অ্যাক্সেসযোগ্যতার উপর কঠোর নিয়ন্ত্রণ বজায় রাখতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "يناقش الفيديو مفهوم حماية الفئات وخصائصها/طرقها في برمجة Dart باستخدام الشرطة السفلية للإشارة إلى الخصوصية. على وجه التحديد، يوضح البرنامج التعليمي كيفية جعل فئة، مثل MyAppState، خاصة بحيث لا يمكن الوصول إليها ومعالجتها إلا داخل نفس الملف الذي تم تعريفها فيه. تضمن هذه الممارسة أن مكونات معينة من الكود، مثل فهرس السؤال أو دالة answerQuestion، مقيدة من الاستخدام الخارجي، مما يمنع الأخطاء المحتملة أو التناقضات في التطبيق. يشرح المدرب أنه على الرغم من أن هذا التغيير قد يبدو تجميليًا، فإن بناء جملة الشرطة السفلية في Dart يميز العناصر العامة عن الخاصة، مما يفرض تغليف البيانات داخل الملف حيث يتم إعلانها. من خلال الاستفادة من الشرطة السفلية في اتفاقيات التسمية، يمكن للمطورين تحسين تنظيم الكود والحفاظ على سيطرة صارمة على إمكانية الوصول إلى مكونات الفئة.",
                                // Persian
                                "فارسی": "این ویدئو مفهوم حفاظت از کلاس ها و خواص/روش های آن ها را در برنامه نویسی دارت با استفاده از زیرخط های پیشرو برای نشان دادن حریم خصوصی مورد بحث قرار می دهد. به طور خاص، این آموزش نشان می دهد که چگونه یک کلاس مانند MyAppState را خصوصی کنید تا فقط در همان فایلی که در آن تعریف شده است قابل دسترسی و دستکاری باشد. این عمل تضمین می‌کند که اجزای خاصی از کد، مانند نمایه سؤال یا تابع پاسخ سؤال، از استفاده خارجی محدود می‌شوند و از اشکالات یا ناسازگاری‌های احتمالی در برنامه جلوگیری می‌کند. مدرس توضیح می دهد که اگرچه این تغییر ممکن است زیبا به نظر برسد، دستور زیر خط در دارت، عناصر عمومی را از خصوصی متمایز می کند و محصورسازی داده ها را در فایلی که در آن اعلان می شوند، اعمال می کند. با استفاده از زیرخط در قراردادهای نامگذاری، توسعه دهندگان می توانند سازماندهی کد را بهبود بخشند و کنترل دقیقی بر دسترسی به اجزای کلاس داشته باشند.",
                            },
                        },
                        // 31 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Creating a New, Custom Widget",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video tutorial introduces the concept of input data in Dart programming within the context of creating custom widgets in Flutter. The instructor demonstrates the process of creating a new widget called 'question' within a separate file named question.dart to enhance code organization and reusability. By passing input data to the 'question' widget through its constructor, developers can efficiently manage data within the widget and optimize UI updates based on external changes. The tutorial emphasizes the importance of using separate files for individual widgets to streamline code management and enhance app performance. Additionally, the instructor explains the significance of marking widget properties as 'final' to prevent unwanted data changes within stateless widgets, promoting code clarity and effective data handling practices. Through practical demonstrations, viewers are guided on how to structure and style custom widgets to improve app functionality and maintain code consistency.",
                                // German
                                "Deutsch": "Das Video-Tutorial führt das Konzept der Eingabedaten in der Dart-Programmierung im Kontext der Erstellung benutzerdefinierter Widgets in Flutter ein. Der Kursleiter demonstriert den Prozess der Erstellung eines neuen Widgets namens „Frage“ in einer separaten Datei namens question.dart, um die Codeorganisation und Wiederverwendbarkeit zu verbessern. Indem sie Eingabedaten über seinen Konstruktor an das Widget „Frage“ übergeben, können Entwickler Daten innerhalb des Widgets effizient verwalten und UI-Updates basierend auf externen Änderungen optimieren. Das Tutorial betont die Bedeutung der Verwendung separater Dateien für einzelne Widgets, um die Codeverwaltung zu optimieren und die App-Leistung zu verbessern. Darüber hinaus erklärt der Kursleiter die Bedeutung der Kennzeichnung von Widget-Eigenschaften als „final“, um unerwünschte Datenänderungen in zustandslosen Widgets zu verhindern und so die Codeklarheit und effektive Datenhandhabungspraktiken zu fördern. Durch praktische Demonstrationen wird den Zuschauern gezeigt, wie sie benutzerdefinierte Widgets strukturieren und gestalten können, um die App-Funktionalität zu verbessern und die Codekonsistenz aufrechtzuerhalten.",
                                // Chinese
                                "中国人": "视频教程在 Flutter 中创建自定义小部件的背景下介绍了 Dart 编程中的输入数据概念。讲师演示了在名为 question.dart 的单独文件中创建名为“question”的新小部件的过程，以增强代码组织和可重用性。通过其构造函数将输入数据传递给“question”小部件，开发人员可以有效地管理小部件内的数据并根据外部变化优化 UI 更新。本教程强调了对各个小部件使用单独的文件以简化代码管理和提高应用性能的重要性。此外，讲师还解释了将小部件属性标记为“final”的重要性，以防止无状态小部件内不必要的数据更改，促进代码清晰度和有效的数据处理实践。通过实际演示，观众将了解如何构造和设计自定义小部件以改进应用功能并保持代码一致性。",
                                // Russian
                                "Русский": "Видеоурок знакомит с концепцией входных данных в программировании Dart в контексте создания пользовательских виджетов во Flutter. Инструктор демонстрирует процесс создания нового виджета с именем «вопрос» в отдельном файле с именем question.dart для улучшения организации кода и возможности повторного использования. Передавая входные данные в виджет «вопрос» через его конструктор, разработчики могут эффективно управлять данными в виджете и оптимизировать обновления пользовательского интерфейса на основе внешних изменений. В уроке подчеркивается важность использования отдельных файлов для отдельных виджетов для упрощения управления кодом и повышения производительности приложения. Кроме того, инструктор объясняет важность маркировки свойств виджета как «окончательный» для предотвращения нежелательных изменений данных в виджетах без сохранения состояния, что способствует ясности кода и эффективным методам обработки данных. С помощью практических демонстраций зрители узнают, как структурировать и оформлять пользовательские виджеты для улучшения функциональности приложения и поддержания согласованности кода.",
                                // French
                                "Français": "Le didacticiel vidéo présente le concept de données d'entrée dans la programmation Dart dans le contexte de la création de widgets personnalisés dans Flutter. L'instructeur démontre le processus de création d'un nouveau widget appelé « question » dans un fichier distinct nommé question.dart pour améliorer l'organisation et la réutilisabilité du code. En transmettant les données d'entrée au widget « question » via son constructeur, les développeurs peuvent gérer efficacement les données dans le widget et optimiser les mises à jour de l'interface utilisateur en fonction des modifications externes. Le didacticiel souligne l'importance d'utiliser des fichiers distincts pour les widgets individuels afin de rationaliser la gestion du code et d'améliorer les performances de l'application. De plus, l'instructeur explique l'importance de marquer les propriétés des widgets comme « finales » pour éviter les modifications de données indésirables dans les widgets sans état, favorisant ainsi la clarté du code et des pratiques efficaces de gestion des données. Grâce à des démonstrations pratiques, les spectateurs sont guidés sur la manière de structurer et de styliser des widgets personnalisés pour améliorer la fonctionnalité de l'application et maintenir la cohérence du code.",
                                // Japanese
                                "日本語": "ビデオチュートリアルでは、Flutter でカスタムウィジェットを作成するという文脈で、Dart プログラミングにおける入力データの概念を紹介します。講師は、コードの整理と再利用性を高めるために、question.dart という別のファイル内に「question」という新しいウィジェットを作成するプロセスを実演します。コンストラクターを介して「question」ウィジェットに入力データを渡すことで、開発者はウィジェット内のデータを効率的に管理し、外部の変更に基づいて UI の更新を最適化できます。チュートリアルでは、コード管理を合理化し、アプリのパフォーマンスを向上させるために、個々のウィジェットに個別のファイルを使用することの重要性を強調しています。さらに、講師は、ステートレスウィジェット内での不要なデータ変更を防ぎ、コードの明確さと効果的なデータ処理方法を促進するために、ウィジェットのプロパティを「final」としてマークすることの重要性を説明します。実践的なデモンストレーションを通じて、視聴者はカスタムウィジェットを構造化してスタイル設定し、アプリの機能を向上させ、コードの一貫性を維持する方法を学習します。",
                                // Korean
                                "한국인": "비디오 튜토리얼은 Flutter에서 사용자 정의 위젯을 만드는 맥락에서 Dart 프로그래밍의 입력 데이터 개념을 소개합니다. 강사는 코드 구성과 재사용성을 향상시키기 위해 question.dart라는 별도의 파일 내에 'question'이라는 새 위젯을 만드는 프로세스를 보여줍니다. 생성자를 통해 'question' 위젯에 입력 데이터를 전달함으로써 개발자는 위젯 내에서 데이터를 효율적으로 관리하고 외부 변경 사항에 따라 UI 업데이트를 최적화할 수 있습니다. 이 튜토리얼은 코드 관리를 간소화하고 앱 성능을 향상시키기 위해 개별 위젯에 대해 별도의 파일을 사용하는 것의 중요성을 강조합니다. 또한 강사는 상태 없는 위젯 내에서 원치 않는 데이터 변경을 방지하고 코드 명확성과 효과적인 데이터 처리 관행을 촉진하기 위해 위젯 속성을 '최종'으로 표시하는 것의 중요성을 설명합니다. 실제 데모를 통해 시청자는 앱 기능을 개선하고 코드 일관성을 유지하기 위해 사용자 정의 위젯을 구성하고 스타일을 지정하는 방법을 안내받습니다.",
                                // Spanish
                                "Español": "El videotutorial presenta el concepto de datos de entrada en la programación Dart en el contexto de la creación de widgets personalizados en Flutter. El instructor demuestra el proceso de creación de un nuevo widget llamado 'pregunta' dentro de un archivo separado llamado question.dart para mejorar la organización y reutilización del código. Al pasar datos de entrada al widget 'pregunta' a través de su constructor, los desarrolladores pueden administrar de manera eficiente los datos dentro del widget y optimizar las actualizaciones de la interfaz de usuario en función de los cambios externos. El tutorial enfatiza la importancia de usar archivos separados para widgets individuales para agilizar la administración del código y mejorar el rendimiento de la aplicación. Además, el instructor explica la importancia de marcar las propiedades de los widgets como 'finales' para evitar cambios de datos no deseados dentro de widgets sin estado, lo que promueve la claridad del código y prácticas efectivas de manejo de datos. A través de demostraciones prácticas, se guía a los espectadores sobre cómo estructurar y diseñar widgets personalizados para mejorar la funcionalidad de la aplicación y mantener la coherencia del código.",
                                // Hindi
                                "हिंदी": "वीडियो ट्यूटोरियल फ़्लटर में कस्टम विजेट बनाने के संदर्भ में डार्ट प्रोग्रामिंग में इनपुट डेटा की अवधारणा का परिचय देता है। प्रशिक्षक कोड संगठन और पुन: प्रयोज्यता को बढ़ाने के लिए question.dart नामक एक अलग फ़ाइल के भीतर 'प्रश्न' नामक एक नया विजेट बनाने की प्रक्रिया का प्रदर्शन करता है। अपने कंस्ट्रक्टर के माध्यम से 'प्रश्न' विजेट में इनपुट डेटा पास करके, डेवलपर्स विजेट के भीतर डेटा को कुशलतापूर्वक प्रबंधित कर सकते हैं और बाहरी परिवर्तनों के आधार पर UI अपडेट को अनुकूलित कर सकते हैं। ट्यूटोरियल कोड प्रबंधन को सुव्यवस्थित करने और ऐप प्रदर्शन को बढ़ाने के लिए अलग-अलग विजेट के लिए अलग-अलग फ़ाइलों का उपयोग करने के महत्व पर जोर देता है। इसके अतिरिक्त, प्रशिक्षक स्टेटलेस विजेट के भीतर अवांछित डेटा परिवर्तनों को रोकने, कोड स्पष्टता और प्रभावी डेटा हैंडलिंग प्रथाओं को बढ़ावा देने के लिए विजेट गुणों को 'अंतिम' के रूप में चिह्नित करने के महत्व को समझाता है। व्यावहारिक प्रदर्शनों के माध्यम से, दर्शकों को ऐप की कार्यक्षमता को बेहतर बनाने और कोड की स्थिरता बनाए रखने के लिए कस्टम विजेट की संरचना और स्टाइल करने के तरीके के बारे में निर्देशित किया जाता है।",
                                // Portuguese
                                "Português": "O tutorial em vídeo apresenta o conceito de dados de entrada na programação Dart no contexto da criação de widgets personalizados no Flutter. O instrutor demonstra o processo de criação de um novo widget chamado 'question' num ficheiro separado chamado question.dart para melhorar a organização e a reutilização do código. Ao passar dados de entrada para o widget 'pergunta' através do seu construtor, os programadores podem gerir eficientemente os dados dentro do widget e otimizar as atualizações da IU com base em alterações externas. O tutorial enfatiza a importância de utilizar ficheiros separados para widgets individuais para agilizar a gestão de código e melhorar o desempenho da aplicação. Além disso, o instrutor explica a importância de marcar as propriedades do widget como ‘finais’ para evitar alterações indesejadas de dados em widgets sem estado, promovendo a clareza do código e práticas eficazes de manipulação de dados. Através de demonstrações práticas, os espectadores são orientados sobre como estruturar e estilizar widgets personalizados para melhorar a funcionalidade da aplicação e manter a consistência do código.",
                                // Bengali
                                "বাংলা": "ভিডিও টিউটোরিয়ালটি ফ্লটারে কাস্টম উইজেট তৈরির প্রেক্ষাপটে ডার্ট প্রোগ্রামিং-এ ইনপুট ডেটার ধারণার পরিচয় দেয়। প্রশিক্ষক কোড সংগঠন এবং পুনঃব্যবহারযোগ্যতা উন্নত করতে question.dart নামে একটি পৃথক ফাইলের মধ্যে 'প্রশ্ন' নামে একটি নতুন উইজেট তৈরির প্রক্রিয়া প্রদর্শন করেন। কনস্ট্রাক্টরের মাধ্যমে 'প্রশ্ন' উইজেটে ইনপুট ডেটা প্রেরণ করে, বিকাশকারীরা দক্ষতার সাথে উইজেটের মধ্যে ডেটা পরিচালনা করতে পারে এবং বাহ্যিক পরিবর্তনের উপর ভিত্তি করে UI আপডেটগুলি অপ্টিমাইজ করতে পারে। টিউটোরিয়ালটি কোড ম্যানেজমেন্টকে স্ট্রীমলাইন করতে এবং অ্যাপের কর্মক্ষমতা বাড়াতে পৃথক উইজেটের জন্য আলাদা ফাইল ব্যবহার করার গুরুত্বের উপর জোর দেয়। অতিরিক্তভাবে, প্রশিক্ষক স্টেটলেস উইজেটগুলির মধ্যে অবাঞ্ছিত ডেটা পরিবর্তন রোধ করতে, কোডের স্বচ্ছতা এবং কার্যকর ডেটা হ্যান্ডলিং অনুশীলনগুলিকে উন্নীত করতে উইজেট বৈশিষ্ট্যগুলিকে 'চূড়ান্ত' হিসাবে চিহ্নিত করার তাত্পর্য ব্যাখ্যা করেন। ব্যবহারিক প্রদর্শনের মাধ্যমে, অ্যাপের কার্যকারিতা উন্নত করতে এবং কোডের সামঞ্জস্য বজায় রাখতে কীভাবে কাস্টম উইজেট গঠন ও স্টাইল করতে হয় সে বিষয়ে দর্শকদের নির্দেশিত করা হয়।",
                                // Arabic
                                "عَرَبِيّ": "يقدم البرنامج التعليمي بالفيديو مفهوم بيانات الإدخال في برمجة Dart في سياق إنشاء عناصر واجهة مستخدم مخصصة في Flutter. يوضح المدرب عملية إنشاء عنصر واجهة مستخدم جديد يسمى 'question' داخل ملف منفصل يسمى question.dart لتحسين تنظيم التعليمات البرمجية وإعادة استخدامها. من خلال تمرير بيانات الإدخال إلى عنصر واجهة المستخدم 'question' من خلال منشئه، يمكن للمطورين إدارة البيانات بكفاءة داخل العنصر وتحسين تحديثات واجهة المستخدم بناءً على التغييرات الخارجية. يؤكد البرنامج التعليمي على أهمية استخدام ملفات منفصلة لعناصر واجهة المستخدم الفردية لتبسيط إدارة التعليمات البرمجية وتحسين أداء التطبيق. بالإضافة إلى ذلك، يشرح المدرب أهمية وضع علامة على خصائص عنصر واجهة المستخدم على أنها 'نهائية' لمنع تغييرات البيانات غير المرغوب فيها داخل عناصر واجهة المستخدم عديمة الجنسية، وتعزيز وضوح التعليمات البرمجية وممارسات التعامل مع البيانات الفعّالة. من خلال العروض التوضيحية العملية، يتم توجيه المشاهدين حول كيفية هيكلة عناصر واجهة المستخدم المخصصة وتصميمها لتحسين وظائف التطبيق والحفاظ على اتساق التعليمات البرمجية.",
                                // Persian
                                "فارسی": "این آموزش تصویری مفهوم داده های ورودی در برنامه نویسی دارت را در چارچوب ایجاد ویجت های سفارشی در فلاتر معرفی می کند. مربی فرآیند ایجاد یک ویجت جدید به نام 'سوال' را در یک فایل جداگانه به نام question.dart نشان می دهد تا سازماندهی کد و قابلیت استفاده مجدد را افزایش دهد. با ارسال داده‌های ورودی به ویجت «پرسش» از طریق سازنده آن، توسعه‌دهندگان می‌توانند به‌طور مؤثر داده‌های درون ویجت را مدیریت کرده و به‌روزرسانی‌های رابط کاربری را بر اساس تغییرات خارجی بهینه کنند. این آموزش بر اهمیت استفاده از فایل‌های جداگانه برای ویجت‌های جداگانه برای ساده‌سازی مدیریت کد و بهبود عملکرد برنامه تأکید می‌کند. علاوه بر این، مربی اهمیت علامت‌گذاری ویژگی‌های ویجت را به‌عنوان «نهایی» برای جلوگیری از تغییرات ناخواسته داده در ویجت‌های بدون حالت، ارتقای وضوح کد و شیوه‌های مدیریت مؤثر داده توضیح می‌دهد. از طریق نمایش های عملی، بینندگان در مورد چگونگی ساختار و استایل ویجت های سفارشی برای بهبود عملکرد برنامه و حفظ ثبات کد راهنمایی می شوند.",
                            },
                        },
                        // 32 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "First Styling & Layouting Steps",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the instructor guides viewers on styling text within a Flutter app by utilizing custom widgets and named arguments. By demonstrating the use of the style and textAlign arguments within the text widget, developers are shown how to enhance the visual appearance of text elements. The instructor explains how to apply a text style object to adjust font size and utilize text align for proper alignment, followed by showcasing the importance of utilizing the container widget to control spacing and alignment. Through practical examples, viewers learn about the margin property of the container widget and how to leverage EdgeInsetsGeometry for precise spacing adjustments within the app layout. By breaking down complex styling concepts and demonstrating their practical application, the tutorial emphasizes the importance of structuring code efficiently with custom widgets to enhance app performance and manage code complexity effectively.",
                                // German
                                "Deutsch": "In diesem Tutorial zeigt der Kursleiter den Zuschauern, wie man Text in einer Flutter-App formatiert, indem er benutzerdefinierte Widgets und benannte Argumente verwendet. Durch die Demonstration der Verwendung der Argumente „style“ und „textAlign“ im Text-Widget wird Entwicklern gezeigt, wie sie das visuelle Erscheinungsbild von Textelementen verbessern können. Der Kursleiter erklärt, wie man ein Textstilobjekt anwendet, um die Schriftgröße anzupassen und „text align“ für die richtige Ausrichtung zu verwenden. Anschließend zeigt er, wie wichtig es ist, das Container-Widget zur Steuerung von Abstand und Ausrichtung zu verwenden. Anhand praktischer Beispiele lernen die Zuschauer die Ränderigenschaft des Container-Widgets kennen und erfahren, wie sie EdgeInsetsGeometry für präzise Abstandsanpassungen im App-Layout nutzen können. Indem das Tutorial komplexe Formatierungskonzepte aufschlüsselt und ihre praktische Anwendung demonstriert, betont es, wie wichtig es ist, Code effizient mit benutzerdefinierten Widgets zu strukturieren, um die App-Leistung zu verbessern und die Codekomplexität effektiv zu verwalten.",
                                // Chinese
                                "中国人": "在本教程中，讲师将指导观众使用自定义小部件和命名参数在 Flutter 应用中设置文本样式。通过演示文本小部件中 style 和 textAlign 参数的使用，向开发人员展示如何增强文本元素的视觉外观。讲师将解释如何应用文本样式对象来调整字体大小以及如何利用文本对齐进行正确对齐，然后展示利用容器小部件控制间距和对齐的重要性。通过实际示例，观众可以了解容器小部件的边距属性以及如何利用 EdgeInsetsGeometry 在应用布局中精确调整间距。通过分解复杂的样式概念并展示其实际应用，本教程强调了使用自定义小部件有效构建代码以提高应用性能和有效管理代码复杂性的重要性。",
                                // Russian
                                "Русский": "В этом уроке инструктор направляет зрителей по стилизации текста в приложении Flutter, используя пользовательские виджеты и именованные аргументы. Демонстрируя использование аргументов style и textAlign в текстовом виджете, разработчикам показывают, как улучшить внешний вид текстовых элементов. Инструктор объясняет, как применять объект стиля текста для настройки размера шрифта и использовать выравнивание текста для правильного выравнивания, а затем демонстрирует важность использования виджета-контейнера для управления интервалами и выравниванием. На практических примерах зрители узнают о свойстве margin виджета-контейнера и о том, как использовать EdgeInsetsGeometry для точной регулировки интервалов в макете приложения. Разбирая сложные концепции стилизации и демонстрируя их практическое применение, учебник подчеркивает важность эффективного структурирования кода с помощью пользовательских виджетов для повышения производительности приложения и эффективного управления сложностью кода.",
                                // French
                                "Français": "Dans ce didacticiel, l'instructeur guide les utilisateurs sur le style du texte dans une application Flutter en utilisant des widgets personnalisés et des arguments nommés. En démontrant l'utilisation des arguments style et textAlign dans le widget de texte, les développeurs apprennent à améliorer l'apparence visuelle des éléments de texte. L'instructeur explique comment appliquer un objet de style de texte pour ajuster la taille de la police et utiliser l'alignement du texte pour un alignement correct, puis montre l'importance d'utiliser le widget conteneur pour contrôler l'espacement et l'alignement. Grâce à des exemples pratiques, les utilisateurs découvrent la propriété margin du widget conteneur et comment exploiter EdgeInsetsGeometry pour des ajustements d'espacement précis dans la mise en page de l'application. En décomposant des concepts de style complexes et en démontrant leur application pratique, le didacticiel souligne l'importance de structurer efficacement le code avec des widgets personnalisés pour améliorer les performances de l'application et gérer efficacement la complexité du code.",
                                // Japanese
                                "日本語": "このチュートリアルでは、インストラクターが、カスタム ウィジェットと名前付き引数を利用して、Flutter アプリ内のテキストをスタイル設定する方法を視聴者に指導します。テキスト ウィジェット内での style 引数と textAlign 引数の使用方法を示すことで、開発者はテキスト要素の外観を向上させる方法を学びます。インストラクターは、テキスト スタイル オブジェクトを適用してフォント サイズを調整し、テキスト配置を使用して適切な配置を設定する方法を説明し、続いて、コンテナー ウィジェットを使用して間隔と配置を制御することの重要性を紹介します。実用的な例を通じて、視聴者はコンテナー ウィジェットの margin プロパティについて学び、EdgeInsetsGeometry を使用してアプリ レイアウト内で正確な間隔調整を行う方法を学びます。複雑なスタイル設定の概念を分解し、その実際の適用方法を示すことで、このチュートリアルでは、カスタム ウィジェットを使用してコードを効率的に構造化し、アプリのパフォーマンスを向上させ、コードの複雑さを効果的に管理することの重要性を強調しています。",
                                // Korean
                                "한국인": "이 튜토리얼에서 강사는 사용자 정의 위젯과 명명된 인수를 활용하여 Flutter 앱 내에서 텍스트 스타일을 지정하는 방법을 시청자에게 안내합니다. 텍스트 위젯 내에서 style 및 textAlign 인수를 사용하는 방법을 보여줌으로써 개발자는 텍스트 요소의 시각적 모양을 개선하는 방법을 보여줍니다. 강사는 텍스트 스타일 객체를 적용하여 글꼴 크기를 조정하고 적절한 정렬을 위해 text align을 사용하는 방법을 설명한 다음, 컨테이너 위젯을 사용하여 간격과 정렬을 제어하는 ​​것의 중요성을 보여줍니다. 시청자는 실제 예제를 통해 컨테이너 위젯의 margin 속성과 앱 레이아웃 내에서 정확한 간격 조정을 위해 EdgeInsetsGeometry를 활용하는 방법을 배웁니다. 복잡한 스타일 개념을 분석하고 실제 적용을 보여줌으로써 이 튜토리얼은 앱 성능을 향상하고 코드 복잡성을 효과적으로 관리하기 위해 사용자 정의 위젯으로 코드를 효율적으로 구성하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este tutorial, el instructor guía a los espectadores sobre cómo aplicar estilo al texto dentro de una aplicación Flutter mediante el uso de widgets personalizados y argumentos con nombre. Al demostrar el uso de los argumentos style y textAlign dentro del widget text, se muestra a los desarrolladores cómo mejorar la apariencia visual de los elementos de texto. El instructor explica cómo aplicar un objeto de estilo de texto para ajustar el tamaño de fuente y utilizar text align para una alineación adecuada, seguido de mostrar la importancia de utilizar el widget contenedor para controlar el espaciado y la alineación. A través de ejemplos prácticos, los espectadores aprenden sobre la propiedad margin del widget contenedor y cómo aprovechar EdgeInsetsGeometry para realizar ajustes de espaciado precisos dentro del diseño de la aplicación. Al desglosar conceptos de estilo complejos y demostrar su aplicación práctica, el tutorial enfatiza la importancia de estructurar el código de manera eficiente con widgets personalizados para mejorar el rendimiento de la aplicación y administrar la complejidad del código de manera efectiva.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, प्रशिक्षक कस्टम विजेट और नामित तर्कों का उपयोग करके फ़्लटर ऐप के भीतर टेक्स्ट को स्टाइल करने के बारे में दर्शकों को मार्गदर्शन करता है। टेक्स्ट विजेट के भीतर स्टाइल और टेक्स्टएलाइन तर्कों के उपयोग का प्रदर्शन करके, डेवलपर्स को दिखाया जाता है कि टेक्स्ट तत्वों के दृश्य स्वरूप को कैसे बढ़ाया जाए। प्रशिक्षक बताते हैं कि फ़ॉन्ट आकार को समायोजित करने और उचित संरेखण के लिए टेक्स्ट एलाइन का उपयोग करने के लिए टेक्स्ट स्टाइल ऑब्जेक्ट को कैसे लागू किया जाए, इसके बाद स्पेसिंग और संरेखण को नियंत्रित करने के लिए कंटेनर विजेट का उपयोग करने के महत्व को प्रदर्शित किया जाता है। व्यावहारिक उदाहरणों के माध्यम से, दर्शक कंटेनर विजेट की मार्जिन प्रॉपर्टी के बारे में सीखते हैं और ऐप लेआउट के भीतर सटीक स्पेसिंग समायोजन के लिए EdgeInsetsGeometry का लाभ कैसे उठाया जाए। जटिल स्टाइलिंग अवधारणाओं को तोड़कर और उनके व्यावहारिक अनुप्रयोग का प्रदर्शन करके, ट्यूटोरियल ऐप प्रदर्शन को बढ़ाने और कोड जटिलता को प्रभावी ढंग से प्रबंधित करने के लिए कस्टम विजेट के साथ कुशलतापूर्वक कोड को संरचित करने के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o instrutor orienta os visualizadores sobre como estilizar o texto numa aplicação Flutter utilizando widgets personalizados e argumentos nomeados. Ao demonstrar a utilização dos argumentos style e textAlign no widget de texto, os programadores aprendem como melhorar a aparência visual dos elementos de texto. O formador explica como aplicar um objeto de estilo de texto para ajustar o tamanho da letra e utilizar o alinhamento do texto para o alinhamento adequado, seguido de mostrar a importância de utilizar o widget contentor para controlar o espaçamento e o alinhamento. Através de exemplos práticos, os visualizadores aprendem sobre a propriedade margin do widget de contentor e como tirar partido do EdgeInsetsGeometry para ajustes precisos de espaçamento no layout da aplicação. Ao detalhar conceitos complexos de estilo e demonstrar a sua aplicação prática, o tutorial enfatiza a importância de estruturar o código de forma eficiente com widgets personalizados para melhorar o desempenho da aplicação e gerir a complexidade do código de forma eficaz.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, প্রশিক্ষক কাস্টম উইজেট এবং নামযুক্ত আর্গুমেন্ট ব্যবহার করে একটি ফ্লাটার অ্যাপের মধ্যে পাঠ্য স্টাইল করার বিষয়ে দর্শকদের গাইড করেন। টেক্সট উইজেটের মধ্যে স্টাইল এবং টেক্সট অ্যালাইন আর্গুমেন্টের ব্যবহার প্রদর্শন করে, ডেভেলপারদের দেখানো হয় কিভাবে টেক্সট এলিমেন্টের ভিজ্যুয়াল চেহারা বাড়ানো যায়। প্রশিক্ষক ব্যাখ্যা করেন কিভাবে ফন্টের আকার সামঞ্জস্য করতে একটি পাঠ্য শৈলী অবজেক্ট প্রয়োগ করতে হয় এবং সঠিক প্রান্তিককরণের জন্য পাঠ্য সারিবদ্ধকরণ ব্যবহার করতে হয়, তারপর ব্যবধান এবং প্রান্তিককরণ নিয়ন্ত্রণ করতে ধারক উইজেট ব্যবহারের গুরুত্ব প্রদর্শন করে। ব্যবহারিক উদাহরণের মাধ্যমে, দর্শকরা কন্টেইনার উইজেটের মার্জিন সম্পত্তি এবং অ্যাপ লেআউটের মধ্যে সুনির্দিষ্ট ব্যবধান সামঞ্জস্যের জন্য EdgeInsetsGeometry কীভাবে লাভ করতে হয় সে সম্পর্কে শিখে। জটিল স্টাইলিং ধারণাগুলি ভেঙ্গে এবং তাদের ব্যবহারিক প্রয়োগ প্রদর্শন করে, টিউটোরিয়ালটি অ্যাপের কার্যকারিতা উন্নত করতে এবং কোড জটিলতা কার্যকরভাবে পরিচালনা করতে কাস্টম উইজেটগুলির সাথে দক্ষতার সাথে কোড গঠনের গুরুত্বের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يرشد المدرب المشاهدين إلى تصميم النص داخل تطبيق Flutter باستخدام عناصر واجهة مستخدم مخصصة وحجج مسماة. من خلال إظهار استخدام حجج style وtextAlign داخل عنصر واجهة المستخدم النصي، يتم عرض كيفية تحسين المظهر المرئي لعناصر النص للمطورين. يشرح المدرب كيفية تطبيق كائن نمط النص لضبط حجم الخط واستخدام text align للمحاذاة الصحيحة، يليه عرض أهمية استخدام عنصر واجهة المستخدم الحاوية للتحكم في التباعد والمحاذاة. من خلال الأمثلة العملية، يتعلم المشاهدون عن خاصية الهامش لعنصر واجهة المستخدم الحاوية وكيفية الاستفادة من EdgeInsetsGeometry لتعديلات التباعد الدقيقة داخل تخطيط التطبيق. من خلال تقسيم مفاهيم التصميم المعقدة وإظهار تطبيقها العملي، يؤكد البرنامج التعليمي على أهمية هيكلة التعليمات البرمجية بكفاءة باستخدام عناصر واجهة مستخدم مخصصة لتحسين أداء التطبيق وإدارة تعقيد التعليمات البرمجية بشكل فعال.",
                                // Persian
                                "فارسی": "در این آموزش، مدرس بینندگان را با استفاده از ابزارک‌های سفارشی و آرگومان‌های نام‌گذاری شده، در مورد سبک‌دهی متن در اپلیکیشن Flutter راهنمایی می‌کند. با نشان دادن استفاده از آرگومان های سبک و textAlign در ویجت متن، به توسعه دهندگان نشان داده می شود که چگونه ظاهر بصری عناصر متن را بهبود بخشند. مدرس نحوه اعمال یک شی سبک متن را برای تنظیم اندازه فونت و استفاده از تراز متن برای تراز مناسب توضیح می دهد و به دنبال آن اهمیت استفاده از ویجت ظرف برای کنترل فاصله و تراز را نشان می دهد. از طریق مثال‌های عملی، بینندگان با ویژگی حاشیه ویجت کانتینر و نحوه استفاده از EdgeInsetsGeometry برای تنظیمات دقیق فاصله در طرح‌بندی برنامه آشنا می‌شوند. با تجزیه مفاهیم پیچیده استایل و نشان دادن کاربرد عملی آنها، این آموزش بر اهمیت ساختار کد به طور کارآمد با ویجت های سفارشی برای افزایش عملکرد برنامه و مدیریت موثر پیچیدگی کد تأکید می کند.",
                            },
                        },
                        // 33 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Enums & Multiple Constructors",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the instructor delves into the Dart features of TextAlign.center and EdgeInsets.all, explaining these features that aid in creating objects in different variants within Flutter. The tutorial highlights how to explore the source code by examining these features to understand their inner workings. Additionally, the instructor discusses EdgeInsets as a class that extends EdgeInsetsGeometry, showcasing the multiple special constructors and their functionality in creating objects with different configurations. Through practical examples and explanations, viewers gain insights into how these Dart features and constructors enable efficient configuration and customization for objects in Flutter application development.",
                                // German
                                "Deutsch": "In diesem Tutorial befasst sich der Kursleiter mit den Dart-Funktionen von TextAlign.center und EdgeInsets.all und erklärt diese Funktionen, die beim Erstellen von Objekten in verschiedenen Varianten in Flutter helfen. Das Tutorial zeigt, wie man den Quellcode durch Untersuchung dieser Funktionen erkunden kann, um ihre Funktionsweise zu verstehen. Darüber hinaus erörtert der Kursleiter EdgeInsets als Klasse, die EdgeInsetsGeometry erweitert, und zeigt die verschiedenen speziellen Konstruktoren und ihre Funktionalität beim Erstellen von Objekten mit unterschiedlichen Konfigurationen. Durch praktische Beispiele und Erklärungen erhalten die Zuschauer Einblicke, wie diese Dart-Funktionen und -Konstruktoren eine effiziente Konfiguration und Anpassung von Objekten bei der Entwicklung von Flutter-Anwendungen ermöglichen.",
                                // Chinese
                                "中国人": "在本教程中，讲师将深入研究 TextAlign.center 和 EdgeInsets.all 的 Dart 功能，解释这些功能如何帮助在 Flutter 中创建不同变体的对象。本教程重点介绍如何通过检查这些功能来探索源代码，以了解其内部工作原理。此外，讲师还将讨论 EdgeInsets 作为扩展 EdgeInsetsGeometry 的类，展示多个特殊构造函数及其在创建具有不同配置的对象中的功能。通过实际示例和解释，观众可以深入了解这些 Dart 功能和构造函数如何在 Flutter 应用程序开发中实现对象的高效配置和自定义。",
                                // Russian
                                "Русский": "В этом уроке инструктор углубляется в функции Dart TextAlign.center и EdgeInsets.all, объясняя эти функции, которые помогают создавать объекты в различных вариантах во Flutter. В уроке подчеркивается, как исследовать исходный код, изучая эти функции, чтобы понять их внутреннюю работу. Кроме того, инструктор обсуждает EdgeInsets как класс, который расширяет EdgeInsetsGeometry, демонстрируя несколько специальных конструкторов и их функциональность при создании объектов с различными конфигурациями. С помощью практических примеров и объяснений зрители получают представление о том, как эти функции и конструкторы Dart обеспечивают эффективную конфигурацию и настройку объектов при разработке приложений Flutter.",
                                // French
                                "Français": "Dans ce didacticiel, l'instructeur se penche sur les fonctionnalités Dart de TextAlign.center et EdgeInsets.all, expliquant ces fonctionnalités qui aident à créer des objets dans différentes variantes dans Flutter. Le didacticiel met en évidence comment explorer le code source en examinant ces fonctionnalités pour comprendre leur fonctionnement interne. De plus, l'instructeur présente EdgeInsets en tant que classe qui étend EdgeInsetsGeometry, présentant les multiples constructeurs spéciaux et leur fonctionnalité dans la création d'objets avec différentes configurations. Grâce à des exemples pratiques et des explications, les spectateurs découvrent comment ces fonctionnalités et constructeurs Dart permettent une configuration et une personnalisation efficaces des objets dans le développement d'applications Flutter.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講師が TextAlign.center と EdgeInsets.all の Dart 機能について詳しく解説し、Flutter 内でさまざまなバリアントのオブジェクトを作成するのに役立つこれらの機能について説明します。このチュートリアルでは、これらの機能を調べて内部の仕組みを理解し、ソース コードを調べる方法を強調します。さらに、講師は EdgeInsets を EdgeInsetsGeometry を拡張するクラスとして説明し、複数の特別なコンストラクターと、さまざまな構成のオブジェクトを作成するためのそれらの機能を紹介します。実用的な例と説明を通じて、視聴者は、これらの Dart 機能とコンストラクターが Flutter アプリケーション開発でオブジェクトの効率的な構成とカスタマイズを可能にする方法について理解を深めることができます。",
                                // Korean
                                "한국인": "이 튜토리얼에서 강사는 TextAlign.center와 EdgeInsets.all의 Dart 기능을 파헤쳐 Flutter 내에서 다양한 변형으로 객체를 만드는 데 도움이 되는 이러한 기능을 설명합니다. 이 튜토리얼은 이러한 기능을 조사하여 소스 코드를 탐색하여 내부 작동 방식을 이해하는 방법을 강조합니다. 또한 강사는 EdgeInsetsGeometry를 확장하는 클래스인 EdgeInsets를 설명하여 다양한 구성으로 객체를 만드는 여러 특수 생성자와 해당 기능을 보여줍니다. 실제 예제와 설명을 통해 시청자는 이러한 Dart 기능과 생성자가 Flutter 애플리케이션 개발에서 객체에 대한 효율적인 구성과 사용자 정의를 가능하게 하는 방법에 대한 통찰력을 얻습니다.",
                                // Spanish
                                "Español": "En este tutorial, el instructor profundiza en las características de Dart de TextAlign.center y EdgeInsets.all, y explica estas características que ayudan a crear objetos en diferentes variantes dentro de Flutter. El tutorial destaca cómo explorar el código fuente examinando estas características para comprender su funcionamiento interno. Además, el instructor analiza EdgeInsets como una clase que extiende EdgeInsetsGeometry, mostrando los múltiples constructores especiales y su funcionalidad para crear objetos con diferentes configuraciones. A través de ejemplos prácticos y explicaciones, los espectadores obtienen información sobre cómo estas características y constructores de Dart permiten una configuración y personalización eficientes de los objetos en el desarrollo de aplicaciones de Flutter.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, प्रशिक्षक TextAlign.center और EdgeInsets.all की डार्ट विशेषताओं के बारे में विस्तार से बताता है, इन विशेषताओं को समझाता है जो फ़्लटर के भीतर विभिन्न प्रकारों में ऑब्जेक्ट बनाने में सहायता करती हैं। ट्यूटोरियल इन विशेषताओं की जांच करके उनके आंतरिक कामकाज को समझने के लिए स्रोत कोड का पता लगाने के तरीके पर प्रकाश डालता है। इसके अतिरिक्त, प्रशिक्षक EdgeInsets को एक वर्ग के रूप में चर्चा करता है जो EdgeInsetsGeometry का विस्तार करता है, विभिन्न कॉन्फ़िगरेशन वाले ऑब्जेक्ट बनाने में कई विशेष कंस्ट्रक्टर और उनकी कार्यक्षमता को प्रदर्शित करता है। व्यावहारिक उदाहरणों और स्पष्टीकरणों के माध्यम से, दर्शक इस बारे में जानकारी प्राप्त करते हैं कि कैसे ये डार्ट सुविधाएँ और कंस्ट्रक्टर फ़्लटर एप्लिकेशन विकास में ऑब्जेक्ट के लिए कुशल कॉन्फ़िगरेशन और अनुकूलन सक्षम करते हैं।",
                                // Portuguese
                                "Português": "Neste tutorial, o instrutor aprofunda as funcionalidades Dart do TextAlign.center e do EdgeInsets.all, explicando estas funcionalidades que auxiliam na criação de objetos em diferentes variantes no Flutter. O tutorial destaca como explorar o código-fonte examinando estas características para compreender o seu funcionamento interno. Além disso, o instrutor aborda o EdgeInsets como uma classe que estende o EdgeInsetsGeometry, apresentando os vários construtores especiais e a sua funcionalidade na criação de objetos com diferentes configurações. Através de exemplos práticos e explicações, os visualizadores obtêm insights sobre como estas características e construtores do Dart permitem uma configuração e personalização eficientes para objetos no desenvolvimento de aplicações Flutter.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, প্রশিক্ষক TextAlign.center এবং EdgeInsets.all-এর ডার্ট বৈশিষ্ট্যগুলি নিয়ে আলোচনা করেছেন, এই বৈশিষ্ট্যগুলি ব্যাখ্যা করেছেন যা Flutter-এর মধ্যে বিভিন্ন ভেরিয়েন্টে বস্তু তৈরি করতে সহায়তা করে৷ টিউটোরিয়াল হাইলাইট করে যে কীভাবে এই বৈশিষ্ট্যগুলি পরীক্ষা করে তাদের অভ্যন্তরীণ কাজগুলি বোঝার জন্য উত্স কোডটি অন্বেষণ করতে হয়। উপরন্তু, প্রশিক্ষক EdgeInsets কে একটি শ্রেণী হিসাবে আলোচনা করেন যা EdgeInsetsGeometry প্রসারিত করে, একাধিক বিশেষ কনস্ট্রাক্টর এবং বিভিন্ন কনফিগারেশন সহ বস্তু তৈরিতে তাদের কার্যকারিতা প্রদর্শন করে। ব্যবহারিক উদাহরণ এবং ব্যাখ্যার মাধ্যমে, দর্শকরা কীভাবে এই ডার্ট বৈশিষ্ট্যগুলি এবং কনস্ট্রাক্টরগুলি ফ্লটার অ্যাপ্লিকেশন ডেভেলপমেন্টে বস্তুগুলির জন্য দক্ষ কনফিগারেশন এবং কাস্টমাইজেশন সক্ষম করে সে সম্পর্কে অন্তর্দৃষ্টি অর্জন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يتعمق المدرب في ميزات Dart الخاصة بـ TextAlign.center وEdgeInsets.all، موضحًا هذه الميزات التي تساعد في إنشاء كائنات بأشكال مختلفة داخل Flutter. يسلط البرنامج التعليمي الضوء على كيفية استكشاف الكود المصدر من خلال فحص هذه الميزات لفهم عملها الداخلي. بالإضافة إلى ذلك، يناقش المدرب EdgeInsets كفئة تمتد إلى EdgeInsetsGeometry، ويعرض العديد من المنشئين الخاصين ووظائفهم في إنشاء كائنات بتكوينات مختلفة. من خلال الأمثلة العملية والشروحات، يكتسب المشاهدون رؤى حول كيفية تمكين ميزات Dart والمنشئين هذه للتكوين والتخصيص الفعالين للكائنات في تطوير تطبيقات Flutter.",
                                // Persian
                                "فارسی": "در این آموزش، مدرس ویژگی‌های Dart TextAlign.center و EdgeInsets.all را بررسی می‌کند و این ویژگی‌ها را توضیح می‌دهد که به ایجاد اشیاء در انواع مختلف در Flutter کمک می‌کنند. این آموزش نحوه کشف کد منبع را با بررسی این ویژگی ها برای درک عملکرد درونی آنها برجسته می کند. علاوه بر این، مدرس EdgeInsets را به عنوان کلاسی که EdgeInsetsGeometry را گسترش می‌دهد، بحث می‌کند و سازنده‌های ویژه متعدد و عملکرد آنها در ایجاد اشیاء با پیکربندی‌های مختلف را نشان می‌دهد. از طریق مثال‌ها و توضیحات عملی، بینندگان بینش‌هایی در مورد اینکه چگونه این ویژگی‌ها و سازنده‌های Dart پیکربندی و سفارشی‌سازی کارآمد را برای اشیاء در توسعه برنامه Flutter می‌کنند، به دست می‌آورند.",
                            },
                        },
                        // 34 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Official Docs & The Widget Catalog",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the instructor explores the documentation and widgets catalog on flutter.dev to gain a deeper understanding of widget configurations and features in Flutter. By navigating the official documentation, viewers learn how to access detailed explanations and examples of various widgets available in Flutter, such as layout widgets like container, column, and row. The tutorial emphasizes the importance of utilizing the official documentation to explore different widget properties, constructors, and behaviors, enabling developers to enhance their understanding and effectively utilize Flutter and Dart functionalities in app development projects. Through practical demonstrations and explanations, viewers are encouraged to leverage the resources available in the Flutter documentation to further their knowledge and proficiency in utilizing various Flutter features.",
                                // German
                                "Deutsch": "In diesem Tutorial erkundet der Kursleiter die Dokumentation und den Widget-Katalog auf flutter.dev, um ein tieferes Verständnis der Widget-Konfigurationen und -Funktionen in Flutter zu erlangen. Durch das Navigieren in der offiziellen Dokumentation erfahren die Zuschauer, wie sie auf detaillierte Erklärungen und Beispiele verschiedener in Flutter verfügbarer Widgets zugreifen können, z. B. Layout-Widgets wie Container, Spalte und Zeile. Das Tutorial betont, wie wichtig es ist, die offizielle Dokumentation zu verwenden, um verschiedene Widget-Eigenschaften, -Konstruktoren und -Verhaltensweisen zu erkunden, damit Entwickler ihr Verständnis verbessern und Flutter- und Dart-Funktionen in App-Entwicklungsprojekten effektiv nutzen können. Durch praktische Demonstrationen und Erklärungen werden die Zuschauer ermutigt, die in der Flutter-Dokumentation verfügbaren Ressourcen zu nutzen, um ihr Wissen und ihre Kompetenz bei der Nutzung verschiedener Flutter-Funktionen zu erweitern.",
                                // Chinese
                                "中国人": "在本教程中，讲师将探索 flutter.dev 上的文档和小部件目录，以更深入地了解 Flutter 中的小部件配置和功能。通过浏览官方文档，观众可以了解如何访问 Flutter 中可用的各种小部件的详细说明和示例，例如容器、列和行等布局小部件。本教程强调了利用官方文档探索不同小部件属性、构造函数和行为的重要性，使开发人员能够增强理解并在应用开发项目中有效利用 Flutter 和 Dart 功能。通过实际的演示和解释，鼓励观众利用 Flutter 文档中提供的资源来进一步了解和熟练使用各种 Flutter 功能。",
                                // Russian
                                "Русский": "В этом руководстве инструктор изучает документацию и каталог виджетов на flutter.dev, чтобы глубже понять конфигурации и функции виджетов во Flutter. Просматривая официальную документацию, зрители узнают, как получить доступ к подробным объяснениям и примерам различных виджетов, доступных во Flutter, таких как виджеты макета, такие как контейнер, столбец и строка. В руководстве подчеркивается важность использования официальной документации для изучения различных свойств виджетов, конструкторов и поведения, что позволяет разработчикам улучшить свое понимание и эффективно использовать функциональные возможности Flutter и Dart в проектах по разработке приложений. С помощью практических демонстраций и объяснений зрителям предлагается использовать ресурсы, доступные в документации Flutter, для расширения своих знаний и навыков в использовании различных функций Flutter.",
                                // French
                                "Français": "Dans ce didacticiel, l'instructeur explore la documentation et le catalogue de widgets sur flutter.dev pour mieux comprendre les configurations et les fonctionnalités des widgets dans Flutter. En parcourant la documentation officielle, les spectateurs apprennent à accéder à des explications détaillées et à des exemples de divers widgets disponibles dans Flutter, tels que les widgets de mise en page tels que les conteneurs, les colonnes et les lignes. Le didacticiel souligne l'importance d'utiliser la documentation officielle pour explorer différentes propriétés, constructeurs et comportements de widgets, permettant aux développeurs d'améliorer leur compréhension et d'utiliser efficacement les fonctionnalités Flutter et Dart dans les projets de développement d'applications. Grâce à des démonstrations et des explications pratiques, les spectateurs sont encouragés à exploiter les ressources disponibles dans la documentation Flutter pour approfondir leurs connaissances et leurs compétences dans l'utilisation de diverses fonctionnalités de Flutter.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講師が flutter.dev のドキュメントとウィジェット カタログを調べて、Flutter のウィジェット構成と機能についてより深く理解します。公式ドキュメントを参照することで、視聴者はコンテナ、列、行などのレイアウト ウィジェットなど、Flutter で使用できるさまざまなウィジェットの詳細な説明と例にアクセスする方法を学びます。このチュートリアルでは、公式ドキュメントを利用してさまざまなウィジェットのプロパティ、コンストラクター、動作を調べることの重要性を強調し、開発者が理解を深め、アプリ開発プロジェクトで Flutter と Dart の機能を効果的に活用できるようにします。実践的なデモンストレーションと説明を通じて、視聴者は Flutter ドキュメントで利用できるリソースを活用して、さまざまな Flutter 機能を利用するための知識と習熟度をさらに高めることができます。",
                                // Korean
                                "한국인": "이 튜토리얼에서 강사는 flutter.dev의 문서와 위젯 카탈로그를 탐색하여 Flutter의 위젯 구성과 기능에 대한 더 깊은 이해를 얻습니다. 시청자는 공식 문서를 탐색하여 컨테이너, 열, 행과 같은 레이아웃 위젯과 같이 Flutter에서 사용할 수 있는 다양한 위젯에 대한 자세한 설명과 예제에 액세스하는 방법을 배웁니다. 이 튜토리얼은 공식 문서를 활용하여 다양한 위젯 속성, 생성자 및 동작을 탐색하는 것의 중요성을 강조하여 개발자가 앱 개발 프로젝트에서 Flutter 및 Dart 기능에 대한 이해를 높이고 효과적으로 활용할 수 있도록 합니다. 시청자는 실제 데모와 설명을 통해 Flutter 문서에서 제공하는 리소스를 활용하여 다양한 Flutter 기능을 활용하는 데 대한 지식과 능숙도를 높이도록 권장합니다.",
                                // Spanish
                                "Español": "En este tutorial, el instructor explora la documentación y el catálogo de widgets en flutter.dev para comprender mejor las configuraciones y características de los widgets en Flutter. Al navegar por la documentación oficial, los espectadores aprenden a acceder a explicaciones detalladas y ejemplos de varios widgets disponibles en Flutter, como widgets de diseño como contenedor, columna y fila. El tutorial enfatiza la importancia de utilizar la documentación oficial para explorar diferentes propiedades, constructores y comportamientos de widgets, lo que permite a los desarrolladores mejorar su comprensión y utilizar de manera eficaz las funcionalidades de Flutter y Dart en proyectos de desarrollo de aplicaciones. A través de demostraciones y explicaciones prácticas, se anima a los espectadores a aprovechar los recursos disponibles en la documentación de Flutter para ampliar sus conocimientos y competencia en el uso de varias funciones de Flutter.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, प्रशिक्षक फ़्लटर में विजेट कॉन्फ़िगरेशन और सुविधाओं की गहरी समझ हासिल करने के लिए flutter.dev पर दस्तावेज़ीकरण और विजेट कैटलॉग का पता लगाता है। आधिकारिक दस्तावेज़ों को नेविगेट करके, दर्शक फ़्लटर में उपलब्ध विभिन्न विजेट्स के विस्तृत स्पष्टीकरण और उदाहरणों तक पहुँचने का तरीका सीखते हैं, जैसे कि कंटेनर, कॉलम और पंक्ति जैसे लेआउट विजेट। ट्यूटोरियल विभिन्न विजेट गुणों, कंस्ट्रक्टर और व्यवहारों का पता लगाने के लिए आधिकारिक दस्तावेज़ों का उपयोग करने के महत्व पर जोर देता है, जिससे डेवलपर्स अपनी समझ को बढ़ा सकते हैं और ऐप डेवलपमेंट प्रोजेक्ट्स में फ़्लटर और डार्ट कार्यक्षमताओं का प्रभावी ढंग से उपयोग कर सकते हैं। व्यावहारिक प्रदर्शनों और स्पष्टीकरणों के माध्यम से, दर्शकों को फ़्लटर दस्तावेज़ों में उपलब्ध संसाधनों का लाभ उठाने के लिए प्रोत्साहित किया जाता है ताकि वे विभिन्न फ़्लटर सुविधाओं का उपयोग करने में अपने ज्ञान और दक्षता को आगे बढ़ा सकें।",
                                // Portuguese
                                "Português": "Neste tutorial, o instrutor explora a documentação e o catálogo de widgets em flutter.dev para obter uma compreensão mais profunda das definições e funcionalidades de widgets em Flutter. Ao navegar na documentação oficial, os visualizadores aprendem como aceder a explicações detalhadas e exemplos de vários widgets disponíveis no Flutter, como widgets de layout como o contentor, a coluna e a linha. O tutorial enfatiza a importância de utilizar a documentação oficial para explorar diferentes propriedades, construtores e comportamentos dos widgets, permitindo aos programadores melhorar a sua compreensão e utilizar eficazmente as funcionalidades Flutter e Dart em projetos de desenvolvimento de aplicações. Através de demonstrações e explicações práticas, os espectadores são encorajados a aproveitar os recursos disponíveis na documentação do Flutter para melhorar o seu conhecimento e proficiência na utilização de vários recursos do Flutter.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, প্রশিক্ষক flutter.dev-তে ডকুমেন্টেশন এবং উইজেট ক্যাটালগ অন্বেষণ করেন যাতে Flutter-এ উইজেট কনফিগারেশন এবং বৈশিষ্ট্যগুলি সম্পর্কে গভীরভাবে বোঝা যায়। অফিসিয়াল ডকুমেন্টেশন নেভিগেট করার মাধ্যমে, দর্শকরা শিখে কিভাবে বিস্তারিত ব্যাখ্যা এবং ফ্লটারে উপলব্ধ বিভিন্ন উইজেটের উদাহরণ, যেমন লেআউট উইজেট যেমন কন্টেইনার, কলাম এবং সারি অ্যাক্সেস করতে হয়। টিউটোরিয়ালটি বিভিন্ন উইজেট বৈশিষ্ট্য, কনস্ট্রাক্টর এবং আচরণগুলি অন্বেষণ করতে অফিসিয়াল ডকুমেন্টেশন ব্যবহার করার গুরুত্বের উপর জোর দেয়, যা ডেভেলপারদের তাদের বোঝাপড়া বাড়াতে এবং অ্যাপ ডেভেলপমেন্ট প্রকল্পগুলিতে ফ্লাটার এবং ডার্ট কার্যকারিতাগুলিকে কার্যকরভাবে ব্যবহার করতে সক্ষম করে। ব্যবহারিক প্রদর্শন এবং ব্যাখ্যার মাধ্যমে, দর্শকদের ফ্লটার ডকুমেন্টেশনে উপলব্ধ সংস্থানগুলিকে কাজে লাগানোর জন্য উত্সাহিত করা হয় যাতে তারা বিভিন্ন ফ্লটার বৈশিষ্ট্যগুলিকে কাজে লাগানোর জন্য তাদের জ্ঞান এবং দক্ষতাকে আরও বাড়িয়ে তোলে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يستكشف المدرب كتالوج الوثائق والأدوات المساعدة على موقع flutter.dev لاكتساب فهم أعمق لتكوينات الأدوات المساعدة وميزاتها في Flutter. من خلال التنقل عبر الوثائق الرسمية، يتعلم المشاهدون كيفية الوصول إلى تفسيرات وأمثلة مفصلة للأدوات المساعدة المختلفة المتاحة في Flutter، مثل أدوات التخطيط مثل الحاوية والعمود والصف. يؤكد البرنامج التعليمي على أهمية الاستفادة من الوثائق الرسمية لاستكشاف خصائص الأدوات المساعدة المختلفة والمنشئين والسلوكيات، مما يتيح للمطورين تعزيز فهمهم والاستفادة بشكل فعال من وظائف Flutter وDart في مشاريع تطوير التطبيقات. من خلال العروض التوضيحية والتوضيحات العملية، يتم تشجيع المشاهدين على الاستفادة من الموارد المتاحة في وثائق Flutter لتعزيز معرفتهم وكفاءتهم في استخدام ميزات Flutter المختلفة.",
                                // Persian
                                "فارسی": "در این آموزش، مدرس اسناد و کاتالوگ ویجت ها را در flutter.dev بررسی می کند تا درک عمیق تری از تنظیمات و ویژگی های ویجت در Flutter به دست آورد. با پیمایش اسناد رسمی، بینندگان نحوه دسترسی به توضیحات دقیق و نمونه‌هایی از ویجت‌های مختلف موجود در Flutter را یاد می‌گیرند، مانند ویجت‌های طرح‌بندی مانند ظرف، ستون و ردیف. این آموزش بر اهمیت استفاده از اسناد رسمی برای کاوش ویژگی‌ها، سازنده‌ها و رفتارهای مختلف ویجت تأکید می‌کند و توسعه‌دهندگان را قادر می‌سازد تا درک خود را افزایش دهند و به طور مؤثر از عملکردهای فلاتر و دارت در پروژه‌های توسعه برنامه استفاده کنند. از طریق نمایش‌ها و توضیحات عملی، بینندگان تشویق می‌شوند تا از منابع موجود در اسناد فلاتر برای افزایش دانش و مهارت خود در استفاده از ویژگی‌های مختلف فلاتر استفاده کنند.",
                            },
                        },
                        // 35 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Passing Callback Functions Around",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video demonstrates how to create custom widgets in Flutter, specifically focusing on creating a separate widget for answer buttons with custom styling. The process involves creating a new stateless widget in a separate file, passing a function pointer as an argument to the widget constructor, and using this function pointer to trigger a function defined in the main widget. This concept of passing functions as arguments facilitates communication between different widgets in Flutter, allowing for efficient state management and functionality implementation.",
                                // German
                                "Deutsch": "Das Video zeigt, wie man in Flutter benutzerdefinierte Widgets erstellt, wobei der Schwerpunkt auf der Erstellung eines separaten Widgets für Antwortschaltflächen mit benutzerdefiniertem Stil liegt. Der Vorgang umfasst das Erstellen eines neuen zustandslosen Widgets in einer separaten Datei, das Übergeben eines Funktionszeigers als Argument an den Widget-Konstruktor und das Verwenden dieses Funktionszeigers zum Auslösen einer im Haupt-Widget definierten Funktion. Dieses Konzept der Übergabe von Funktionen als Argumente erleichtert die Kommunikation zwischen verschiedenen Widgets in Flutter und ermöglicht eine effiziente Zustandsverwaltung und Funktionsimplementierung.",
                                // Chinese
                                "中国人": "该视频演示了如何在 Flutter 中创建自定义小部件，特别侧重于为具有自定义样式的答案按钮创建单独的小部件。该过程包括在单独的文件中创建一个新的无状态小部件，将函数指针作为参数传递给小部件构造函数，并使用此函数指针触发主小部件中定义的函数。将函数作为参数传递的概念促进了 Flutter 中不同小部件之间的通信，从而实现了高效的状态管理和功能实现。",
                                // Russian
                                "Русский": "Видео демонстрирует, как создавать пользовательские виджеты во Flutter, уделяя особое внимание созданию отдельного виджета для кнопок ответа с пользовательским стилем. Процесс включает создание нового виджета без состояния в отдельном файле, передачу указателя функции в качестве аргумента конструктору виджета и использование этого указателя функции для запуска функции, определенной в основном виджете. Эта концепция передачи функций в качестве аргументов облегчает взаимодействие между различными виджетами во Flutter, позволяя эффективно управлять состоянием и реализовывать функциональность.",
                                // French
                                "Français": "La vidéo montre comment créer des widgets personnalisés dans Flutter, en se concentrant spécifiquement sur la création d'un widget distinct pour les boutons de réponse avec un style personnalisé. Le processus consiste à créer un nouveau widget sans état dans un fichier séparé, à transmettre un pointeur de fonction comme argument au constructeur du widget et à utiliser ce pointeur de fonction pour déclencher une fonction définie dans le widget principal. Ce concept de transmission de fonctions comme arguments facilite la communication entre différents widgets dans Flutter, permettant une gestion efficace de l'état et une implémentation des fonctionnalités.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter でカスタム ウィジェットを作成する方法、特にカスタム スタイルの回答ボタン用の別のウィジェットの作成方法を説明します。プロセスには、別のファイルに新しいステートレス ウィジェットを作成し、ウィジェット コンストラクターに関数ポインターを引数として渡し、この関数ポインターを使用してメイン ウィジェットで定義された関数をトリガーすることが含まれます。関数を引数として渡すというこの概念により、Flutter のさまざまなウィジェット間の通信が容易になり、効率的な状態管理と機能の実装が可能になります。",
                                // Korean
                                "한국인": "이 비디오는 Flutter에서 사용자 정의 위젯을 만드는 방법을 보여주며, 특히 사용자 정의 스타일이 있는 답변 버튼에 대한 별도 위젯을 만드는 데 중점을 둡니다. 이 프로세스에는 별도 파일에 새 상태 없는 위젯을 만들고, 위젯 생성자에 인수로 함수 포인터를 전달하고, 이 함수 포인터를 사용하여 기본 위젯에 정의된 함수를 트리거하는 것이 포함됩니다. 함수를 인수로 전달하는 이 개념은 Flutter에서 서로 다른 위젯 간의 통신을 용이하게 하여 효율적인 상태 관리와 기능 구현을 가능하게 합니다.",
                                // Spanish
                                "Español": "El video muestra cómo crear widgets personalizados en Flutter, centrándose específicamente en la creación de un widget independiente para botones de respuesta con estilo personalizado. El proceso implica crear un nuevo widget sin estado en un archivo independiente, pasar un puntero de función como argumento al constructor del widget y usar este puntero de función para activar una función definida en el widget principal. Este concepto de pasar funciones como argumentos facilita la comunicación entre diferentes widgets en Flutter, lo que permite una gestión de estado y una implementación de funcionalidad eficientes.",
                                // Hindi
                                "हिंदी": "वीडियो में दिखाया गया है कि फ़्लटर में कस्टम विजेट कैसे बनाएं, खास तौर पर कस्टम स्टाइलिंग के साथ उत्तर बटन के लिए एक अलग विजेट बनाने पर ध्यान केंद्रित किया गया है। इस प्रक्रिया में एक अलग फ़ाइल में एक नया स्टेटलेस विजेट बनाना, विजेट कंस्ट्रक्टर को एक तर्क के रूप में फ़ंक्शन पॉइंटर पास करना और मुख्य विजेट में परिभाषित फ़ंक्शन को ट्रिगर करने के लिए इस फ़ंक्शन पॉइंटर का उपयोग करना शामिल है। फ़ंक्शन को तर्क के रूप में पास करने की यह अवधारणा फ़्लटर में विभिन्न विजेट के बीच संचार को सुविधाजनक बनाती है, जिससे कुशल राज्य प्रबंधन और कार्यक्षमता कार्यान्वयन की अनुमति मिलती है।",
                                // Portuguese
                                "Português": "O vídeo demonstra como criar widgets personalizados no Flutter, focando-se especificamente na criação de um widget separado para botões de resposta com estilo personalizado. O processo envolve a criação de um novo widget sem estado num ficheiro separado, passando um ponteiro de função como argumento para o construtor do widget e utilizando esse ponteiro de função para acionar uma função definida no widget principal. Este conceito de passar funções como argumentos facilita a comunicação entre diferentes widgets no Flutter, permitindo uma gestão eficiente do estado e implementação de funcionalidades.",
                                // Bengali
                                "বাংলা": "ভিডিওটি দেখায় কিভাবে ফ্লটারে কাস্টম উইজেট তৈরি করা যায়, বিশেষভাবে কাস্টম স্টাইলিং সহ উত্তর বোতামগুলির জন্য একটি পৃথক উইজেট তৈরির উপর ফোকাস করা। প্রক্রিয়াটির মধ্যে একটি পৃথক ফাইলে একটি নতুন স্টেটলেস উইজেট তৈরি করা, উইজেট কনস্ট্রাক্টরের কাছে একটি যুক্তি হিসাবে একটি ফাংশন পয়েন্টার পাস করা এবং প্রধান উইজেটে সংজ্ঞায়িত একটি ফাংশন ট্রিগার করতে এই ফাংশন পয়েন্টার ব্যবহার করা জড়িত। আর্গুমেন্ট হিসাবে ফাংশন পাস করার এই ধারণাটি ফ্লটারে বিভিন্ন উইজেটগুলির মধ্যে যোগাযোগের সুবিধা দেয়, দক্ষ রাষ্ট্র পরিচালনা এবং কার্যকারিতা বাস্তবায়নের অনুমতি দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو كيفية إنشاء عناصر واجهة مستخدم مخصصة في Flutter، مع التركيز بشكل خاص على إنشاء عنصر واجهة مستخدم منفصل لأزرار الإجابة بتصميم مخصص. تتضمن العملية إنشاء عنصر واجهة مستخدم جديد بدون حالة في ملف منفصل، وتمرير مؤشر وظيفة كحجة إلى منشئ عنصر واجهة المستخدم، واستخدام مؤشر الوظيفة هذا لتشغيل وظيفة محددة في عنصر واجهة المستخدم الرئيسي. يسهل مفهوم تمرير الوظائف كحجة الاتصال بين عناصر واجهة المستخدم المختلفة في Flutter، مما يسمح بإدارة الحالة وتنفيذ الوظائف بكفاءة.",
                                // Persian
                                "فارسی": "این ویدئو نحوه ایجاد ویجت‌های سفارشی در Flutter را نشان می‌دهد، به‌ویژه تمرکز بر ایجاد یک ویجت جداگانه برای دکمه‌های پاسخ با استایل سفارشی. این فرآیند شامل ایجاد یک ویجت بدون حالت جدید در یک فایل جداگانه، ارسال نشانگر تابع به عنوان آرگومان به سازنده ویجت و استفاده از این نشانگر تابع برای فعال کردن یک تابع تعریف شده در ویجت اصلی است. این مفهوم انتقال توابع به عنوان آرگومان، ارتباط بین ویجت‌های مختلف در Flutter را تسهیل می‌کند و امکان مدیریت کارآمد حالت و اجرای عملکرد را فراهم می‌کند.",
                            },
                        },
                        // 36 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Introducing Maps",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explains how to pass functions as arguments to widgets in Flutter to enable interaction between widgets. It demonstrates customizing button text and styling, such as changing text color to white. The focus then shifts to creating more complex question objects using maps in Dart, where questions are no longer just strings but contain additional information like answer choices. By utilizing maps as a simple data structure, the video shows how to create multiple questions with corresponding answer options efficiently without the need for custom classes, providing insight into Dart language features for managing data structures in Flutter development.",
                                // German
                                "Deutsch": "Das Video erklärt, wie man Funktionen als Argumente an Widgets in Flutter übergibt, um die Interaktion zwischen Widgets zu ermöglichen. Es zeigt, wie man Schaltflächentext und -stil anpasst, z. B. die Textfarbe auf Weiß ändert. Der Fokus verschiebt sich dann auf das Erstellen komplexerer Frageobjekte mithilfe von Maps in Dart, wo Fragen nicht mehr nur Zeichenfolgen sind, sondern zusätzliche Informationen wie Antwortmöglichkeiten enthalten. Durch die Verwendung von Maps als einfache Datenstruktur zeigt das Video, wie man effizient mehrere Fragen mit entsprechenden Antwortoptionen erstellt, ohne dass benutzerdefinierte Klassen erforderlich sind, und bietet Einblick in die Dart-Sprachfunktionen zum Verwalten von Datenstrukturen in der Flutter-Entwicklung.",
                                // Chinese
                                "中国人": "视频介绍了如何将函数作为参数传递给 Flutter 中的小部件，以实现小部件之间的交互。它演示了自定义按钮文本和样式，例如将文本颜色更改为白色。然后，重点转移到使用 Dart 中的映射创建更复杂的问题对象，其中问题不再只是字符串，还包含其他信息，例如答案选项。通过将映射用作简单的数据结构，视频展示了如何高效地创建具有相应答案选项的多个问题，而无需自定义类，从而深入了解了用于管理 Flutter 开发中的数据结构的 Dart 语言功能。",
                                // Russian
                                "Русский": "Видео объясняет, как передавать функции в качестве аргументов виджетам во Flutter, чтобы обеспечить взаимодействие между виджетами. Оно демонстрирует настройку текста и стиля кнопок, например, изменение цвета текста на белый. Затем фокус смещается на создание более сложных объектов вопросов с использованием карт в Dart, где вопросы больше не являются просто строками, а содержат дополнительную информацию, например, варианты ответов. Используя карты как простую структуру данных, видео показывает, как эффективно создавать несколько вопросов с соответствующими вариантами ответов без необходимости в пользовательских классах, предоставляя представление о функциях языка Dart для управления структурами данных при разработке Flutter.",
                                // French
                                "Français": "La vidéo explique comment transmettre des fonctions en tant qu'arguments aux widgets dans Flutter pour permettre l'interaction entre les widgets. Elle montre comment personnaliser le texte et le style des boutons, comme changer la couleur du texte en blanc. L'accent est ensuite mis sur la création d'objets de questions plus complexes à l'aide de cartes dans Dart, où les questions ne sont plus seulement des chaînes mais contiennent des informations supplémentaires comme des choix de réponses. En utilisant des cartes comme structure de données simple, la vidéo montre comment créer efficacement plusieurs questions avec des options de réponse correspondantes sans avoir besoin de classes personnalisées, offrant un aperçu des fonctionnalités du langage Dart pour la gestion des structures de données dans le développement Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、ウィジェット間のインタラクションを可能にするために、Flutter のウィジェットに関数を引数として渡す方法を説明しています。ボタンのテキストとスタイルをカスタマイズする方法 (テキストの色を白に変更するなど) を実演しています。次に、Dart のマップを使用してより複雑な質問オブジェクトを作成することに焦点が移ります。質問は単なる文字列ではなく、回答の選択肢などの追加情報が含まれます。マップを単純なデータ構造として利用することで、ビデオでは、カスタム クラスを必要とせずに、対応する回答オプションを持つ複数の質問を効率的に作成する方法を示し、Flutter 開発でデータ構造を管理するための Dart 言語機能についての洞察を提供します。",
                                // Korean
                                "한국인": "이 비디오는 Flutter에서 위젯 간의 상호 작용을 가능하게 하기 위해 함수를 인수로 위젯에 전달하는 방법을 설명합니다. 버튼 텍스트와 스타일을 사용자 정의하는 방법(예: 텍스트 색상을 흰색으로 변경)을 보여줍니다. 그런 다음 Dart에서 맵을 사용하여 더 복잡한 질문 객체를 만드는 것으로 초점을 옮기는데, 여기서 질문은 더 이상 단순한 문자열이 아니라 답변 선택지와 같은 추가 정보를 포함합니다. 이 비디오는 맵을 간단한 데이터 구조로 활용하여 사용자 정의 클래스 없이도 해당 답변 옵션이 있는 여러 질문을 효율적으로 만드는 방법을 보여주며, Flutter 개발에서 데이터 구조를 관리하기 위한 Dart 언어 기능에 대한 통찰력을 제공합니다.",
                                // Spanish
                                "Español": "El video explica cómo pasar funciones como argumentos a los widgets en Flutter para permitir la interacción entre ellos. Demuestra cómo personalizar el texto y el estilo de los botones, como cambiar el color del texto a blanco. Luego, el enfoque se centra en la creación de objetos de preguntas más complejos mediante mapas en Dart, donde las preguntas ya no son solo cadenas, sino que contienen información adicional, como opciones de respuesta. Al utilizar mapas como una estructura de datos simple, el video muestra cómo crear múltiples preguntas con las opciones de respuesta correspondientes de manera eficiente sin la necesidad de clases personalizadas, lo que brinda información sobre las características del lenguaje Dart para administrar estructuras de datos en el desarrollo de Flutter.",
                                // Hindi
                                "हिंदी": "वीडियो में बताया गया है कि फ़्लटर में विजेट्स के बीच इंटरेक्शन को सक्षम करने के लिए फ़ंक्शन को तर्क के रूप में कैसे पास किया जाए। यह बटन टेक्स्ट और स्टाइलिंग को कस्टमाइज़ करने का प्रदर्शन करता है, जैसे कि टेक्स्ट का रंग बदलकर सफ़ेद करना। फिर फ़ोकस डार्ट में मैप्स का उपयोग करके अधिक जटिल प्रश्न ऑब्जेक्ट बनाने पर जाता है, जहाँ प्रश्न अब केवल स्ट्रिंग नहीं होते हैं, बल्कि उनमें उत्तर विकल्प जैसी अतिरिक्त जानकारी होती है। मैप्स को एक सरल डेटा संरचना के रूप में उपयोग करके, वीडियो दिखाता है कि कस्टम क्लास की आवश्यकता के बिना कुशलतापूर्वक संबंधित उत्तर विकल्पों के साथ कई प्रश्न कैसे बनाएं, फ़्लटर विकास में डेटा संरचनाओं के प्रबंधन के लिए डार्ट भाषा सुविधाओं में अंतर्दृष्टि प्रदान करते हैं।",
                                // Portuguese
                                "Português": "O vídeo explica como passar funções como argumentos para widgets no Flutter para permitir a interação entre widgets. Demonstra a personalização do texto e do estilo do botão, como alterar a cor do texto para branco. O foco passa então para a criação de objetos de perguntas mais complexos utilizando mapas no Dart, onde as perguntas já não são apenas strings, mas contêm informações adicionais, como opções de resposta. Ao utilizar mapas como uma estrutura de dados simples, o vídeo mostra como criar múltiplas perguntas com opções de resposta correspondentes de forma eficiente, sem a necessidade de classes personalizadas, fornecendo informações sobre as capacidades da linguagem Dart para gerir estruturas de dados no desenvolvimento do Flutter .",
                                // Bengali
                                "বাংলা": "ভিডিওটি ব্যাখ্যা করে কিভাবে উইজেটগুলির মধ্যে মিথস্ক্রিয়া সক্ষম করতে ফ্লটারে উইজেটগুলিতে আর্গুমেন্ট হিসাবে ফাংশনগুলি পাস করতে হয়৷ এটি কাস্টমাইজিং বোতাম পাঠ্য এবং স্টাইলিং প্রদর্শন করে, যেমন পাঠ্যের রঙ সাদাতে পরিবর্তন করা। ফোকাস তারপরে ডার্টে মানচিত্র ব্যবহার করে আরও জটিল প্রশ্ন অবজেক্ট তৈরিতে স্থানান্তরিত হয়, যেখানে প্রশ্নগুলি আর কেবল স্ট্রিং নয় বরং উত্তর পছন্দের মতো অতিরিক্ত তথ্য থাকে। একটি সাধারণ ডেটা স্ট্রাকচার হিসাবে মানচিত্রকে ব্যবহার করে, ভিডিওটি দেখায় যে কীভাবে কাস্টম ক্লাসের প্রয়োজন ছাড়াই দক্ষতার সাথে সংশ্লিষ্ট উত্তর বিকল্পগুলির সাথে একাধিক প্রশ্ন তৈরি করা যায়, ফ্লটার ডেভেলপমেন্টে ডেটা স্ট্রাকচার পরিচালনার জন্য ডার্ট ভাষার বৈশিষ্ট্যগুলির অন্তর্দৃষ্টি প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو كيفية تمرير الدوال كحجج إلى عناصر واجهة المستخدم في Flutter لتمكين التفاعل بين عناصر واجهة المستخدم. كما يوضح كيفية تخصيص نص الزر وتصميمه، مثل تغيير لون النص إلى الأبيض. ثم ينتقل التركيز إلى إنشاء كائنات أسئلة أكثر تعقيدًا باستخدام الخرائط في Dart، حيث لم تعد الأسئلة مجرد سلاسل ولكنها تحتوي على معلومات إضافية مثل خيارات الإجابة. من خلال استخدام الخرائط كبنية بيانات بسيطة، يوضح الفيديو كيفية إنشاء أسئلة متعددة مع خيارات الإجابة المقابلة بكفاءة دون الحاجة إلى فئات مخصصة، مما يوفر نظرة ثاقبة لميزات لغة Dart لإدارة هياكل البيانات في تطوير Flutter.",
                                // Persian
                                "فارسی": "این ویدیو توضیح می دهد که چگونه توابع را به عنوان آرگومان به ویجت ها در Flutter منتقل کنیم تا تعامل بین ویجت ها را فعال کنیم. سفارشی کردن متن و استایل دکمه مانند تغییر رنگ متن به سفید را نشان می دهد. سپس تمرکز روی ایجاد اشیاء سوال پیچیده‌تر با استفاده از نقشه‌ها در Dart تغییر می‌کند، جایی که سوالات دیگر فقط رشته‌ای نیستند، بلکه حاوی اطلاعات اضافی مانند گزینه‌های پاسخ هستند. با استفاده از نقشه ها به عنوان یک ساختار داده ساده، این ویدئو نشان می دهد که چگونه می توان چندین سوال را با گزینه های پاسخ متناظر به طور موثر و بدون نیاز به کلاس های سفارشی ایجاد کرد و بینشی در مورد ویژگی های زبان دارت برای مدیریت ساختارهای داده در توسعه Flutter ارائه می دهد.",
                            },
                        },
                        // 37 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Mapping Lists to Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explains the process of dynamically creating answer widgets in Flutter based on selected questions using maps in Dart. By mapping a list of questions into a list of widgets, the video demonstrates how to transform data structures efficiently, passing values and functions as needed. The tutorial covers accessing specific keys in maps using square brackets, handling errors with Dart type inference, and utilizing the spread operator to avoid nested lists when adding widgets to a column. The video showcases the concept of transformation and iteration in Flutter development, allowing for the creation of dynamic UI elements based on data structures.",
                                // German
                                "Deutsch": "Das Video erklärt den Prozess der dynamischen Erstellung von Antwort-Widgets in Flutter basierend auf ausgewählten Fragen mithilfe von Maps in Dart. Durch die Zuordnung einer Fragenliste zu einer Widgetliste zeigt das Video, wie Datenstrukturen effizient transformiert werden und Werte und Funktionen nach Bedarf übergeben werden. Das Tutorial behandelt den Zugriff auf bestimmte Schlüssel in Maps mithilfe von eckigen Klammern, die Fehlerbehandlung mit Dart-Typinferenz und die Verwendung des Spread-Operators, um verschachtelte Listen beim Hinzufügen von Widgets zu einer Spalte zu vermeiden. Das Video zeigt das Konzept der Transformation und Iteration in der Flutter-Entwicklung und ermöglicht die Erstellung dynamischer UI-Elemente basierend auf Datenstrukturen.",
                                // Chinese
                                "中国人": "视频解释了如何使用 Dart 中的映射根据选定的问题在 Flutter 中动态创建答案小部件的过程。通过将问题列表映射到小部件列表，视频演示了如何高效地转换数据结构，并根据需要传递值和函数。本教程介绍了如何使用方括号访问映射中的特定键、使用 Dart 类型推断处理错误，以及在将小部件添加到列时使用扩展运算符避免嵌套列表。视频展示了 Flutter 开发中的转换和迭代概念，允许基于数据结构创建动态 UI 元素。",
                                // Russian
                                "Русский": "Видео объясняет процесс динамического создания виджетов ответов во Flutter на основе выбранных вопросов с использованием карт в Dart. Сопоставляя список вопросов со списком виджетов, видео демонстрирует, как эффективно преобразовывать структуры данных, передавая значения и функции по мере необходимости. В руководстве рассматривается доступ к определенным ключам в картах с использованием квадратных скобок, обработка ошибок с помощью вывода типов Dart и использование оператора распространения для избежания вложенных списков при добавлении виджетов в столбец. Видео демонстрирует концепцию преобразования и итерации в разработке Flutter, что позволяет создавать динамические элементы пользовательского интерфейса на основе структур данных.",
                                // French
                                "Français": "La vidéo explique le processus de création dynamique de widgets de réponse dans Flutter en fonction de questions sélectionnées à l'aide de cartes dans Dart. En mappant une liste de questions dans une liste de widgets, la vidéo montre comment transformer efficacement les structures de données, en transmettant des valeurs et des fonctions selon les besoins. Le didacticiel couvre l'accès à des clés spécifiques dans les cartes à l'aide de crochets, la gestion des erreurs avec l'inférence de type Dart et l'utilisation de l'opérateur de propagation pour éviter les listes imbriquées lors de l'ajout de widgets à une colonne. La vidéo présente le concept de transformation et d'itération dans le développement Flutter, permettant la création d'éléments d'interface utilisateur dynamiques basés sur des structures de données.",
                                // Japanese
                                "日本語": "このビデオでは、Dart のマップを使用して、選択した質問に基づいて Flutter で回答ウィジェットを動的に作成するプロセスについて説明します。質問のリストをウィジェットのリストにマッピングすることで、必要に応じて値と関数を渡し、データ構造を効率的に変換する方法をビデオで示します。チュートリアルでは、角括弧を使用してマップ内の特定のキーにアクセスする方法、Dart の型推論でエラーを処理する方法、列にウィジェットを追加するときにスプレッド演算子を使用してネストされたリストを回避する方法について説明します。このビデオでは、Flutter 開発における変換と反復の概念を紹介し、データ構造に基づいて動的な UI 要素を作成できるようにします。",
                                // Korean
                                "한국인": "이 비디오는 Dart의 맵을 사용하여 선택한 질문에 따라 Flutter에서 동적으로 답변 위젯을 만드는 프로세스를 설명합니다. 질문 목록을 위젯 목록에 매핑하여 비디오는 필요에 따라 값과 함수를 전달하여 데이터 구조를 효율적으로 변환하는 방법을 보여줍니다. 이 튜토리얼은 대괄호를 사용하여 맵의 특정 키에 액세스하고, Dart 유형 추론을 사용하여 오류를 처리하고, 열에 위젯을 추가할 때 중첩된 목록을 피하기 위해 스프레드 연산자를 활용하는 방법을 다룹니다. 이 비디오는 Flutter 개발에서 변환 및 반복의 개념을 보여주며, 이를 통해 데이터 구조에 따라 동적 UI 요소를 만들 수 있습니다.",
                                // Spanish
                                "Español": "El video explica el proceso de creación dinámica de widgets de respuesta en Flutter en función de preguntas seleccionadas mediante mapas en Dart. Al mapear una lista de preguntas en una lista de widgets, el video demuestra cómo transformar estructuras de datos de manera eficiente, pasando valores y funciones según sea necesario. El tutorial cubre el acceso a claves específicas en mapas mediante corchetes, el manejo de errores con la inferencia de tipo de Dart y el uso del operador de propagación para evitar listas anidadas al agregar widgets a una columna. El video muestra el concepto de transformación e iteración en el desarrollo de Flutter, lo que permite la creación de elementos de IU dinámicos basados ​​en estructuras de datos.",
                                // Hindi
                                "हिंदी": "वीडियो में डार्ट में मैप्स का उपयोग करके चयनित प्रश्नों के आधार पर फ़्लटर में उत्तर विजेट को गतिशील रूप से बनाने की प्रक्रिया को समझाया गया है। विजेट्स की सूची में प्रश्नों की सूची को मैप करके, वीडियो दर्शाता है कि डेटा संरचनाओं को कुशलतापूर्वक कैसे बदला जाए, आवश्यकतानुसार मान और फ़ंक्शन पास किए जाएं। ट्यूटोरियल में स्क्वायर ब्रैकेट का उपयोग करके मैप्स में विशिष्ट कुंजियों तक पहुँचने, डार्ट प्रकार अनुमान के साथ त्रुटियों को संभालने और कॉलम में विजेट जोड़ते समय नेस्टेड सूचियों से बचने के लिए स्प्रेड ऑपरेटर का उपयोग करने को शामिल किया गया है। वीडियो फ़्लटर विकास में परिवर्तन और पुनरावृत्ति की अवधारणा को प्रदर्शित करता है, जिससे डेटा संरचनाओं के आधार पर गतिशील UI तत्वों के निर्माण की अनुमति मिलती है।",
                                // Portuguese
                                "Português": "O vídeo explica o processo de criação dinâmica de widgets de resposta no Flutter com base em perguntas selecionadas utilizando mapas no Dart. Ao mapear uma lista de perguntas numa lista de widgets, o vídeo demonstra como transformar estruturas de dados de forma eficiente, passando valores e funções conforme necessário. O tutorial aborda o acesso a chaves específicas em mapas utilizando parêntesis rectos, o tratamento de erros com inferência do tipo Dart e a utilização do operador spread para evitar listas aninhadas ao adicionar widgets a uma coluna. O vídeo mostra o conceito de transformação e iteração no desenvolvimento do Flutter, permitindo a criação de elementos de UI dinâmicos baseados em estruturas de dados.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ডার্ট-এ মানচিত্র ব্যবহার করে নির্বাচিত প্রশ্নের উপর ভিত্তি করে ফ্লটারে উত্তর উইজেট তৈরি করার প্রক্রিয়া ব্যাখ্যা করে। উইজেটগুলির একটি তালিকায় প্রশ্নগুলির একটি তালিকা ম্যাপ করে, ভিডিওটি দেখায় কিভাবে দক্ষতার সাথে ডেটা স্ট্রাকচার রূপান্তর করা যায়, প্রয়োজনীয় মান এবং ফাংশন পাস করে। টিউটোরিয়ালটি বর্গাকার বন্ধনী ব্যবহার করে মানচিত্রে নির্দিষ্ট কীগুলি অ্যাক্সেস করা, ডার্ট টাইপ ইনফারেন্সের সাথে ত্রুটিগুলি পরিচালনা করা এবং একটি কলামে উইজেটগুলি যুক্ত করার সময় নেস্টেড তালিকা এড়াতে স্প্রেড অপারেটর ব্যবহার করে। ভিডিওটি ফ্লটার ডেভেলপমেন্টে রূপান্তর এবং পুনরাবৃত্তির ধারণা প্রদর্শন করে, যা ডেটা স্ট্রাকচারের উপর ভিত্তি করে গতিশীল UI উপাদান তৈরি করার অনুমতি দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يشرح الفيديو عملية إنشاء عناصر واجهة مستخدم إجابة بشكل ديناميكي في Flutter استنادًا إلى أسئلة مختارة باستخدام الخرائط في Dart. من خلال تعيين قائمة من الأسئلة في قائمة من عناصر واجهة المستخدم، يوضح الفيديو كيفية تحويل هياكل البيانات بكفاءة، وتمرير القيم والوظائف حسب الحاجة. يغطي البرنامج التعليمي الوصول إلى مفاتيح معينة في الخرائط باستخدام الأقواس المربعة، ومعالجة الأخطاء باستخدام استنتاج نوع Dart، واستخدام عامل الانتشار لتجنب القوائم المتداخلة عند إضافة عناصر واجهة مستخدم إلى عمود. يعرض الفيديو مفهوم التحويل والتكرار في تطوير Flutter، مما يسمح بإنشاء عناصر واجهة مستخدم ديناميكية استنادًا إلى هياكل البيانات.",
                                // Persian
                                "فارسی": "این ویدئو روند ایجاد پویا ویجت‌های پاسخ در فلاتر را بر اساس سوالات انتخابی با استفاده از نقشه‌ها در دارت توضیح می‌دهد. با نگاشت فهرستی از سؤالات در فهرستی از ویجت ها، این ویدیو نشان می دهد که چگونه می توان ساختارهای داده را به طور کارآمد تغییر داد و مقادیر و توابع را در صورت نیاز ارسال کرد. این آموزش شامل دسترسی به کلیدهای خاص در نقشه ها با استفاده از براکت مربع، رسیدگی به خطاها با استنتاج نوع دارت و استفاده از عملگر spread برای جلوگیری از لیست های تو در تو در هنگام افزودن ویجت ها به یک ستون است. این ویدئو مفهوم تبدیل و تکرار در توسعه Flutter را به نمایش می‌گذارد که امکان ایجاد عناصر UI پویا بر اساس ساختارهای داده را فراهم می‌کند.",
                            },
                        },
                        // 38 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "final vs const",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video discusses the concepts of final and const in Dart programming, highlighting their differences and implications for variable values. It explains how final variables represent values that do not change once the program runs, while const values are compile-time constants that cannot be modified. The video demonstrates the use of final and const in variables and values, emphasizing the importance of explicitly defining variable goals to prevent errors and ensure data integrity. By clarifying the distinction between final and const, the tutorial aims to enhance code organization and clean coding practices in Flutter development.",
                                // German
                                "Deutsch": "Das Video erläutert die Konzepte von final und const in der Dart-Programmierung und hebt ihre Unterschiede und Auswirkungen auf Variablenwerte hervor. Es erklärt, wie finale Variablen Werte darstellen, die sich nach Ausführung des Programms nicht ändern, während const-Werte Konstanten zur Kompilierungszeit sind, die nicht geändert werden können. Das Video demonstriert die Verwendung von final und const in Variablen und Werten und betont die Bedeutung der expliziten Definition von Variablenzielen, um Fehler zu vermeiden und die Datenintegrität sicherzustellen. Durch die Klärung der Unterscheidung zwischen final und const zielt das Tutorial darauf ab, die Codeorganisation und saubere Codierungspraktiken in der Flutter-Entwicklung zu verbessern.",
                                // Chinese
                                "中国人": "该视频讨论了 Dart 编程中的 final 和 const 概念，重点介绍了它们的区别以及对变量值的影响。它解释了 final 变量如何表示程序运行后不会改变的值，而 const 值是无法修改的编译时常量。该视频演示了 final 和 const 在变量和值中的用法，强调了明确定义变量目标以防止错误和确保数据完整性的重要性。通过阐明 final 和 const 之间的区别，本教程旨在增强 Flutter 开发中的代码组织和干净的编码实践。",
                                // Russian
                                "Русский": "В видео обсуждаются концепции final и const в программировании Dart, подчеркиваются их различия и последствия для значений переменных. В нем объясняется, как final-переменные представляют значения, которые не изменяются после запуска программы, в то время как const-значения являются константами времени компиляции, которые не могут быть изменены. Видео демонстрирует использование final и const в переменных и значениях, подчеркивая важность явного определения целей переменных для предотвращения ошибок и обеспечения целостности данных. Разъясняя различие между final и const, руководство направлено на улучшение организации кода и практики чистого кодирования при разработке Flutter.",
                                // French
                                "Français": "La vidéo aborde les concepts de final et de const dans la programmation Dart, en soulignant leurs différences et leurs implications pour les valeurs des variables. Elle explique comment les variables finales représentent des valeurs qui ne changent pas une fois le programme exécuté, tandis que les valeurs const sont des constantes de compilation qui ne peuvent pas être modifiées. La vidéo montre l'utilisation de final et de const dans les variables et les valeurs, en soulignant l'importance de définir explicitement les objectifs des variables pour éviter les erreurs et garantir l'intégrité des données. En clarifiant la distinction entre final et const, le didacticiel vise à améliorer l'organisation du code et les pratiques de codage propres dans le développement Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、Dart プログラミングにおける final と const の概念について説明し、その違いと変数値への影響に焦点を当てています。final 変数はプログラムの実行後は変化しない値を表すのに対し、const 値は変更できないコンパイル時の定数である点について説明します。このビデオでは、変数と値における final と const の使用方法を示し、エラーを防ぎデータの整合性を確保するために変数の目標を明示的に定義することの重要性を強調しています。final と const の違いを明確にすることで、このチュートリアルは Flutter 開発におけるコード編成とクリーンなコーディング プラクティスを強化することを目的としています。",
                                // Korean
                                "한국인": "이 영상은 Dart 프로그래밍에서 final과 const의 개념을 논의하고, 그 차이점과 변수 값에 대한 의미를 강조합니다. final 변수는 프로그램이 실행되면 변경되지 않는 값을 나타내는 반면, const 값은 수정할 수 없는 컴파일 타임 상수임을 설명합니다. 이 영상은 변수와 값에서 final과 const를 사용하는 방법을 보여주며, 오류를 방지하고 데이터 무결성을 보장하기 위해 변수 목표를 명시적으로 정의하는 것의 중요성을 강조합니다. 이 튜토리얼은 final과 const의 차이점을 명확히 함으로써 Flutter 개발에서 코드 구성과 깔끔한 ​​코딩 관행을 강화하는 것을 목표로 합니다.",
                                // Spanish
                                "Español": "El video analiza los conceptos de final y const en la programación de Dart, destacando sus diferencias e implicaciones para los valores de las variables. Explica cómo las variables finales representan valores que no cambian una vez que se ejecuta el programa, mientras que los valores const son constantes de tiempo de compilación que no se pueden modificar. El video demuestra el uso de final y const en variables y valores, enfatizando la importancia de definir explícitamente los objetivos de las variables para evitar errores y garantizar la integridad de los datos. Al aclarar la distinción entre final y const, el tutorial tiene como objetivo mejorar la organización del código y las prácticas de codificación limpias en el desarrollo de Flutter.",
                                // Hindi
                                "हिंदी": "वीडियो डार्ट प्रोग्रामिंग में फाइनल और कॉन्स्ट की अवधारणाओं पर चर्चा करता है, उनके अंतर और चर मानों के लिए निहितार्थों पर प्रकाश डालता है। यह बताता है कि कैसे फाइनल वैरिएबल उन मानों का प्रतिनिधित्व करते हैं जो प्रोग्राम चलने के बाद नहीं बदलते हैं, जबकि कॉन्स्ट मान संकलन-समय स्थिरांक हैं जिन्हें संशोधित नहीं किया जा सकता है। वीडियो वैरिएबल और मानों में फाइनल और कॉन्स्ट के उपयोग को प्रदर्शित करता है, त्रुटियों को रोकने और डेटा अखंडता सुनिश्चित करने के लिए वैरिएबल लक्ष्यों को स्पष्ट रूप से परिभाषित करने के महत्व पर जोर देता है। फाइनल और कॉन्स्ट के बीच अंतर को स्पष्ट करके, ट्यूटोरियल का उद्देश्य फ़्लटर डेवलपमेंट में कोड संगठन और स्वच्छ कोडिंग प्रथाओं को बढ़ाना है।",
                                // Portuguese
                                "Português": "O vídeo discute os conceitos de final e const na programação Dart, destacando as suas diferenças e implicações para os valores das variáveis. Explica como as variáveis ​​finais representam valores que não se alteram quando o programa é executado, enquanto os valores const são constantes em tempo de compilação que não podem ser modificadas. O vídeo demonstra a utilização de final e const em variáveis ​​e valores, enfatizando a importância de definir explicitamente os objetivos das variáveis ​​para evitar erros e garantir a integridade dos dados. Ao clarificar a distinção entre final e const, o tutorial visa melhorar a organização do código e as práticas de codificação limpas no desenvolvimento do Flutter.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ডার্ট প্রোগ্রামিং-এ ফাইনাল এবং কনস্টের ধারণা নিয়ে আলোচনা করে, পরিবর্তনশীল মানের জন্য তাদের পার্থক্য এবং প্রভাব তুলে ধরে। এটি ব্যাখ্যা করে যে কীভাবে চূড়ান্ত ভেরিয়েবলগুলি এমন মানগুলিকে উপস্থাপন করে যা একবার প্রোগ্রাম চালানোর পরে পরিবর্তিত হয় না, যখন const মানগুলি কম্পাইল-টাইম কনস্ট্যান্ট যা পরিবর্তন করা যায় না। ভিডিওটি ভেরিয়েবল এবং মানগুলিতে চূড়ান্ত এবং কনস্টের ব্যবহার প্রদর্শন করে, ত্রুটিগুলি প্রতিরোধ করতে এবং ডেটা অখণ্ডতা নিশ্চিত করতে পরিবর্তনশীল লক্ষ্যগুলিকে স্পষ্টভাবে সংজ্ঞায়িত করার গুরুত্বের উপর জোর দেয়। ফাইনাল এবং কনস্টের মধ্যে পার্থক্য স্পষ্ট করে, টিউটোরিয়ালটির লক্ষ্য হল কোড সংগঠন উন্নত করা এবং ফ্লটার ডেভেলপমেন্টে কোডিং অনুশীলন পরিষ্কার করা।",
                                // Arabic
                                "عَرَبِيّ": "يناقش الفيديو مفهومي final وconst في برمجة Dart، مع تسليط الضوء على الاختلافات بينهما وتأثيراتهما على قيم المتغيرات. ويشرح كيف تمثل المتغيرات final قيمًا لا تتغير بمجرد تشغيل البرنامج، في حين أن قيم const هي ثوابت وقت التجميع التي لا يمكن تعديلها. ويوضح الفيديو استخدام final وconst في المتغيرات والقيم، مع التأكيد على أهمية تحديد أهداف المتغيرات صراحةً لمنع الأخطاء وضمان سلامة البيانات. ومن خلال توضيح التمييز بين final وconst، يهدف البرنامج التعليمي إلى تحسين تنظيم الكود وممارسات الترميز النظيف في تطوير Flutter.",
                                // Persian
                                "فارسی": "این ویدئو مفاهیم نهایی و نهایی در برنامه نویسی دارت را مورد بحث قرار می دهد و تفاوت ها و مفاهیم آنها را برای مقادیر متغیر برجسته می کند. توضیح می‌دهد که چگونه متغیرهای نهایی مقادیری را نشان می‌دهند که پس از اجرای برنامه تغییر نمی‌کنند، در حالی که مقادیر const ثابت‌های زمان کامپایل هستند که قابل تغییر نیستند. این ویدئو استفاده از نهایی و const را در متغیرها و مقادیر نشان می‌دهد و بر اهمیت تعریف واضح اهداف متغیر برای جلوگیری از خطا و اطمینان از یکپارچگی داده‌ها تاکید می‌کند. با روشن کردن تمایز بین نهایی و const، هدف این آموزش تقویت سازماندهی کد و شیوه‌های کدگذاری پاک در توسعه Flutter است.",
                            },
                        },
                        // 39 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Introducing _if_ Statements",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video introduces conditional statements in Dart programming, specifically focusing on the if keyword for running code conditionally based on a specified condition. The tutorial explains how to use if checks to control the output of widgets in a Flutter app, illustrating the process with examples and highlighting the importance of scoping variables correctly within the class. By demonstrating the implementation of if statements to control widget behavior dynamically, the video enhances understanding of conditional logic in Flutter development, improving user experience by displaying different widgets based on specific conditions.",
                                // German
                                "Deutsch": "Das Video stellt bedingte Anweisungen in der Dart-Programmierung vor und konzentriert sich dabei insbesondere auf das Schlüsselwort if, mit dem Code bedingt auf der Grundlage einer angegebenen Bedingung ausgeführt werden kann. Das Tutorial erklärt, wie man mithilfe von if-Prüfungen die Ausgabe von Widgets in einer Flutter-App steuert. Dabei wird der Vorgang anhand von Beispielen veranschaulicht und die Bedeutung der korrekten Bereichszuweisung von Variablen innerhalb der Klasse hervorgehoben. Durch die Demonstration der Implementierung von if-Anweisungen zur dynamischen Steuerung des Widget-Verhaltens verbessert das Video das Verständnis der bedingten Logik in der Flutter-Entwicklung und verbessert die Benutzererfahrung durch die Anzeige unterschiedlicher Widgets auf der Grundlage bestimmter Bedingungen.",
                                // Chinese
                                "中国人": "该视频介绍了 Dart 编程中的条件语句，特别关注了 if 关键字，用于根据指定条件有条件地运行代码。该教程解释了如何使用 if 检查来控制 Flutter 应用中的小部件的输出，并通过示例说明了该过程，并强调了在类中正确确定变量范围的重要性。通过演示 if 语句的实现来动态控制小部件行为，该视频增强了对 Flutter 开发中条件逻辑的理解，通过根据特定条件显示不同的小部件来改善用户体验。",
                                // Russian
                                "Русский": "Видео знакомит с условными операторами в программировании Dart, уделяя особое внимание ключевому слову if для условного запуска кода на основе указанного условия. В руководстве объясняется, как использовать проверки if для управления выводом виджетов в приложении Flutter, иллюстрируя процесс примерами и подчеркивая важность правильного определения области видимости переменных в классе. Демонстрируя реализацию операторов if для динамического управления поведением виджетов, видео улучшает понимание условной логики в разработке Flutter, улучшая пользовательский опыт за счет отображения различных виджетов на основе определенных условий.",
                                // French
                                "Français": "La vidéo présente les instructions conditionnelles dans la programmation Dart, en se concentrant spécifiquement sur le mot-clé if pour exécuter du code de manière conditionnelle en fonction d'une condition spécifiée. Le didacticiel explique comment utiliser les vérifications if pour contrôler la sortie des widgets dans une application Flutter, en illustrant le processus avec des exemples et en soulignant l'importance de définir correctement la portée des variables au sein de la classe. En démontrant l'implémentation des instructions if pour contrôler le comportement des widgets de manière dynamique, la vidéo améliore la compréhension de la logique conditionnelle dans le développement Flutter, améliorant l'expérience utilisateur en affichant différents widgets en fonction de conditions spécifiques.",
                                // Japanese
                                "日本語": "このビデオでは、Dart プログラミングにおける条件文について紹介します。特に、指定された条件に基づいて条件付きでコードを実行するための if キーワードに焦点を当てています。このチュートリアルでは、Flutter アプリでウィジェットの出力を制御するために if チェックを使用する方法について説明し、例を挙げてプロセスを示し、クラス内で変数のスコープを正しく設定することの重要性を強調しています。ウィジェットの動作を動的に制御するための if ステートメントの実装を示すことで、このビデオは Flutter 開発における条件付きロジックの理解を深め、特定の条件に基づいて異なるウィジェットを表示することでユーザー エクスペリエンスを向上させます。",
                                // Korean
                                "한국인": "이 영상은 Dart 프로그래밍의 조건문을 소개하며, 특히 지정된 조건에 따라 코드를 조건부로 실행하기 위한 if 키워드에 초점을 맞춥니다. 이 튜토리얼은 Flutter 앱에서 위젯의 출력을 제어하기 위해 if 검사를 사용하는 방법을 설명하고, 예를 들어 프로세스를 설명하고, 클래스 내에서 변수를 올바르게 범위 지정하는 것의 중요성을 강조합니다. 이 영상은 위젯 동작을 동적으로 제어하기 위한 if 명령문 구현을 보여줌으로써 Flutter 개발에서 조건 논리에 대한 이해를 높이고, 특정 조건에 따라 다양한 위젯을 표시하여 사용자 경험을 개선합니다.",
                                // Spanish
                                "Español": "El video presenta las declaraciones condicionales en la programación Dart, centrándose específicamente en la palabra clave if para ejecutar código condicionalmente según una condición específica. El tutorial explica cómo usar las comprobaciones if para controlar la salida de los widgets en una aplicación Flutter, ilustrando el proceso con ejemplos y destacando la importancia de definir correctamente el alcance de las variables dentro de la clase. Al demostrar la implementación de las declaraciones if para controlar el comportamiento de los widgets de forma dinámica, el video mejora la comprensión de la lógica condicional en el desarrollo de Flutter, mejorando la experiencia del usuario al mostrar diferentes widgets según condiciones específicas.",
                                // Hindi
                                "हिंदी": "वीडियो डार्ट प्रोग्रामिंग में सशर्त कथनों का परिचय देता है, विशेष रूप से निर्दिष्ट शर्त के आधार पर सशर्त रूप से कोड चलाने के लिए if कीवर्ड पर ध्यान केंद्रित करता है। ट्यूटोरियल बताता है कि फ़्लटर ऐप में विजेट के आउटपुट को नियंत्रित करने के लिए if चेक का उपयोग कैसे करें, उदाहरणों के साथ प्रक्रिया को स्पष्ट करें और क्लास के भीतर चर को सही ढंग से स्कोप करने के महत्व पर प्रकाश डालें। विजेट व्यवहार को गतिशील रूप से नियंत्रित करने के लिए if कथनों के कार्यान्वयन का प्रदर्शन करके, वीडियो फ़्लटर विकास में सशर्त तर्क की समझ को बढ़ाता है, विशिष्ट स्थितियों के आधार पर विभिन्न विजेट प्रदर्शित करके उपयोगकर्ता अनुभव में सुधार करता है।",
                                // Portuguese
                                "Português": "O vídeo apresenta instruções condicionais na programação Dart, focando especificamente a palavra-chave if para executar código condicionalmente com base numa condição especificada. O tutorial explica como utilizar verificações if para controlar a saída de widgets numa aplicação Flutter, ilustrando o processo com exemplos e destacando a importância de definir o âmbito das variáveis ​​corretamente dentro da classe. Ao demonstrar a implementação de instruções if para controlar dinamicamente o comportamento do widget, o vídeo melhora a compreensão da lógica condicional no desenvolvimento do Flutter, melhorando a experiência do utilizador ao exibir diferentes widgets com base em condições específicas.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ডার্ট প্রোগ্রামিং-এ শর্তসাপেক্ষ বিবৃতি উপস্থাপন করে, বিশেষ করে নির্দিষ্ট শর্তের উপর ভিত্তি করে শর্তসাপেক্ষে কোড চালানোর জন্য if কীওয়ার্ডের উপর ফোকাস করে। টিউটোরিয়াল ব্যাখ্যা করে যে কীভাবে ব্যবহার করতে হয় যদি একটি ফ্লাটার অ্যাপে উইজেটগুলির আউটপুট নিয়ন্ত্রণ করতে চেক করা হয়, উদাহরণ সহ প্রক্রিয়াটি চিত্রিত করে এবং ক্লাসের মধ্যে সঠিকভাবে স্কোপিং ভেরিয়েবলের গুরুত্ব তুলে ধরে। উইজেট আচরণকে গতিশীলভাবে নিয়ন্ত্রণ করতে ইফ স্টেটমেন্টের বাস্তবায়ন প্রদর্শন করে, ভিডিওটি ফ্লটার ডেভেলপমেন্টে শর্তসাপেক্ষ যুক্তির বোঝা বাড়ায়, নির্দিষ্ট শর্তের উপর ভিত্তি করে বিভিন্ন উইজেট প্রদর্শন করে ব্যবহারকারীর অভিজ্ঞতা উন্নত করে।",
                                // Arabic
                                "عَرَبِيّ": "يقدم الفيديو عبارات شرطية في برمجة Dart، مع التركيز بشكل خاص على كلمة if لتشغيل التعليمات البرمجية بشكل شرطي بناءً على شرط محدد. يشرح البرنامج التعليمي كيفية استخدام عمليات التحقق if للتحكم في مخرجات عناصر واجهة المستخدم في تطبيق Flutter، مع توضيح العملية بأمثلة وتسليط الضوء على أهمية تحديد نطاق المتغيرات بشكل صحيح داخل الفصل. من خلال إظهار تنفيذ عبارات if للتحكم في سلوك عناصر واجهة المستخدم بشكل ديناميكي، يعزز الفيديو فهم المنطق الشرطي في تطوير Flutter، مما يحسن تجربة المستخدم من خلال عرض عناصر واجهة مستخدم مختلفة بناءً على شروط محددة.",
                                // Persian
                                "فارسی": "این ویدیو عبارات شرطی را در برنامه نویسی دارت معرفی می کند، به طور خاص بر روی کلمه کلیدی if برای اجرای کد به صورت شرطی بر اساس یک شرط مشخص تمرکز می کند. این آموزش نحوه استفاده از چک‌های if را برای کنترل خروجی ویجت‌ها در برنامه Flutter توضیح می‌دهد، فرآیند را با مثال‌هایی نشان می‌دهد و اهمیت تعیین دامنه به درستی متغیرها در کلاس را برجسته می‌کند. با نشان دادن اجرای دستورات if برای کنترل رفتار ویجت به صورت پویا، ویدئو درک منطق شرطی را در توسعه Flutter افزایش می‌دهد و با نمایش ویجت‌های مختلف بر اساس شرایط خاص، تجربه کاربر را بهبود می‌بخشد.",
                            },
                        },
                        // 40 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "[DART DEEP DIVE] More on _if_ Statements",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video provides a comprehensive explanation of if statements in Dart programming, demonstrating how to use conditionals to control code execution based on specified conditions. The tutorial covers the syntax of if statements, including the use of boolean expressions to evaluate true or false conditions and the implementation of if-else and if-else-if structures to handle alternative conditions. The video emphasizes the importance of understanding comparison operators, boolean values, and logical operators in creating efficient and flexible conditional logic in programming, encouraging experimentation and practice to enhance proficiency in working with if statements.",
                                // German
                                "Deutsch": "Das Video bietet eine umfassende Erklärung der if-Anweisungen in der Dart-Programmierung und zeigt, wie man Bedingungen verwendet, um die Codeausführung basierend auf angegebenen Bedingungen zu steuern. Das Tutorial behandelt die Syntax von if-Anweisungen, einschließlich der Verwendung von Booleschen Ausdrücken zur Auswertung wahrer oder falscher Bedingungen und der Implementierung von if-else- und if-else-if-Strukturen zur Behandlung alternativer Bedingungen. Das Video betont die Bedeutung des Verständnisses von Vergleichsoperatoren, Booleschen Werten und logischen Operatoren für die Erstellung effizienter und flexibler bedingter Logik in der Programmierung und fördert Experimentieren und Üben, um die Kompetenz im Umgang mit if-Anweisungen zu verbessern.",
                                // Chinese
                                "中国人": "该视频全面解释了 Dart 编程中的 if 语句，演示了如何使用条件语句根据指定条件控制代码执行。本教程涵盖了 if 语句的语法，包括使用布尔表达式来评估真或假条件，以及实现 if-else 和 if-else-if 结构来处理替代条件。该视频强调了理解比较运算符、布尔值和逻辑运算符在编程中创建高效灵活的条件逻辑的重要性，鼓励进行实验和实践以提高使用 if 语句的熟练程度。",
                                // Russian
                                "Русский": "Видео дает исчерпывающее объяснение операторов if в программировании Dart, демонстрируя, как использовать условные операторы для управления выполнением кода на основе указанных условий. В руководстве рассматривается синтаксис операторов if, включая использование булевых выражений для оценки истинных или ложных условий и реализацию структур if-else и if-else-if для обработки альтернативных условий. Видео подчеркивает важность понимания операторов сравнения, булевых значений и логических операторов для создания эффективной и гибкой условной логики в программировании, поощряя эксперименты и практику для повышения мастерства в работе с операторами if.",
                                // French
                                "Français": "La vidéo fournit une explication complète des instructions if dans la programmation Dart, montrant comment utiliser les conditions pour contrôler l'exécution du code en fonction de conditions spécifiées. Le didacticiel couvre la syntaxe des instructions if, y compris l'utilisation d'expressions booléennes pour évaluer les conditions vraies ou fausses et l'implémentation des structures if-else et if-else-if pour gérer les conditions alternatives. La vidéo souligne l'importance de comprendre les opérateurs de comparaison, les valeurs booléennes et les opérateurs logiques pour créer une logique conditionnelle efficace et flexible dans la programmation, en encourageant l'expérimentation et la pratique pour améliorer la maîtrise du travail avec les instructions if.",
                                // Japanese
                                "日本語": "このビデオでは、Dart プログラミングにおける if 文について包括的に説明し、条件文を使用して指定された条件に基づいてコード実行を制御する方法を示します。チュートリアルでは、真偽の条件を評価するためのブール式の使用や、代替条件を処理するための if-else および if-else-if 構造の実装など、if 文の構文について説明します。このビデオでは、プログラミングで効率的で柔軟な条件付きロジックを作成するために、比較演算子、ブール値、および論理演算子を理解することの重要性を強調し、if 文の操作の習熟度を高めるための実験と練習を奨励しています。",
                                // Korean
                                "한국인": "이 비디오는 Dart 프로그래밍에서 if 문에 대한 포괄적인 설명을 제공하며, 지정된 조건에 따라 코드 실행을 제어하기 위해 조건문을 사용하는 방법을 보여줍니다. 이 튜토리얼은 true 또는 false 조건을 평가하기 위한 부울 표현식 사용 및 대체 조건을 처리하기 위한 if-else 및 if-else-if 구조 구현을 포함하여 if 문의 구문을 다룹니다. 이 비디오는 프로그래밍에서 효율적이고 유연한 조건 논리를 만드는 데 있어 비교 연산자, 부울 값 및 논리 연산자를 이해하는 것의 중요성을 강조하며, if 문 작업의 숙련도를 높이기 위한 실험과 연습을 장려합니다.",
                                // Spanish
                                "Español": "El video ofrece una explicación completa de las instrucciones if en la programación Dart, y demuestra cómo usar condicionales para controlar la ejecución del código en función de condiciones específicas. El tutorial cubre la sintaxis de las instrucciones if, incluido el uso de expresiones booleanas para evaluar condiciones verdaderas o falsas y la implementación de estructuras if-else e if-else-if para manejar condiciones alternativas. El video enfatiza la importancia de comprender los operadores de comparación, los valores booleanos y los operadores lógicos para crear una lógica condicional eficiente y flexible en la programación, y fomenta la experimentación y la práctica para mejorar la competencia en el trabajo con instrucciones if.",
                                // Hindi
                                "हिंदी": "वीडियो डार्ट प्रोग्रामिंग में if स्टेटमेंट्स की विस्तृत व्याख्या प्रदान करता है, जिसमें निर्दिष्ट शर्तों के आधार पर कोड निष्पादन को नियंत्रित करने के लिए कंडीशनल्स का उपयोग करने का तरीका दिखाया गया है। ट्यूटोरियल if स्टेटमेंट्स के सिंटैक्स को कवर करता है, जिसमें सही या गलत स्थितियों का मूल्यांकन करने के लिए बूलियन एक्सप्रेशन का उपयोग और वैकल्पिक स्थितियों को संभालने के लिए if-else और if-else-if संरचनाओं का कार्यान्वयन शामिल है। वीडियो प्रोग्रामिंग में कुशल और लचीले कंडीशनल लॉजिक बनाने में तुलना ऑपरेटर, बूलियन मान और लॉजिकल ऑपरेटर को समझने के महत्व पर जोर देता है, if स्टेटमेंट्स के साथ काम करने में दक्षता बढ़ाने के लिए प्रयोग और अभ्यास को प्रोत्साहित करता है।",
                                // Portuguese
                                "Português": "O vídeo fornece uma explicação abrangente das instruções if na programação Dart, demonstrando como utilizar condicionais para controlar a execução de código com base em condições especificadas. O tutorial aborda a sintaxe das instruções if, incluindo a utilização de expressões booleanas para avaliar condições verdadeiras ou falsas e a implementação de estruturas if-else e if-else-if para lidar com condições alternativas. O vídeo enfatiza a importância de compreender os operadores de comparação, os valores booleanos e os operadores lógicos na criação de lógica condicional eficiente e flexível na programação, incentivando a experimentação e a prática para melhorar a proficiência no trabalho com instruções if.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ডার্ট প্রোগ্রামিং-এ ইফ স্টেটমেন্টের একটি বিস্তৃত ব্যাখ্যা প্রদান করে, নির্দিষ্ট শর্তের উপর ভিত্তি করে কোড এক্সিকিউশন নিয়ন্ত্রণ করতে কন্ডিশনাল কীভাবে ব্যবহার করতে হয় তা প্রদর্শন করে। টিউটোরিয়ালটিতে if স্টেটমেন্টের সিনট্যাক্স রয়েছে, যার মধ্যে সত্য বা মিথ্যা অবস্থার মূল্যায়ন করার জন্য বুলিয়ান এক্সপ্রেশনের ব্যবহার এবং বিকল্প শর্তগুলি পরিচালনা করতে if-else এবং if-else-if কাঠামোর বাস্তবায়ন অন্তর্ভুক্ত রয়েছে। ভিডিওটি প্রোগ্রামিং-এ দক্ষ এবং নমনীয় শর্তসাপেক্ষ লজিক তৈরিতে তুলনা অপারেটর, বুলিয়ান মান এবং যৌক্তিক অপারেটর বোঝার গুরুত্বের ওপর জোর দেয়, ইফ স্টেটমেন্টের সাথে কাজ করার দক্ষতা বাড়ানোর জন্য পরীক্ষা-নিরীক্ষা এবং অনুশীলনকে উৎসাহিত করে।",
                                // Arabic
                                "عَرَبِيّ": "يقدم الفيديو شرحًا شاملاً لعبارات الشرط في برمجة دارت، ويوضح كيفية استخدام الشرطيات للتحكم في تنفيذ التعليمات البرمجية استنادًا إلى شروط محددة. يغطي البرنامج التعليمي بناء جملة عبارات الشرط، بما في ذلك استخدام التعبيرات المنطقية لتقييم الشروط الصحيحة أو الخاطئة وتنفيذ هياكل if-else وif-else-if للتعامل مع الشروط البديلة. يؤكد الفيديو على أهمية فهم عوامل المقارنة والقيم المنطقية والعوامل المنطقية في إنشاء منطق شرطي فعال ومرن في البرمجة، وتشجيع التجريب والممارسة لتعزيز الكفاءة في العمل مع عبارات الشرط.",
                                // Persian
                                "فارسی": "این ویدئو توضیح جامعی از دستورات if در برنامه نویسی دارت ارائه می دهد و نحوه استفاده از شرطی ها برای کنترل اجرای کد بر اساس شرایط مشخص شده را نشان می دهد. این آموزش سینتکس دستورات if را شامل استفاده از عبارات بولی برای ارزیابی شرایط درست یا نادرست و اجرای ساختارهای if-else و if-else-if برای مدیریت شرایط جایگزین را پوشش می دهد. این ویدئو بر اهمیت درک عملگرهای مقایسه، مقادیر بولی و عملگرهای منطقی در ایجاد منطق شرطی کارآمد و انعطاف پذیر در برنامه نویسی، تشویق آزمایش و تمرین برای افزایش مهارت در کار با دستورات if تاکید می کند.",
                            },
                        },
                        // 41 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "[DART DEEP DIVE] The _null_ Value",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video introduces the concept of the null value in Dart programming, highlighting its significance as a built-in value that can be used to reset variables to an uninitialized state or indicate the absence of a value. Null is explained as a versatile value that can be assigned to any data type, allowing for easy resetting of variables or checking for uninitialized states in boolean comparisons. The tutorial emphasizes the practical applications of null in variable manipulation and checks, showcasing its importance in maintaining data integrity and ensuring variables are properly initialized in programming tasks.",
                                // German
                                "Deutsch": "Das Video stellt das Konzept des Nullwerts in der Dart-Programmierung vor und hebt seine Bedeutung als integrierter Wert hervor, der verwendet werden kann, um Variablen in einen nicht initialisierten Zustand zurückzusetzen oder das Fehlen eines Werts anzuzeigen. Null wird als vielseitiger Wert erklärt, der jedem Datentyp zugewiesen werden kann, wodurch das einfache Zurücksetzen von Variablen oder das Prüfen auf nicht initialisierte Zustände in booleschen Vergleichen ermöglicht wird. Das Tutorial betont die praktischen Anwendungen von Null bei der Variablenmanipulation und -prüfung und zeigt seine Bedeutung für die Wahrung der Datenintegrität und die Gewährleistung, dass Variablen in Programmieraufgaben ordnungsgemäß initialisiert werden.",
                                // Chinese
                                "中国人": "该视频介绍了 Dart 编程中的 null 值概念，强调了它作为内置值的重要性，可用于将变量重置为未初始化状态或指示值缺失。Null 被解释为可以分配给任何数据类型的多功能值，允许轻松重置变量或在布尔比较中检查未初始化状态。该教程强调了 null 在变量操作和检查中的实际应用，展示了它在维护数据完整性和确保变量在编程任务中正确初始化方面的重要性。",
                                // Russian
                                "Русский": "Видео знакомит с концепцией нулевого значения в программировании на Dart, подчеркивая его значимость как встроенного значения, которое может использоваться для сброса переменных в неинициализированное состояние или указания на отсутствие значения. Нуль объясняется как универсальное значение, которое может быть назначено любому типу данных, что позволяет легко сбрасывать переменные или проверять неинициализированные состояния в булевых сравнениях. В руководстве подчеркивается практическое применение нулевого значения в манипуляциях и проверках переменных, демонстрируя его важность для поддержания целостности данных и обеспечения правильной инициализации переменных в задачах программирования.",
                                // French
                                "Français": "La vidéo présente le concept de la valeur null dans la programmation Dart, en soulignant son importance en tant que valeur intégrée qui peut être utilisée pour réinitialiser des variables à un état non initialisé ou indiquer l'absence d'une valeur. Null est expliqué comme une valeur polyvalente qui peut être attribuée à n'importe quel type de données, ce qui permet de réinitialiser facilement les variables ou de vérifier les états non initialisés dans les comparaisons booléennes. Le didacticiel met l'accent sur les applications pratiques de null dans la manipulation et les vérifications de variables, en montrant son importance pour maintenir l'intégrité des données et garantir que les variables sont correctement initialisées dans les tâches de programmation.",
                                // Japanese
                                "日本語": "このビデオでは、Dart プログラミングにおける null 値の概念を紹介し、変数を未初期化状態にリセットしたり、値がないことを示すために使用できる組み込み値としての重要性を強調しています。null は、任意のデータ型に割り当てることができる多目的な値であり、変数を簡単にリセットしたり、ブール比較で未初期化状態をチェックしたりできることが説明されています。このチュートリアルでは、変数の操作とチェックにおける null の実際の用途を強調し、データの整合性を維持し、プログラミング タスクで変数が適切に初期化されることを保証する上での重要性を示します。",
                                // Korean
                                "한국인": "이 비디오는 Dart 프로그래밍에서 null 값의 개념을 소개하고, 변수를 초기화되지 않은 상태로 재설정하거나 값이 없음을 나타내는 데 사용할 수 있는 내장된 값으로서의 중요성을 강조합니다. Null은 모든 데이터 유형에 할당할 수 있는 다재다능한 값으로 설명되어 변수를 쉽게 재설정하거나 부울 비교에서 초기화되지 않은 상태를 확인할 수 있습니다. 이 튜토리얼은 변수 조작 및 검사에서 null의 실제 적용을 강조하고, 데이터 무결성을 유지하고 프로그래밍 작업에서 변수가 적절하게 초기화되도록 하는 데 있어서 null이 중요한 이유를 보여줍니다.",
                                // Spanish
                                "Español": "El video presenta el concepto de valor nulo en la programación Dart, destacando su importancia como valor incorporado que se puede utilizar para restablecer variables a un estado no inicializado o indicar la ausencia de un valor. Se explica que el valor nulo es un valor versátil que se puede asignar a cualquier tipo de datos, lo que permite restablecer fácilmente las variables o verificar estados no inicializados en comparaciones booleanas. El tutorial enfatiza las aplicaciones prácticas del valor nulo en la manipulación y verificación de variables, mostrando su importancia para mantener la integridad de los datos y garantizar que las variables se inicialicen correctamente en las tareas de programación.",
                                // Hindi
                                "हिंदी": "वीडियो डार्ट प्रोग्रामिंग में शून्य मान की अवधारणा का परिचय देता है, एक अंतर्निहित मान के रूप में इसके महत्व पर प्रकाश डालता है जिसका उपयोग चर को अप्रारंभीकृत स्थिति में रीसेट करने या किसी मान की अनुपस्थिति को इंगित करने के लिए किया जा सकता है। शून्य को एक बहुमुखी मान के रूप में समझाया गया है जिसे किसी भी डेटा प्रकार को सौंपा जा सकता है, जिससे चर को आसानी से रीसेट किया जा सकता है या बूलियन तुलनाओं में अप्रारंभीकृत स्थितियों की जाँच की जा सकती है। ट्यूटोरियल चर हेरफेर और जाँच में शून्य के व्यावहारिक अनुप्रयोगों पर जोर देता है, डेटा अखंडता को बनाए रखने और यह सुनिश्चित करने में इसके महत्व को प्रदर्शित करता है कि प्रोग्रामिंग कार्यों में चर ठीक से आरंभ किए गए हैं।",
                                // Portuguese
                                "Português": "O vídeo apresenta o conceito de valor nulo na programação Dart, destacando a sua importância como um valor integrado que pode ser utilizado para repor variáveis ​​para um estado não inicializado ou indicar a ausência de um valor. Nulo é explicado como um valor versátil que pode ser atribuído a qualquer tipo de dados, permitindo uma fácil redefinição de variáveis ​​ou verificação de estados não inicializados em comparações booleanas. O tutorial enfatiza as aplicações práticas de null na manipulação e verificação de variáveis, mostrando a sua importância na manutenção da integridade dos dados e na garantia de que as variáveis ​​são corretamente inicializadas em tarefas de programação.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ডার্ট প্রোগ্রামিং-এ নাল মানের ধারণাটি উপস্থাপন করে, একটি অন্তর্নির্মিত মান হিসাবে এটির তাত্পর্যকে হাইলাইট করে যা ভেরিয়েবলগুলিকে একটি অপ্রচলিত অবস্থায় পুনরায় সেট করতে বা একটি মানের অনুপস্থিতি নির্দেশ করতে ব্যবহার করা যেতে পারে। নালকে একটি বহুমুখী মান হিসাবে ব্যাখ্যা করা হয়েছে যা যেকোন ডেটা টাইপের জন্য বরাদ্দ করা যেতে পারে, যাতে ভেরিয়েবলের সহজে রিসেট করা যায় বা বুলিয়ান তুলনাতে অপ্রচলিত অবস্থার জন্য পরীক্ষা করা যায়। টিউটোরিয়ালটি ভেরিয়েবল ম্যানিপুলেশন এবং চেকের ক্ষেত্রে নাল এর ব্যবহারিক প্রয়োগের উপর জোর দেয়, ডেটা অখণ্ডতা বজায় রাখার ক্ষেত্রে এর গুরুত্ব প্রদর্শন করে এবং প্রোগ্রামিং কাজগুলিতে ভেরিয়েবলগুলি সঠিকভাবে শুরু হয় তা নিশ্চিত করে।",
                                // Arabic
                                "عَرَبِيّ": "يقدم الفيديو مفهوم القيمة الفارغة في برمجة دارت، مع تسليط الضوء على أهميتها كقيمة مدمجة يمكن استخدامها لإعادة تعيين المتغيرات إلى حالة غير مهيأة أو للإشارة إلى عدم وجود قيمة. يتم شرح القيمة الفارغة كقيمة متعددة الاستخدامات يمكن تعيينها لأي نوع بيانات، مما يسمح بإعادة تعيين المتغيرات بسهولة أو التحقق من الحالات غير المهيأة في المقارنات المنطقية. يؤكد البرنامج التعليمي على التطبيقات العملية للقيمة الفارغة في معالجة المتغيرات والتحقق منها، مع إظهار أهميتها في الحفاظ على سلامة البيانات وضمان تهيئة المتغيرات بشكل صحيح في مهام البرمجة.",
                                // Persian
                                "فارسی": "این ویدئو مفهوم مقدار تهی را در برنامه نویسی دارت معرفی می کند و اهمیت آن را به عنوان یک مقدار داخلی برجسته می کند که می تواند برای تنظیم مجدد متغیرها به حالت اولیه یا نشان دادن عدم وجود یک مقدار استفاده شود. تهی به عنوان یک مقدار همه کاره توضیح داده می شود که می تواند به هر نوع داده ای نسبت داده شود و امکان تنظیم مجدد متغیرها یا بررسی حالت های اولیه را در مقایسه های بولی فراهم می کند. این آموزش بر کاربردهای عملی null در دستکاری و بررسی متغیرها تأکید می کند و اهمیت آن را در حفظ یکپارچگی داده ها و اطمینان از اینکه متغیرها به درستی در کارهای برنامه نویسی مقداردهی اولیه می شوند، نشان می دهد.",
                            },
                        },
                        // 42 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Outputting Widgets Conditionally",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explains how to utilize ternary expressions in Dart programming to create conditional statements using a concise syntax. The tutorial demonstrates how to structure a ternary expression with a condition followed by a question mark and code to run if the condition is true, then a colon and code to run if the condition is false. The concept of an 'else block' is introduced, allowing for an alternative code execution if the condition is not met. The video showcases how to implement a ternary expression in a Flutter app to display a centered text message, such as 'you did it,' after a specific user interaction, highlighting the practical application of ternary expressions in enhancing user experience.",
                                // German
                                "Deutsch": "Das Video erklärt, wie man ternäre Ausdrücke in der Dart-Programmierung verwendet, um bedingte Anweisungen mit einer prägnanten Syntax zu erstellen. Das Tutorial zeigt, wie man einen ternären Ausdruck mit einer Bedingung strukturiert, gefolgt von einem Fragezeichen und Code, der ausgeführt werden soll, wenn die Bedingung erfüllt ist, dann einem Doppelpunkt und Code, der ausgeführt werden soll, wenn die Bedingung falsch ist. Das Konzept eines „else-Blocks“ wird eingeführt, der eine alternative Codeausführung ermöglicht, wenn die Bedingung nicht erfüllt ist. Das Video zeigt, wie man einen ternären Ausdruck in einer Flutter-App implementiert, um nach einer bestimmten Benutzerinteraktion eine zentrierte Textnachricht wie „Sie haben es geschafft“ anzuzeigen, und hebt die praktische Anwendung ternärer Ausdrücke zur Verbesserung der Benutzererfahrung hervor.",
                                // Chinese
                                "中国人": "该视频解释了如何在 Dart 编程中使用三元表达式，以简洁的语法创建条件语句。本教程演示了如何构造一个三元表达式，其中条件后跟问号和条件为真时运行的代码，然后是冒号和条件为假时运行的代码。视频引入了“else 块”的概念，允许在条件不满足时执行替代代码。视频展示了如何在 Flutter 应用中实现三元表达式，以在特定用户交互后显示居中的文本消息，例如“你做到了”，突出了三元表达式在增强用户体验方面的实际应用。",
                                // Russian
                                "Русский": "Видео объясняет, как использовать тернарные выражения в программировании Dart для создания условных операторов с использованием краткого синтаксиса. В руководстве показано, как структурировать тернарное выражение с условием, за которым следует вопросительный знак и код для выполнения, если условие истинно, затем двоеточие и код для выполнения, если условие ложно. Вводится концепция «блока else», позволяющая выполнять альтернативный код, если условие не выполняется. Видео демонстрирует, как реализовать тернарное выражение в приложении Flutter для отображения центрированного текстового сообщения, например «you did it», после определенного взаимодействия с пользователем, подчеркивая практическое применение тернарных выражений для улучшения пользовательского опыта.",
                                // French
                                "Français": "La vidéo explique comment utiliser des expressions ternaires dans la programmation Dart pour créer des instructions conditionnelles à l'aide d'une syntaxe concise. Le didacticiel montre comment structurer une expression ternaire avec une condition suivie d'un point d'interrogation et d'un code à exécuter si la condition est vraie, puis de deux points et d'un code à exécuter si la condition est fausse. Le concept de « bloc else » est introduit, permettant une exécution de code alternative si la condition n'est pas remplie. La vidéo montre comment implémenter une expression ternaire dans une application Flutter pour afficher un message texte centré, tel que « vous l'avez fait », après une interaction utilisateur spécifique, mettant en évidence l'application pratique des expressions ternaires pour améliorer l'expérience utilisateur.",
                                // Japanese
                                "日本語": "このビデオでは、簡潔な構文を使用して条件文を作成するために、Dart プログラミングで三項式を利用する方法を説明しています。このチュートリアルでは、条件の後に疑問符と条件が真の場合に実行するコード、コロンと条件が偽の場合に実行するコードが続く三項式を構成する方法を示します。条件が満たされない場合に代替コードを実行できるようにする「else ブロック」の概念が導入されています。このビデオでは、Flutter アプリで三項式を実装して、特定のユーザー操作の後に「you did it」などの中央揃えのテキスト メッセージを表示する方法を紹介し、ユーザー エクスペリエンスを向上させるための三項式の実用的なアプリケーションを強調しています。",
                                // Korean
                                "한국인": "이 비디오는 간결한 구문을 사용하여 Dart 프로그래밍에서 3항 표현식을 사용하여 조건문을 만드는 방법을 설명합니다. 이 튜토리얼은 조건 뒤에 물음표와 조건이 참일 경우 실행할 코드, 그리고 조건이 거짓일 경우 실행할 콜론과 코드로 3항 표현식을 구성하는 방법을 보여줍니다. 조건이 충족되지 않을 경우 대체 코드 실행을 허용하는 'else 블록'의 개념이 소개됩니다. 이 비디오는 특정 사용자 상호 작용 후 'you did it'과 같은 가운데 정렬된 텍스트 메시지를 표시하기 위해 Flutter 앱에서 3항 표현식을 구현하는 방법을 보여주며, 사용자 경험을 향상시키는 데 3항 표현식을 실제로 적용하는 방법을 강조합니다.",
                                // Spanish
                                "Español": "El video explica cómo utilizar expresiones ternarias en la programación Dart para crear declaraciones condicionales utilizando una sintaxis concisa. El tutorial demuestra cómo estructurar una expresión ternaria con una condición seguida de un signo de interrogación y un código para ejecutar si la condición es verdadera, luego dos puntos y un código para ejecutar si la condición es falsa. Se presenta el concepto de un 'bloque else', que permite la ejecución de un código alternativo si no se cumple la condición. El video muestra cómo implementar una expresión ternaria en una aplicación Flutter para mostrar un mensaje de texto centrado, como 'lo hiciste', después de una interacción específica del usuario, destacando la aplicación práctica de las expresiones ternarias para mejorar la experiencia del usuario.",
                                // Hindi
                                "हिंदी": "वीडियो बताता है कि संक्षिप्त वाक्यविन्यास का उपयोग करके सशर्त कथन बनाने के लिए डार्ट प्रोग्रामिंग में टर्नरी एक्सप्रेशन का उपयोग कैसे किया जाए। ट्यूटोरियल दर्शाता है कि एक शर्त के साथ एक टर्नरी एक्सप्रेशन को कैसे संरचित किया जाए, उसके बाद एक प्रश्न चिह्न और यदि शर्त सत्य है तो चलाने के लिए कोड, फिर एक कोलन और यदि शर्त गलत है तो चलाने के लिए कोड। 'अन्य ब्लॉक' की अवधारणा पेश की गई है, जो शर्त पूरी न होने पर वैकल्पिक कोड निष्पादन की अनुमति देती है। वीडियो दिखाता है कि फ़्लटर ऐप में टर्नरी एक्सप्रेशन को कैसे लागू किया जाए ताकि एक विशिष्ट उपयोगकर्ता इंटरैक्शन के बाद 'आपने यह किया' जैसे केंद्रित टेक्स्ट संदेश प्रदर्शित किया जा सके, जो उपयोगकर्ता अनुभव को बढ़ाने में टर्नरी एक्सप्रेशन के व्यावहारिक अनुप्रयोग पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "O vídeo explica como utilizar expressões ternárias na programação Dart para criar instruções condicionais utilizando uma sintaxe concisa. O tutorial demonstra como estruturar uma expressão ternária com uma condição seguida de um ponto de interrogação e código a ser executado se a condição for verdadeira, depois dois pontos e código a ser executado se a condição for falsa. É introduzido o conceito de 'bloco else', permitindo uma execução alternativa de código caso a condição não seja satisfeita. O vídeo mostra como implementar uma expressão ternária numa aplicação Flutter para exibir uma mensagem de texto centralizada, como 'conseguiu', após uma interação específica do utilizador, destacando a aplicação prática de expressões ternárias para melhorar a experiência do utilizador.",
                                // Bengali
                                "বাংলা": "একটি সংক্ষিপ্ত বাক্য গঠন ব্যবহার করে শর্তসাপেক্ষ বিবৃতি তৈরি করতে কিভাবে ডার্ট প্রোগ্রামিং-এ ত্রিনারি অভিব্যক্তি ব্যবহার করা যায় তা ভিডিওটি ব্যাখ্যা করে। টিউটোরিয়ালটি দেখায় যে কীভাবে একটি শর্ত সহ একটি ত্রিনারি এক্সপ্রেশন গঠন করতে হয় তার পরে একটি প্রশ্ন চিহ্ন এবং কন্ডিশন সত্য হলে চালানোর জন্য কোড, তারপর একটি কোলন এবং শর্তটি মিথ্যা হলে চালানোর জন্য কোড। একটি 'অন্য ব্লক' ধারণাটি চালু করা হয়েছে, শর্ত পূরণ না হলে একটি বিকল্প কোড কার্যকর করার অনুমতি দেয়। ভিডিওটি প্রদর্শন করে যে কীভাবে একটি কেন্দ্রীভূত পাঠ্য বার্তা প্রদর্শন করতে একটি ফ্লটার অ্যাপে একটি ত্রিদেশীয় অভিব্যক্তি প্রয়োগ করতে হয়, যেমন 'আপনি এটি করেছেন', একটি নির্দিষ্ট ব্যবহারকারীর ইন্টারঅ্যাকশনের পরে, ব্যবহারকারীর অভিজ্ঞতা বাড়ানোর ক্ষেত্রে ত্রিনারি অভিব্যক্তির ব্যবহারিক প্রয়োগকে হাইলাইট করে৷",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو كيفية استخدام التعبيرات الثلاثية في برمجة Dart لإنشاء عبارات شرطية باستخدام بناء جملة موجز. يوضح البرنامج التعليمي كيفية بناء تعبير ثلاثي بشرط يتبعه علامة استفهام وكود يتم تشغيله إذا كان الشرط صحيحًا، ثم علامة نقطتين وكود يتم تشغيله إذا كان الشرط خاطئًا. يتم تقديم مفهوم 'كتلة آخر'، مما يسمح بتنفيذ كود بديل إذا لم يتم استيفاء الشرط. يعرض الفيديو كيفية تنفيذ تعبير ثلاثي في ​​تطبيق Flutter لعرض رسالة نصية مركزية، مثل 'لقد فعلتها'، بعد تفاعل مستخدم معين، مع تسليط الضوء على التطبيق العملي للتعبيرات الثلاثية في تحسين تجربة المستخدم.",
                                // Persian
                                "فارسی": "این ویدئو نحوه استفاده از عبارات سه تایی را در برنامه نویسی دارت برای ایجاد عبارات شرطی با استفاده از یک نحو مختصر توضیح می دهد. این آموزش نشان می دهد که چگونه یک عبارت سه تایی را با یک شرط به دنبال آن یک علامت سوال و کد برای اجرا در صورت صحیح بودن شرط، سپس یک دونقطه و کد برای اجرا در صورت نادرست بودن شرط، نشان می دهد. مفهوم 'بلوک دیگری' معرفی شده است که امکان اجرای کد جایگزین را در صورت عدم رعایت شرط فراهم می کند. این ویدئو نحوه پیاده‌سازی یک عبارت سه تایی را در یک برنامه Flutter برای نمایش یک پیام متنی متمرکز، مانند «تو آن را انجام دادی» پس از یک تعامل خاص با کاربر نشان می‌دهد و کاربرد عملی عبارت‌های سه تایی را در بهبود تجربه کاربر برجسته می‌کند.",
                            },
                        },
                        // 43 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Splitting the App Into Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video demonstrates the optimization of code structure in a Flutter app by implementing a ternary expression and splitting the widget tree into separate sub-widgets for better readability and manageability. By introducing the concepts of ternary expressions and sub-widget creation, the tutorial emphasizes the importance of breaking down complex code structures into smaller, more manageable components to enhance code organization and maintainability. The video showcases the process of creating sub-widgets for quiz and result components to streamline the app layout and improve code readability, encouraging the practice of creating smaller, focused widgets for efficient Flutter development.",
                                // German
                                "Deutsch": "Das Video demonstriert die Optimierung der Codestruktur in einer Flutter-App durch Implementierung eines ternären Ausdrucks und Aufteilung des Widget-Baums in separate Unter-Widgets zur besseren Lesbarkeit und Verwaltbarkeit. Durch die Einführung der Konzepte ternärer Ausdrücke und der Erstellung von Unter-Widgets betont das Tutorial, wie wichtig es ist, komplexe Codestrukturen in kleinere, besser verwaltbare Komponenten aufzuteilen, um die Codeorganisation und Wartbarkeit zu verbessern. Das Video zeigt den Prozess der Erstellung von Unter-Widgets für Quiz- und Ergebniskomponenten, um das App-Layout zu optimieren und die Lesbarkeit des Codes zu verbessern, und fördert die Praxis der Erstellung kleinerer, fokussierter Widgets für eine effiziente Flutter-Entwicklung.",
                                // Chinese
                                "中国人": "视频演示了如何通过实现三元表达式并将 widget 树拆分为单独的子 widget 来优化 Flutter 应用程序中的代码结构，以提高可读性和可管理性。通过介绍三元表达式和子 widget 创建的概念，本教程强调了将复杂的代码结构分解为更小、更易于管理的组件以增强代码组织和可维护性的重要性。视频展示了为测验和结果组件创建子 widget 的过程，以简化应用程序布局并提高代码可读性，鼓励创建更小、更集中的 widget 以实现高效的 Flutter 开发。",
                                // Russian
                                "Русский": "Видео демонстрирует оптимизацию структуры кода в приложении Flutter путем внедрения тернарного выражения и разделения дерева виджетов на отдельные подвиджеты для лучшей читаемости и управляемости. Вводя концепции тернарных выражений и создания подвиджетов, руководство подчеркивает важность разбиения сложных структур кода на более мелкие, более управляемые компоненты для улучшения организации кода и удобства обслуживания. Видео демонстрирует процесс создания подвиджетов для компонентов тестов и результатов для оптимизации макета приложения и улучшения читаемости кода, поощряя практику создания более мелких, целенаправленных виджетов для эффективной разработки Flutter.",
                                // French
                                "Français": "La vidéo montre l'optimisation de la structure du code dans une application Flutter en implémentant une expression ternaire et en divisant l'arborescence des widgets en sous-widgets distincts pour une meilleure lisibilité et une meilleure gestion. En introduisant les concepts d'expressions ternaires et de création de sous-widgets, le didacticiel souligne l'importance de décomposer les structures de code complexes en composants plus petits et plus faciles à gérer pour améliorer l'organisation et la maintenabilité du code. La vidéo présente le processus de création de sous-widgets pour les composants de quiz et de résultats afin de rationaliser la mise en page de l'application et d'améliorer la lisibilité du code, encourageant la pratique de la création de widgets plus petits et ciblés pour un développement Flutter efficace.",
                                // Japanese
                                "日本語": "このビデオでは、三項式を実装し、ウィジェット ツリーを個別のサブウィジェットに分割して読みやすさと管理性を向上させることで、Flutter アプリのコード構造を最適化する方法を紹介します。チュートリアルでは、三項式とサブウィジェット作成の概念を紹介することで、複雑なコード構造をより小さく管理しやすいコンポーネントに分解して、コードの整理と保守性を高めることの重要性を強調しています。ビデオでは、クイズと結果コンポーネントのサブウィジェットを作成してアプリのレイアウトを合理化し、コードの読みやすさを向上させるプロセスを紹介し、効率的な Flutter 開発のために小さくて焦点を絞ったウィジェットを作成する方法を推奨しています。",
                                // Korean
                                "한국인": "이 비디오는 3항 표현식을 구현하고 위젯 트리를 별도의 하위 위젯으로 분할하여 가독성과 관리 용이성을 개선함으로써 Flutter 앱의 코드 구조를 최적화하는 방법을 보여줍니다. 3항 표현식과 하위 위젯 생성의 개념을 소개함으로써 이 튜토리얼은 복잡한 코드 구조를 더 작고 관리하기 쉬운 구성 요소로 분해하여 코드 구성과 유지 관리를 향상시키는 것의 중요성을 강조합니다. 이 비디오는 퀴즈 및 결과 구성 요소에 대한 하위 위젯을 생성하여 앱 레이아웃을 간소화하고 코드 가독성을 개선하는 프로세스를 보여주며 효율적인 Flutter 개발을 위해 더 작고 집중적인 위젯을 생성하는 관행을 장려합니다.",
                                // Spanish
                                "Español": "El video demuestra la optimización de la estructura del código en una aplicación Flutter mediante la implementación de una expresión ternaria y la división del árbol de widgets en subwidgets separados para una mejor legibilidad y capacidad de administración. Al presentar los conceptos de expresiones ternarias y creación de subwidgets, el tutorial enfatiza la importancia de dividir estructuras de código complejas en componentes más pequeños y más manejables para mejorar la organización y la capacidad de mantenimiento del código. El video muestra el proceso de creación de subwidgets para componentes de cuestionarios y resultados para optimizar el diseño de la aplicación y mejorar la legibilidad del código, lo que fomenta la práctica de crear widgets más pequeños y enfocados para un desarrollo eficiente de Flutter.",
                                // Hindi
                                "हिंदी": "वीडियो में फ़्लटर ऐप में कोड संरचना के अनुकूलन को एक टर्नरी एक्सप्रेशन को लागू करके और बेहतर पठनीयता और प्रबंधनीयता के लिए विजेट ट्री को अलग-अलग उप-विजेट में विभाजित करके प्रदर्शित किया गया है। टर्नरी एक्सप्रेशन और उप-विजेट निर्माण की अवधारणाओं को पेश करके, ट्यूटोरियल कोड संगठन और रखरखाव को बढ़ाने के लिए जटिल कोड संरचनाओं को छोटे, अधिक प्रबंधनीय घटकों में तोड़ने के महत्व पर जोर देता है। वीडियो ऐप लेआउट को सुव्यवस्थित करने और कोड पठनीयता में सुधार करने के लिए क्विज़ और परिणाम घटकों के लिए उप-विजेट बनाने की प्रक्रिया को प्रदर्शित करता है, जो कुशल फ़्लटर विकास के लिए छोटे, केंद्रित विजेट बनाने के अभ्यास को प्रोत्साहित करता है।",
                                // Portuguese
                                "Português": "O vídeo demonstra a otimização da estrutura do código numa aplicação Flutter implementando uma expressão ternária e dividindo a árvore de widgets em subwidgets separados para uma melhor legibilidade e gestão. Ao apresentar os conceitos de expressões ternárias e criação de subwidgets, o tutorial enfatiza a importância de dividir estruturas de código complexas em componentes mais pequenas e mais geríveis para melhorar a organização e a manutenção do código. O vídeo mostra o processo de criação de subwidgets para componentes de questionários e resultados para agilizar o layout da aplicação e melhorar a legibilidade do código, incentivando a prática de criação de widgets mais pequenos e focados para o desenvolvimento eficiente do Flutter.",
                                // Bengali
                                "বাংলা": "ভিডিওটি একটি ফ্লাটার অ্যাপে কোড স্ট্রাকচারের অপ্টিমাইজেশন প্রদর্শন করে একটি ত্রিদেশীয় অভিব্যক্তি প্রয়োগ করে এবং ভাল পঠনযোগ্যতা এবং পরিচালনাযোগ্যতার জন্য উইজেট ট্রিকে আলাদা সাব-উইজেটে বিভক্ত করে। টার্নারি এক্সপ্রেশন এবং সাব-উইজেট তৈরির ধারণাগুলি প্রবর্তন করে, টিউটোরিয়ালটি কোড সংগঠন এবং রক্ষণাবেক্ষণযোগ্যতা উন্নত করার জন্য জটিল কোড কাঠামোকে ছোট, আরও পরিচালনাযোগ্য উপাদানগুলিতে বিভক্ত করার গুরুত্বের উপর জোর দেয়। ভিডিওটি অ্যাপ লেআউটকে স্ট্রীমলাইন করতে এবং কোড পঠনযোগ্যতা উন্নত করতে কুইজ এবং ফলাফলের উপাদানগুলির জন্য সাব-উইজেট তৈরির প্রক্রিয়া প্রদর্শন করে, দক্ষ ফ্লাটার বিকাশের জন্য ছোট, ফোকাসড উইজেট তৈরির অনুশীলনকে উত্সাহিত করে৷",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو تحسين بنية التعليمات البرمجية في تطبيق Flutter من خلال تنفيذ تعبير ثلاثي وتقسيم شجرة الأدوات إلى أدوات فرعية منفصلة لتحسين قابلية القراءة والإدارة. من خلال تقديم مفاهيم التعبيرات الثلاثية وإنشاء الأدوات الفرعية، يؤكد البرنامج التعليمي على أهمية تقسيم هياكل التعليمات البرمجية المعقدة إلى مكونات أصغر وأكثر قابلية للإدارة لتعزيز تنظيم التعليمات البرمجية وقابليتها للصيانة. يعرض الفيديو عملية إنشاء أدوات فرعية لمكونات الاختبار والنتيجة لتبسيط تخطيط التطبيق وتحسين قابلية قراءة التعليمات البرمجية، وتشجيع ممارسة إنشاء أدوات أصغر وأكثر تركيزًا لتطوير Flutter بكفاءة.",
                                // Persian
                                "فارسی": "این ویدیو بهینه سازی ساختار کد را در یک برنامه Flutter با پیاده سازی یک عبارت سه تایی و تقسیم درخت ویجت به ابزارک های فرعی جداگانه برای خوانایی و مدیریت بهتر نشان می دهد. با معرفی مفاهیم عبارات سه تایی و ایجاد ابزارک فرعی، این آموزش بر اهمیت تجزیه ساختارهای کد پیچیده به اجزای کوچکتر و قابل مدیریت تر برای افزایش سازماندهی کد و قابلیت نگهداری تأکید می کند. این ویدئو فرآیند ایجاد ابزارک‌های فرعی برای کامپوننت‌های آزمون و نتیجه را به نمایش می‌گذارد تا طرح‌بندی برنامه را ساده‌تر کند و خوانایی کد را بهبود بخشد، و تمرین ایجاد ویجت‌های کوچک‌تر و متمرکز برای توسعه کارآمد Flutter را تشویق می‌کند.",
                            },
                        },
                        // 44 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Calculating a Total Score",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker wraps up a module by creating a quiz with different results based on the answers chosen. Each answer is turned into a map with text and a score, which is used to calculate an overall score for the quiz taker. The speaker explains how to update the answer function to include the score, and how to pass the score to the result widget to display different results based on the total score calculated from the quiz answers. They demonstrate using anonymous functions and function references to achieve this in Dart programming.",
                                // German
                                "Deutsch": "In diesem Video schließt der Sprecher ein Modul ab, indem er ein Quiz mit unterschiedlichen Ergebnissen basierend auf den gewählten Antworten erstellt. Jede Antwort wird in eine Karte mit Text und einer Punktzahl umgewandelt, die zur Berechnung einer Gesamtpunktzahl für den Quizteilnehmer verwendet wird. Der Sprecher erklärt, wie die Antwortfunktion aktualisiert wird, um die Punktzahl einzuschließen, und wie die Punktzahl an das Ergebnis-Widget übergeben wird, um unterschiedliche Ergebnisse basierend auf der aus den Quizantworten berechneten Gesamtpunktzahl anzuzeigen. Sie demonstrieren die Verwendung anonymer Funktionen und Funktionsreferenzen, um dies in der Dart-Programmierung zu erreichen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者通过创建一个测验来总结模块，该测验根据所选答案产生不同的结果。每个答案都变成带有文本和分数的地图，用于计算测验者的总分。演讲者解释了如何更新答案函数以包含分数，以及如何将分数传递给结果小部件以根据从测验答案计算出的总分显示不同的结果。他们演示了如何使用匿名函数和函数引用在 Dart 编程中实现这一点。",
                                // Russian
                                "Русский": "В этом видео спикер завершает модуль, создавая тест с разными результатами на основе выбранных ответов. Каждый ответ превращается в карту с текстом и оценкой, которая используется для расчета общей оценки для участника теста. Спикер объясняет, как обновить функцию ответа, чтобы включить оценку, и как передать оценку в виджет результатов, чтобы отобразить разные результаты на основе общей оценки, рассчитанной из ответов теста. Они демонстрируют использование анонимных функций и ссылок на функции для достижения этого в программировании Dart.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant conclut un module en créant un questionnaire avec des résultats différents en fonction des réponses choisies. Chaque réponse est transformée en une carte avec du texte et un score, qui est utilisée pour calculer un score global pour le participant au questionnaire. L'intervenant explique comment mettre à jour la fonction de réponse pour inclure le score et comment transmettre le score au widget de résultat pour afficher différents résultats en fonction du score total calculé à partir des réponses au questionnaire. Il montre comment utiliser des fonctions anonymes et des références de fonctions pour y parvenir dans la programmation Dart.",
                                // Japanese
                                "日本語": "このビデオでは、講師がモジュールの締めくくりとして、選択した回答に基づいて異なる結果を出すクイズを作成します。各回答はテキストとスコアを含むマップに変換され、クイズ受験者の総合スコアを計算するために使用されます。講師は、スコアを含めるように回答関数を更新する方法と、クイズの回答から計算された総合スコアに基づいて異なる結果を表示するためにスコアを結果ウィジェットに渡す方法について説明します。講師は、匿名関数と関数参照を使用して Dart プログラミングでこれを実現する方法を示します。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 선택한 답변에 따라 다른 결과가 나오는 퀴즈를 만들어 모듈을 마무리합니다. 각 답변은 텍스트와 점수가 있는 맵으로 바뀌고, 이를 사용하여 퀴즈 응시자의 전체 점수를 계산합니다. 발표자는 점수를 포함하도록 답변 함수를 업데이트하는 방법과 퀴즈 답변에서 계산된 총점에 따라 다른 결과를 표시하기 위해 점수를 결과 위젯에 전달하는 방법을 설명합니다. 그들은 익명 함수와 함수 참조를 사용하여 Dart 프로그래밍에서 이를 달성하는 방법을 보여줍니다.",
                                // Spanish
                                "Español": "En este video, el orador finaliza un módulo creando un cuestionario con diferentes resultados según las respuestas elegidas. Cada respuesta se convierte en un mapa con texto y una puntuación, que se utiliza para calcular una puntuación general para el participante del cuestionario. El orador explica cómo actualizar la función de respuesta para incluir la puntuación y cómo pasar la puntuación al widget de resultados para mostrar diferentes resultados según la puntuación total calculada a partir de las respuestas del cuestionario. Demuestra cómo usar funciones anónimas y referencias de funciones para lograr esto en la programación Dart.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता चुने गए उत्तरों के आधार पर अलग-अलग परिणामों के साथ एक प्रश्नोत्तरी बनाकर एक मॉड्यूल को समाप्त करता है। प्रत्येक उत्तर को टेक्स्ट और स्कोर के साथ एक मानचित्र में बदल दिया जाता है, जिसका उपयोग प्रश्नोत्तरी लेने वाले के लिए समग्र स्कोर की गणना करने के लिए किया जाता है। वक्ता बताते हैं कि स्कोर को शामिल करने के लिए उत्तर फ़ंक्शन को कैसे अपडेट किया जाए, और क्विज़ उत्तरों से गणना किए गए कुल स्कोर के आधार पर अलग-अलग परिणाम प्रदर्शित करने के लिए स्कोर को परिणाम विजेट में कैसे पास किया जाए। वे डार्ट प्रोग्रामिंग में इसे प्राप्त करने के लिए अनाम फ़ंक्शन और फ़ंक्शन संदर्भों का उपयोग करके प्रदर्शन करते हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador termina um módulo criando um quiz com resultados diferenciados com base nas respostas escolhidas. Cada resposta é transformada num mapa com texto e uma pontuação, que é utilizada para calcular a pontuação global do inquirido. O orador explica como atualizar a função de resposta para incluir a pontuação e como passar a pontuação para o widget de resultados para exibir resultados diferentes com base na pontuação total calculada a partir das respostas do questionário. Demonstram o uso de funções anónimas e referências de funções para o conseguir na programação Dart.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার নির্বাচিত উত্তরগুলির উপর ভিত্তি করে বিভিন্ন ফলাফল সহ একটি কুইজ তৈরি করে একটি মডিউল গুটিয়েছেন৷ প্রতিটি উত্তর পাঠ্য এবং একটি স্কোর সহ একটি মানচিত্রে পরিণত হয়, যা কুইজ গ্রহণকারীর জন্য একটি সামগ্রিক স্কোর গণনা করতে ব্যবহৃত হয়। স্পিকার ব্যাখ্যা করেন কিভাবে স্কোর অন্তর্ভুক্ত করার জন্য উত্তর ফাংশন আপডেট করতে হয়, এবং কুইজের উত্তর থেকে গণনা করা মোট স্কোরের উপর ভিত্তি করে বিভিন্ন ফলাফল প্রদর্শন করতে ফলাফল উইজেটে স্কোর পাস করতে হয়। তারা ডার্ট প্রোগ্রামিং এ এটি অর্জন করতে বেনামী ফাংশন এবং ফাংশন রেফারেন্স ব্যবহার করে প্রদর্শন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يختتم المتحدث وحدة من خلال إنشاء اختبار بنتائج مختلفة بناءً على الإجابات المختارة. يتم تحويل كل إجابة إلى خريطة تحتوي على نص ونتيجة، والتي تُستخدم لحساب النتيجة الإجمالية للمشارك في الاختبار. يشرح المتحدث كيفية تحديث وظيفة الإجابة لتشمل النتيجة، وكيفية تمرير النتيجة إلى أداة النتيجة لعرض نتائج مختلفة بناءً على النتيجة الإجمالية المحسوبة من إجابات الاختبار. كما يوضحون استخدام الدوال المجهولة ومراجع الوظائف لتحقيق ذلك في برمجة Dart.",
                                // Persian
                                "فارسی": "در این ویدئو، گوینده یک ماژول را با ایجاد یک مسابقه با نتایج متفاوت بر اساس پاسخ‌های انتخابی جمع‌بندی می‌کند. هر پاسخ به یک نقشه با متن و یک امتیاز تبدیل می شود که برای محاسبه نمره کلی برای آزمون گیرنده استفاده می شود. گوینده نحوه به روز رسانی تابع پاسخ را برای گنجاندن امتیاز و نحوه انتقال امتیاز به ویجت نتیجه برای نمایش نتایج مختلف بر اساس نمره کل محاسبه شده از پاسخ های مسابقه توضیح می دهد. آنها استفاده از توابع ناشناس و ارجاعات تابع را برای دستیابی به این هدف در برنامه نویسی دارت نشان می دهند.",
                            },
                        },
                        // 45 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Getters & _else-if_",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker demonstrates how to add a final property called resultScore to the result widget and receive the total score as a constructor argument. They explain how to output different texts based on the result score, using a getter to dynamically calculate the result based on the score. The speaker uses if statements to determine the text displayed depending on the result score, with higher scores indicating a more negative personality. By reloading the application and selecting different answers in the quiz, they show how the result text changes based on the user's choices. The speaker also adjusts the text alignment in the result widget to center the text. Overall, they showcase how to create a realistic application that can be fine-tuned and deployed to app stores.",
                                // German
                                "Deutsch": "In diesem Video demonstriert der Sprecher, wie man dem Ergebnis-Widget eine letzte Eigenschaft namens resultScore hinzufügt und die Gesamtpunktzahl als Konstruktorargument erhält. Er erklärt, wie man basierend auf der Ergebnispunktzahl unterschiedliche Texte ausgibt, indem er einen Getter verwendet, um das Ergebnis basierend auf der Punktzahl dynamisch zu berechnen. Der Sprecher verwendet if-Anweisungen, um den angezeigten Text abhängig von der Ergebnispunktzahl zu bestimmen, wobei höhere Punktzahlen auf eine negativere Persönlichkeit hinweisen. Indem er die Anwendung neu lädt und verschiedene Antworten im Quiz auswählt, zeigt er, wie sich der Ergebnistext basierend auf den Entscheidungen des Benutzers ändert. Der Sprecher passt auch die Textausrichtung im Ergebnis-Widget an, um den Text zu zentrieren. Insgesamt zeigt er, wie man eine realistische Anwendung erstellt, die feinabgestimmt und in App-Stores bereitgestellt werden kann.",
                                // Chinese
                                "中国人": "在本视频中，演讲者演示了如何向结果小部件添加一个名为 resultScore 的最终属性，并接收总分作为构造函数参数。他们解释了如何根据结果分数输出不同的文本，使用 getter 根据分数动态计算结果。演讲者使用 if 语句根据结果分数确定显示的文本，分数越高表示性格越消极。通过重新加载应用程序并在测验中选择不同的答案，他们展示了结果文本如何根据用户的选择而变化。演讲者还调整了结果小部件中的文本对齐方式以使文本居中。总的来说，他们展示了如何创建一个可以微调并部署到应用商店的现实应用程序。",
                                // Russian
                                "Русский": "В этом видео докладчик демонстрирует, как добавить конечное свойство, называемое resultScore, в виджет результата и получить общий балл в качестве аргумента конструктора. Они объясняют, как выводить различные тексты на основе балла результата, используя геттер для динамического вычисления результата на основе балла. Докладчик использует операторы if для определения отображаемого текста в зависимости от балла результата, причем более высокие баллы указывают на более негативную личность. Перезагружая приложение и выбирая различные ответы в тесте, они показывают, как текст результата меняется в зависимости от выбора пользователя. Докладчик также настраивает выравнивание текста в виджете результата, чтобы центрировать текст. В целом, они демонстрируют, как создать реалистичное приложение, которое можно настроить и развернуть в магазинах приложений.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant montre comment ajouter une propriété finale appelée resultScore au widget de résultat et recevoir le score total comme argument de constructeur. Il explique comment générer différents textes en fonction du score de résultat, en utilisant un getter pour calculer dynamiquement le résultat en fonction du score. L'intervenant utilise des instructions if pour déterminer le texte affiché en fonction du score de résultat, les scores plus élevés indiquant une personnalité plus négative. En rechargeant l'application et en sélectionnant différentes réponses dans le questionnaire, il montre comment le texte du résultat change en fonction des choix de l'utilisateur. L'intervenant ajuste également l'alignement du texte dans le widget de résultat pour centrer le texte. Dans l'ensemble, il montre comment créer une application réaliste qui peut être peaufinée et déployée sur les magasins d'applications.",
                                // Japanese
                                "日本語": "このビデオでは、講師が resultScore という最終プロパティを結果ウィジェットに追加し、合計スコアをコンストラクター引数として受け取る方法を紹介します。また、スコアに基づいて結果を動的に計算するゲッターを使用して、結果スコアに基づいて異なるテキストを出力する方法についても説明します。講師は、if ステートメントを使用して、結果スコアに応じて表示されるテキストを決定します。スコアが高いほど、性格がネガティブであることを示します。アプリケーションをリロードし、クイズで異なる回答を選択すると、ユーザーの選択に基づいて結果テキストがどのように変化するかを示します。講師はまた、結果ウィジェットのテキスト配置を調整して、テキストを中央に配置します。全体として、微調整してアプリストアに展開できる現実的なアプリケーションを作成する方法を示しています。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 resultScore라는 최종 속성을 result 위젯에 추가하고 총점을 생성자 인수로 받는 방법을 보여줍니다. 발표자는 getter를 사용하여 점수에 따라 동적으로 결과를 계산하여 결과 점수에 따라 다른 텍스트를 출력하는 방법을 설명합니다. 발표자는 if 문을 사용하여 결과 점수에 따라 표시되는 텍스트를 결정하며, 점수가 높을수록 더 부정적인 성격을 나타냅니다. 애플리케이션을 다시 로드하고 퀴즈에서 다른 답변을 선택하여 사용자의 선택에 따라 결과 텍스트가 어떻게 변경되는지 보여줍니다. 발표자는 또한 결과 위젯에서 텍스트 정렬을 조정하여 텍스트를 가운데에 맞춥니다. 전반적으로 미세 조정하여 앱 스토어에 배포할 수 있는 현실적인 애플리케이션을 만드는 방법을 보여줍니다.",
                                // Spanish
                                "Español": "En este video, el orador demuestra cómo agregar una propiedad final llamada resultScore al widget de resultados y recibir la puntuación total como argumento del constructor. Explica cómo generar diferentes textos según la puntuación del resultado, utilizando un captador para calcular dinámicamente el resultado según la puntuación. El orador utiliza instrucciones if para determinar el texto que se muestra según la puntuación del resultado, donde las puntuaciones más altas indican una personalidad más negativa. Al volver a cargar la aplicación y seleccionar diferentes respuestas en el cuestionario, muestra cómo cambia el texto del resultado según las opciones del usuario. El orador también ajusta la alineación del texto en el widget de resultados para centrarlo. En general, muestra cómo crear una aplicación realista que se puede ajustar e implementar en las tiendas de aplicaciones.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता यह दर्शाता है कि परिणाम विजेट में resultScore नामक अंतिम प्रॉपर्टी कैसे जोड़ें और कंस्ट्रक्टर तर्क के रूप में कुल स्कोर कैसे प्राप्त करें। वे बताते हैं कि परिणाम स्कोर के आधार पर अलग-अलग टेक्स्ट कैसे आउटपुट करें, स्कोर के आधार पर परिणाम की गतिशील रूप से गणना करने के लिए गेटर का उपयोग करें। वक्ता परिणाम स्कोर के आधार पर प्रदर्शित टेक्स्ट को निर्धारित करने के लिए if स्टेटमेंट का उपयोग करता है, जिसमें उच्च स्कोर अधिक नकारात्मक व्यक्तित्व का संकेत देते हैं। एप्लिकेशन को फिर से लोड करके और क्विज़ में अलग-अलग उत्तरों का चयन करके, वे दिखाते हैं कि उपयोगकर्ता की पसंद के आधार पर परिणाम टेक्स्ट कैसे बदलता है। स्पीकर परिणाम विजेट में टेक्स्ट संरेखण को भी समायोजित करता है ताकि टेक्स्ट को केंद्र में रखा जा सके। कुल मिलाकर, वे दिखाते हैं कि एक यथार्थवादी एप्लिकेशन कैसे बनाया जाए जिसे ठीक से ट्यून किया जा सके और ऐप स्टोर पर तैनात किया जा सके।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador demonstra como adicionar uma propriedade final chamada resultScore ao widget de resultado e receber a pontuação total como argumento do construtor. Explicam como gerar diferentes textos com base na pontuação do resultado, utilizando um getter para calcular dinamicamente o resultado com base na pontuação. O locutor utiliza as declarações if para determinar o texto apresentado em função da pontuação do resultado, sendo que pontuações mais elevadas indicam uma personalidade mais negativa. Ao recarregar a aplicação e selecionar diferentes respostas no questionário, mostram como o texto do resultado muda com base nas escolhas do utilizador. O altifalante também ajusta o alinhamento do texto no widget de resultados para o centrar. No geral, mostram como criar uma aplicação realista que pode ser ajustada e implementada em lojas de aplicações.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার দেখান কিভাবে ফলাফল উইজেটে resultScore নামক একটি চূড়ান্ত প্রপার্টি যোগ করতে হয় এবং কনস্ট্রাক্টর আর্গুমেন্ট হিসেবে মোট স্কোর পেতে হয়। তারা ব্যাখ্যা করে কিভাবে ফলাফলের স্কোরের উপর ভিত্তি করে বিভিন্ন টেক্সট আউটপুট করতে হয়, একটি গেটার ব্যবহার করে গতিশীলভাবে স্কোরের উপর ভিত্তি করে ফলাফল গণনা করা যায়। স্পিকার ফলাফল স্কোরের উপর নির্ভর করে প্রদর্শিত পাঠ্য নির্ধারণ করতে যদি বিবৃতি ব্যবহার করে, উচ্চতর স্কোরগুলি আরও নেতিবাচক ব্যক্তিত্ব নির্দেশ করে। অ্যাপ্লিকেশনটি পুনরায় লোড করে এবং কুইজে বিভিন্ন উত্তর নির্বাচন করে, তারা ব্যবহারকারীর পছন্দের উপর ভিত্তি করে ফলাফলের পাঠ্য কীভাবে পরিবর্তিত হয় তা দেখায়। স্পিকার পাঠ্যকে কেন্দ্রে রাখতে ফলাফল উইজেটে পাঠ্য সারিবদ্ধকরণও সামঞ্জস্য করে। সামগ্রিকভাবে, তারা কীভাবে একটি বাস্তবসম্মত অ্যাপ্লিকেশন তৈরি করতে হয় তা প্রদর্শন করে যা সূক্ষ্ম সুর করা যায় এবং অ্যাপ স্টোরগুলিতে স্থাপন করা যায়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المتحدث كيفية إضافة خاصية نهائية تسمى resultScore إلى عنصر واجهة المستخدم للنتيجة وتلقي النتيجة الإجمالية كحجة منشئ. كما يشرح كيفية إخراج نصوص مختلفة بناءً على نتيجة النتيجة، باستخدام getter لحساب النتيجة ديناميكيًا بناءً على النتيجة. يستخدم المتحدث عبارات if لتحديد النص المعروض بناءً على نتيجة النتيجة، حيث تشير الدرجات الأعلى إلى شخصية أكثر سلبية. من خلال إعادة تحميل التطبيق واختيار إجابات مختلفة في الاختبار، يوضح كيف يتغير نص النتيجة بناءً على اختيارات المستخدم. كما يضبط المتحدث محاذاة النص في عنصر واجهة المستخدم للنتيجة لتمركز النص. بشكل عام، يوضح كيفية إنشاء تطبيق واقعي يمكن ضبطه ونشره على متاجر التطبيقات.",
                                // Persian
                                "فارسی": "در این ویدئو، سخنران نشان می دهد که چگونه می توان یک ویژگی نهایی به نام resultScore را به ویجت نتیجه اضافه کرد و نمره کل را به عنوان آرگومان سازنده دریافت کرد. آنها نحوه خروجی متن های مختلف را بر اساس امتیاز نتیجه، با استفاده از یک گیرنده برای محاسبه پویا نتیجه بر اساس امتیاز توضیح می دهند. گوینده از جملات if برای تعیین متن نمایش داده شده بسته به امتیاز نتیجه استفاده می کند، با نمرات بالاتر که نشان دهنده شخصیت منفی تر است. با بارگذاری مجدد برنامه و انتخاب پاسخ های مختلف در مسابقه، نحوه تغییر متن نتیجه بر اساس انتخاب کاربر را نشان می دهند. بلندگو همچنین تراز متن را در ویجت نتیجه تنظیم می کند تا متن را در مرکز قرار دهد. به طور کلی، آنها نحوه ایجاد یک برنامه کاربردی واقع گرایانه را نشان می دهند که می تواند به خوبی تنظیم شود و در فروشگاه های برنامه مستقر شود.",
                            },
                        },
                        // 46 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Resetting the Quiz",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor explains how to add a button in the results screen to reset the quiz progress. They demonstrate wrapping the text in a column widget using automatic refactoring in Flutter IDE, and adding a FlatButton button below the text. The instructor notes the deprecation of FlatButton in Flutter version two and suggests using TextButton as an alternative. They show how to reset the quiz by creating a reset function in the main.dart file and passing a pointer to the function to the result widget for the reset button. The instructor also discusses styling the button with colors and addresses differences in styling for TextButton if used instead of FlatButton. The video concludes with a reminder that the user interface can be improved with further exploration into building interfaces, styling applications, and layouting in Flutter.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Kursleiter, wie man im Ergebnisbildschirm eine Schaltfläche hinzufügt, um den Quizfortschritt zurückzusetzen. Er demonstriert, wie man den Text mithilfe automatischer Refaktorierung in Flutter IDE in ein Spalten-Widget einbindet und eine FlatButton-Schaltfläche unter dem Text hinzufügt. Der Kursleiter weist darauf hin, dass FlatButton in Flutter Version 2 veraltet ist, und schlägt als Alternative die Verwendung von TextButton vor. Er zeigt, wie man das Quiz zurücksetzt, indem man eine Reset-Funktion in der Datei main.dart erstellt und einen Zeiger auf die Funktion an das Ergebnis-Widget für die Reset-Schaltfläche übergibt. Der Kursleiter bespricht auch die Gestaltung der Schaltfläche mit Farben und geht auf Unterschiede bei der Gestaltung von TextButton ein, wenn dieser anstelle von FlatButton verwendet wird. Das Video endet mit der Erinnerung, dass die Benutzeroberfläche durch weitere Erkundungen beim Erstellen von Schnittstellen, Gestalten von Anwendungen und Layouten in Flutter verbessert werden kann.",
                                // Chinese
                                "中国人": "在本视频中，讲师解释了如何在结果屏幕中添加按钮以重置测验进度。他们演示了如何使用 Flutter IDE 中的自动重构将文本包装在列小部件中，并在文本下方添加一个 FlatButton 按钮。讲师指出，Flutter 版本 2 中已弃用 FlatButton，并建议使用 TextButton 作为替代方案。他们展示了如何通过在 main.dart 文件中创建一个重置函数并将指向该函数的指针传递给重置按钮的结果小部件来重置测验。讲师还讨论了使用颜色设置按钮的样式，并解决了使用 TextButton 代替 FlatButton 时样式的差异。视频最后提醒大家，通过进一步探索在 Flutter 中构建界面、设计应用程序样式和布局，可以改进用户界面。",
                                // Russian
                                "Русский": "В этом видео инструктор объясняет, как добавить кнопку на экран результатов для сброса хода выполнения теста. Они демонстрируют перенос текста в виджет столбца с использованием автоматического рефакторинга в Flutter IDE и добавление кнопки FlatButton под текстом. Инструктор отмечает устаревание FlatButton во Flutter версии два и предлагает использовать TextButton в качестве альтернативы. Они показывают, как сбросить тест, создав функцию сброса в файле main.dart и передав указатель на функцию в виджет результата для кнопки сброса. Инструктор также обсуждает стилизацию кнопки с помощью цветов и рассматривает различия в стилизации для TextButton, если она используется вместо FlatButton. Видео завершается напоминанием о том, что пользовательский интерфейс можно улучшить, если продолжить изучение создания интерфейсов, стилизации приложений и макетирования во Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur explique comment ajouter un bouton dans l'écran des résultats pour réinitialiser la progression du quiz. Il montre comment envelopper le texte dans un widget de colonne à l'aide de la refactorisation automatique dans Flutter IDE et ajouter un bouton FlatButton sous le texte. L'instructeur note l'obsolescence de FlatButton dans la version 2 de Flutter et suggère d'utiliser TextButton comme alternative. Il montre comment réinitialiser le quiz en créant une fonction de réinitialisation dans le fichier main.dart et en transmettant un pointeur vers la fonction au widget de résultat pour le bouton de réinitialisation. L'instructeur discute également du style du bouton avec des couleurs et aborde les différences de style pour TextButton s'il est utilisé à la place de FlatButton. La vidéo se termine par un rappel que l'interface utilisateur peut être améliorée en explorant davantage la création d'interfaces, le style des applications et la mise en page dans Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、講師が結果画面にボタンを追加してクイズの進行状況をリセットする方法を説明しています。Flutter IDE の自動リファクタリングを使用してテキストを列ウィジェットにラップし、テキストの下に FlatButton ボタンを追加する方法を示します。講師は、Flutter バージョン 2 で FlatButton が非推奨になったことを指摘し、代わりに TextButton を使用することを提案しています。また、main.dart ファイルにリセット関数を作成し、その関数へのポインタをリセット ボタンの結果ウィジェットに渡すことでクイズをリセットする方法を示します。講師は、ボタンの色によるスタイル設定についても説明し、FlatButton の代わりに TextButton を使用した場合のスタイル設定の違いについても説明します。ビデオの最後には、Flutter でのインターフェイスの構築、アプリケーションのスタイル設定、レイアウトをさらに検討することで、ユーザー インターフェイスを改善できることを再度示しています。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 결과 화면에 퀴즈 진행 상황을 재설정하는 버튼을 추가하는 방법을 설명합니다. 강사는 Flutter IDE에서 자동 리팩토링을 사용하여 텍스트를 열 위젯에 래핑하고 텍스트 아래에 FlatButton 버튼을 추가하는 방법을 보여줍니다. 강사는 Flutter 버전 2에서 FlatButton이 더 이상 사용되지 않는다는 점을 언급하고 대안으로 TextButton을 사용할 것을 제안합니다. 강사는 main.dart 파일에 재설정 함수를 만들고 재설정 버튼의 결과 위젯에 함수 포인터를 전달하여 퀴즈를 재설정하는 방법을 보여줍니다. 강사는 또한 색상으로 버튼 스타일을 지정하는 방법을 설명하고 FlatButton 대신 TextButton을 사용하는 경우 스타일의 차이점을 다룹니다. 이 비디오는 Flutter에서 인터페이스 구축, 애플리케이션 스타일 지정 및 레이아웃을 더 탐구하면 사용자 인터페이스를 개선할 수 있다는 점을 상기시키며 마무리합니다.",
                                // Spanish
                                "Español": "En este video, el instructor explica cómo agregar un botón en la pantalla de resultados para restablecer el progreso del cuestionario. Demuestra cómo envolver el texto en un widget de columna mediante la refactorización automática en Flutter IDE y cómo agregar un botón FlatButton debajo del texto. El instructor señala la obsolescencia de FlatButton en la versión dos de Flutter y sugiere usar TextButton como alternativa. Muestra cómo restablecer el cuestionario creando una función de restablecimiento en el archivo main.dart y pasando un puntero a la función al widget de resultados para el botón de restablecimiento. El instructor también analiza cómo aplicar estilos al botón con colores y aborda las diferencias en el estilo de TextButton si se usa en lugar de FlatButton. El video concluye con un recordatorio de que la interfaz de usuario se puede mejorar con una mayor exploración en la creación de interfaces, el diseño de aplicaciones y el diseño en Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक बताते हैं कि क्विज़ प्रगति को रीसेट करने के लिए परिणाम स्क्रीन में बटन कैसे जोड़ा जाए। वे फ़्लटर IDE में स्वचालित रीफ़ैक्टरिंग का उपयोग करके कॉलम विजेट में टेक्स्ट को लपेटना और टेक्स्ट के नीचे फ़्लैटबटन बटन जोड़ना प्रदर्शित करते हैं। प्रशिक्षक फ़्लटर संस्करण दो में फ़्लैटबटन के अप्रचलन को नोट करता है और विकल्प के रूप में टेक्स्टबटन का उपयोग करने का सुझाव देता है। वे दिखाते हैं कि main.dart फ़ाइल में रीसेट फ़ंक्शन बनाकर और रीसेट बटन के लिए परिणाम विजेट को फ़ंक्शन के लिए पॉइंटर पास करके क्विज़ को कैसे रीसेट किया जाए। प्रशिक्षक रंगों के साथ बटन को स्टाइल करने पर भी चर्चा करता है और फ़्लैटबटन के बजाय उपयोग किए जाने पर टेक्स्टबटन के लिए स्टाइलिंग में अंतर को संबोधित करता है। वीडियो एक अनुस्मारक के साथ समाप्त होता है कि फ़्लटर में इंटरफ़ेस बनाने, एप्लिकेशन को स्टाइल करने और लेआउटिंग में आगे की खोज के साथ उपयोगकर्ता इंटरफ़ेस को बेहतर बनाया जा सकता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor explica como adicionar um botão no ecrã de resultados para repor o progresso do questionário. Demonstram a quebra do texto num widget de coluna utilizando a refatoração automática no Flutter IDE e adicionando um botão FlatButton abaixo do texto. O instrutor observa a descontinuação do FlatButton na versão dois do Flutter e sugere a utilização do TextButton como alternativa. Mostram como repor o questionário criando uma função de reposição no ficheiro main.dart e passando um ponteiro para a função para o widget de resultado do botão de reposição. O instrutor também discute o estilo do botão com cores e aborda as diferenças no estilo do TextButton se for utilizado em vez do FlatButton. O vídeo termina com um lembrete de que a interface do utilizador pode ser melhorada com uma exploração mais aprofundada da construção de interfaces, estilo de aplicações e layout no Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক ব্যাখ্যা করেছেন কীভাবে কুইজের অগ্রগতি পুনরায় সেট করতে ফলাফলের পর্দায় একটি বোতাম যুক্ত করতে হয়। তারা ফ্লাটার আইডিই-তে স্বয়ংক্রিয় রিফ্যাক্টরিং ব্যবহার করে একটি কলাম উইজেটে পাঠ্যটি মোড়ানো এবং পাঠ্যের নীচে একটি ফ্ল্যাটবাটন বোতাম যুক্ত করার প্রদর্শন করে। প্রশিক্ষক ফ্লটার সংস্করণ দুই-এ ফ্ল্যাটবাটনের অবমূল্যায়ন নোট করেন এবং বিকল্প হিসেবে টেক্সটবাটন ব্যবহার করার পরামর্শ দেন। তারা দেখায় কিভাবে main.dart ফাইলে একটি রিসেট ফাংশন তৈরি করে এবং রিসেট বোতামের জন্য ফলাফল উইজেটে ফাংশনে একটি পয়েন্টার পাঠানোর মাধ্যমে কুইজটি পুনরায় সেট করতে হয়। এছাড়াও প্রশিক্ষক রঙের সাথে বোতামের স্টাইলিং নিয়ে আলোচনা করেন এবং ফ্ল্যাটবাটনের পরিবর্তে ব্যবহার করা হলে টেক্সটবাটনের স্টাইলিংয়ে পার্থক্যগুলিকে ঠিকানা দেন। ভিডিওটি একটি অনুস্মারক দিয়ে শেষ করা হয়েছে যে ইউজার ইন্টারফেসটিকে আরও অন্বেষণের মাধ্যমে বিল্ডিং ইন্টারফেস, স্টাইলিং অ্যাপ্লিকেশন এবং ফ্লাটারে লেআউটিংয়ের মাধ্যমে উন্নত করা যেতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المدرب كيفية إضافة زر في شاشة النتائج لإعادة تعيين تقدم الاختبار. كما يوضح كيفية لف النص في عنصر واجهة مستخدم عمودي باستخدام إعادة الهيكلة التلقائية في Flutter IDE، وإضافة زر FlatButton أسفل النص. ويشير المدرب إلى إهمال FlatButton في إصدار Flutter الثاني ويقترح استخدام TextButton كبديل. كما يوضح كيفية إعادة تعيين الاختبار عن طريق إنشاء دالة إعادة تعيين في ملف main.dart وتمرير مؤشر إلى الدالة إلى عنصر واجهة المستخدم للنتيجة لزر إعادة التعيين. ويناقش المدرب أيضًا تصميم الزر بالألوان ويتناول الاختلافات في التصميم لـ TextButton إذا تم استخدامه بدلاً من FlatButton. ويختتم الفيديو بتذكير بأنه يمكن تحسين واجهة المستخدم بمزيد من الاستكشاف في بناء الواجهات وتصميم التطبيقات والتخطيط في Flutter.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس نحوه اضافه کردن دکمه در صفحه نتایج را برای بازنشانی پیشرفت مسابقه توضیح می دهد. آنها نشان می دهند که متن را در یک ویجت ستونی با استفاده از refactoring خودکار در Flutter IDE، و اضافه کردن دکمه FlatButton در زیر متن نشان می دهند. مربی به منسوخ شدن FlatButton در Flutter نسخه دو اشاره می کند و پیشنهاد می کند از TextButton به عنوان جایگزین استفاده کنید. آنها نحوه بازنشانی مسابقه را با ایجاد یک تابع بازنشانی در فایل main.dart و ارسال یک اشاره گر به تابع به ویجت نتیجه برای دکمه تنظیم مجدد نشان می دهند. مدرس همچنین در مورد استایل دادن به دکمه با رنگ‌ها بحث می‌کند و در صورت استفاده به جای FlatButton، تفاوت‌ها در استایل TextButton را بیان می‌کند. این ویدئو با یادآوری به پایان می رسد که رابط کاربری را می توان با کاوش بیشتر در رابط های ساختمان، برنامه های کاربردی سبک و چیدمان در Flutter بهبود بخشید.",
                            },
                        },
                        // 47 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "_Old_ Button Widgets vs _New_ Button Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, Maximilian discusses the deprecation of certain buttons in Flutter versions greater than Flutter. He explains that despite the deprecation warnings, users can still use the old buttons such as RaisedButton, FlatButton, and OutlineButton. Maximilian demonstrates how to migrate to the new buttons, including ElevatedButton to replace RaisedButton, TextButton to replace FlatButton, and OutlinedButton (with an extra 'D') to replace the old OutlinedButton. He details how the new buttons have a different styling approach, with a single style argument to set styling preferences, contrasting with the old buttons' individual style properties. Maximilian shows how to use the ElevatedButton, TextButton, and OutlinedButton widgets along with the style arguments to customize button appearance, providing options for simple cases with minimal customization as well as more complex styling needs. Max advises users that while they can continue using the deprecated buttons, migrating to the new buttons is not difficult and offers a more future-proof solution.",
                                // German
                                "Deutsch": "In diesem Video bespricht Maximilian die Abkündigung bestimmter Schaltflächen in Flutter-Versionen höher als Flutter. Er erklärt, dass Benutzer trotz der Abkündigungswarnungen immer noch die alten Schaltflächen wie RaisedButton, FlatButton und OutlineButton verwenden können. Maximilian zeigt, wie man auf die neuen Schaltflächen migriert, darunter ElevatedButton als Ersatz für RaisedButton, TextButton als Ersatz für FlatButton und OutlinedButton (mit einem zusätzlichen „D“) als Ersatz für den alten OutlinedButton. Er beschreibt ausführlich, wie die neuen Schaltflächen einen anderen Stilansatz haben, mit einem einzigen Stilargument zum Festlegen von Stileinstellungen, im Gegensatz zu den einzelnen Stileigenschaften der alten Schaltflächen. Maximilian zeigt, wie man die Widgets ElevatedButton, TextButton und OutlinedButton zusammen mit den Stilargumenten verwendet, um das Erscheinungsbild der Schaltflächen anzupassen, und bietet Optionen für einfache Fälle mit minimaler Anpassung sowie für komplexere Stilanforderungen. Max weist Benutzer darauf hin, dass sie zwar weiterhin die veralteten Schaltflächen verwenden können, die Migration auf die neuen Schaltflächen jedoch nicht schwierig ist und eine zukunftssicherere Lösung bietet.",
                                // Chinese
                                "中国人": "在本视频中，Maximilian 讨论了 Flutter 版本高于 Flutter 版本中某些按钮的弃用情况。他解释说，尽管有弃用警告，用户仍然可以使用旧按钮，例如 RaisedButton、FlatButton 和 OutlineButton。Maximilian 演示了如何迁移到新按钮，包括用 ElevatedButton 替换 RaisedButton、用 TextButton 替换 FlatButton 以及用 OutlinedButton（多了一个“D”）替换旧 OutlinedButton。他详细介绍了新按钮的样式方法的不同，使用单个样式参数来设置样式首选项，与旧按钮的单个样式属性形成对比。Maximilian 展示了如何使用 ElevatedButton、TextButton 和 OutlinedButton 小部件以及样式参数来自定义按钮外观，为需要最少自定义的简单情况以及更复杂的样式需求提供选项。Max 建议用户，虽然他们可以继续使用弃用的按钮，但迁移到新按钮并不困难，并且提供了更具前瞻性的解决方案。",
                                // Russian
                                "Русский": "В этом видео Максимилиан обсуждает устаревание некоторых кнопок в версиях Flutter старше Flutter. Он объясняет, что, несмотря на предупреждения об устаревании, пользователи по-прежнему могут использовать старые кнопки, такие как RaisedButton, FlatButton и OutlineButton. Максимилиан демонстрирует, как перейти на новые кнопки, включая ElevatedButton для замены RaisedButton, TextButton для замены FlatButton и OutlinedButton (с дополнительной буквой «D») для замены старой OutlinedButton. Он подробно описывает, как новые кнопки имеют другой подход к стилю, с одним аргументом стиля для установки предпочтений стиля, в отличие от индивидуальных свойств стиля старых кнопок. Максимилиан показывает, как использовать виджеты ElevatedButton, TextButton и OutlinedButton вместе с аргументами стиля для настройки внешнего вида кнопок, предоставляя варианты для простых случаев с минимальной настройкой, а также для более сложных потребностей в стиле. Макс сообщает пользователям, что, хотя они могут продолжать использовать устаревшие кнопки, переход на новые кнопки несложный и представляет собой более перспективное решение.",
                                // French
                                "Français": "Dans cette vidéo, Maximilian discute de la dépréciation de certains boutons dans les versions de Flutter supérieures à Flutter. Il explique que malgré les avertissements de dépréciation, les utilisateurs peuvent toujours utiliser les anciens boutons tels que RaisedButton, FlatButton et OutlineButton. Maximilian montre comment migrer vers les nouveaux boutons, notamment ElevatedButton pour remplacer RaisedButton, TextButton pour remplacer FlatButton et OutlinedButton (avec un « D » supplémentaire) pour remplacer l'ancien OutlinedButton. Il détaille comment les nouveaux boutons ont une approche de style différente, avec un seul argument de style pour définir les préférences de style, contrastant avec les propriétés de style individuelles des anciens boutons. Maximilian montre comment utiliser les widgets ElevatedButton, TextButton et OutlinedButton avec les arguments de style pour personnaliser l'apparence des boutons, en fournissant des options pour les cas simples avec une personnalisation minimale ainsi que pour les besoins de style plus complexes. Max informe les utilisateurs que même s'ils peuvent continuer à utiliser les boutons obsolètes, la migration vers les nouveaux boutons n'est pas difficile et offre une solution plus pérenne.",
                                // Japanese
                                "日本語": "このビデオでは、Maximilian が Flutter よりも上位の Flutter バージョンで特定のボタンが非推奨になることについて説明しています。非推奨の警告があるにもかかわらず、ユーザーは RaisedButton、FlatButton、OutlineButton などの古いボタンを引き続き使用できると説明しています。Maximilian は、RaisedButton を置き換える ElevatedButton、FlatButton を置き換える TextButton、古い OutlinedButton を置き換える OutlinedButton ('D' が 1 つ追加) など、新しいボタンに移行する方法を示しています。新しいボタンのスタイル設定のアプローチが異なり、古いボタンの個々のスタイル プロパティとは対照的に、スタイル設定を設定するための単一のスタイル引数が使用されていることを詳しく説明しています。Maximilian は、ElevatedButton、TextButton、OutlinedButton ウィジェットをスタイル引数とともに使用してボタンの外観をカスタマイズする方法を示し、最小限のカスタマイズで単純なケースとより複雑なスタイル設定のニーズに対応するオプションを提供します。 Max 氏は、廃止されたボタンを引き続き使用することはできるが、新しいボタンへの移行は難しくなく、より将来性のあるソリューションになるとユーザーにアドバイスしています。",
                                // Korean
                                "한국인": "이 비디오에서 Maximilian은 Flutter보다 더 큰 버전의 Flutter에서 특정 버튼의 사용 중단에 대해 설명합니다. 그는 사용 중단 경고에도 불구하고 사용자는 RaisedButton, FlatButton 및 OutlineButton과 같은 이전 버튼을 계속 사용할 수 있다고 설명합니다. Maximilian은 RaisedButton을 대체하는 ElevatedButton, FlatButton을 대체하는 TextButton, 이전 OutlinedButton을 대체하는 OutlinedButton(추가 'D' 포함)을 포함하여 새 버튼으로 마이그레이션하는 방법을 보여줍니다. 그는 새 버튼이 스타일 기본 설정을 설정하는 단일 스타일 인수와 이전 버튼의 개별 스타일 속성과 대조되는 다른 스타일 접근 방식을 사용하는 방법을 자세히 설명합니다. Maximilian은 ElevatedButton, TextButton 및 OutlinedButton 위젯을 스타일 인수와 함께 사용하여 버튼 모양을 사용자 지정하고 최소한의 사용자 지정이 필요한 간단한 사례와 더 복잡한 스타일 요구 사항에 대한 옵션을 제공하는 방법을 보여줍니다. Max는 사용자에게 사용 중단된 버튼을 계속 사용할 수 있지만 새 버튼으로 마이그레이션하는 것이 어렵지 않으며 더욱 미래 지향적인 솔루션을 제공한다고 조언합니다.",
                                // Spanish
                                "Español": "En este video, Maximilian analiza la descontinuación de ciertos botones en versiones de Flutter posteriores a Flutter. Explica que, a pesar de las advertencias de descontinuación, los usuarios aún pueden usar los botones antiguos, como RaisedButton, FlatButton y OutlineButton. Maximilian demuestra cómo migrar a los nuevos botones, incluidos ElevatedButton para reemplazar a RaisedButton, TextButton para reemplazar a FlatButton y OutlinedButton (con una 'D' adicional) para reemplazar al antiguo OutlinedButton. Detalla cómo los nuevos botones tienen un enfoque de estilo diferente, con un solo argumento de estilo para establecer las preferencias de estilo, en contraste con las propiedades de estilo individuales de los botones antiguos. Maximilian muestra cómo usar los widgets ElevatedButton, TextButton y OutlinedButton junto con los argumentos de estilo para personalizar la apariencia del botón, brindando opciones para casos simples con una personalización mínima, así como necesidades de estilo más complejas. Max advierte a los usuarios que, si bien pueden continuar usando los botones obsoletos, migrar a los nuevos botones no es difícil y ofrece una solución más preparada para el futuro.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, मैक्सीमिलियन फ़्लटर से बड़े फ़्लटर संस्करणों में कुछ बटनों के अप्रचलन पर चर्चा करते हैं। वह बताते हैं कि अप्रचलन चेतावनियों के बावजूद, उपयोगकर्ता अभी भी पुराने बटन जैसे कि RaisedButton, FlatButton और OutlineButton का उपयोग कर सकते हैं। मैक्सीमिलियन प्रदर्शित करते हैं कि नए बटनों पर कैसे माइग्रेट किया जाए, जिसमें RaisedButton को बदलने के लिए ElevatedButton, FlatButton को बदलने के लिए TextButton और पुराने OutlinedButton को बदलने के लिए OutlinedButton (एक अतिरिक्त 'D' के साथ) शामिल हैं। वह विस्तार से बताते हैं कि कैसे नए बटनों में स्टाइलिंग का एक अलग तरीका है, स्टाइलिंग वरीयताओं को सेट करने के लिए एक ही स्टाइल तर्क के साथ, पुराने बटनों की व्यक्तिगत स्टाइल विशेषताओं के विपरीत। मैक्सीमिलियन दिखाते हैं कि बटन की उपस्थिति को अनुकूलित करने के लिए स्टाइल तर्कों के साथ ElevatedButton, TextButton और OutlinedButton विजेट का उपयोग कैसे करें, न्यूनतम अनुकूलन के साथ-साथ अधिक जटिल स्टाइलिंग आवश्यकताओं के लिए विकल्प प्रदान करते हैं। मैक्स उपयोगकर्ताओं को सलाह देते हैं कि जब वे अप्रचलित बटनों का उपयोग करना जारी रख सकते हैं, तो नए बटनों पर माइग्रेट करना मुश्किल नहीं है और यह भविष्य के लिए अधिक सुरक्षित समाधान प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, Maximilian discute a descontinuação de determinados botões em versões do Flutter superiores ao Flutter. Explica que, apesar dos avisos de descontinuação, os utilizadores ainda podem utilizar os botões antigos, como o RaisedButton, FlatButton e OutlineButton. Maximilian demonstra como migrar para os novos botões, incluindo o ElevatedButton para substituir o RaisedButton, o TextButton para substituir o FlatButton e o OutlinedButton (com um 'D' extra) para substituir o antigo OutlinedButton. Detalha como os novos botões têm uma abordagem de estilo diferente, com um único argumento de estilo para definir as preferências de estilo, contrastando com as propriedades de estilo individuais dos botões antigos. O Maximilian mostra como utilizar os widgets ElevatedButton, TextButton e OutlinedButton juntamente com os argumentos de estilo para personalizar a aparência do botão, fornecendo opções para casos simples com personalização mínima, bem como necessidades de estilo mais complexas. O Max informa os utilizadores que, embora possam continuar a utilizar os botões obsoletos, a migração para os novos botões não é difícil e oferece uma solução mais preparada para o futuro.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, ম্যাক্সিমিলিয়ান ফ্লটারের চেয়ে বড় ফ্লটার সংস্করণে কিছু বোতামের অবচয় নিয়ে আলোচনা করেছে। তিনি ব্যাখ্যা করেছেন যে অবমূল্যায়ন সতর্কতা সত্ত্বেও, ব্যবহারকারীরা এখনও পুরানো বোতামগুলি যেমন RaisedButton, FlatButton, এবং OutlineButton ব্যবহার করতে পারেন৷ ম্যাক্সিমিলিয়ান দেখায় কিভাবে নতুন বোতামে স্থানান্তর করা যায়, যার মধ্যে রয়েছে RaisedButton প্রতিস্থাপন করার জন্য ElevatedButton, FlatButton প্রতিস্থাপনের জন্য TextButton এবং পুরানো OutlinedButton প্রতিস্থাপন করার জন্য OutlinedButton (একটি অতিরিক্ত 'D' সহ)। তিনি বিশদ বর্ণনা করেছেন কিভাবে নতুন বোতামগুলির একটি ভিন্ন স্টাইলিং পদ্ধতি রয়েছে, স্টাইলিং পছন্দগুলি সেট করার জন্য একটি একক শৈলী যুক্তি সহ, পুরানো বোতামগুলির স্বতন্ত্র শৈলী বৈশিষ্ট্যগুলির সাথে বৈপরীত্য। ম্যাক্সিমিলিয়ান দেখায় কিভাবে এলিভেটেড বাটন, টেক্সটবাটন এবং আউটলাইনডবাটন উইজেটগুলি ব্যবহার করতে হয় বোতামের উপস্থিতি কাস্টমাইজ করার জন্য শৈলী আর্গুমেন্টের সাথে, ন্যূনতম কাস্টমাইজেশনের পাশাপাশি আরও জটিল স্টাইলিং প্রয়োজনের জন্য সহজ ক্ষেত্রে বিকল্পগুলি প্রদান করে। ম্যাক্স ব্যবহারকারীদের পরামর্শ দেয় যে তারা যখন অবহেলিত বোতামগুলি ব্যবহার করা চালিয়ে যেতে পারে, তখন নতুন বোতামগুলিতে স্থানান্তর করা কঠিন নয় এবং আরও ভবিষ্যত-প্রমাণ সমাধান অফার করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش Maximilian إهمال بعض الأزرار في إصدارات Flutter الأكبر من Flutter. ويوضح أنه على الرغم من تحذيرات الإهمال، لا يزال بإمكان المستخدمين استخدام الأزرار القديمة مثل RaisedButton وFlatButton وOutlineButton. ويوضح Maximilian كيفية الانتقال إلى الأزرار الجديدة، بما في ذلك ElevatedButton لاستبدال RaisedButton وTextButton لاستبدال FlatButton وOutlinedButton (مع إضافة حرف 'D') لاستبدال OutlinedButton القديم. ويوضح بالتفصيل كيف أن الأزرار الجديدة لها نهج تصميم مختلف، مع وسيطة تصميم واحدة لتعيين تفضيلات التصميم، على النقيض من خصائص التصميم الفردية للأزرار القديمة. ويوضح Maximilian كيفية استخدام عناصر واجهة المستخدم ElevatedButton وTextButton وOutlinedButton جنبًا إلى جنب مع وسيطات التصميم لتخصيص مظهر الزر، مما يوفر خيارات للحالات البسيطة مع الحد الأدنى من التخصيص بالإضافة إلى احتياجات التصميم الأكثر تعقيدًا. وينصح ماكس المستخدمين بأنه على الرغم من قدرتهم على الاستمرار في استخدام الأزرار القديمة، فإن الانتقال إلى الأزرار الجديدة ليس بالأمر الصعب ويقدم حلاً أكثر استعدادًا للمستقبل.",
                                // Persian
                                "فارسی": "در این ویدیو، ماکسیمیلیان در مورد از بین رفتن دکمه‌های خاص در نسخه‌های فلاتر بزرگتر از فلاتر صحبت می‌کند. او توضیح می دهد که با وجود هشدارهای منسوخ، کاربران همچنان می توانند از دکمه های قدیمی مانند RaisedButton، FlatButton و OutlineButton استفاده کنند. Maximilian نحوه مهاجرت به دکمه های جدید را نشان می دهد، از جمله ElevatedButton برای جایگزینی RaisedButton، TextButton برای جایگزینی FlatButton، و OutlinedButton (با یک 'D' اضافی) برای جایگزینی OutlinedButton قدیمی. او توضیح می‌دهد که چگونه دکمه‌های جدید یک رویکرد استایل متفاوت دارند، با یک استدلال سبک واحد برای تنظیم ترجیحات استایل، در تضاد با ویژگی‌های سبک فردی دکمه‌های قدیمی. Maximilian نحوه استفاده از ویجت‌های ElevatedButton، TextButton و OutlinedButton را به همراه آرگومان‌های سبک برای سفارشی‌سازی ظاهر دکمه‌ها نشان می‌دهد و گزینه‌هایی را برای موارد ساده با حداقل سفارشی‌سازی و همچنین نیازهای یک ظاهر طراحی پیچیده‌تر ارائه می‌دهد. Max به کاربران توصیه می کند که در حالی که می توانند به استفاده از دکمه های منسوخ شده ادامه دهند، مهاجرت به دکمه های جدید دشوار نیست و راه حلی برای آینده ارائه می دهد.",
                            },
                        },
                        // 48 [Video Number]
                        {
                            "SectionName": "Flutter Basics [QUIZ APP]",
                            "VideoName": "Wrap Up",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this module, the instructor covered important concepts such as widgets, stateful and stateless widgets, managing data, and working with Dart fundamentals. Students learned about built-in widgets, creating custom widgets, passing data as arguments, and accessing resources in the official widget catalog. The module focused on understanding Flutter basics, building user interfaces, and getting familiar with Dart programming. The instructor encouraged students to explore attached resources and text lectures to enhance their understanding further. Moving forward, the course will delve deeper into advanced features and functionalities of Dart and Flutter.",
                                // German
                                "Deutsch": "In diesem Modul behandelte der Dozent wichtige Konzepte wie Widgets, zustandsbehaftete und zustandslose Widgets, Datenverwaltung und die Arbeit mit Dart-Grundlagen. Die Studierenden lernten integrierte Widgets kennen, erstellten benutzerdefinierte Widgets, übergaben Daten als Argumente und griffen auf Ressourcen im offiziellen Widget-Katalog zu. Das Modul konzentrierte sich auf das Verständnis der Flutter-Grundlagen, das Erstellen von Benutzeroberflächen und die Vertrautheit mit der Dart-Programmierung. Der Dozent ermutigte die Studierenden, die beigefügten Ressourcen und Textvorträge zu erkunden, um ihr Verständnis weiter zu vertiefen. Im weiteren Verlauf wird der Kurs tiefer in die erweiterten Funktionen und Funktionalitäten von Dart und Flutter eintauchen.",
                                // Chinese
                                "中国人": "在本模块中，讲师介绍了一些重要概念，例如小部件、有状态和无状态小部件、管理数据以及使用 Dart 基础知识。学生学习了内置小部件、创建自定义小部件、将数据作为参数传递以及访问官方小部件目录中的资源。该模块侧重于了解 Flutter 基础知识、构建用户界面以及熟悉 Dart 编程。讲师鼓励学生探索附加的资源和文本讲座，以进一步加深他们的理解。接下来，该课程将深入探讨 Dart 和 Flutter 的高级特性和功能。",
                                // Russian
                                "Русский": "В этом модуле преподаватель рассмотрел такие важные концепции, как виджеты, виджеты с сохранением и без сохранения состояния, управление данными и работа с основами Dart. Студенты узнали о встроенных виджетах, создании пользовательских виджетов, передаче данных в качестве аргументов и доступе к ресурсам в официальном каталоге виджетов. Модуль был сосредоточен на понимании основ Flutter, создании пользовательских интерфейсов и знакомстве с программированием Dart. Преподаватель рекомендовал студентам изучать прикрепленные ресурсы и текстовые лекции для дальнейшего углубления их понимания. В дальнейшем курс будет углубляться в расширенные возможности и функции Dart и Flutter.",
                                // French
                                "Français": "Dans ce module, l'instructeur a abordé des concepts importants tels que les widgets, les widgets avec et sans état, la gestion des données et l'utilisation des principes fondamentaux de Dart. Les étudiants ont découvert les widgets intégrés, la création de widgets personnalisés, la transmission de données en tant qu'arguments et l'accès aux ressources du catalogue officiel de widgets. Le module s'est concentré sur la compréhension des bases de Flutter, la création d'interfaces utilisateur et la familiarisation avec la programmation Dart. L'instructeur a encouragé les étudiants à explorer les ressources jointes et les cours magistraux pour améliorer davantage leur compréhension. À l'avenir, le cours approfondira les fonctionnalités avancées de Dart et Flutter.",
                                // Japanese
                                "日本語": "このモジュールでは、講師がウィジェット、ステートフル ウィジェットとステートレス ウィジェット、データの管理、Dart の基礎の操作などの重要な概念について説明しました。学生は、組み込みウィジェット、カスタム ウィジェットの作成、引数としてのデータの受け渡し、公式ウィジェット カタログのリソースへのアクセスについて学びました。このモジュールでは、Flutter の基礎の理解、ユーザー インターフェイスの構築、Dart プログラミングの習得に重点が置かれました。講師は、理解をさらに深めるために、添付のリソースやテキスト レクチャーを調べるように学生に勧めました。このコースでは、今後、Dart と Flutter の高度な機能についてさらに深く掘り下げていきます。",
                                // Korean
                                "한국인": "이 모듈에서 강사는 위젯, 상태 저장 및 상태 비저장 위젯, 데이터 관리, Dart 기본 사항 작업과 같은 중요한 개념을 다루었습니다. 학생들은 내장 위젯, 사용자 정의 위젯 만들기, 인수로 데이터 전달, 공식 위젯 카탈로그의 리소스 액세스에 대해 배웠습니다. 이 모듈은 Flutter 기본 사항 이해, 사용자 인터페이스 구축, Dart 프로그래밍에 익숙해지는 데 중점을 두었습니다. 강사는 학생들이 첨부된 리소스와 텍스트 강의를 탐색하여 이해를 더욱 높이도록 권장했습니다. 앞으로 이 과정은 Dart와 Flutter의 고급 기능과 기능에 대해 더 깊이 파고들 것입니다.",
                                // Spanish
                                "Español": "En este módulo, el instructor abordó conceptos importantes como widgets, widgets con estado y sin estado, administración de datos y cómo trabajar con los fundamentos de Dart. Los estudiantes aprendieron sobre widgets integrados, cómo crear widgets personalizados, cómo pasar datos como argumentos y cómo acceder a recursos en el catálogo oficial de widgets. El módulo se centró en comprender los conceptos básicos de Flutter, crear interfaces de usuario y familiarizarse con la programación de Dart. El instructor alentó a los estudiantes a explorar los recursos adjuntos y las lecciones de texto para mejorar aún más su comprensión. En el futuro, el curso profundizará en las características y funcionalidades avanzadas de Dart y Flutter.",
                                // Hindi
                                "हिंदी": "इस मॉड्यूल में, प्रशिक्षक ने विजेट, स्टेटफुल और स्टेटलेस विजेट, डेटा प्रबंधन और डार्ट फंडामेंटल्स के साथ काम करने जैसी महत्वपूर्ण अवधारणाओं को कवर किया। छात्रों ने बिल्ट-इन विजेट, कस्टम विजेट बनाने, डेटा को तर्क के रूप में पास करने और आधिकारिक विजेट कैटलॉग में संसाधनों तक पहुँचने के बारे में सीखा। मॉड्यूल फ़्लटर की मूल बातें समझने, उपयोगकर्ता इंटरफ़ेस बनाने और डार्ट प्रोग्रामिंग से परिचित होने पर केंद्रित था। प्रशिक्षक ने छात्रों को अपनी समझ को और बढ़ाने के लिए संलग्न संसाधनों और पाठ व्याख्यानों का पता लगाने के लिए प्रोत्साहित किया। आगे बढ़ते हुए, पाठ्यक्रम डार्ट और फ़्लटर की उन्नत सुविधाओं और कार्यात्मकताओं में गहराई से उतरेगा।",
                                // Portuguese
                                "Português": "Neste módulo, o formador abordou conceitos importantes como widgets, widgets com e sem estado, gestão de dados e trabalho com os fundamentos do Dart. Os alunos aprenderam sobre widgets integrados, como criar widgets personalizados, passar dados como argumentos e aceder a recursos no catálogo oficial de widgets. O módulo centrou-se na compreensão dos fundamentos do Flutter, na construção de interfaces de utilizador e na familiarização com a programação Dart. O instrutor incentivou os alunos a explorar os recursos anexados e as aulas de texto para melhorar ainda mais a sua compreensão. Seguindo em frente, o curso irá aprofundar as características e funcionalidades avançadas do Dart e do Flutter.",
                                // Bengali
                                "বাংলা": "এই মডিউলে, প্রশিক্ষক গুরুত্বপূর্ণ ধারণাগুলি কভার করেছেন যেমন উইজেট, স্টেটফুল এবং স্টেটলেস উইজেট, ডেটা পরিচালনা এবং ডার্টের মৌলিক বিষয়গুলির সাথে কাজ করা। শিক্ষার্থীরা বিল্ট-ইন উইজেট, কাস্টম উইজেট তৈরি, আর্গুমেন্ট হিসেবে ডেটা পাস করা এবং অফিসিয়াল উইজেট ক্যাটালগে রিসোর্স অ্যাক্সেস করার বিষয়ে শিখেছে। মডিউলটি ফ্লাটার বেসিক বোঝা, ব্যবহারকারীর ইন্টারফেস তৈরি করা এবং ডার্ট প্রোগ্রামিংয়ের সাথে পরিচিত হওয়ার উপর দৃষ্টি নিবদ্ধ করে। প্রশিক্ষক শিক্ষার্থীদের তাদের বোঝাপড়াকে আরও উন্নত করার জন্য সংযুক্ত সংস্থান এবং পাঠ্য বক্তৃতাগুলি অন্বেষণ করতে উত্সাহিত করেছিলেন। সামনের দিকে অগ্রসর হওয়া, কোর্সটি ডার্ট এবং ফ্লাটারের উন্নত বৈশিষ্ট্য এবং কার্যকারিতাগুলির গভীরে প্রবেশ করবে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذه الوحدة، غطى المدرب مفاهيم مهمة مثل الأدوات، والأدوات ذات الحالة والأدوات عديمة الحالة، وإدارة البيانات، والعمل مع أساسيات Dart. تعلم الطلاب عن الأدوات المضمنة، وإنشاء أدوات مخصصة، وتمرير البيانات كحجج، والوصول إلى الموارد في كتالوج الأدوات الرسمي. ركزت الوحدة على فهم أساسيات Flutter، وبناء واجهات المستخدم، والتعرف على برمجة Dart. شجع المدرب الطلاب على استكشاف الموارد المرفقة والمحاضرات النصية لتعزيز فهمهم بشكل أكبر. في المستقبل، ستخوض الدورة بشكل أعمق في الميزات والوظائف المتقدمة لـ Dart وFlutter.",
                                // Persian
                                "فارسی": "در این ماژول، مدرس مفاهیم مهمی مانند ویجت ها، ویجت های حالت دار و بدون حالت، مدیریت داده ها و کار با اصول دارت را پوشش می دهد. دانش‌آموزان در مورد ویجت‌های داخلی، ایجاد ویجت‌های سفارشی، انتقال داده‌ها به‌عنوان آرگومان‌ها و دسترسی به منابع موجود در کاتالوگ ویجت رسمی یاد گرفتند. این ماژول بر درک اصول فلاتر، ایجاد رابط های کاربری و آشنایی با برنامه نویسی دارت متمرکز بود. مربی دانش آموزان را تشویق کرد تا منابع پیوست و سخنرانی های متنی را برای تقویت بیشتر درک خود کاوش کنند. با حرکت رو به جلو، این دوره عمیق تر به ویژگی ها و عملکردهای پیشرفته Dart و Flutter می پردازد.",
                            },
                        },
                    ]
                },
                // Section 3 : Running Apps on Different Devices & Debugging Apps
                {
                    "SectionName": "Running Apps on Different Devices & Debugging Apps",
                    "Videos": [
                        // 49 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Module Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this module, the focus is on testing Flutter applications on different platforms, such as Android and iOS, as well as real devices. The importance of understanding and fixing error messages, logical errors, and UI issues using tools like Visual Studio Code debugger, Dart DevTools, and Flutter Inspector is highlighted. The goal is to help developers effectively debug their code, understand UI components, and enhance performance in their applications.",
                                // German
                                "Deutsch": "In diesem Modul liegt der Schwerpunkt auf dem Testen von Flutter-Anwendungen auf verschiedenen Plattformen wie Android und iOS sowie auf echten Geräten. Die Bedeutung des Verstehens und Behebens von Fehlermeldungen, logischen Fehlern und UI-Problemen mithilfe von Tools wie Visual Studio Code Debugger, Dart DevTools und Flutter Inspector wird hervorgehoben. Ziel ist es, Entwicklern zu helfen, ihren Code effektiv zu debuggen, UI-Komponenten zu verstehen und die Leistung ihrer Anwendungen zu verbessern.",
                                // Chinese
                                "中国人": "本模块重点介绍如何在不同平台（例如 Android 和 iOS）以及真实设备上测试 Flutter 应用程序。本模块强调了使用 Visual Studio Code 调试器、Dart DevTools 和 Flutter Inspector 等工具理解和修复错误消息、逻辑错误和 UI 问题的重要性。本模块旨在帮助开发人员有效地调试代码、理解 UI 组件并提高应用程序的性能。",
                                // Russian
                                "Русский": "В этом модуле основное внимание уделяется тестированию приложений Flutter на разных платформах, таких как Android и iOS, а также на реальных устройствах. Подчеркивается важность понимания и исправления сообщений об ошибках, логических ошибок и проблем пользовательского интерфейса с помощью таких инструментов, как отладчик Visual Studio Code, Dart DevTools и Flutter Inspector. Цель — помочь разработчикам эффективно отлаживать свой код, понимать компоненты пользовательского интерфейса и повышать производительность своих приложений.",
                                // French
                                "Français": "Dans ce module, l'accent est mis sur le test des applications Flutter sur différentes plateformes, telles qu'Android et iOS, ainsi que sur des appareils réels. L'importance de comprendre et de corriger les messages d'erreur, les erreurs logiques et les problèmes d'interface utilisateur à l'aide d'outils tels que le débogueur Visual Studio Code, Dart DevTools et Flutter Inspector est soulignée. L'objectif est d'aider les développeurs à déboguer efficacement leur code, à comprendre les composants de l'interface utilisateur et à améliorer les performances de leurs applications.",
                                // Japanese
                                "日本語": "このモジュールでは、Android や iOS などのさまざまなプラットフォームや実際のデバイスで Flutter アプリケーションをテストすることに重点を置いています。Visual Studio Code デバッガー、Dart DevTools、Flutter Inspector などのツールを使用して、エラー メッセージ、論理エラー、UI の問題を理解して修正することの重要性を強調します。目標は、開発者がコードを効果的にデバッグし、UI コンポーネントを理解し、アプリケーションのパフォーマンスを向上できるようにすることです。",
                                // Korean
                                "한국인": "이 모듈에서는 Android 및 iOS와 같은 다양한 플랫폼과 실제 기기에서 Flutter 애플리케이션을 테스트하는 데 중점을 둡니다. Visual Studio Code 디버거, Dart DevTools, Flutter Inspector와 같은 도구를 사용하여 오류 메시지, 논리적 오류 및 UI 문제를 이해하고 수정하는 것의 중요성이 강조됩니다. 목표는 개발자가 코드를 효과적으로 디버깅하고, UI 구성 요소를 이해하고, 애플리케이션의 성능을 향상하도록 돕는 것입니다.",
                                // Spanish
                                "Español": "En este módulo, el enfoque está puesto en probar aplicaciones Flutter en diferentes plataformas, como Android e iOS, así como en dispositivos reales. Se destaca la importancia de comprender y corregir mensajes de error, errores lógicos y problemas de interfaz de usuario mediante herramientas como el depurador de Visual Studio Code, Dart DevTools y Flutter Inspector. El objetivo es ayudar a los desarrolladores a depurar eficazmente su código, comprender los componentes de la interfaz de usuario y mejorar el rendimiento de sus aplicaciones.",
                                // Hindi
                                "हिंदी": "इस मॉड्यूल में, एंड्रॉइड और आईओएस जैसे विभिन्न प्लेटफ़ॉर्म पर फ़्लटर एप्लिकेशन के परीक्षण पर ध्यान केंद्रित किया गया है, साथ ही वास्तविक डिवाइस पर भी। विज़ुअल स्टूडियो कोड डीबगर, डार्ट डेवटूल और फ़्लटर इंस्पेक्टर जैसे उपकरणों का उपयोग करके त्रुटि संदेशों, तार्किक त्रुटियों और UI समस्याओं को समझने और ठीक करने के महत्व पर प्रकाश डाला गया है। इसका लक्ष्य डेवलपर्स को उनके कोड को प्रभावी ढंग से डीबग करने, UI घटकों को समझने और उनके अनुप्रयोगों में प्रदर्शन को बढ़ाने में मदद करना है।",
                                // Portuguese
                                "Português": "Neste módulo, o foco está em testar aplicações Flutter em diferentes plataformas, como Android e iOS, bem como dispositivos reais. É realçada a importância de compreender e corrigir mensagens de erro, erros lógicos e problemas de UI utilizando ferramentas como o depurador Visual Studio Code, Dart DevTools e Flutter Inspector. O objetivo é ajudar os programadores a depurar o seu código de forma eficaz, compreender os componentes da UI e melhorar o desempenho das suas aplicações.",
                                // Bengali
                                "বাংলা": "এই মডিউলে, বিভিন্ন প্ল্যাটফর্মে যেমন অ্যান্ড্রয়েড এবং আইওএস, সেইসাথে বাস্তব ডিভাইসগুলিতে ফ্লাটার অ্যাপ্লিকেশনগুলি পরীক্ষা করার উপর ফোকাস করা হয়৷ ভিজ্যুয়াল স্টুডিও কোড ডিবাগার, ডার্ট ডেভটুলস এবং ফ্লাটার ইন্সপেক্টরের মতো টুল ব্যবহার করে ত্রুটির বার্তা, যৌক্তিক ত্রুটি এবং UI সমস্যাগুলি বোঝা এবং ঠিক করার গুরুত্ব তুলে ধরা হয়েছে। লক্ষ্য হল ডেভেলপারদের কার্যকরভাবে তাদের কোড ডিবাগ করতে, UI উপাদানগুলি বুঝতে এবং তাদের অ্যাপ্লিকেশনগুলিতে কর্মক্ষমতা উন্নত করতে সহায়তা করা।",
                                // Arabic
                                "عَرَبِيّ": "في هذه الوحدة، يركز الدرس على اختبار تطبيقات Flutter على منصات مختلفة، مثل Android وiOS، وكذلك على الأجهزة الحقيقية. يتم تسليط الضوء على أهمية فهم رسائل الخطأ والأخطاء المنطقية ومشكلات واجهة المستخدم وإصلاحها باستخدام أدوات مثل Visual Studio Code debugger وDart DevTools وFlutter Inspector. والهدف هو مساعدة المطورين على تصحيح أخطاء أكوادهم بشكل فعال وفهم مكونات واجهة المستخدم وتحسين الأداء في تطبيقاتهم.",
                                // Persian
                                "فارسی": "در این ماژول تمرکز بر روی تست اپلیکیشن های فلاتر در پلتفرم های مختلف مانند اندروید و iOS و همچنین دستگاه های واقعی است. اهمیت درک و رفع پیام‌های خطا، خطاهای منطقی و مشکلات رابط کاربری با استفاده از ابزارهایی مانند دیباگر کد ویژوال استودیو، Dart DevTools و Flutter Inspector برجسته شده است. هدف کمک به توسعه دهندگان است که به طور موثر کد خود را اشکال زدایی کنند، اجزای رابط کاربری را درک کنند و عملکرد برنامه های خود را افزایش دهند.",
                            },
                        },
                        // 50 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Running the App on a Real Android Device",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video discusses the importance of testing Flutter applications on iOS simulators, real Android devices, and understanding the process of launching an app on a real Android device. The tutorial walks through enabling developer options and USB debugging on an Android device, connecting it to the development machine, choosing the device for deployment, and running the Flutter app on the real device. Testing on real devices is emphasized as crucial for app development, as emulators can only simulate real device experiences. The demonstration showcases the app running smoothly on a real connected Android device, highlighting the need for thorough testing on different devices during the development process.",
                                // German
                                "Deutsch": "Das Video erläutert, wie wichtig es ist, Flutter-Anwendungen auf iOS-Simulatoren und echten Android-Geräten zu testen und wie man eine App auf einem echten Android-Gerät startet. Das Tutorial führt Sie durch das Aktivieren von Entwickleroptionen und USB-Debugging auf einem Android-Gerät, das Verbinden mit der Entwicklungsmaschine, das Auswählen des Geräts für die Bereitstellung und das Ausführen der Flutter-App auf dem echten Gerät. Das Testen auf echten Geräten wird als entscheidend für die App-Entwicklung hervorgehoben, da Emulatoren nur Erfahrungen mit echten Geräten simulieren können. Die Demonstration zeigt, wie die App auf einem echten verbundenen Android-Gerät reibungslos läuft, und unterstreicht die Notwendigkeit gründlicher Tests auf verschiedenen Geräten während des Entwicklungsprozesses.",
                                // Chinese
                                "中国人": "该视频讨论了在 iOS 模拟器、真实 Android 设备上测试 Flutter 应用程序的重要性，以及了解在真实 Android 设备上启动应用程序的过程。本教程介绍了如何在 Android 设备上启用开发人员选项和 USB 调试、将其连接到开发机器、选择要部署的设备以及在真实设备上运行 Flutter 应用程序。在真实设备上进行测试对于应用程序开发至关重要，因为模拟器只能模拟真实设备的体验。该演示展示了应用程序在真实连接的 Android 设备上流畅运行，强调了在开发过程中对不同设备进行全面测试的必要性。",
                                // Russian
                                "Русский": "В видео обсуждается важность тестирования приложений Flutter на симуляторах iOS, реальных устройствах Android и понимание процесса запуска приложения на реальном устройстве Android. В руководстве рассматриваются включение параметров разработчика и отладка USB на устройстве Android, подключение его к машине разработки, выбор устройства для развертывания и запуск приложения Flutter на реальном устройстве. Тестирование на реальных устройствах подчеркивается как критически важное для разработки приложений, поскольку эмуляторы могут имитировать только реальные устройства. Демонстрация демонстрирует бесперебойную работу приложения на реальном подключенном устройстве Android, подчеркивая необходимость тщательного тестирования на разных устройствах в процессе разработки.",
                                // French
                                "Français": "La vidéo explique l'importance de tester les applications Flutter sur des simulateurs iOS, de véritables appareils Android et de comprendre le processus de lancement d'une application sur un véritable appareil Android. Le didacticiel explique comment activer les options de développement et le débogage USB sur un appareil Android, le connecter à la machine de développement, choisir l'appareil à déployer et exécuter l'application Flutter sur l'appareil réel. Les tests sur des appareils réels sont considérés comme essentiels pour le développement d'applications, car les émulateurs ne peuvent simuler que des expériences sur des appareils réels. La démonstration montre l'application fonctionnant sans problème sur un véritable appareil Android connecté, soulignant la nécessité de réaliser des tests approfondis sur différents appareils pendant le processus de développement.",
                                // Japanese
                                "日本語": "このビデオでは、iOS シミュレーター、実際の Android デバイスで Flutter アプリケーションをテストすることの重要性、および実際の Android デバイスでアプリを起動するプロセスを理解することについて説明しています。チュートリアルでは、Android デバイスで開発者オプションと USB デバッグを有効にする方法、開発マシンに接続する方法、展開するデバイスを選択する方法、実際のデバイスで Flutter アプリを実行する方法を説明します。エミュレーターでは実際のデバイスのエクスペリエンスしかシミュレートできないため、実際のデバイスでのテストはアプリ開発にとって非常に重要であると強調されています。デモでは、実際に接続した Android デバイスでアプリがスムーズに実行される様子を示し、開発プロセス中にさまざまなデバイスで徹底的にテストする必要があることを強調しています。",
                                // Korean
                                "한국인": "이 비디오에서는 iOS 시뮬레이터, 실제 Android 기기에서 Flutter 애플리케이션을 테스트하는 것의 중요성과 실제 Android 기기에서 앱을 시작하는 프로세스를 이해하는 것에 대해 설명합니다. 이 튜토리얼은 Android 기기에서 개발자 옵션과 USB 디버깅을 활성화하고, 개발 머신에 연결하고, 배포할 기기를 선택하고, 실제 기기에서 Flutter 앱을 실행하는 방법을 안내합니다. 에뮬레이터는 실제 기기 경험만 시뮬레이션할 수 있으므로 실제 기기에서 테스트하는 것이 앱 개발에 매우 ​​중요하다고 강조합니다. 이 데모에서는 앱이 실제로 연결된 Android 기기에서 원활하게 실행되는 것을 보여주며, 개발 프로세스 중에 다양한 기기에서 철저한 테스트가 필요하다는 점을 강조합니다.",
                                // Spanish
                                "Español": "El video analiza la importancia de probar las aplicaciones Flutter en simuladores de iOS, dispositivos Android reales y comprender el proceso de lanzamiento de una aplicación en un dispositivo Android real. El tutorial explica cómo habilitar las opciones de desarrollador y la depuración USB en un dispositivo Android, conectarlo a la máquina de desarrollo, elegir el dispositivo para la implementación y ejecutar la aplicación Flutter en el dispositivo real. Se enfatiza que las pruebas en dispositivos reales son cruciales para el desarrollo de aplicaciones, ya que los emuladores solo pueden simular experiencias de dispositivos reales. La demostración muestra la aplicación ejecutándose sin problemas en un dispositivo Android real conectado, lo que resalta la necesidad de realizar pruebas exhaustivas en diferentes dispositivos durante el proceso de desarrollo.",
                                // Hindi
                                "हिंदी": "वीडियो में iOS सिमुलेटर, वास्तविक Android डिवाइस पर फ़्लटर एप्लिकेशन के परीक्षण के महत्व और वास्तविक Android डिवाइस पर ऐप लॉन्च करने की प्रक्रिया को समझने के बारे में चर्चा की गई है। ट्यूटोरियल Android डिवाइस पर डेवलपर विकल्प और USB डिबगिंग को सक्षम करने, इसे डेवलपमेंट मशीन से कनेक्ट करने, परिनियोजन के लिए डिवाइस चुनने और वास्तविक डिवाइस पर फ़्लटर ऐप चलाने के बारे में बताता है। ऐप डेवलपमेंट के लिए वास्तविक डिवाइस पर परीक्षण को महत्वपूर्ण माना जाता है, क्योंकि एमुलेटर केवल वास्तविक डिवाइस अनुभवों का अनुकरण कर सकते हैं। प्रदर्शन वास्तविक कनेक्टेड Android डिवाइस पर ऐप को सुचारू रूप से चलाता है, जो विकास प्रक्रिया के दौरान विभिन्न डिवाइस पर गहन परीक्षण की आवश्यकता पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "O vídeo discute a importância de testar aplicações Flutter em simuladores iOS, dispositivos Android reais, e compreender o processo de arranque de uma aplicação num dispositivo Android real. O tutorial percorre a ativação das opções de programador e a depuração USB num dispositivo Android, ligando-o à máquina de desenvolvimento, escolhendo o dispositivo para implementação e executando a aplicação Flutter no dispositivo real. O teste em dispositivos reais é enfatizado como crucial para o desenvolvimento de aplicações, uma vez que os emuladores apenas conseguem simular experiências reais em dispositivos. A demonstração mostra a aplicação a funcionar perfeitamente num dispositivo Android real ligado, destacando a necessidade de testes completos em diferentes dispositivos durante o processo de desenvolvimento.",
                                // Bengali
                                "বাংলা": "ভিডিওটি iOS সিমুলেটর, বাস্তব অ্যান্ড্রয়েড ডিভাইসে ফ্লটার অ্যাপ্লিকেশন পরীক্ষা করার গুরুত্ব এবং একটি বাস্তব অ্যান্ড্রয়েড ডিভাইসে একটি অ্যাপ চালু করার প্রক্রিয়া বোঝার বিষয়ে আলোচনা করে। টিউটোরিয়ালটি একটি অ্যান্ড্রয়েড ডিভাইসে বিকাশকারী বিকল্পগুলি এবং USB ডিবাগিং সক্ষম করা, এটিকে ডেভেলপমেন্ট মেশিনের সাথে সংযুক্ত করা, স্থাপনার জন্য ডিভাইসটি বেছে নেওয়া এবং আসল ডিভাইসে ফ্লটার অ্যাপ চালানোর মাধ্যমে চলে। বাস্তব ডিভাইসে পরীক্ষা করা অ্যাপ ডেভেলপমেন্টের জন্য অত্যন্ত গুরুত্বপূর্ণ হিসাবে জোর দেওয়া হয়, কারণ এমুলেটররা শুধুমাত্র বাস্তব ডিভাইসের অভিজ্ঞতা অনুকরণ করতে পারে। প্রদর্শনীটি একটি বাস্তব সংযুক্ত অ্যান্ড্রয়েড ডিভাইসে মসৃণভাবে চলমান অ্যাপটি প্রদর্শন করে, উন্নয়ন প্রক্রিয়া চলাকালীন বিভিন্ন ডিভাইসে পুঙ্খানুপুঙ্খ পরীক্ষার প্রয়োজনীয়তা তুলে ধরে।",
                                // Arabic
                                "عَرَبِيّ": "يناقش الفيديو أهمية اختبار تطبيقات Flutter على محاكيات iOS وأجهزة Android الحقيقية وفهم عملية تشغيل التطبيق على جهاز Android حقيقي. يشرح البرنامج التعليمي كيفية تمكين خيارات المطور وتصحيح أخطاء USB على جهاز Android وتوصيله بجهاز التطوير واختيار الجهاز للنشر وتشغيل تطبيق Flutter على الجهاز الحقيقي. يتم التأكيد على الاختبار على الأجهزة الحقيقية باعتباره أمرًا بالغ الأهمية لتطوير التطبيق، حيث لا يمكن للمحاكيات سوى محاكاة تجارب الأجهزة الحقيقية. يعرض العرض التوضيحي التطبيق وهو يعمل بسلاسة على جهاز Android متصل حقيقي، مما يسلط الضوء على الحاجة إلى الاختبار الشامل على أجهزة مختلفة أثناء عملية التطوير.",
                                // Persian
                                "فارسی": "در این ویدیو اهمیت آزمایش برنامه های Flutter در شبیه سازهای iOS، دستگاه های اندروید واقعی و درک فرآیند راه اندازی یک برنامه در یک دستگاه اندروید واقعی بحث می شود. این آموزش شامل فعال کردن گزینه‌های توسعه‌دهنده و اشکال‌زدایی USB در دستگاه اندروید، اتصال آن به دستگاه توسعه، انتخاب دستگاه برای استقرار و اجرای برنامه Flutter در دستگاه واقعی است. آزمایش بر روی دستگاه های واقعی برای توسعه برنامه بسیار مهم است، زیرا شبیه سازها فقط می توانند تجربیات واقعی دستگاه را شبیه سازی کنند. این نمایش برنامه را به نمایش می‌گذارد که بر روی یک دستگاه اندرویدی متصل واقعی اجرا می‌شود و نیاز به آزمایش کامل روی دستگاه‌های مختلف در طول فرآیند توسعه را برجسته می‌کند.",
                            },
                        },
                        // 51 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Running the App on an iOS Emulator",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explains the process of building and testing Flutter apps on iOS devices, emphasizing that a Mac OS operating system is required to develop iOS apps due to Apple's restrictions. The tutorial guides users through setting up Xcode, configuring developer options, and selecting a development team for the project. It also covers the importance of having an Apple developer account, which is necessary for running the app on a simulator or a real iOS device. The demonstration showcases running the app on an iOS simulator and highlights how Flutter's framework controls every pixel, resulting in a consistent look across different platforms. Additionally, the video hints at adjusting the app's appearance for specific platforms and promises further exploration of customization options in the course.",
                                // German
                                "Deutsch": "Das Video erklärt den Prozess des Erstellens und Testens von Flutter-Apps auf iOS-Geräten und betont, dass aufgrund der Einschränkungen von Apple ein Mac OS-Betriebssystem erforderlich ist, um iOS-Apps zu entwickeln. Das Tutorial führt Benutzer durch die Einrichtung von Xcode, die Konfiguration von Entwickleroptionen und die Auswahl eines Entwicklungsteams für das Projekt. Es geht auch darauf ein, wie wichtig ein Apple-Entwicklerkonto ist, das zum Ausführen der App auf einem Simulator oder einem echten iOS-Gerät erforderlich ist. Die Demonstration zeigt das Ausführen der App auf einem iOS-Simulator und zeigt, wie das Flutter-Framework jedes Pixel steuert, was zu einem einheitlichen Erscheinungsbild auf verschiedenen Plattformen führt. Darüber hinaus gibt das Video Hinweise zum Anpassen des Erscheinungsbilds der App für bestimmte Plattformen und verspricht eine weitere Erkundung der Anpassungsoptionen im Kurs.",
                                // Chinese
                                "中国人": "视频介绍了在 iOS 设备上构建和测试 Flutter 应用的过程，强调由于 Apple 的限制，开发 iOS 应用需要 Mac OS 操作系统。教程指导用户设置 Xcode、配置开发者选项以及为项目选择开发团队。它还介绍了拥有 Apple 开发者帐户的重要性，这是在模拟器或真实 iOS 设备上运行应用的必要条件。演示展示了如何在 iOS 模拟器上运行应用，并强调了 Flutter 的框架如何控制每个像素，从而在不同平台上实现一致的外观。此外，视频还暗示了如何针对特定平台调整应用的外观，并承诺在课程中进一步探索自定义选项。",
                                // Russian
                                "Русский": "Видео объясняет процесс создания и тестирования приложений Flutter на устройствах iOS, подчеркивая, что для разработки приложений iOS требуется операционная система Mac OS из-за ограничений Apple. Учебник проводит пользователей через настройку Xcode, настройку параметров разработчика и выбор команды разработчиков для проекта. Он также охватывает важность наличия учетной записи разработчика Apple, которая необходима для запуска приложения на симуляторе или реальном устройстве iOS. Демонстрация демонстрирует запуск приложения на симуляторе iOS и подчеркивает, как фреймворк Flutter контролирует каждый пиксель, что приводит к единообразному виду на разных платформах. Кроме того, видео намекает на настройку внешнего вида приложения для определенных платформ и обещает дальнейшее изучение параметров настройки в курсе.",
                                // French
                                "Français": "La vidéo explique le processus de création et de test des applications Flutter sur les appareils iOS, en soulignant qu'un système d'exploitation Mac OS est nécessaire pour développer des applications iOS en raison des restrictions d'Apple. Le didacticiel guide les utilisateurs dans la configuration de Xcode, la configuration des options de développement et la sélection d'une équipe de développement pour le projet. Il couvre également l'importance d'avoir un compte de développeur Apple, qui est nécessaire pour exécuter l'application sur un simulateur ou un véritable appareil iOS. La démonstration présente l'exécution de l'application sur un simulateur iOS et met en évidence la manière dont le framework de Flutter contrôle chaque pixel, ce qui permet d'obtenir un aspect cohérent sur différentes plates-formes. De plus, la vidéo suggère d'ajuster l'apparence de l'application pour des plates-formes spécifiques et promet une exploration plus approfondie des options de personnalisation dans le cours.",
                                // Japanese
                                "日本語": "このビデオでは、iOS デバイスで Flutter アプリを構築およびテストするプロセスについて説明し、Apple の制限により iOS アプリを開発するには Mac OS オペレーティング システムが必要であることを強調しています。このチュートリアルでは、Xcode の設定、開発者オプションの構成、プロジェクトの開発チームの選択について説明しています。また、シミュレーターまたは実際の iOS デバイスでアプリを実行するために必要な Apple 開発者アカウントを持つことの重要性についても説明しています。デモでは、iOS シミュレーターでアプリを実行する方法を紹介し、Flutter のフレームワークがすべてのピクセルを制御し、さまざまなプラットフォームで一貫した外観を実現する方法を強調しています。さらに、ビデオでは特定のプラットフォーム向けにアプリの外観を調整する方法についても説明しており、コースでカスタマイズ オプションをさらに検討することを約束しています。",
                                // Korean
                                "한국인": "이 비디오는 iOS 기기에서 Flutter 앱을 빌드하고 테스트하는 과정을 설명하며, Apple의 제한으로 인해 iOS 앱을 개발하려면 Mac OS 운영 체제가 필요하다는 점을 강조합니다. 이 튜토리얼은 사용자에게 Xcode 설정, 개발자 옵션 구성, 프로젝트 개발팀 선택 방법을 안내합니다. 또한 시뮬레이터나 실제 iOS 기기에서 앱을 실행하는 데 필요한 Apple 개발자 계정이 중요한 이유도 다룹니다. 이 데모는 iOS 시뮬레이터에서 앱을 실행하는 방법을 보여주고 Flutter 프레임워크가 모든 픽셀을 제어하여 다양한 플랫폼에서 일관된 모양을 만드는 방법을 강조합니다. 또한 이 비디오는 특정 플랫폼에 맞게 앱의 모양을 조정하는 방법을 암시하며 과정에서 사용자 정의 옵션을 추가로 탐색할 것을 약속합니다.",
                                // Spanish
                                "Español": "El video explica el proceso de creación y prueba de aplicaciones Flutter en dispositivos iOS, y hace hincapié en que se requiere un sistema operativo Mac OS para desarrollar aplicaciones iOS debido a las restricciones de Apple. El tutorial guía a los usuarios a través de la configuración de Xcode, la configuración de las opciones de desarrollador y la selección de un equipo de desarrollo para el proyecto. También cubre la importancia de tener una cuenta de desarrollador de Apple, que es necesaria para ejecutar la aplicación en un simulador o un dispositivo iOS real. La demostración muestra la ejecución de la aplicación en un simulador de iOS y destaca cómo el marco de Flutter controla cada píxel, lo que da como resultado una apariencia consistente en diferentes plataformas. Además, el video sugiere cómo ajustar la apariencia de la aplicación para plataformas específicas y promete una mayor exploración de las opciones de personalización en el curso.",
                                // Hindi
                                "हिंदी": "वीडियो iOS डिवाइस पर फ़्लटर ऐप बनाने और उसका परीक्षण करने की प्रक्रिया को समझाता है, इस बात पर ज़ोर देता है कि Apple के प्रतिबंधों के कारण iOS ऐप विकसित करने के लिए Mac OS ऑपरेटिंग सिस्टम की आवश्यकता होती है। ट्यूटोरियल उपयोगकर्ताओं को Xcode सेट अप करने, डेवलपर विकल्पों को कॉन्फ़िगर करने और प्रोजेक्ट के लिए डेवलपमेंट टीम चुनने के बारे में बताता है। इसमें Apple डेवलपर अकाउंट होने के महत्व को भी शामिल किया गया है, जो सिम्युलेटर या असली iOS डिवाइस पर ऐप चलाने के लिए आवश्यक है। डेमो में iOS सिम्युलेटर पर ऐप चलाने का प्रदर्शन किया गया है और इस बात पर प्रकाश डाला गया है कि फ़्लटर का फ्रेमवर्क प्रत्येक पिक्सेल को कैसे नियंत्रित करता है, जिसके परिणामस्वरूप विभिन्न प्लेटफ़ॉर्म पर एक समान रूप मिलता है। इसके अतिरिक्त, वीडियो विशिष्ट प्लेटफ़ॉर्म के लिए ऐप के स्वरूप को समायोजित करने का संकेत देता है और पाठ्यक्रम में अनुकूलन विकल्पों की आगे की खोज का वादा करता है।",
                                // Portuguese
                                "Português": "O vídeo explica o processo de criação e teste de aplicações Flutter em dispositivos iOS, sublinhando que é necessário um sistema operativo Mac OS para desenvolver aplicações iOS devido às restrições da Apple. O tutorial orienta os utilizadores na configuração do Xcode, na configuração das opções do programador e na seleção de uma equipa de desenvolvimento para o projeto. Aborda também a importância de ter uma conta de programador Apple, necessária para executar a aplicação num simulador ou num dispositivo iOS real. A demonstração mostra a execução da aplicação num simulador iOS e destaca como a estrutura Flutter controla cada pixel, resultando numa aparência consistente em diferentes plataformas. Além disso, o vídeo sugere como ajustar a aparência da aplicação a plataformas específicas e promete uma exploração mais aprofundada das opções de personalização no curso.",
                                // Bengali
                                "বাংলা": "ভিডিওটি iOS ডিভাইসে ফ্লাটার অ্যাপ তৈরি এবং পরীক্ষা করার প্রক্রিয়া ব্যাখ্যা করে, জোর দিয়ে যে অ্যাপলের বিধিনিষেধের কারণে iOS অ্যাপ তৈরি করতে একটি Mac OS অপারেটিং সিস্টেম প্রয়োজন। টিউটোরিয়াল ব্যবহারকারীদের এক্সকোড সেট আপ, বিকাশকারী বিকল্পগুলি কনফিগার করার এবং প্রকল্পের জন্য একটি উন্নয়ন দল নির্বাচন করার মাধ্যমে গাইড করে। এটি একটি অ্যাপল বিকাশকারী অ্যাকাউন্ট থাকার গুরুত্বও কভার করে, যা একটি সিমুলেটর বা একটি বাস্তব iOS ডিভাইসে অ্যাপ চালানোর জন্য প্রয়োজনীয়। প্রদর্শনীটি একটি iOS সিমুলেটরে অ্যাপটি চালানোর প্রদর্শন করে এবং হাইলাইট করে যে কীভাবে ফ্লটারের ফ্রেমওয়ার্ক প্রতিটি পিক্সেলকে নিয়ন্ত্রণ করে, যার ফলে বিভিন্ন প্ল্যাটফর্ম জুড়ে সামঞ্জস্যপূর্ণ চেহারা পাওয়া যায়। অতিরিক্তভাবে, ভিডিওটি নির্দিষ্ট প্ল্যাটফর্মের জন্য অ্যাপের চেহারা সামঞ্জস্য করার ইঙ্গিত দেয় এবং কোর্সে কাস্টমাইজেশন বিকল্পগুলির আরও অনুসন্ধানের প্রতিশ্রুতি দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يشرح الفيديو عملية بناء واختبار تطبيقات Flutter على أجهزة iOS، مع التأكيد على أن نظام التشغيل Mac OS مطلوب لتطوير تطبيقات iOS بسبب القيود التي تفرضها Apple. يرشد البرنامج التعليمي المستخدمين خلال إعداد Xcode وتكوين خيارات المطور واختيار فريق التطوير للمشروع. كما يغطي أهمية وجود حساب مطور Apple، وهو أمر ضروري لتشغيل التطبيق على جهاز محاكاة أو جهاز iOS حقيقي. يعرض العرض التوضيحي تشغيل التطبيق على جهاز محاكاة iOS ويسلط الضوء على كيفية تحكم إطار عمل Flutter في كل بكسل، مما يؤدي إلى مظهر متسق عبر منصات مختلفة. بالإضافة إلى ذلك، يشير الفيديو إلى تعديل مظهر التطبيق لمنصات معينة ويعد بمزيد من الاستكشاف لخيارات التخصيص في الدورة.",
                                // Persian
                                "فارسی": "این ویدئو روند ساخت و آزمایش اپلیکیشن های Flutter را در دستگاه های iOS توضیح می دهد و تاکید می کند که به دلیل محدودیت های اپل، برای توسعه اپلیکیشن های iOS به سیستم عامل مک OS نیاز است. این آموزش کاربران را از طریق راه اندازی Xcode، پیکربندی گزینه های توسعه دهنده و انتخاب یک تیم توسعه برای پروژه راهنمایی می کند. همچنین اهمیت داشتن یک حساب توسعه دهنده اپل را پوشش می دهد، که برای اجرای برنامه در یک شبیه ساز یا یک دستگاه iOS واقعی ضروری است. این نمایش اجرای برنامه را بر روی یک شبیه‌ساز iOS نشان می‌دهد و نشان می‌دهد که چگونه چارچوب Flutter هر پیکسل را کنترل می‌کند و در نتیجه ظاهری ثابت در پلتفرم‌های مختلف ایجاد می‌کند. علاوه بر این، این ویدئو به تنظیم ظاهر برنامه برای پلتفرم‌های خاص اشاره می‌کند و نوید کاوش بیشتر گزینه‌های سفارشی‌سازی در این دوره را می‌دهد.",
                            },
                        },
                        // 52 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Running the App on a Real iOS Device",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video illustrates the process of launching a Flutter app on an iPhone connected to a macOS device. The tutorial mentions that upon connecting the iPhone to the macOS device, users are prompted to trust the connected device, which should be accepted. The narrator demonstrates selecting the iPhone as the device to run the app on in Visual Studio Code but notes the inability to choose it in the particular instance shown in the video.",
                                // German
                                "Deutsch": "Das Video veranschaulicht den Vorgang des Startens einer Flutter-App auf einem iPhone, das mit einem macOS-Gerät verbunden ist. Im Tutorial wird erwähnt, dass Benutzer beim Verbinden des iPhone mit dem macOS-Gerät aufgefordert werden, dem verbundenen Gerät zu vertrauen, was akzeptiert werden sollte. Der Sprecher demonstriert, wie das iPhone als Gerät ausgewählt wird, auf dem die App in Visual Studio Code ausgeführt werden soll, weist jedoch darauf hin, dass es in dem im Video gezeigten konkreten Fall nicht ausgewählt werden kann.",
                                // Chinese
                                "中国人": "该视频演示了在连接到 macOS 设备的 iPhone 上启动 Flutter 应用的过程。教程中提到，将 iPhone 连接到 macOS 设备后，系统会提示用户信任所连接的设备，用户应接受该操作。解说员演示了如何在 Visual Studio Code 中选择 iPhone 作为运行应用的设备，但指出在视频中显示的特定实例中无法选择它。",
                                // Russian
                                "Русский": "Видео иллюстрирует процесс запуска приложения Flutter на iPhone, подключенном к устройству macOS. В руководстве упоминается, что при подключении iPhone к устройству macOS пользователям предлагается доверять подключенному устройству, что должно быть принято. Рассказчик демонстрирует выбор iPhone в качестве устройства для запуска приложения в Visual Studio Code, но отмечает невозможность выбора в конкретном случае, показанном в видео.",
                                // French
                                "Français": "La vidéo illustre le processus de lancement d'une application Flutter sur un iPhone connecté à un appareil macOS. Le didacticiel mentionne que lors de la connexion de l'iPhone à l'appareil macOS, les utilisateurs sont invités à faire confiance à l'appareil connecté, ce qui doit être accepté. Le narrateur montre comment sélectionner l'iPhone comme appareil sur lequel exécuter l'application dans Visual Studio Code, mais note l'impossibilité de le choisir dans l'instance particulière présentée dans la vidéo.",
                                // Japanese
                                "日本語": "このビデオでは、macOS デバイスに接続された iPhone で Flutter アプリを起動するプロセスが説明されています。チュートリアルでは、iPhone を macOS デバイスに接続すると、接続されたデバイスを信頼するように求められ、これを受け入れる必要があることが説明されています。ナレーターは、Visual Studio Code でアプリを実行するデバイスとして iPhone を選択する方法を示していますが、ビデオに示されている特定のインスタンスでは iPhone を選択できないことを指摘しています。",
                                // Korean
                                "한국인": "이 비디오는 macOS 기기에 연결된 iPhone에서 Flutter 앱을 시작하는 과정을 보여줍니다. 이 튜토리얼에서는 iPhone을 macOS 기기에 연결하면 사용자에게 연결된 기기를 신뢰하라는 메시지가 표시되며, 이를 수락해야 한다고 언급합니다. 내레이터는 Visual Studio Code에서 앱을 실행할 기기로 iPhone을 선택하는 방법을 보여주지만, 비디오에 표시된 특정 인스턴스에서는 선택할 수 없다는 점에 유의합니다.",
                                // Spanish
                                "Español": "El video ilustra el proceso de lanzamiento de una aplicación Flutter en un iPhone conectado a un dispositivo macOS. El tutorial menciona que, al conectar el iPhone al dispositivo macOS, se les solicita a los usuarios que confíen en el dispositivo conectado, lo cual debe aceptarse. El narrador demuestra cómo seleccionar el iPhone como el dispositivo en el que ejecutar la aplicación en Visual Studio Code, pero señala la imposibilidad de elegirlo en la instancia particular que se muestra en el video.",
                                // Hindi
                                "हिंदी": "वीडियो में मैकओएस डिवाइस से जुड़े आईफोन पर फ़्लटर ऐप लॉन्च करने की प्रक्रिया को दर्शाया गया है। ट्यूटोरियल में बताया गया है कि आईफोन को मैकओएस डिवाइस से कनेक्ट करने पर, उपयोगकर्ताओं को कनेक्टेड डिवाइस पर भरोसा करने के लिए कहा जाता है, जिसे स्वीकार किया जाना चाहिए। वर्णनकर्ता विजुअल स्टूडियो कोड में ऐप चलाने के लिए डिवाइस के रूप में आईफोन का चयन करने का प्रदर्शन करता है, लेकिन वीडियो में दिखाए गए विशेष उदाहरण में इसे चुनने में असमर्थता को नोट करता है।",
                                // Portuguese
                                "Português": "O vídeo ilustra o processo de arranque de uma aplicação Flutter num iPhone ligado a um dispositivo macOS. O tutorial refere que ao ligar o iPhone ao dispositivo macOS, os utilizadores são solicitados a confiar no dispositivo ligado, o que deve ser aceite. O narrador demonstra a seleção do iPhone como dispositivo para executar a aplicação no Visual Studio Code, mas observa a impossibilidade de a escolher na instância específica mostrada no vídeo.",
                                // Bengali
                                "বাংলা": "ভিডিওটি একটি ম্যাকওএস ডিভাইসের সাথে সংযুক্ত একটি আইফোনে একটি ফ্লাটার অ্যাপ চালু করার প্রক্রিয়াকে চিত্রিত করে৷ টিউটোরিয়ালে উল্লেখ করা হয়েছে যে ম্যাকওএস ডিভাইসের সাথে আইফোন সংযোগ করার পরে, ব্যবহারকারীদের সংযুক্ত ডিভাইসে বিশ্বাস করার জন্য অনুরোধ করা হয়, যা গ্রহণ করা উচিত। কথক ভিজ্যুয়াল স্টুডিও কোডে অ্যাপটি চালানোর জন্য ডিভাইস হিসাবে আইফোন নির্বাচন করা দেখায় কিন্তু ভিডিওতে দেখানো বিশেষ উদাহরণে এটি চয়ন করতে অক্ষমতা নোট করে।",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو عملية تشغيل تطبيق Flutter على iPhone متصل بجهاز macOS. يذكر البرنامج التعليمي أنه عند توصيل iPhone بجهاز macOS، يُطلب من المستخدمين الوثوق بالجهاز المتصل، والذي يجب قبوله. يوضح الراوي تحديد iPhone كجهاز لتشغيل التطبيق عليه في Visual Studio Code ولكنه يلاحظ عدم القدرة على اختياره في الحالة المحددة الموضحة في الفيديو.",
                                // Persian
                                "فارسی": "این ویدیو روند راه‌اندازی یک برنامه Flutter را در آیفون متصل به یک دستگاه macOS نشان می‌دهد. در این آموزش ذکر شده است که با اتصال آیفون به دستگاه macOS، از کاربران خواسته می شود به دستگاه متصل اعتماد کنند که باید پذیرفته شود. راوی انتخاب آیفون را به‌عنوان دستگاهی برای اجرای برنامه در کد ویژوال استودیو نشان می‌دهد، اما ناتوانی در انتخاب آن را در نمونه خاصی که در ویدیو نشان داده شده است، نشان می‌دهد.",
                            },
                        },
                        // 53 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Working with the Emulators _ Using the Emulators",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video focuses on launching Flutter apps on simulators and devices, primarily emphasizing the use of Android emulators due to accessibility reasons, as not all students might have a macOS system for iOS app development. The tutorial covers navigating the control panel of the Android emulator, enabling device rotation for testing landscape mode, and discusses the importance of adjusting layouts for various device sizes and orientations. It also briefly touches on the iOS simulator's features, such as rotating the device and controlling the soft keyboard. The video encourages viewers to familiarize themselves with emulator settings to effectively test their apps.",
                                // German
                                "Deutsch": "Das Video konzentriert sich auf das Starten von Flutter-Apps auf Simulatoren und Geräten und betont vor allem die Verwendung von Android-Emulatoren aus Gründen der Zugänglichkeit, da möglicherweise nicht alle Studenten über ein macOS-System für die Entwicklung von iOS-Apps verfügen. Das Tutorial behandelt die Navigation im Bedienfeld des Android-Emulators, das Aktivieren der Gerätedrehung zum Testen des Querformats und erörtert die Bedeutung der Anpassung von Layouts an verschiedene Gerätegrößen und -ausrichtungen. Es geht auch kurz auf die Funktionen des iOS-Simulators ein, z. B. das Drehen des Geräts und die Steuerung der Bildschirmtastatur. Das Video ermutigt die Zuschauer, sich mit den Emulatoreinstellungen vertraut zu machen, um ihre Apps effektiv zu testen.",
                                // Chinese
                                "中国人": "该视频重点介绍如何在模拟器和设备上启动 Flutter 应用，主要强调出于可访问性原因使用 Android 模拟器，因为并非所有学生都拥有用于 iOS 应用开发的 macOS 系统。该教程介绍了如何导航 Android 模拟器的控制面板、启用设备旋转以测试横向模式，并讨论了调整布局以适应各种设备尺寸和方向的重要性。它还简要介绍了 iOS 模拟器的功能，例如旋转设备和控制软键盘。该视频鼓励观看者熟悉模拟器设置，以便有效地测试他们的应用。",
                                // Russian
                                "Русский": "Видео посвящено запуску приложений Flutter на симуляторах и устройствах, в первую очередь подчеркивая использование эмуляторов Android из-за соображений доступности, поскольку не у всех студентов может быть система macOS для разработки приложений iOS. В руководстве рассматривается навигация по панели управления эмулятора Android, включение поворота устройства для тестирования ландшафтного режима и обсуждается важность настройки макетов для различных размеров и ориентаций устройств. Также вкратце затрагиваются функции симулятора iOS, такие как поворот устройства и управление программной клавиатурой. Видео призывает зрителей ознакомиться с настройками эмулятора для эффективного тестирования своих приложений.",
                                // French
                                "Français": "La vidéo se concentre sur le lancement d'applications Flutter sur des simulateurs et des appareils, en mettant principalement l'accent sur l'utilisation d'émulateurs Android pour des raisons d'accessibilité, car tous les étudiants ne disposent pas nécessairement d'un système macOS pour le développement d'applications iOS. Le didacticiel couvre la navigation dans le panneau de configuration de l'émulateur Android, l'activation de la rotation de l'appareil pour tester le mode paysage et discute de l'importance d'ajuster les dispositions pour différentes tailles et orientations d'appareils. Il aborde également brièvement les fonctionnalités du simulateur iOS, telles que la rotation de l'appareil et le contrôle du clavier logiciel. La vidéo encourage les spectateurs à se familiariser avec les paramètres de l'émulateur pour tester efficacement leurs applications.",
                                // Japanese
                                "日本語": "このビデオでは、シミュレーターとデバイス上での Flutter アプリの起動に焦点を当てています。すべての学生が iOS アプリ開発用の macOS システムを持っているわけではないため、アクセシビリティ上の理由から、主に Android エミュレーターの使用を強調しています。チュートリアルでは、Android エミュレーターのコントロール パネルの操作方法、横向きモードのテスト用にデバイスの回転を有効にする方法、さまざまなデバイスのサイズと向きに合わせてレイアウトを調整することの重要性について説明します。また、デバイスの回転やソフト キーボードの制御など、iOS シミュレーターの機能についても簡単に触れています。このビデオでは、視聴者がエミュレーターの設定に慣れてアプリを効果的にテストすることを推奨しています。",
                                // Korean
                                "한국인": "이 비디오는 시뮬레이터와 기기에서 Flutter 앱을 시작하는 데 중점을 두고 있으며, 모든 학생이 iOS 앱 개발을 위해 macOS 시스템을 가지고 있지는 않을 수 있으므로 접근성을 이유로 Android 에뮬레이터를 사용하는 것을 주로 강조합니다. 이 튜토리얼은 Android 에뮬레이터의 제어판 탐색, 가로 모드 테스트를 위한 기기 회전 활성화, 다양한 기기 크기와 방향에 맞게 레이아웃을 조정하는 것의 중요성에 대해 설명합니다. 또한 기기를 회전하고 소프트 키보드를 제어하는 ​​것과 같은 iOS 시뮬레이터의 기능에 대해서도 간략하게 다룹니다. 이 비디오는 시청자가 앱을 효과적으로 테스트하기 위해 에뮬레이터 설정에 익숙해지도록 권장합니다.",
                                // Spanish
                                "Español": "El video se centra en el lanzamiento de aplicaciones Flutter en simuladores y dispositivos, y se hace hincapié principalmente en el uso de emuladores de Android por razones de accesibilidad, ya que no todos los estudiantes pueden tener un sistema macOS para el desarrollo de aplicaciones iOS. El tutorial cubre la navegación por el panel de control del emulador de Android, la habilitación de la rotación del dispositivo para probar el modo horizontal y analiza la importancia de ajustar los diseños para varios tamaños y orientaciones de dispositivos. También se abordan brevemente las funciones del simulador de iOS, como la rotación del dispositivo y el control del teclado virtual. El video alienta a los espectadores a familiarizarse con la configuración del emulador para probar sus aplicaciones de manera efectiva.",
                                // Hindi
                                "हिंदी": "वीडियो में सिमुलेटर और डिवाइस पर फ़्लटर ऐप लॉन्च करने पर ध्यान केंद्रित किया गया है, मुख्य रूप से एक्सेसिबिलिटी कारणों से एंड्रॉइड एमुलेटर के उपयोग पर जोर दिया गया है, क्योंकि सभी छात्रों के पास iOS ऐप डेवलपमेंट के लिए macOS सिस्टम नहीं हो सकता है। ट्यूटोरियल में एंड्रॉइड एमुलेटर के कंट्रोल पैनल को नेविगेट करना, लैंडस्केप मोड के परीक्षण के लिए डिवाइस रोटेशन को सक्षम करना और विभिन्न डिवाइस आकारों और ओरिएंटेशन के लिए लेआउट को समायोजित करने के महत्व पर चर्चा की गई है। यह iOS सिम्युलेटर की विशेषताओं पर भी संक्षेप में चर्चा करता है, जैसे कि डिवाइस को घुमाना और सॉफ्ट कीबोर्ड को नियंत्रित करना। वीडियो दर्शकों को अपने ऐप्स को प्रभावी ढंग से परखने के लिए एमुलेटर सेटिंग्स से खुद को परिचित करने के लिए प्रोत्साहित करता है।",
                                // Portuguese
                                "Português": "O vídeo centra-se no lançamento de aplicações Flutter em simuladores e dispositivos, enfatizando principalmente a utilização de emuladores Android por motivos de acessibilidade, uma vez que nem todos os alunos podem ter um sistema macOS para o desenvolvimento de aplicações iOS. O tutorial aborda a navegação no painel de controlo do emulador Android, a ativação da rotação do dispositivo para testar o modo paisagem e discute a importância de ajustar os layouts para vários tamanhos e orientações dos dispositivos. Aborda também brevemente as características do simulador iOS, como rodar o dispositivo e controlar o teclado virtual. O vídeo incentiva os espectadores a familiarizarem-se com as definições do emulador para testar as suas aplicações de forma eficaz.",
                                // Bengali
                                "বাংলা": "ভিডিওটি সিমুলেটর এবং ডিভাইসগুলিতে ফ্লাটার অ্যাপ চালু করার উপর ফোকাস করে, প্রাথমিকভাবে অ্যাক্সেসযোগ্যতার কারণে অ্যান্ড্রয়েড এমুলেটর ব্যবহারের উপর জোর দেয়, কারণ সমস্ত শিক্ষার্থীর iOS অ্যাপ ডেভেলপমেন্টের জন্য ম্যাকওএস সিস্টেম নাও থাকতে পারে। টিউটোরিয়ালটি অ্যান্ড্রয়েড এমুলেটরের কন্ট্রোল প্যানেলে নেভিগেট করা, ল্যান্ডস্কেপ মোড পরীক্ষা করার জন্য ডিভাইস ঘূর্ণন সক্ষম করে এবং বিভিন্ন ডিভাইসের আকার এবং অভিযোজনের জন্য লেআউট সামঞ্জস্য করার গুরুত্ব নিয়ে আলোচনা করে। এটি iOS সিমুলেটরের বৈশিষ্ট্যগুলিকেও সংক্ষিপ্তভাবে স্পর্শ করে, যেমন ডিভাইসটি ঘোরানো এবং নরম কীবোর্ড নিয়ন্ত্রণ করা। ভিডিওটি দর্শকদের তাদের অ্যাপগুলিকে কার্যকরভাবে পরীক্ষা করার জন্য এমুলেটর সেটিংসের সাথে নিজেদের পরিচিত করতে উত্সাহিত করে৷",
                                // Arabic
                                "عَرَبِيّ": "يركز الفيديو على تشغيل تطبيقات Flutter على المحاكيات والأجهزة، مع التركيز بشكل أساسي على استخدام محاكيات Android لأسباب تتعلق بإمكانية الوصول، حيث قد لا يكون لدى جميع الطلاب نظام macOS لتطوير تطبيقات iOS. يغطي البرنامج التعليمي التنقل في لوحة التحكم لمحاكي Android، وتمكين تدوير الجهاز لاختبار الوضع الأفقي، ويناقش أهمية ضبط التخطيطات لأحجام الأجهزة واتجاهاتها المختلفة. كما يتطرق بإيجاز إلى ميزات محاكي iOS، مثل تدوير الجهاز والتحكم في لوحة المفاتيح الناعمة. يشجع الفيديو المشاهدين على التعرف على إعدادات المحاكي لاختبار تطبيقاتهم بشكل فعال.",
                                // Persian
                                "فارسی": "این ویدیو بر راه‌اندازی برنامه‌های Flutter بر روی شبیه‌سازها و دستگاه‌ها تمرکز دارد و در درجه اول بر استفاده از شبیه‌سازهای اندروید به دلایل دسترسی تأکید دارد، زیرا ممکن است همه دانش‌آموزان یک سیستم macOS برای توسعه برنامه iOS نداشته باشند. این آموزش ناوبری در کنترل پنل شبیه‌ساز اندروید، فعال کردن چرخش دستگاه برای آزمایش حالت افقی را پوشش می‌دهد و اهمیت تنظیم طرح‌بندی برای اندازه‌ها و جهت‌های مختلف دستگاه را مورد بحث قرار می‌دهد. همچنین به طور مختصر به ویژگی‌های شبیه‌ساز iOS، مانند چرخاندن دستگاه و کنترل صفحه‌کلید نرم، اشاره می‌کند. این ویدیو بینندگان را تشویق می کند تا با تنظیمات شبیه ساز آشنا شوند تا به طور موثر برنامه های خود را آزمایش کنند.",
                            },
                        },
                        // 54 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Understanding Error Messages & Fixing Errors",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video delves into tools for effective debugging in Flutter app development, covering error resolution, identifying logical errors, and monitoring performance. It discusses common errors like syntax errors and illustrates how these can be detected in the IDE's problems tab. The tutorial also addresses runtime errors that may not be immediately recognized by the IDE but are encountered when the app is running. Using a concrete coding example, the video demonstrates how to interpret error messages and locate the specific code causing the issue, emphasizing the importance of analyzing error messages from the beginning to effectively troubleshoot and resolve errors.",
                                // German
                                "Deutsch": "Das Video befasst sich mit Tools für effektives Debugging bei der Entwicklung von Flutter-Apps und behandelt Fehlerbehebung, Identifizierung logischer Fehler und Leistungsüberwachung. Es bespricht häufige Fehler wie Syntaxfehler und zeigt, wie diese auf der Registerkarte „Probleme“ der IDE erkannt werden können. Das Tutorial behandelt auch Laufzeitfehler, die von der IDE möglicherweise nicht sofort erkannt werden, aber beim Ausführen der App auftreten. Anhand eines konkreten Codierungsbeispiels zeigt das Video, wie Fehlermeldungen interpretiert und der spezifische Code gefunden werden, der das Problem verursacht. Dabei wird betont, wie wichtig es ist, Fehlermeldungen von Anfang an zu analysieren, um Fehler effektiv zu beheben.",
                                // Chinese
                                "中国人": "该视频深入探讨了 Flutter 应用开发中有效调试的工具，涵盖错误解决、识别逻辑错误和监控性能。它讨论了语法错误等常见错误，并说明了如何在 IDE 的问题选项卡中检测这些错误。本教程还介绍了 IDE 可能无法立即识别但在应用运行时遇到的运行时错误。视频使用具体的编码示例演示了如何解释错误消息并找到导致问题的特定代码，强调了从一开始就分析错误消息以有效排除故障和解决错误的重要性。",
                                // Russian
                                "Русский": "Видео углубляется в инструменты для эффективной отладки в разработке приложений Flutter, охватывая разрешение ошибок, выявление логических ошибок и мониторинг производительности. В нем обсуждаются распространенные ошибки, такие как синтаксические ошибки, и иллюстрируется, как их можно обнаружить на вкладке проблем IDE. В руководстве также рассматриваются ошибки времени выполнения, которые могут не быть немедленно распознаны IDE, но возникают при запуске приложения. Используя конкретный пример кодирования, видео демонстрирует, как интерпретировать сообщения об ошибках и находить конкретный код, вызывающий проблему, подчеркивая важность анализа сообщений об ошибках с самого начала для эффективного устранения неполадок и устранения ошибок.",
                                // French
                                "Français": "La vidéo aborde les outils de débogage efficaces dans le développement d'applications Flutter, couvrant la résolution des erreurs, l'identification des erreurs logiques et la surveillance des performances. Elle aborde les erreurs courantes telles que les erreurs de syntaxe et illustre comment celles-ci peuvent être détectées dans l'onglet Problèmes de l'IDE. Le didacticiel aborde également les erreurs d'exécution qui peuvent ne pas être immédiatement reconnues par l'IDE mais qui se produisent lorsque l'application est en cours d'exécution. À l'aide d'un exemple de codage concret, la vidéo montre comment interpréter les messages d'erreur et localiser le code spécifique à l'origine du problème, en soulignant l'importance d'analyser les messages d'erreur dès le début pour dépanner et résoudre efficacement les erreurs.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter アプリ開発における効果的なデバッグのためのツールについて詳しく解説し、エラー解決、論理エラーの特定、パフォーマンスの監視について取り上げています。構文エラーなどの一般的なエラーについて説明し、IDE の問題タブでこれらを検出する方法を示します。また、このチュートリアルでは、IDE ではすぐには認識されないものの、アプリの実行中に発生するランタイム エラーについても取り上げています。ビデオでは、具体的なコーディング例を使用して、エラー メッセージを解釈し、問題の原因となっている特定のコードを見つける方法を示し、エラーを効果的にトラブルシューティングして解決するために、最初からエラー メッセージを分析することの重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오는 Flutter 앱 개발에서 효과적인 디버깅을 위한 도구에 대해 깊이 있게 다루고, 오류 해결, 논리적 오류 식별, 성능 모니터링을 다룹니다. 구문 오류와 같은 일반적인 오류를 논의하고 이러한 오류를 IDE의 문제 탭에서 감지하는 방법을 보여줍니다. 이 튜토리얼은 또한 IDE에서 즉시 인식하지 못할 수 있지만 앱이 실행 중일 때 발생하는 런타임 오류를 다룹니다. 이 비디오는 구체적인 코딩 예제를 사용하여 오류 메시지를 해석하고 문제를 일으키는 특정 코드를 찾는 방법을 보여주며, 효과적으로 문제를 해결하고 오류를 해결하기 위해 처음부터 오류 메시지를 분석하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "El video profundiza en las herramientas para una depuración eficaz en el desarrollo de aplicaciones Flutter, abarcando la resolución de errores, la identificación de errores lógicos y la supervisión del rendimiento. Analiza errores comunes como errores de sintaxis e ilustra cómo se pueden detectar en la pestaña de problemas del IDE. El tutorial también aborda errores de tiempo de ejecución que el IDE puede no reconocer de inmediato, pero que se encuentran cuando se ejecuta la aplicación. Mediante un ejemplo de codificación concreto, el video demuestra cómo interpretar los mensajes de error y localizar el código específico que causa el problema, enfatizando la importancia de analizar los mensajes de error desde el principio para solucionar y resolver errores de manera eficaz.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर ऐप डेवलपमेंट में प्रभावी डिबगिंग के लिए उपकरणों पर विस्तार से चर्चा करता है, जिसमें त्रुटि समाधान, तार्किक त्रुटियों की पहचान और प्रदर्शन की निगरानी शामिल है। यह सिंटैक्स त्रुटियों जैसी सामान्य त्रुटियों पर चर्चा करता है और दिखाता है कि इन्हें IDE के समस्या टैब में कैसे पहचाना जा सकता है। ट्यूटोरियल रनटाइम त्रुटियों को भी संबोधित करता है जिन्हें IDE द्वारा तुरंत पहचाना नहीं जा सकता है लेकिन ऐप चलने पर सामने आती हैं। एक ठोस कोडिंग उदाहरण का उपयोग करते हुए, वीडियो प्रदर्शित करता है कि त्रुटि संदेशों की व्याख्या कैसे करें और समस्या पैदा करने वाले विशिष्ट कोड का पता लगाएं, त्रुटियों का प्रभावी ढंग से निवारण और समाधान करने के लिए शुरुआत से ही त्रुटि संदेशों का विश्लेषण करने के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "O vídeo aborda ferramentas para uma depuração eficaz no desenvolvimento de aplicações Flutter, abordando a resolução de erros, a identificação de erros lógicos e a monitorização de desempenho. Discute erros comuns, como erros de sintaxe, e ilustra como podem ser detetados no separador de problemas do IDE. O tutorial também aborda os erros de tempo de execução que podem não ser reconhecidos imediatamente pelo IDE, mas são encontrados quando a aplicação está em execução. Utilizando um exemplo concreto de codificação, o vídeo demonstra como interpretar as mensagens de erro e localizar o código específico que está a causar o problema, enfatizando a importância de analisar as mensagens de erro desde o início para solucionar problemas e resolver erros de forma eficaz.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ফ্লাটার অ্যাপ ডেভেলপমেন্টে কার্যকরী ডিবাগিং, ত্রুটির রেজোলিউশন কভার করার, যৌক্তিক ত্রুটি সনাক্তকরণ এবং পারফরম্যান্স নিরীক্ষণের জন্য সরঞ্জামগুলির সন্ধান করে৷ এটি সিনট্যাক্স ত্রুটির মতো সাধারণ ত্রুটিগুলি নিয়ে আলোচনা করে এবং কীভাবে এগুলি IDE এর সমস্যা ট্যাবে সনাক্ত করা যায় তা ব্যাখ্যা করে৷ টিউটোরিয়ালটি রানটাইম ত্রুটিগুলিকেও সম্বোধন করে যা IDE দ্বারা অবিলম্বে স্বীকৃত নাও হতে পারে তবে অ্যাপটি চলাকালীন সম্মুখীন হয়। একটি কংক্রিট কোডিং উদাহরণ ব্যবহার করে, ভিডিওটি দেখায় কিভাবে ত্রুটির বার্তাগুলিকে ব্যাখ্যা করা যায় এবং সমস্যা সৃষ্টিকারী নির্দিষ্ট কোডটি সনাক্ত করা যায়, কার্যকরভাবে সমস্যা সমাধান এবং ত্রুটিগুলি সমাধান করার জন্য প্রথম থেকেই ত্রুটি বার্তাগুলি বিশ্লেষণ করার গুরুত্বের উপর জোর দেয়৷",
                                // Arabic
                                "عَرَبِيّ": "يتناول الفيديو الأدوات اللازمة لتصحيح الأخطاء بفعالية في تطوير تطبيقات Flutter، ويغطي حل الأخطاء وتحديد الأخطاء المنطقية ومراقبة الأداء. ويناقش الأخطاء الشائعة مثل أخطاء بناء الجملة ويوضح كيف يمكن اكتشافها في علامة تبويب المشكلات في IDE. كما يتناول البرنامج التعليمي أخطاء وقت التشغيل التي قد لا يتم التعرف عليها فورًا بواسطة IDE ولكن يتم مواجهتها عند تشغيل التطبيق. باستخدام مثال ترميز ملموس، يوضح الفيديو كيفية تفسير رسائل الخطأ وتحديد الكود المحدد الذي يسبب المشكلة، مع التأكيد على أهمية تحليل رسائل الخطأ من البداية لاستكشاف الأخطاء وإصلاحها بشكل فعال.",
                                // Persian
                                "فارسی": "این ویدیو به ابزارهایی برای اشکال زدایی مؤثر در توسعه برنامه Flutter، پوشش حل خطا، شناسایی خطاهای منطقی و نظارت بر عملکرد می پردازد. این خطاهای رایج مانند خطاهای نحوی را مورد بحث قرار می دهد و نشان می دهد که چگونه می توان آنها را در برگه مشکلات IDE شناسایی کرد. این آموزش همچنین به خطاهای زمان اجرا می‌پردازد که ممکن است فوراً توسط IDE شناسایی نشوند، اما هنگام اجرای برنامه با آن‌ها مواجه می‌شوند. با استفاده از یک مثال برنامه‌نویسی ملموس، این ویدیو نحوه تفسیر پیام‌های خطا و مکان‌یابی کد خاصی را که باعث این مشکل می‌شود، نشان می‌دهد، و بر اهمیت تجزیه و تحلیل پیام‌های خطا از ابتدا برای عیب‌یابی و حل و فصل مؤثر خطاها تأکید می‌کند.",
                            },
                        },
                        // 55 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Using the Debugger",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video demonstrates methods for identifying and resolving logical errors in Flutter app development, addressing scenarios where errors do not trigger explicit error messages. The content explains logical errors using an example of incorrect code behavior resulting in a skipped question without displaying an error. The tutorial outlines two approaches for diagnosing these issues, starting with using print statements to monitor variable values and progressing to utilizing the debugger tool for more complex problems. The video showcases setting breakpoints, stepping through code execution, and examining variable values to analyze and troubleshoot code effectively for logical errors.",
                                // German
                                "Deutsch": "Das Video zeigt Methoden zum Identifizieren und Beheben logischer Fehler bei der Entwicklung von Flutter-Apps und behandelt Szenarien, in denen Fehler keine expliziten Fehlermeldungen auslösen. Der Inhalt erklärt logische Fehler anhand eines Beispiels für falsches Codeverhalten, das dazu führt, dass eine Frage übersprungen wird, ohne dass ein Fehler angezeigt wird. Das Tutorial beschreibt zwei Ansätze zur Diagnose dieser Probleme, beginnend mit der Verwendung von Druckanweisungen zum Überwachen von Variablenwerten und fortschreitend mit der Verwendung des Debugger-Tools für komplexere Probleme. Das Video zeigt das Setzen von Haltepunkten, das Durchlaufen der Codeausführung und das Untersuchen von Variablenwerten, um Code effektiv auf logische Fehler zu analysieren und zu beheben.",
                                // Chinese
                                "中国人": "该视频演示了在 Flutter 应用开发中识别和解决逻辑错误的方法，解决了错误不会触发明确错误消息的情况。内容使用不正确的代码行为示例来解释逻辑错误，该示例导致跳过问题而不显示错误。本教程概述了诊断这些问题的两种方法，首先使用打印语句来监视变量值，然后利用调试器工具来解决更复杂的问题。视频展示了如何设置断点、逐步执行代码执行和检查变量值，以有效地分析和排除代码中的逻辑错误。",
                                // Russian
                                "Русский": "Видео демонстрирует методы выявления и устранения логических ошибок при разработке приложений Flutter, рассматривая сценарии, в которых ошибки не вызывают явных сообщений об ошибках. В содержании объясняются логические ошибки на примере неправильного поведения кода, приводящего к пропуску вопроса без отображения ошибки. В руководстве описываются два подхода к диагностике этих проблем, начиная с использования операторов печати для мониторинга значений переменных и заканчивая использованием инструмента отладчика для более сложных проблем. Видео демонстрирует установку точек останова, пошаговое выполнение кода и проверку значений переменных для эффективного анализа и устранения неполадок кода на предмет логических ошибок.",
                                // French
                                "Français": "La vidéo présente des méthodes permettant d'identifier et de résoudre les erreurs logiques dans le développement d'applications Flutter, en abordant des scénarios dans lesquels les erreurs ne déclenchent pas de messages d'erreur explicites. Le contenu explique les erreurs logiques à l'aide d'un exemple de comportement de code incorrect entraînant une question ignorée sans afficher d'erreur. Le didacticiel décrit deux approches pour diagnostiquer ces problèmes, en commençant par l'utilisation d'instructions d'impression pour surveiller les valeurs des variables et en progressant vers l'utilisation de l'outil de débogage pour des problèmes plus complexes. La vidéo présente la définition de points d'arrêt, l'exécution pas à pas du code et l'examen des valeurs des variables pour analyser et dépanner efficacement le code pour détecter les erreurs logiques.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter アプリ開発における論理エラーを特定して解決する方法を示し、エラーによって明示的なエラー メッセージがトリガーされないシナリオに対処します。コンテンツでは、エラーが表示されずに質問がスキップされるという誤ったコード動作の例を使用して、論理エラーについて説明します。チュートリアルでは、これらの問題を診断するための 2 つのアプローチについて概説します。まず、print ステートメントを使用して変数値を監視し、次にデバッガー ツールを使用してより複雑な問題に対処します。ビデオでは、ブレークポイントの設定、コード実行のステップ実行、変数値の調査を行って、論理エラーのコードを効果的に分析およびトラブルシューティングする方法を紹介します。",
                                // Korean
                                "한국인": "이 비디오는 Flutter 앱 개발에서 논리적 오류를 식별하고 해결하는 방법을 보여주며, 오류가 명시적 오류 메시지를 트리거하지 않는 시나리오를 다룹니다. 이 콘텐츠는 오류를 표시하지 않고 질문을 건너뛰는 잘못된 코드 동작의 예를 사용하여 논리적 오류를 설명합니다. 이 튜토리얼은 이러한 문제를 진단하는 두 가지 접근 방식을 설명하는데, 먼저 print 문을 사용하여 변수 값을 모니터링하고 더 복잡한 문제에 디버거 도구를 활용하는 것으로 진행합니다. 이 비디오는 중단점 설정, 코드 실행 단계별 실행, 변수 값을 검사하여 논리적 오류에 대한 코드를 효과적으로 분석하고 문제를 해결하는 방법을 보여줍니다.",
                                // Spanish
                                "Español": "El video muestra métodos para identificar y resolver errores lógicos en el desarrollo de aplicaciones Flutter, abordando situaciones en las que los errores no activan mensajes de error explícitos. El contenido explica los errores lógicos mediante un ejemplo de comportamiento incorrecto del código que da como resultado una pregunta omitida sin mostrar un error. El tutorial describe dos enfoques para diagnosticar estos problemas, comenzando con el uso de declaraciones de impresión para monitorear valores de variables y progresando hasta utilizar la herramienta de depuración para problemas más complejos. El video muestra la configuración de puntos de interrupción, el recorrido por la ejecución del código y el examen de los valores de las variables para analizar y solucionar problemas del código de manera eficaz en busca de errores lógicos.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर ऐप डेवलपमेंट में तार्किक त्रुटियों की पहचान करने और उन्हें हल करने के तरीकों को प्रदर्शित करता है, उन परिदृश्यों को संबोधित करता है जहाँ त्रुटियाँ स्पष्ट त्रुटि संदेशों को ट्रिगर नहीं करती हैं। सामग्री गलत कोड व्यवहार के उदाहरण का उपयोग करके तार्किक त्रुटियों को समझाती है जिसके परिणामस्वरूप त्रुटि प्रदर्शित किए बिना एक प्रश्न छोड़ दिया जाता है। ट्यूटोरियल इन समस्याओं के निदान के लिए दो दृष्टिकोणों की रूपरेखा तैयार करता है, जो चर मानों की निगरानी के लिए प्रिंट स्टेटमेंट का उपयोग करने से शुरू होता है और अधिक जटिल समस्याओं के लिए डीबगर टूल का उपयोग करने के लिए आगे बढ़ता है। वीडियो ब्रेकपॉइंट सेट करना, कोड निष्पादन के माध्यम से कदम बढ़ाना और तार्किक त्रुटियों के लिए कोड का प्रभावी ढंग से विश्लेषण और समस्या निवारण करने के लिए चर मानों की जांच करना दिखाता है।",
                                // Portuguese
                                "Português": "O vídeo demonstra métodos para identificar e resolver erros lógicos no desenvolvimento de aplicações Flutter, abordando cenários em que os erros não desencadeiam mensagens de erro explícitas. O conteúdo explica os erros lógicos utilizando um exemplo de comportamento incorreto do código, resultando numa pergunta ignorada sem apresentar um erro. O tutorial descreve duas abordagens para diagnosticar estes problemas, começando pela utilização de instruções print para monitorizar valores de variáveis ​​e progredindo para a utilização da ferramenta depurador para problemas mais complexos. O vídeo mostra a configuração de pontos de interrupção, a execução de código e o exame de valores de variáveis ​​para analisar e solucionar problemas de código de forma eficaz em busca de erros lógicos.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ফ্লটার অ্যাপ ডেভেলপমেন্টে যৌক্তিক ত্রুটি সনাক্তকরণ এবং সমাধান করার পদ্ধতিগুলি প্রদর্শন করে, এমন পরিস্থিতিগুলিকে সম্বোধন করে যেখানে ত্রুটিগুলি স্পষ্ট ত্রুটি বার্তাগুলিকে ট্রিগার করে না৷ বিষয়বস্তু ভুল কোড আচরণের একটি উদাহরণ ব্যবহার করে যৌক্তিক ত্রুটিগুলি ব্যাখ্যা করে যার ফলে একটি ত্রুটি প্রদর্শন ছাড়াই একটি প্রশ্ন এড়িয়ে যায়৷ টিউটোরিয়ালটি এই সমস্যাগুলি নির্ণয়ের জন্য দুটি পদ্ধতির রূপরেখা দেয়, পরিবর্তনশীল মান নিরীক্ষণের জন্য প্রিন্ট স্টেটমেন্ট ব্যবহার করে এবং আরও জটিল সমস্যার জন্য ডিবাগার টুল ব্যবহার করার জন্য অগ্রগতি। ভিডিওটিতে ব্রেকপয়েন্ট সেট করা, কোড এক্সিকিউশনের মাধ্যমে ধাপে ধাপে যাওয়া, এবং লজিক্যাল ত্রুটির জন্য কার্যকরভাবে কোড বিশ্লেষণ ও সমস্যা সমাধানের জন্য পরিবর্তনশীল মান পরীক্ষা করা দেখানো হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو طرق تحديد الأخطاء المنطقية وحلها في تطوير تطبيقات Flutter، ومعالجة السيناريوهات التي لا تؤدي فيها الأخطاء إلى ظهور رسائل خطأ صريحة. يشرح المحتوى الأخطاء المنطقية باستخدام مثال لسلوك الكود غير الصحيح الذي يؤدي إلى تخطي سؤال دون عرض خطأ. يوضح البرنامج التعليمي طريقتين لتشخيص هذه المشكلات، بدءًا من استخدام عبارات الطباعة لمراقبة قيم المتغيرات والتقدم إلى استخدام أداة المصحح للمشكلات الأكثر تعقيدًا. يعرض الفيديو تعيين نقاط التوقف، والتنقل عبر تنفيذ التعليمات البرمجية، وفحص قيم المتغيرات لتحليل التعليمات البرمجية واستكشاف الأخطاء وإصلاحها بشكل فعال بحثًا عن الأخطاء المنطقية.",
                                // Persian
                                "فارسی": "این ویدئو روش‌هایی را برای شناسایی و رفع خطاهای منطقی در توسعه برنامه Flutter نشان می‌دهد، و سناریوهایی را که خطاها باعث ایجاد پیام‌های خطای صریح نمی‌شوند را نشان می‌دهد. محتوا خطاهای منطقی را با استفاده از مثالی از رفتار کد نادرست که منجر به یک سوال رد شده بدون نمایش خطا می شود توضیح می دهد. این آموزش دو رویکرد را برای تشخیص این مسائل تشریح می‌کند، که با استفاده از عبارات چاپی برای نظارت بر مقادیر متغیر شروع می‌شود و تا استفاده از ابزار دیباگر برای مشکلات پیچیده‌تر پیش می‌رود. این ویدئو تنظیم نقاط شکست، گام برداشتن در اجرای کد، و بررسی مقادیر متغیر برای تجزیه و تحلیل و عیب‌یابی کد به طور موثر برای خطاهای منطقی را نشان می‌دهد.",
                            },
                        },
                        // 56 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Getting Started with the Dart DevTools",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explores the functionality of the debugger and the Dart DevTools for debugging and user interface (UI) analysis in Flutter app development. It suggests running the app without debugging to fast-track development, specifically noting that utilizing the debugger can slow down the app. The content introduces the Dart DevTools feature accessible through Visual Studio Code, enabling developers to inspect the UI components, analyze widget configuration, and enhance performance. The demonstration includes selecting widgets, identifying layout structures, and utilizing debug paint to visualize app layout. Additionally, the video touches on utilizing the performance overlay feature for tracking app performance, emphasizing the need to evaluate performance on real devices for accurate results.",
                                // German
                                "Deutsch": "Das Video untersucht die Funktionalität des Debuggers und der Dart DevTools zum Debuggen und zur Analyse der Benutzeroberfläche (UI) bei der Entwicklung von Flutter-Apps. Es wird empfohlen, die App ohne Debuggen auszuführen, um die Entwicklung zu beschleunigen. Dabei wird insbesondere darauf hingewiesen, dass die Verwendung des Debuggers die App verlangsamen kann. Der Inhalt stellt die über Visual Studio Code zugängliche Dart DevTools-Funktion vor, mit der Entwickler die UI-Komponenten prüfen, die Widget-Konfiguration analysieren und die Leistung verbessern können. Die Demonstration umfasst das Auswählen von Widgets, das Identifizieren von Layoutstrukturen und die Verwendung von Debug Paint zum Visualisieren des App-Layouts. Darüber hinaus geht das Video auf die Verwendung der Leistungs-Overlay-Funktion zum Verfolgen der App-Leistung ein und betont die Notwendigkeit, die Leistung auf realen Geräten zu bewerten, um genaue Ergebnisse zu erzielen.",
                                // Chinese
                                "中国人": "该视频探讨了调试器和 Dart DevTools 在 Flutter 应用开发中用于调试和用户界面 (UI) 分析的功能。它建议在不进行调试的情况下运行应用以加快开发速度，特别指出使用调试器可能会降低应用速度。内容介绍了可通过 Visual Studio Code 访问的 Dart DevTools 功能，使开发人员能够检查 UI 组件、分析小部件配置并提高性能。演示包括选择小部件、识别布局结构以及利用调试绘制来可视化应用布局。此外，视频还涉及利用性能叠加功能来跟踪应用性能，强调需要评估真实设备上的性能以获得准确的结果。",
                                // Russian
                                "Русский": "В видео рассматриваются функциональные возможности отладчика и Dart DevTools для отладки и анализа пользовательского интерфейса (UI) при разработке приложений Flutter. В нем предлагается запустить приложение без отладки для ускорения разработки, в частности, отмечая, что использование отладчика может замедлить приложение. В контенте представлена ​​функция Dart DevTools, доступная через Visual Studio Code, позволяющая разработчикам проверять компоненты пользовательского интерфейса, анализировать конфигурацию виджетов и повышать производительность. Демонстрация включает выбор виджетов, определение структур макета и использование отладочной краски для визуализации макета приложения. Кроме того, в видео затрагивается использование функции наложения производительности для отслеживания производительности приложения, подчеркивая необходимость оценки производительности на реальных устройствах для получения точных результатов.",
                                // French
                                "Français": "La vidéo explore les fonctionnalités du débogueur et des outils de développement Dart pour le débogage et l'analyse de l'interface utilisateur (UI) dans le développement d'applications Flutter. Elle suggère d'exécuter l'application sans débogage pour accélérer le développement, en notant spécifiquement que l'utilisation du débogueur peut ralentir l'application. Le contenu présente la fonctionnalité Dart DevTools accessible via Visual Studio Code, permettant aux développeurs d'inspecter les composants de l'interface utilisateur, d'analyser la configuration des widgets et d'améliorer les performances. La démonstration comprend la sélection de widgets, l'identification des structures de mise en page et l'utilisation de la peinture de débogage pour visualiser la mise en page de l'application. De plus, la vidéo aborde l'utilisation de la fonction de superposition des performances pour suivre les performances de l'application, en soulignant la nécessité d'évaluer les performances sur des appareils réels pour obtenir des résultats précis.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter アプリ開発におけるデバッグとユーザー インターフェース (UI) 分析のためのデバッガーと Dart DevTools の機能について説明します。デバッガーを使用するとアプリの速度が低下する可能性があることを特に指摘し、開発を高速化するためにデバッグなしでアプリを実行することを提案しています。コンテンツでは、Visual Studio Code からアクセスできる Dart DevTools 機能を紹介し、開発者が UI コンポーネントを検査し、ウィジェット構成を分析し、パフォーマンスを向上できるようにします。デモでは、ウィジェットの選択、レイアウト構造の特定、デバッグ ペイントを使用したアプリ レイアウトの視覚化を行います。さらに、このビデオでは、アプリのパフォーマンスを追跡するためのパフォーマンス オーバーレイ機能の使用についても触れ、正確な結果を得るには実際のデバイスでパフォーマンスを評価する必要があることを強調しています。",
                                // Korean
                                "한국인": "이 비디오는 Flutter 앱 개발에서 디버깅 및 사용자 인터페이스(UI) 분석을 위한 디버거와 Dart DevTools의 기능을 살펴봅니다. 개발을 빠르게 진행하기 위해 디버깅 없이 앱을 실행하는 것을 제안하며, 특히 디버거를 활용하면 앱 속도가 느려질 수 있다는 점을 언급합니다. 이 콘텐츠에서는 Visual Studio Code를 통해 액세스할 수 있는 Dart DevTools 기능을 소개하여 개발자가 UI 구성 요소를 검사하고, 위젯 구성을 분석하고, 성능을 향상시킬 수 있도록 합니다. 데모에는 위젯 선택, 레이아웃 구조 식별, 디버그 페인트 활용을 통한 앱 레이아웃 시각화가 포함됩니다. 또한 이 비디오는 앱 성능을 추적하기 위한 성능 오버레이 기능 활용에 대해 다루며, 정확한 결과를 위해 실제 기기에서 성능을 평가해야 할 필요성을 강조합니다.",
                                // Spanish
                                "Español": "El video explora la funcionalidad del depurador y Dart DevTools para la depuración y el análisis de la interfaz de usuario (UI) en el desarrollo de aplicaciones Flutter. Sugiere ejecutar la aplicación sin depurar para acelerar el desarrollo, y señala específicamente que el uso del depurador puede ralentizar la aplicación. El contenido presenta la función Dart DevTools, a la que se puede acceder a través de Visual Studio Code, que permite a los desarrolladores inspeccionar los componentes de la UI, analizar la configuración de los widgets y mejorar el rendimiento. La demostración incluye la selección de widgets, la identificación de estructuras de diseño y el uso de pintura de depuración para visualizar el diseño de la aplicación. Además, el video aborda el uso de la función de superposición de rendimiento para realizar un seguimiento del rendimiento de la aplicación, y enfatiza la necesidad de evaluar el rendimiento en dispositivos reales para obtener resultados precisos.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर ऐप डेवलपमेंट में डिबगिंग और यूज़र इंटरफ़ेस (UI) विश्लेषण के लिए डिबगर और डार्ट डेवटूल्स की कार्यक्षमता का पता लगाता है। यह विकास को तेज़ करने के लिए डिबगिंग के बिना ऐप चलाने का सुझाव देता है, विशेष रूप से यह ध्यान में रखते हुए कि डिबगर का उपयोग करने से ऐप धीमा हो सकता है। सामग्री विजुअल स्टूडियो कोड के माध्यम से सुलभ डार्ट डेवटूल्स सुविधा का परिचय देती है, जिससे डेवलपर्स UI घटकों का निरीक्षण कर सकते हैं, विजेट कॉन्फ़िगरेशन का विश्लेषण कर सकते हैं और प्रदर्शन को बढ़ा सकते हैं। प्रदर्शन में विजेट का चयन करना, लेआउट संरचनाओं की पहचान करना और ऐप लेआउट को विज़ुअलाइज़ करने के लिए डिबग पेंट का उपयोग करना शामिल है। इसके अतिरिक्त, वीडियो ऐप प्रदर्शन को ट्रैक करने के लिए प्रदर्शन ओवरले सुविधा का उपयोग करने पर भी प्रकाश डालता है, सटीक परिणामों के लिए वास्तविक डिवाइस पर प्रदर्शन का मूल्यांकन करने की आवश्यकता पर बल देता है।",
                                // Portuguese
                                "Português": "O vídeo explora a funcionalidade do depurador e do Dart DevTools para depuração e análise da interface do utilizador (UI) no desenvolvimento de aplicações Flutter. Sugere a execução da aplicação sem depuração para acelerar o desenvolvimento, observando especificamente que a utilização do depurador pode tornar a aplicação mais lenta. O conteúdo apresenta a funcionalidade Dart DevTools acessível através do Visual Studio Code, permitindo aos programadores inspecionar os componentes da IU, analisar a configuração do widget e melhorar o desempenho. A demonstração inclui a seleção de widgets, a identificação de estruturas de layout e a utilização de pintura de depuração para visualizar o layout da aplicação. Além disso, o vídeo aborda a utilização da funcionalidade de sobreposição de desempenho para monitorizar o desempenho da aplicação, enfatizando a necessidade de avaliar o desempenho em dispositivos reais para obter resultados precisos.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ফ্লটার অ্যাপ ডেভেলপমেন্টে ডিবাগিং এবং ইউজার ইন্টারফেস (UI) বিশ্লেষণের জন্য ডিবাগার এবং ডার্ট ডেভটুলগুলির কার্যকারিতা অন্বেষণ করে। এটি ফাস্ট-ট্র্যাক ডেভেলপমেন্টে ডিবাগিং ছাড়াই অ্যাপ চালানোর পরামর্শ দেয়, বিশেষ করে উল্লেখ করে যে ডিবাগার ব্যবহার করলে অ্যাপটি ধীর হয়ে যেতে পারে। বিষয়বস্তু ভিজ্যুয়াল স্টুডিও কোডের মাধ্যমে অ্যাক্সেসযোগ্য Dart DevTools বৈশিষ্ট্যের সাথে পরিচয় করিয়ে দেয়, যা ডেভেলপারদের UI উপাদানগুলি পরিদর্শন করতে, উইজেট কনফিগারেশন বিশ্লেষণ করতে এবং কর্মক্ষমতা বাড়াতে সক্ষম করে। প্রদর্শনীতে উইজেট নির্বাচন করা, লেআউট স্ট্রাকচার শনাক্ত করা এবং অ্যাপ লেআউটকে কল্পনা করতে ডিবাগ পেইন্ট ব্যবহার করা অন্তর্ভুক্ত। উপরন্তু, ভিডিওটি অ্যাপের পারফরম্যান্স ট্র্যাক করার জন্য পারফরম্যান্স ওভারলে বৈশিষ্ট্যটি ব্যবহার করার উপর স্পর্শ করে, সঠিক ফলাফলের জন্য বাস্তব ডিভাইসে কর্মক্ষমতা মূল্যায়ন করার প্রয়োজনীয়তার উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يستكشف الفيديو وظائف المصحح وأدوات تطوير Dart لتصحيح الأخطاء وتحليل واجهة المستخدم (UI) في تطوير تطبيقات Flutter. ويقترح تشغيل التطبيق دون تصحيح الأخطاء لتسريع التطوير، مع ملاحظة أن استخدام المصحح يمكن أن يبطئ التطبيق. يقدم المحتوى ميزة Dart DevTools التي يمكن الوصول إليها من خلال Visual Studio Code، مما يتيح للمطورين فحص مكونات واجهة المستخدم وتحليل تكوين الأدوات وتحسين الأداء. يتضمن العرض التوضيحي تحديد الأدوات وتحديد هياكل التخطيط واستخدام طلاء التصحيح لتصور تخطيط التطبيق. بالإضافة إلى ذلك، يتطرق الفيديو إلى استخدام ميزة تراكب الأداء لتتبع أداء التطبيق، مع التأكيد على الحاجة إلى تقييم الأداء على الأجهزة الحقيقية للحصول على نتائج دقيقة.",
                                // Persian
                                "فارسی": "این ویدیو به بررسی عملکرد اشکال‌زدا و Dart DevTools برای اشکال‌زدایی و تجزیه و تحلیل رابط کاربری (UI) در توسعه برنامه Flutter می‌پردازد. پیشنهاد می‌کند برنامه را بدون اشکال‌زدایی برای ردیابی سریع توسعه اجرا کنید، به‌ویژه توجه داشته باشید که استفاده از دیباگر می‌تواند سرعت برنامه را کاهش دهد. این محتوا ویژگی Dart DevTools را معرفی می‌کند که از طریق Visual Studio Code قابل دسترسی است و توسعه‌دهندگان را قادر می‌سازد تا اجزای UI را بررسی کنند، پیکربندی ویجت را تجزیه و تحلیل کنند و عملکرد را بهبود بخشند. این نمایش شامل انتخاب ویجت‌ها، شناسایی ساختارهای طرح‌بندی، و استفاده از رنگ‌های اشکال زدایی برای تجسم طرح‌بندی برنامه است. علاوه بر این، ویدیو به استفاده از ویژگی پوشش عملکرد برای ردیابی عملکرد برنامه می پردازد و بر نیاز به ارزیابی عملکرد در دستگاه های واقعی برای نتایج دقیق تأکید می کند.",
                            },
                        },
                        // 57 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Understanding the Repaint Rainbow",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explores the concept of the repaint rainbow feature in Flutter for visualizing screen elements that are repainted upon user interactions. It demonstrates how the tool highlights repainted UI elements based on color changes, aiding in identifying unnecessary repaints and potential optimization opportunities. The content highlights the importance of efficiently managing widget rebuilds, suggesting strategies like separating state management into distinct widgets to prevent unnecessary rebuild triggers on unaffected elements, ultimately improving app performance. The video emphasizes the distinctions between repainting and recreating elements in Flutter and the performance considerations associated with each process, while stressing the significance of optimal element handling for enhancing application performance and efficiency.",
                                // German
                                "Deutsch": "Das Video untersucht das Konzept der Repaint-Rainbow-Funktion in Flutter zur Visualisierung von Bildschirmelementen, die bei Benutzerinteraktionen neu gezeichnet werden. Es zeigt, wie das Tool neu gezeichnete UI-Elemente anhand von Farbänderungen hervorhebt und so dabei hilft, unnötige Neuzeichnungen und potenzielle Optimierungsmöglichkeiten zu identifizieren. Der Inhalt hebt die Bedeutung einer effizienten Verwaltung von Widget-Neuerstellungen hervor und schlägt Strategien vor, wie die Trennung der Statusverwaltung in unterschiedliche Widgets, um unnötige Neuerstellungsauslöser für nicht betroffene Elemente zu verhindern und so letztendlich die App-Leistung zu verbessern. Das Video betont die Unterschiede zwischen dem Neuzeichnen und Neuerstellen von Elementen in Flutter und die mit jedem Prozess verbundenen Leistungsaspekte und betont gleichzeitig die Bedeutung einer optimalen Elementbehandlung zur Verbesserung der Anwendungsleistung und -effizienz.",
                                // Chinese
                                "中国人": "该视频探讨了 Flutter 中重绘彩虹功能的概念，该功能用于可视化在用户交互时重绘的屏幕元素。它演示了该工具如何根据颜色变化突出显示重绘的 UI 元素，帮助识别不必要的重绘和潜在的优化机会。内容强调了有效管理小部件重建的重要性，并提出了一些策略，例如将状态管理分离到不同的小部件中，以防止在未受影响的元素上触发不必要的重建，最终提高应用程序性能。该视频强调了 Flutter 中重绘和重新创建元素之间的区别以及与每个过程相关的性能考虑因素，同时强调了最佳元素处理对于提高应用程序性能和效率的重要性。",
                                // Russian
                                "Русский": "В видео рассматривается концепция функции перерисовки радуги во Flutter для визуализации элементов экрана, которые перерисовываются при взаимодействии с пользователем. В нем показано, как инструмент выделяет перерисованные элементы пользовательского интерфейса на основе изменений цвета, помогая выявлять ненужные перерисовки и потенциальные возможности оптимизации. В контенте подчеркивается важность эффективного управления перестройками виджетов, предлагаются такие стратегии, как разделение управления состоянием на отдельные виджеты для предотвращения ненужных триггеров перестройки на незатронутых элементах, что в конечном итоге повышает производительность приложения. В видео подчеркиваются различия между перерисовкой и воссозданием элементов во Flutter и соображения производительности, связанные с каждым процессом, при этом подчеркивается важность оптимальной обработки элементов для повышения производительности и эффективности приложения.",
                                // French
                                "Français": "La vidéo explore le concept de la fonction de repeinture arc-en-ciel dans Flutter pour visualiser les éléments d'écran qui sont repeints lors des interactions de l'utilisateur. Elle montre comment l'outil met en évidence les éléments d'interface utilisateur repeints en fonction des changements de couleur, ce qui permet d'identifier les repeintures inutiles et les opportunités d'optimisation potentielles. Le contenu souligne l'importance de gérer efficacement les reconstructions de widgets, en suggérant des stratégies telles que la séparation de la gestion d'état en widgets distincts pour éviter les déclencheurs de reconstruction inutiles sur les éléments non affectés, améliorant ainsi les performances de l'application. La vidéo met l'accent sur les distinctions entre repeindre et recréer des éléments dans Flutter et les considérations de performances associées à chaque processus, tout en soulignant l'importance d'une gestion optimale des éléments pour améliorer les performances et l'efficacité de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、ユーザー操作によって再描画される画面要素を視覚化する Flutter の再描画レインボー機能の概念について説明します。ツールが色の変化に基づいて再描画された UI 要素を強調表示し、不要な再描画と潜在的な最適化の機会を特定するのに役立つ方法を示します。コンテンツでは、ウィジェットの再構築を効率的に管理することの重要性を強調し、影響を受けていない要素で不要な再構築トリガーを防ぐため、状態管理を個別のウィジェットに分離するなどの戦略を提案し、最終的にアプリのパフォーマンスを向上させます。ビデオでは、Flutter での要素の再描画と再作成の違いと、各プロセスに関連するパフォーマンスの考慮事項を強調しながら、アプリケーションのパフォーマンスと効率を向上させるための最適な要素処理の重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오는 사용자 상호작용 시 다시 칠해지는 화면 요소를 시각화하기 위한 Flutter의 다시 칠하기 레인보우 기능 개념을 살펴봅니다. 이 도구가 색상 변경에 따라 다시 칠해진 UI 요소를 강조하여 불필요한 다시 칠하기와 잠재적인 최적화 기회를 식별하는 데 도움이 되는 방법을 보여줍니다. 이 콘텐츠는 위젯 재구축을 효율적으로 관리하는 것의 중요성을 강조하고, 영향을 받지 않는 요소에 불필요한 재구축 트리거를 방지하기 위해 상태 관리를 별도의 위젯으로 분리하는 것과 같은 전략을 제안하여 궁극적으로 앱 성능을 개선합니다. 이 비디오는 Flutter에서 요소를 다시 칠하고 재생성하는 것의 차이점과 각 프로세스와 관련된 성능 고려 사항을 강조하는 동시에 애플리케이션 성능과 효율성을 향상시키기 위한 최적의 요소 처리의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "El video explora el concepto de la función de repintado de arcoíris en Flutter para visualizar elementos de pantalla que se vuelven a pintar con las interacciones del usuario. Demuestra cómo la herramienta resalta los elementos de la interfaz de usuario repintados en función de los cambios de color, lo que ayuda a identificar repintados innecesarios y posibles oportunidades de optimización. El contenido destaca la importancia de administrar de manera eficiente las reconstrucciones de widgets y sugiere estrategias como separar la administración de estados en widgets distintos para evitar activadores de reconstrucción innecesarios en elementos no afectados, lo que en última instancia mejora el rendimiento de la aplicación. El video enfatiza las distinciones entre repintar y recrear elementos en Flutter y las consideraciones de rendimiento asociadas con cada proceso, al tiempo que destaca la importancia del manejo óptimo de elementos para mejorar el rendimiento y la eficiencia de la aplicación.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर में रीपेंट रेनबो फ़ीचर की अवधारणा का पता लगाता है, जो उपयोगकर्ता इंटरैक्शन पर रीपेंट किए गए स्क्रीन तत्वों को विज़ुअलाइज़ करने के लिए है। यह दर्शाता है कि कैसे टूल रंग परिवर्तनों के आधार पर रीपेंट किए गए UI तत्वों को हाइलाइट करता है, अनावश्यक रीपेंट और संभावित अनुकूलन अवसरों की पहचान करने में सहायता करता है। सामग्री विजेट पुनर्निर्माण को कुशलतापूर्वक प्रबंधित करने के महत्व पर प्रकाश डालती है, अप्रभावित तत्वों पर अनावश्यक पुनर्निर्माण ट्रिगर्स को रोकने के लिए राज्य प्रबंधन को अलग-अलग विजेट में अलग करने जैसी रणनीतियों का सुझाव देती है, जिससे अंततः ऐप प्रदर्शन में सुधार होता है। वीडियो फ़्लटर में तत्वों को फिर से रंगने और फिर से बनाने के बीच के अंतर और प्रत्येक प्रक्रिया से जुड़े प्रदर्शन संबंधी विचारों पर जोर देता है, जबकि एप्लिकेशन प्रदर्शन और दक्षता को बढ़ाने के लिए इष्टतम तत्व हैंडलिंग के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "O vídeo explora o conceito da funcionalidade repintar arco-íris no Flutter para visualizar elementos do ecrã que são repintados de acordo com as interações do utilizador. Demonstra como a ferramenta destaca elementos da interface do utilizador repintados com base nas mudanças de cor, auxiliando na identificação de repinturas desnecessárias e possíveis oportunidades de otimização. O conteúdo destaca a importância de gerir eficientemente as recriações de widgets, sugerindo estratégias como separar a gestão de estado em widgets distintos para evitar gatilhos de recriação desnecessários em elementos não afetados, melhorando, em última análise, o desempenho da aplicação. O vídeo enfatiza as distinções entre repintar e recriar elementos no Flutter e as considerações de desempenho associadas a cada processo, ao mesmo tempo que enfatiza a importância do manuseamento ideal dos elementos para melhorar o desempenho e a eficiência da aplicação.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ব্যবহারকারীর ইন্টারঅ্যাকশনের উপর পুনরায় রং করা স্ক্রিন উপাদানগুলিকে ভিজ্যুয়ালাইজ করার জন্য ফ্লটারে পুনরায় রং করা রংধনু বৈশিষ্ট্যের ধারণাটি অন্বেষণ করে। এটি প্রদর্শন করে কিভাবে টুলটি রঙ পরিবর্তনের উপর ভিত্তি করে পুনরায় রং করা UI উপাদানগুলিকে হাইলাইট করে, অপ্রয়োজনীয় পুনরায় রং করা এবং সম্ভাব্য অপ্টিমাইজেশন সুযোগগুলি সনাক্ত করতে সহায়তা করে। বিষয়বস্তু উইজেট পুনর্নির্মাণের দক্ষতার সাথে পরিচালনার গুরুত্ব তুলে ধরে, অপ্রভাবিত উপাদানগুলিতে অপ্রয়োজনীয় পুনর্নির্মাণ ট্রিগার রোধ করতে, অবশেষে অ্যাপের কার্যকারিতা উন্নত করার জন্য রাষ্ট্র পরিচালনাকে পৃথক উইজেটে আলাদা করার মতো কৌশলগুলির পরামর্শ দেয়। ভিডিওটি ফ্লটারে উপাদানগুলি পুনরায় রং করা এবং পুনরায় তৈরি করার মধ্যে পার্থক্য এবং প্রতিটি প্রক্রিয়ার সাথে যুক্ত কর্মক্ষমতা বিবেচনার মধ্যে পার্থক্যের উপর জোর দেয়, পাশাপাশি অ্যাপ্লিকেশন কার্যক্ষমতা এবং দক্ষতা বাড়ানোর জন্য সর্বোত্তম উপাদান পরিচালনার তাত্পর্যের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يستكشف الفيديو مفهوم ميزة إعادة طلاء قوس قزح في Flutter لتصور عناصر الشاشة التي يتم إعادة طلائها عند تفاعل المستخدم. ويوضح كيف تسلط الأداة الضوء على عناصر واجهة المستخدم المعاد طلائها بناءً على تغييرات اللون، مما يساعد في تحديد عمليات إعادة الطلاء غير الضرورية وفرص التحسين المحتملة. ويسلط المحتوى الضوء على أهمية إدارة عمليات إعادة بناء الأدوات بكفاءة، واقتراح استراتيجيات مثل فصل إدارة الحالة إلى أدوات مميزة لمنع عمليات إعادة البناء غير الضرورية على العناصر غير المتأثرة، وتحسين أداء التطبيق في النهاية. ويؤكد الفيديو على التمييز بين إعادة طلاء العناصر وإعادة إنشائها في Flutter واعتبارات الأداء المرتبطة بكل عملية، مع التأكيد على أهمية التعامل الأمثل مع العناصر لتحسين أداء التطبيق وكفاءته.",
                                // Persian
                                "فارسی": "این ویدیو مفهوم ویژگی رنگین کمان را در Flutter برای تجسم عناصر صفحه نمایش که بر اساس تعاملات کاربر دوباره نقاشی می شوند را بررسی می کند. این نشان می دهد که چگونه این ابزار عناصر UI رنگ شده را بر اساس تغییرات رنگ برجسته می کند و به شناسایی رنگ های مجدد غیر ضروری و فرصت های بالقوه بهینه سازی کمک می کند. این محتوا اهمیت مدیریت کارآمد بازسازی ویجت‌ها را برجسته می‌کند و استراتژی‌هایی مانند تفکیک مدیریت حالت به ویجت‌های مجزا را برای جلوگیری از ایجاد مجدد غیرضروری در عناصر بی‌تأثیر پیشنهاد می‌کند و در نهایت عملکرد برنامه را بهبود می‌بخشد. این ویدیو بر تمایز بین رنگ‌آمیزی و بازسازی عناصر در فلاتر و ملاحظات عملکرد مرتبط با هر فرآیند تأکید می‌کند، در حالی که بر اهمیت مدیریت بهینه عناصر برای افزایش عملکرد و کارایی برنامه تأکید می‌کند.",
                            },
                        },
                        // 58 [Video Number]
                        {
                            "SectionName": "Running Apps on Different Devices & Debugging Apps",
                            "VideoName": "Wrapping up the Dart DevTools",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video explores the concept of the repaint rainbow feature in Flutter for visualizing screen elements that are repainted upon user interactions. It demonstrates how the tool highlights repainted UI elements based on color changes, aiding in identifying unnecessary repaints and potential optimization opportunities. The content highlights the importance of efficiently managing widget rebuilds, suggesting strategies like separating state management into distinct widgets to prevent unnecessary rebuild triggers on unaffected elements, ultimately improving app performance. The video emphasizes the distinctions between repainting and recreating elements in Flutter and the performance considerations associated with each process, while stressing the significance of optimal element handling for enhancing application performance and efficiency.",
                                // German
                                "Deutsch": "Das Video untersucht das Konzept der Repaint-Rainbow-Funktion in Flutter zur Visualisierung von Bildschirmelementen, die bei Benutzerinteraktionen neu gezeichnet werden. Es zeigt, wie das Tool neu gezeichnete UI-Elemente anhand von Farbänderungen hervorhebt und so dabei hilft, unnötige Neuzeichnungen und potenzielle Optimierungsmöglichkeiten zu identifizieren. Der Inhalt hebt die Bedeutung einer effizienten Verwaltung von Widget-Neuerstellungen hervor und schlägt Strategien vor, wie die Trennung der Statusverwaltung in unterschiedliche Widgets, um unnötige Neuerstellungsauslöser für nicht betroffene Elemente zu verhindern und so letztendlich die App-Leistung zu verbessern. Das Video betont die Unterschiede zwischen dem Neuzeichnen und Neuerstellen von Elementen in Flutter und die mit jedem Prozess verbundenen Leistungsaspekte und betont gleichzeitig die Bedeutung einer optimalen Elementbehandlung zur Verbesserung der Anwendungsleistung und -effizienz.",
                                // Chinese
                                "中国人": "该视频探讨了 Flutter 中重绘彩虹功能的概念，该功能用于可视化在用户交互时重绘的屏幕元素。它演示了该工具如何根据颜色变化突出显示重绘的 UI 元素，帮助识别不必要的重绘和潜在的优化机会。内容强调了有效管理小部件重建的重要性，并提出了一些策略，例如将状态管理分离到不同的小部件中，以防止在未受影响的元素上触发不必要的重建，最终提高应用程序性能。该视频强调了 Flutter 中重绘和重新创建元素之间的区别以及与每个过程相关的性能考虑因素，同时强调了最佳元素处理对于提高应用程序性能和效率的重要性。",
                                // Russian
                                "Русский": "В видео рассматривается концепция функции перерисовки радуги во Flutter для визуализации элементов экрана, которые перерисовываются при взаимодействии с пользователем. В нем показано, как инструмент выделяет перерисованные элементы пользовательского интерфейса на основе изменений цвета, помогая выявлять ненужные перерисовки и потенциальные возможности оптимизации. В контенте подчеркивается важность эффективного управления перестройками виджетов, предлагаются такие стратегии, как разделение управления состоянием на отдельные виджеты для предотвращения ненужных триггеров перестройки на незатронутых элементах, что в конечном итоге повышает производительность приложения. В видео подчеркиваются различия между перерисовкой и воссозданием элементов во Flutter и соображения производительности, связанные с каждым процессом, при этом подчеркивается важность оптимальной обработки элементов для повышения производительности и эффективности приложения.",
                                // French
                                "Français": "La vidéo explore le concept de la fonction de repeinture arc-en-ciel dans Flutter pour visualiser les éléments d'écran qui sont repeints lors des interactions de l'utilisateur. Elle montre comment l'outil met en évidence les éléments d'interface utilisateur repeints en fonction des changements de couleur, ce qui permet d'identifier les repeintures inutiles et les opportunités d'optimisation potentielles. Le contenu souligne l'importance de gérer efficacement les reconstructions de widgets, en suggérant des stratégies telles que la séparation de la gestion d'état en widgets distincts pour éviter les déclencheurs de reconstruction inutiles sur les éléments non affectés, améliorant ainsi les performances de l'application. La vidéo met l'accent sur les distinctions entre repeindre et recréer des éléments dans Flutter et les considérations de performances associées à chaque processus, tout en soulignant l'importance d'une gestion optimale des éléments pour améliorer les performances et l'efficacité de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、ユーザー操作によって再描画される画面要素を視覚化する Flutter の再描画レインボー機能の概念について説明します。ツールが色の変化に基づいて再描画された UI 要素を強調表示し、不要な再描画と潜在的な最適化の機会を特定するのに役立つ方法を示します。コンテンツでは、ウィジェットの再構築を効率的に管理することの重要性を強調し、影響を受けていない要素で不要な再構築トリガーを防ぐため、状態管理を個別のウィジェットに分離するなどの戦略を提案し、最終的にアプリのパフォーマンスを向上させます。ビデオでは、Flutter での要素の再描画と再作成の違いと、各プロセスに関連するパフォーマンスの考慮事項を強調しながら、アプリケーションのパフォーマンスと効率を向上させるための最適な要素処理の重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오는 사용자 상호작용 시 다시 칠해지는 화면 요소를 시각화하기 위한 Flutter의 다시 칠하기 레인보우 기능 개념을 살펴봅니다. 이 도구가 색상 변경에 따라 다시 칠해진 UI 요소를 강조하여 불필요한 다시 칠하기와 잠재적인 최적화 기회를 식별하는 데 도움이 되는 방법을 보여줍니다. 이 콘텐츠는 위젯 재구축을 효율적으로 관리하는 것의 중요성을 강조하고, 영향을 받지 않는 요소에 불필요한 재구축 트리거를 방지하기 위해 상태 관리를 별도의 위젯으로 분리하는 것과 같은 전략을 제안하여 궁극적으로 앱 성능을 개선합니다. 이 비디오는 Flutter에서 요소를 다시 칠하고 재생성하는 것의 차이점과 각 프로세스와 관련된 성능 고려 사항을 강조하는 동시에 애플리케이션 성능과 효율성을 향상시키기 위한 최적의 요소 처리의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "El video explora el concepto de la función de repintado de arcoíris en Flutter para visualizar elementos de pantalla que se vuelven a pintar con las interacciones del usuario. Demuestra cómo la herramienta resalta los elementos de la interfaz de usuario repintados en función de los cambios de color, lo que ayuda a identificar repintados innecesarios y posibles oportunidades de optimización. El contenido destaca la importancia de administrar de manera eficiente las reconstrucciones de widgets y sugiere estrategias como separar la administración de estados en widgets distintos para evitar activadores de reconstrucción innecesarios en elementos no afectados, lo que en última instancia mejora el rendimiento de la aplicación. El video enfatiza las distinciones entre repintar y recrear elementos en Flutter y las consideraciones de rendimiento asociadas con cada proceso, al tiempo que destaca la importancia del manejo óptimo de elementos para mejorar el rendimiento y la eficiencia de la aplicación.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर में रीपेंट रेनबो फ़ीचर की अवधारणा का पता लगाता है, जो उपयोगकर्ता इंटरैक्शन पर रीपेंट किए गए स्क्रीन तत्वों को विज़ुअलाइज़ करने के लिए है। यह दर्शाता है कि कैसे टूल रंग परिवर्तनों के आधार पर रीपेंट किए गए UI तत्वों को हाइलाइट करता है, अनावश्यक रीपेंट और संभावित अनुकूलन अवसरों की पहचान करने में सहायता करता है। सामग्री विजेट पुनर्निर्माण को कुशलतापूर्वक प्रबंधित करने के महत्व पर प्रकाश डालती है, अप्रभावित तत्वों पर अनावश्यक पुनर्निर्माण ट्रिगर्स को रोकने के लिए राज्य प्रबंधन को अलग-अलग विजेट में अलग करने जैसी रणनीतियों का सुझाव देती है, जिससे अंततः ऐप प्रदर्शन में सुधार होता है। वीडियो फ़्लटर में तत्वों को फिर से रंगने और फिर से बनाने के बीच के अंतर और प्रत्येक प्रक्रिया से जुड़े प्रदर्शन संबंधी विचारों पर जोर देता है, जबकि एप्लिकेशन प्रदर्शन और दक्षता को बढ़ाने के लिए इष्टतम तत्व हैंडलिंग के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "O vídeo explora o conceito da funcionalidade repintar arco-íris no Flutter para visualizar elementos do ecrã que são repintados de acordo com as interações do utilizador. Demonstra como a ferramenta destaca elementos da interface do utilizador repintados com base nas mudanças de cor, auxiliando na identificação de repinturas desnecessárias e possíveis oportunidades de otimização. O conteúdo destaca a importância de gerir eficientemente as recriações de widgets, sugerindo estratégias como separar a gestão de estado em widgets distintos para evitar gatilhos de recriação desnecessários em elementos não afetados, melhorando, em última análise, o desempenho da aplicação. O vídeo enfatiza as distinções entre repintar e recriar elementos no Flutter e as considerações de desempenho associadas a cada processo, ao mesmo tempo que enfatiza a importância do manuseamento ideal dos elementos para melhorar o desempenho e a eficiência da aplicação.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ব্যবহারকারীর ইন্টারঅ্যাকশনের উপর পুনরায় রং করা স্ক্রিন উপাদানগুলিকে ভিজ্যুয়ালাইজ করার জন্য ফ্লটারে পুনরায় রং করা রংধনু বৈশিষ্ট্যের ধারণাটি অন্বেষণ করে। এটি প্রদর্শন করে কিভাবে টুলটি রঙ পরিবর্তনের উপর ভিত্তি করে পুনরায় রং করা UI উপাদানগুলিকে হাইলাইট করে, অপ্রয়োজনীয় পুনরায় রং করা এবং সম্ভাব্য অপ্টিমাইজেশন সুযোগগুলি সনাক্ত করতে সহায়তা করে। বিষয়বস্তু উইজেট পুনর্নির্মাণের দক্ষতার সাথে পরিচালনার গুরুত্ব তুলে ধরে, অপ্রভাবিত উপাদানগুলিতে অপ্রয়োজনীয় পুনর্নির্মাণ ট্রিগার রোধ করতে, অবশেষে অ্যাপের কার্যকারিতা উন্নত করার জন্য রাষ্ট্র পরিচালনাকে পৃথক উইজেটে আলাদা করার মতো কৌশলগুলির পরামর্শ দেয়। ভিডিওটি ফ্লটারে উপাদানগুলি পুনরায় রং করা এবং পুনরায় তৈরি করার মধ্যে পার্থক্য এবং প্রতিটি প্রক্রিয়ার সাথে যুক্ত কর্মক্ষমতা বিবেচনার মধ্যে পার্থক্যের উপর জোর দেয়, পাশাপাশি অ্যাপ্লিকেশন কার্যক্ষমতা এবং দক্ষতা বাড়ানোর জন্য সর্বোত্তম উপাদান পরিচালনার তাত্পর্যের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يستكشف الفيديو مفهوم ميزة إعادة طلاء قوس قزح في Flutter لتصور عناصر الشاشة التي يتم إعادة طلائها عند تفاعل المستخدم. ويوضح كيف تسلط الأداة الضوء على عناصر واجهة المستخدم المعاد طلائها بناءً على تغييرات اللون، مما يساعد في تحديد عمليات إعادة الطلاء غير الضرورية وفرص التحسين المحتملة. ويسلط المحتوى الضوء على أهمية إدارة عمليات إعادة بناء الأدوات بكفاءة، واقتراح استراتيجيات مثل فصل إدارة الحالة إلى أدوات مميزة لمنع عمليات إعادة البناء غير الضرورية على العناصر غير المتأثرة، وتحسين أداء التطبيق في النهاية. ويؤكد الفيديو على التمييز بين إعادة طلاء العناصر وإعادة إنشائها في Flutter واعتبارات الأداء المرتبطة بكل عملية، مع التأكيد على أهمية التعامل الأمثل مع العناصر لتحسين أداء التطبيق وكفاءته.",
                                // Persian
                                "فارسی": "این ویدیو مفهوم ویژگی رنگین کمان را در Flutter برای تجسم عناصر صفحه نمایش که بر اساس تعاملات کاربر دوباره نقاشی می شوند را بررسی می کند. این نشان می دهد که چگونه این ابزار عناصر UI رنگ شده را بر اساس تغییرات رنگ برجسته می کند و به شناسایی رنگ های مجدد غیر ضروری و فرصت های بالقوه بهینه سازی کمک می کند. این محتوا اهمیت مدیریت کارآمد بازسازی ویجت‌ها را برجسته می‌کند و استراتژی‌هایی مانند تفکیک مدیریت حالت به ویجت‌های مجزا را برای جلوگیری از ایجاد مجدد غیرضروری در عناصر بی‌تأثیر پیشنهاد می‌کند و در نهایت عملکرد برنامه را بهبود می‌بخشد. این ویدیو بر تمایز بین رنگ‌آمیزی و بازسازی عناصر در فلاتر و ملاحظات عملکرد مرتبط با هر فرآیند تأکید می‌کند، در حالی که بر اهمیت مدیریت بهینه عناصر برای افزایش عملکرد و کارایی برنامه تأکید می‌کند.",
                            },
                        },
                    ]
                },
                // Section 4 : Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]
                {
                    "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                    "Videos": [
                        // 59 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Module Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor discusses moving beyond the core basics of Flutter and building more realistic apps by exploring additional widgets and features such as styling, theming, adding logic, and creating custom widgets. The instructor walks through the process of building a personal expenses tracker app, demonstrating how to add expenses, display transactions, and update spending charts dynamically. The video emphasizes the importance of working with Flutter documentation and provides extra materials for learning. Additionally, topics covered include theming with Material Design, adding images and custom fonts, and integrating business logic into app functionality. This comprehensive module aims to provide users with the knowledge and skills needed to create more advanced applications using Flutter.",
                                // German
                                "Deutsch": "Das Video untersucht das Konzept der Repaint-Rainbow-Funktion in Flutter zur Visualisierung von Bildschirmelementen, die bei Benutzerinteraktionen neu gezeichnet werden. Es zeigt, wie das Tool neu gezeichnete UI-Elemente anhand von Farbänderungen hervorhebt und so dabei hilft, unnötige Neuzeichnungen und potenzielle Optimierungsmöglichkeiten zu identifizieren. Der Inhalt hebt die Bedeutung einer effizienten Verwaltung von Widget-Neuerstellungen hervor und schlägt Strategien vor, wie die Trennung der Statusverwaltung in unterschiedliche Widgets, um unnötige Neuerstellungsauslöser für nicht betroffene Elemente zu verhindern und so letztendlich die App-Leistung zu verbessern. Das Video betont die Unterschiede zwischen dem Neuzeichnen und Neuerstellen von Elementen in Flutter und die mit jedem Prozess verbundenen Leistungsaspekte und betont gleichzeitig die Bedeutung einer optimalen Elementbehandlung zur Verbesserung der Anwendungsleistung und -effizienz.",
                                // Chinese
                                "中国人": "该视频探讨了 Flutter 中重绘彩虹功能的概念，该功能用于可视化在用户交互时重绘的屏幕元素。它演示了该工具如何根据颜色变化突出显示重绘的 UI 元素，帮助识别不必要的重绘和潜在的优化机会。内容强调了有效管理小部件重建的重要性，并提出了一些策略，例如将状态管理分离到不同的小部件中，以防止在未受影响的元素上触发不必要的重建，最终提高应用程序性能。该视频强调了 Flutter 中重绘和重新创建元素之间的区别以及与每个过程相关的性能考虑因素，同时强调了最佳元素处理对于提高应用程序性能和效率的重要性。",
                                // Russian
                                "Русский": "В видео рассматривается концепция функции перерисовки радуги во Flutter для визуализации элементов экрана, которые перерисовываются при взаимодействии с пользователем. В нем показано, как инструмент выделяет перерисованные элементы пользовательского интерфейса на основе изменений цвета, помогая выявлять ненужные перерисовки и потенциальные возможности оптимизации. В контенте подчеркивается важность эффективного управления перестройками виджетов, предлагаются такие стратегии, как разделение управления состоянием на отдельные виджеты для предотвращения ненужных триггеров перестройки на незатронутых элементах, что в конечном итоге повышает производительность приложения. В видео подчеркиваются различия между перерисовкой и воссозданием элементов во Flutter и соображения производительности, связанные с каждым процессом, при этом подчеркивается важность оптимальной обработки элементов для повышения производительности и эффективности приложения.",
                                // French
                                "Français": "La vidéo explore le concept de la fonction de repeinture arc-en-ciel dans Flutter pour visualiser les éléments d'écran qui sont repeints lors des interactions de l'utilisateur. Elle montre comment l'outil met en évidence les éléments d'interface utilisateur repeints en fonction des changements de couleur, ce qui permet d'identifier les repeintures inutiles et les opportunités d'optimisation potentielles. Le contenu souligne l'importance de gérer efficacement les reconstructions de widgets, en suggérant des stratégies telles que la séparation de la gestion d'état en widgets distincts pour éviter les déclencheurs de reconstruction inutiles sur les éléments non affectés, améliorant ainsi les performances de l'application. La vidéo met l'accent sur les distinctions entre repeindre et recréer des éléments dans Flutter et les considérations de performances associées à chaque processus, tout en soulignant l'importance d'une gestion optimale des éléments pour améliorer les performances et l'efficacité de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、ユーザー操作によって再描画される画面要素を視覚化する Flutter の再描画レインボー機能の概念について説明します。ツールが色の変化に基づいて再描画された UI 要素を強調表示し、不要な再描画と潜在的な最適化の機会を特定するのに役立つ方法を示します。コンテンツでは、ウィジェットの再構築を効率的に管理することの重要性を強調し、影響を受けていない要素で不要な再構築トリガーを防ぐため、状態管理を個別のウィジェットに分離するなどの戦略を提案し、最終的にアプリのパフォーマンスを向上させます。ビデオでは、Flutter での要素の再描画と再作成の違いと、各プロセスに関連するパフォーマンスの考慮事項を強調しながら、アプリケーションのパフォーマンスと効率を向上させるための最適な要素処理の重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오는 사용자 상호작용 시 다시 칠해지는 화면 요소를 시각화하기 위한 Flutter의 다시 칠하기 레인보우 기능 개념을 살펴봅니다. 이 도구가 색상 변경에 따라 다시 칠해진 UI 요소를 강조하여 불필요한 다시 칠하기와 잠재적인 최적화 기회를 식별하는 데 도움이 되는 방법을 보여줍니다. 이 콘텐츠는 위젯 재구축을 효율적으로 관리하는 것의 중요성을 강조하고, 영향을 받지 않는 요소에 불필요한 재구축 트리거를 방지하기 위해 상태 관리를 별도의 위젯으로 분리하는 것과 같은 전략을 제안하여 궁극적으로 앱 성능을 개선합니다. 이 비디오는 Flutter에서 요소를 다시 칠하고 재생성하는 것의 차이점과 각 프로세스와 관련된 성능 고려 사항을 강조하는 동시에 애플리케이션 성능과 효율성을 향상시키기 위한 최적의 요소 처리의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "El video explora el concepto de la función de repintado de arcoíris en Flutter para visualizar elementos de pantalla que se vuelven a pintar con las interacciones del usuario. Demuestra cómo la herramienta resalta los elementos de la interfaz de usuario repintados en función de los cambios de color, lo que ayuda a identificar repintados innecesarios y posibles oportunidades de optimización. El contenido destaca la importancia de administrar de manera eficiente las reconstrucciones de widgets y sugiere estrategias como separar la administración de estados en widgets distintos para evitar activadores de reconstrucción innecesarios en elementos no afectados, lo que en última instancia mejora el rendimiento de la aplicación. El video enfatiza las distinciones entre repintar y recrear elementos en Flutter y las consideraciones de rendimiento asociadas con cada proceso, al tiempo que destaca la importancia del manejo óptimo de elementos para mejorar el rendimiento y la eficiencia de la aplicación.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर में रीपेंट रेनबो फ़ीचर की अवधारणा का पता लगाता है, जो उपयोगकर्ता इंटरैक्शन पर रीपेंट किए गए स्क्रीन तत्वों को विज़ुअलाइज़ करने के लिए है। यह दर्शाता है कि कैसे टूल रंग परिवर्तनों के आधार पर रीपेंट किए गए UI तत्वों को हाइलाइट करता है, अनावश्यक रीपेंट और संभावित अनुकूलन अवसरों की पहचान करने में सहायता करता है। सामग्री विजेट पुनर्निर्माण को कुशलतापूर्वक प्रबंधित करने के महत्व पर प्रकाश डालती है, अप्रभावित तत्वों पर अनावश्यक पुनर्निर्माण ट्रिगर्स को रोकने के लिए राज्य प्रबंधन को अलग-अलग विजेट में अलग करने जैसी रणनीतियों का सुझाव देती है, जिससे अंततः ऐप प्रदर्शन में सुधार होता है। वीडियो फ़्लटर में तत्वों को फिर से रंगने और फिर से बनाने के बीच के अंतर और प्रत्येक प्रक्रिया से जुड़े प्रदर्शन संबंधी विचारों पर जोर देता है, जबकि एप्लिकेशन प्रदर्शन और दक्षता को बढ़ाने के लिए इष्टतम तत्व हैंडलिंग के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "O vídeo explora o conceito da funcionalidade repintar arco-íris no Flutter para visualizar elementos do ecrã que são repintados de acordo com as interações do utilizador. Demonstra como a ferramenta destaca elementos da interface do utilizador repintados com base nas mudanças de cor, auxiliando na identificação de repinturas desnecessárias e possíveis oportunidades de otimização. O conteúdo destaca a importância de gerir eficientemente as recriações de widgets, sugerindo estratégias como separar a gestão de estado em widgets distintos para evitar gatilhos de recriação desnecessários em elementos não afetados, melhorando, em última análise, o desempenho da aplicação. O vídeo enfatiza as distinções entre repintar e recriar elementos no Flutter e as considerações de desempenho associadas a cada processo, ao mesmo tempo que enfatiza a importância do manuseamento ideal dos elementos para melhorar o desempenho e a eficiência da aplicação.",
                                // Bengali
                                "বাংলা": "ভিডিওটি ব্যবহারকারীর ইন্টারঅ্যাকশনের উপর পুনরায় রং করা স্ক্রিন উপাদানগুলিকে ভিজ্যুয়ালাইজ করার জন্য ফ্লটারে পুনরায় রং করা রংধনু বৈশিষ্ট্যের ধারণাটি অন্বেষণ করে। এটি প্রদর্শন করে কিভাবে টুলটি রঙ পরিবর্তনের উপর ভিত্তি করে পুনরায় রং করা UI উপাদানগুলিকে হাইলাইট করে, অপ্রয়োজনীয় পুনরায় রং করা এবং সম্ভাব্য অপ্টিমাইজেশন সুযোগগুলি সনাক্ত করতে সহায়তা করে। বিষয়বস্তু উইজেট পুনর্নির্মাণের দক্ষতার সাথে পরিচালনার গুরুত্ব তুলে ধরে, অপ্রভাবিত উপাদানগুলিতে অপ্রয়োজনীয় পুনর্নির্মাণ ট্রিগার রোধ করতে, অবশেষে অ্যাপের কার্যকারিতা উন্নত করার জন্য রাষ্ট্র পরিচালনাকে পৃথক উইজেটে আলাদা করার মতো কৌশলগুলির পরামর্শ দেয়। ভিডিওটি ফ্লটারে উপাদানগুলি পুনরায় রং করা এবং পুনরায় তৈরি করার মধ্যে পার্থক্য এবং প্রতিটি প্রক্রিয়ার সাথে যুক্ত কর্মক্ষমতা বিবেচনার মধ্যে পার্থক্যের উপর জোর দেয়, পাশাপাশি অ্যাপ্লিকেশন কার্যক্ষমতা এবং দক্ষতা বাড়ানোর জন্য সর্বোত্তম উপাদান পরিচালনার তাত্পর্যের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يستكشف الفيديو مفهوم ميزة إعادة طلاء قوس قزح في Flutter لتصور عناصر الشاشة التي يتم إعادة طلائها عند تفاعل المستخدم. ويوضح كيف تسلط الأداة الضوء على عناصر واجهة المستخدم المعاد طلائها بناءً على تغييرات اللون، مما يساعد في تحديد عمليات إعادة الطلاء غير الضرورية وفرص التحسين المحتملة. ويسلط المحتوى الضوء على أهمية إدارة عمليات إعادة بناء الأدوات بكفاءة، واقتراح استراتيجيات مثل فصل إدارة الحالة إلى أدوات مميزة لمنع عمليات إعادة البناء غير الضرورية على العناصر غير المتأثرة، وتحسين أداء التطبيق في النهاية. ويؤكد الفيديو على التمييز بين إعادة طلاء العناصر وإعادة إنشائها في Flutter واعتبارات الأداء المرتبطة بكل عملية، مع التأكيد على أهمية التعامل الأمثل مع العناصر لتحسين أداء التطبيق وكفاءته.",
                                // Persian
                                "فارسی": "این ویدیو مفهوم ویژگی رنگین کمان را در Flutter برای تجسم عناصر صفحه نمایش که بر اساس تعاملات کاربر دوباره نقاشی می شوند را بررسی می کند. این نشان می دهد که چگونه این ابزار عناصر UI رنگ شده را بر اساس تغییرات رنگ برجسته می کند و به شناسایی رنگ های مجدد غیر ضروری و فرصت های بالقوه بهینه سازی کمک می کند. این محتوا اهمیت مدیریت کارآمد بازسازی ویجت‌ها را برجسته می‌کند و استراتژی‌هایی مانند تفکیک مدیریت حالت به ویجت‌های مجزا را برای جلوگیری از ایجاد مجدد غیرضروری در عناصر بی‌تأثیر پیشنهاد می‌کند و در نهایت عملکرد برنامه را بهبود می‌بخشد. این ویدیو بر تمایز بین رنگ‌آمیزی و بازسازی عناصر در فلاتر و ملاحظات عملکرد مرتبط با هر فرآیند تأکید می‌کند، در حالی که بر اهمیت مدیریت بهینه عناصر برای افزایش عملکرد و کارایی برنامه تأکید می‌کند.",
                            },
                        },
                        // 60 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "An Overview of the Core Flutter Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor emphasizes the importance of exploring the Flutter widget catalog to understand and utilize the wide range of built-in widgets available. The instructor discusses various key widgets such as MaterialApp, CupertinoApp, container, row, column, ListView, and others that are essential for laying out and structuring app content. The video provides an overview of different types of widgets for different purposes, including content containers, layout widgets, user input widgets, and widgets for presenting text, images, and icons. The instructor highlights the flexibility of Flutter in allowing users to create custom widgets in addition to utilizing the built-in ones, and encourages viewers to experiment with different widgets to determine which ones best suit their app development needs. Throughout the video, practical examples and usage scenarios of these widgets are provided to help viewers understand their functionalities better.",
                                // German
                                "Deutsch": "In diesem Video betont der Kursleiter, wie wichtig es ist, den Flutter-Widget-Katalog zu erkunden, um die große Bandbreite der verfügbaren integrierten Widgets zu verstehen und zu nutzen. Der Kursleiter bespricht verschiedene wichtige Widgets wie MaterialApp, CupertinoApp, Container, Zeile, Spalte, ListView und andere, die für das Layout und die Strukturierung von App-Inhalten wichtig sind. Das Video bietet einen Überblick über verschiedene Arten von Widgets für unterschiedliche Zwecke, darunter Inhaltscontainer, Layout-Widgets, Benutzereingabe-Widgets und Widgets zur Darstellung von Text, Bildern und Symbolen. Der Kursleiter hebt die Flexibilität von Flutter hervor, die es Benutzern ermöglicht, neben der Nutzung der integrierten Widgets auch benutzerdefinierte Widgets zu erstellen, und ermutigt die Zuschauer, mit verschiedenen Widgets zu experimentieren, um herauszufinden, welche ihren App-Entwicklungsanforderungen am besten entsprechen. Im gesamten Video werden praktische Beispiele und Nutzungsszenarien dieser Widgets bereitgestellt, damit die Zuschauer ihre Funktionen besser verstehen.",
                                // Chinese
                                "中国人": "在本视频中，讲师强调了探索 Flutter 小部件目录以了解和利用各种可用的内置小部件的重要性。讲师讨论了各种关键小部件，例如 MaterialApp、CupertinoApp、容器、行、列、ListView 以及其他对于布局和构建应用内容至关重要的小部件。视频概述了用于不同目的的不同类型小部件，包括内容容器、布局小部件、用户输入小部件以及用于呈现文本、图像和图标的小部件。讲师强调了 Flutter 的灵活性，它允许用户除了使用内置小部件之外还创建自定义小部件，并鼓励观众尝试使用不同的小部件来确定哪些小部件最适合他们的应用开发需求。在整个视频中，提供了这些小部件的实际示例和使用场景，以帮助观众更好地了解它们的功能。",
                                // Russian
                                "Русский": "В этом видео инструктор подчеркивает важность изучения каталога виджетов Flutter для понимания и использования широкого спектра доступных встроенных виджетов. Инструктор обсуждает различные ключевые виджеты, такие как MaterialApp, CupertinoApp, контейнер, строка, столбец, ListView и другие, которые необходимы для компоновки и структурирования содержимого приложения. Видео дает обзор различных типов виджетов для различных целей, включая контейнеры контента, виджеты макета, виджеты пользовательского ввода и виджеты для представления текста, изображений и значков. Инструктор подчеркивает гибкость Flutter, позволяющую пользователям создавать собственные виджеты в дополнение к использованию встроенных, и призывает зрителей экспериментировать с различными виджетами, чтобы определить, какие из них лучше всего подходят для разработки их приложений. На протяжении всего видео приводятся практические примеры и сценарии использования этих виджетов, чтобы помочь зрителям лучше понять их функциональные возможности.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur souligne l'importance d'explorer le catalogue de widgets Flutter pour comprendre et utiliser la large gamme de widgets intégrés disponibles. L'instructeur aborde divers widgets clés tels que MaterialApp, CupertinoApp, container, row, column, ListView et d'autres qui sont essentiels pour la mise en page et la structuration du contenu des applications. La vidéo donne un aperçu des différents types de widgets à des fins différentes, notamment les conteneurs de contenu, les widgets de mise en page, les widgets de saisie utilisateur et les widgets de présentation de texte, d'images et d'icônes. L'instructeur souligne la flexibilité de Flutter qui permet aux utilisateurs de créer des widgets personnalisés en plus d'utiliser ceux intégrés, et encourage les spectateurs à expérimenter différents widgets pour déterminer ceux qui conviennent le mieux à leurs besoins de développement d'applications. Tout au long de la vidéo, des exemples pratiques et des scénarios d'utilisation de ces widgets sont fournis pour aider les spectateurs à mieux comprendre leurs fonctionnalités.",
                                // Japanese
                                "日本語": "このビデオでは、インストラクターは、Flutter ウィジェット カタログを調べて、利用可能なさまざまな組み込みウィジェットを理解して活用することの重要性を強調しています。インストラクターは、MaterialApp、CupertinoApp、コンテナー、行、列、ListView など、アプリ コンテンツのレイアウトと構造化に不可欠なさまざまな主要なウィジェットについて説明します。ビデオでは、コンテンツ コンテナー、レイアウト ウィジェット、ユーザー入力ウィジェット、テキスト、画像、アイコンを表示するためのウィジェットなど、さまざまな目的のさまざまな種類のウィジェットの概要を示します。インストラクターは、組み込みウィジェットの利用に加えて、ユーザーがカスタム ウィジェットを作成できる Flutter の柔軟性を強調し、視聴者がさまざまなウィジェットを試して、アプリ開発のニーズに最適なものを判断することを推奨しています。ビデオ全体を通して、これらのウィジェットの実用的な例と使用シナリオが提供され、視聴者が機能を理解できるようになります。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 다양한 기본 제공 위젯을 이해하고 활용하기 위해 Flutter 위젯 카탈로그를 탐색하는 것의 중요성을 강조합니다. 강사는 앱 콘텐츠를 레이아웃하고 구성하는 데 필수적인 MaterialApp, CupertinoApp, 컨테이너, 행, 열, ListView 등과 같은 다양한 주요 위젯에 대해 설명합니다. 이 비디오는 콘텐츠 컨테이너, 레이아웃 위젯, 사용자 입력 위젯, 텍스트, 이미지, 아이콘을 표시하는 위젯을 포함하여 다양한 목적을 위한 다양한 유형의 위젯에 대한 개요를 제공합니다. 강사는 기본 제공 위젯을 활용하는 것 외에도 사용자가 사용자 정의 위젯을 만들 수 있도록 하는 Flutter의 유연성을 강조하고 시청자가 앱 개발 요구 사항에 가장 적합한 위젯을 결정하기 위해 다양한 위젯을 실험하도록 권장합니다. 비디오 전체에서 이러한 위젯의 실제 예와 사용 시나리오를 제공하여 시청자가 기능을 더 잘 이해하도록 돕습니다.",
                                // Spanish
                                "Español": "En este video, el instructor enfatiza la importancia de explorar el catálogo de widgets de Flutter para comprender y utilizar la amplia gama de widgets integrados disponibles. El instructor analiza varios widgets clave, como MaterialApp, CupertinoApp, contenedor, fila, columna, ListView y otros que son esenciales para diseñar y estructurar el contenido de la aplicación. El video proporciona una descripción general de los diferentes tipos de widgets para diferentes propósitos, incluidos los contenedores de contenido, los widgets de diseño, los widgets de entrada del usuario y los widgets para presentar texto, imágenes e íconos. El instructor destaca la flexibilidad de Flutter al permitir a los usuarios crear widgets personalizados además de utilizar los integrados, y alienta a los espectadores a experimentar con diferentes widgets para determinar cuáles se adaptan mejor a sus necesidades de desarrollo de aplicaciones. A lo largo del video, se proporcionan ejemplos prácticos y escenarios de uso de estos widgets para ayudar a los espectadores a comprender mejor sus funcionalidades.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक उपलब्ध बिल्ट-इन विजेट की विस्तृत श्रृंखला को समझने और उसका उपयोग करने के लिए फ़्लटर विजेट कैटलॉग की खोज करने के महत्व पर ज़ोर देता है। प्रशिक्षक विभिन्न प्रमुख विजेट जैसे कि मटेरियलऐप, क्यूपर्टिनोऐप, कंटेनर, रो, कॉलम, लिस्ट व्यू और अन्य पर चर्चा करता है जो ऐप सामग्री को लेआउट और संरचना करने के लिए आवश्यक हैं। वीडियो विभिन्न उद्देश्यों के लिए विभिन्न प्रकार के विजेट का अवलोकन प्रदान करता है, जिसमें सामग्री कंटेनर, लेआउट विजेट, उपयोगकर्ता इनपुट विजेट और टेक्स्ट, चित्र और आइकन प्रस्तुत करने के लिए विजेट शामिल हैं। प्रशिक्षक उपयोगकर्ताओं को बिल्ट-इन का उपयोग करने के अलावा कस्टम विजेट बनाने की अनुमति देने में फ़्लटर की लचीलेपन पर प्रकाश डालता है, और दर्शकों को विभिन्न विजेट के साथ प्रयोग करने के लिए प्रोत्साहित करता है ताकि यह निर्धारित किया जा सके कि कौन सा विजेट उनकी ऐप विकास आवश्यकताओं के लिए सबसे उपयुक्त है। पूरे वीडियो में, दर्शकों को उनकी कार्यक्षमताओं को बेहतर ढंग से समझने में मदद करने के लिए इन विजेट के व्यावहारिक उदाहरण और उपयोग परिदृश्य प्रदान किए गए हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor sublinha a importância de explorar o catálogo de widgets Flutter para compreender e utilizar a grande variedade de widgets integrados disponíveis. O instrutor discute vários widgets importantes, como MaterialApp, CupertinoApp, contentor, linha, coluna, ListView e outros que são essenciais para definir e estruturar o conteúdo da aplicação. O vídeo fornece uma visão geral de diferentes tipos de widgets para diferentes finalidades, incluindo contentores de conteúdo, widgets de layout, widgets de entrada do utilizador e widgets para apresentação de texto, imagens e ícones. O instrutor destaca a flexibilidade do Flutter ao permitir que os utilizadores criem widgets personalizados, além de utilizar os integrados, e incentiva os espectadores a experimentar diferentes widgets para determinar quais deles melhor se adequam às suas necessidades de desenvolvimento de aplicações. Ao longo do vídeo, são fornecidos exemplos práticos e cenários de utilização destes widgets para ajudar os espectadores a compreender melhor as suas funcionalidades.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক ফ্লটার উইজেট ক্যাটালগ অন্বেষণের গুরুত্বের উপর জোর দিয়েছেন যাতে উপলব্ধ বিল্ট-ইন উইজেটগুলির বিস্তৃত পরিসর বোঝার এবং ব্যবহার করা যায়। প্রশিক্ষক বিভিন্ন মূল উইজেট নিয়ে আলোচনা করেন যেমন MaterialApp, CupertinoApp, কন্টেইনার, সারি, কলাম, ListView এবং অন্যান্য যা অ্যাপের বিষয়বস্তু সাজানো এবং গঠনের জন্য অপরিহার্য। ভিডিওটি বিভিন্ন উদ্দেশ্যে বিভিন্ন ধরনের উইজেটগুলির একটি ওভারভিউ প্রদান করে, যার মধ্যে বিষয়বস্তু কন্টেনার, লেআউট উইজেট, ব্যবহারকারীর ইনপুট উইজেট এবং পাঠ্য, ছবি এবং আইকন উপস্থাপনের জন্য উইজেট রয়েছে। প্রশিক্ষক বিল্ট-ইন ব্যবহার করার পাশাপাশি ব্যবহারকারীদের কাস্টম উইজেট তৈরি করার অনুমতি দেওয়ার ক্ষেত্রে ফ্লটারের নমনীয়তা তুলে ধরেন এবং দর্শকদের তাদের অ্যাপ বিকাশের প্রয়োজনে কোনটি সবচেয়ে উপযুক্ত তা নির্ধারণ করতে বিভিন্ন উইজেট নিয়ে পরীক্ষা করতে উত্সাহিত করেন। ভিডিও জুড়ে, এই উইজেটগুলির ব্যবহারিক উদাহরণ এবং ব্যবহারের পরিস্থিতি দর্শকদের তাদের কার্যকারিতাগুলি আরও ভালভাবে বুঝতে সহায়তা করার জন্য প্রদান করা হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يؤكد المدرب على أهمية استكشاف كتالوج عناصر واجهة المستخدم الرسومية Flutter لفهم واستخدام مجموعة واسعة من عناصر واجهة المستخدم الرسومية المضمنة المتاحة. يناقش المدرب عناصر واجهة المستخدم الرسومية الرئيسية المختلفة مثل MaterialApp وCupertinoApp وcontainer وrow وcolumn وListView وغيرها والتي تعد ضرورية لتخطيط وهيكلة محتوى التطبيق. يوفر الفيديو نظرة عامة على أنواع مختلفة من عناصر واجهة المستخدم الرسومية لأغراض مختلفة، بما في ذلك حاويات المحتوى وعناصر واجهة المستخدم الرسومية للتخطيط وعناصر واجهة المستخدم الرسومية لإدخال المستخدم وعناصر واجهة المستخدم الرسومية لعرض النصوص والصور والأيقونات. يسلط المدرب الضوء على مرونة Flutter في السماح للمستخدمين بإنشاء عناصر واجهة مستخدم مخصصة بالإضافة إلى استخدام العناصر المضمنة، ويشجع المشاهدين على تجربة عناصر واجهة مستخدم مختلفة لتحديد أي منها يناسب احتياجات تطوير التطبيقات الخاصة بهم بشكل أفضل. طوال الفيديو، يتم تقديم أمثلة عملية وسيناريوهات استخدام لهذه العناصر الرسومية لمساعدة المشاهدين على فهم وظائفها بشكل أفضل.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس بر اهمیت کاوش در کاتالوگ ویجت فلاتر برای درک و استفاده از طیف گسترده ای از ویجت های داخلی موجود تاکید می کند. مدرس ویجت‌های کلیدی مختلفی مانند MaterialApp، CupertinoApp، ظرف، ردیف، ستون، ListView و موارد دیگر را که برای چیدمان و ساختار محتوای برنامه ضروری هستند، مورد بحث قرار می‌دهد. این ویدئو مروری بر انواع مختلف ویجت‌ها برای اهداف مختلف، از جمله محفظه‌های محتوا، ویجت‌های طرح‌بندی، ویجت‌های ورودی کاربر و ویجت‌هایی برای ارائه متن، تصاویر و نمادها ارائه می‌کند. مدرس انعطاف پذیری Flutter را در اجازه دادن به کاربران برای ایجاد ویجت های سفارشی علاوه بر استفاده از ویجت های داخلی برجسته می کند و بینندگان را تشویق می کند تا با ویجت های مختلف آزمایش کنند تا تعیین کنند کدام یک به بهترین وجه با نیازهای توسعه برنامه آنها مطابقت دارند. در سراسر ویدیو، مثال‌های عملی و سناریوهای استفاده از این ابزارک‌ها ارائه شده است تا به بینندگان کمک کند تا عملکردهای آنها را بهتر درک کنند.",
                            },
                        },
                        // 61 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Planning the App",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor introduces the application that will be built in the module, which is an expense planner. The app will allow users to add expenses such as purchases of items like milk or shoes, keep track of these expenses in a list, and display a chart summarizing spending over the last week. The instructor provides a visual representation of the app layout on an iPhone or Android phone, including a chart for spending, a list of transactions, plus buttons for adding new items, and a floating action button for triggering a new mode on the existing page. The video hints at using advanced Flutter widgets and theming features to enhance the app's appearance and functionality.",
                                // German
                                "Deutsch": "In diesem Video stellt der Kursleiter die Anwendung vor, die in das Modul integriert wird, nämlich einen Ausgabenplaner. Mit der App können Benutzer Ausgaben wie den Kauf von Artikeln wie Milch oder Schuhen hinzufügen, diese Ausgaben in einer Liste verfolgen und ein Diagramm mit einer Zusammenfassung der Ausgaben der letzten Woche anzeigen. Der Kursleiter bietet eine visuelle Darstellung des App-Layouts auf einem iPhone oder Android-Telefon, einschließlich eines Diagramms für Ausgaben, einer Liste von Transaktionen sowie Schaltflächen zum Hinzufügen neuer Artikel und einer schwebenden Aktionsschaltfläche zum Auslösen eines neuen Modus auf der vorhandenen Seite. Das Video gibt Hinweise zur Verwendung erweiterter Flutter-Widgets und Designfunktionen, um das Erscheinungsbild und die Funktionalität der App zu verbessern.",
                                // Chinese
                                "中国人": "在本视频中，讲师介绍了将在模块中构建的应用程序，即费用规划器。该应用程序将允许用户添加费用，例如购买牛奶或鞋子等物品，在列表中跟踪这些费用，并显示总结过去一周支出的图表。讲师在 iPhone 或 Android 手机上提供了应用程序布局的视觉表示，包括支出图表、交易列表，以及用于添加新项目的按钮，以及用于在现有页面上触发新模式的浮动操作按钮。视频暗示了使用高级 Flutter 小部件和主题功能来增强应用程序的外观和功能。",
                                // Russian
                                "Русский": "В этом видео инструктор представляет приложение, которое будет встроено в модуль, а именно планировщик расходов. Приложение позволит пользователям добавлять расходы, такие как покупка таких товаров, как молоко или обувь, отслеживать эти расходы в списке и отображать диаграмму, суммирующую расходы за последнюю неделю. Инструктор наглядно демонстрирует макет приложения на iPhone или телефоне Android, включая диаграмму расходов, список транзакций, а также кнопки для добавления новых элементов и плавающую кнопку действия для запуска нового режима на существующей странице. Видео намекает на использование расширенных виджетов Flutter и функций тем для улучшения внешнего вида и функциональности приложения.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur présente l'application qui sera intégrée au module, qui est un planificateur de dépenses. L'application permettra aux utilisateurs d'ajouter des dépenses telles que des achats d'articles comme du lait ou des chaussures, de suivre ces dépenses dans une liste et d'afficher un graphique résumant les dépenses de la semaine dernière. L'instructeur fournit une représentation visuelle de la présentation de l'application sur un iPhone ou un téléphone Android, y compris un graphique des dépenses, une liste des transactions, ainsi que des boutons pour ajouter de nouveaux articles et un bouton d'action flottant pour déclencher un nouveau mode sur la page existante. La vidéo fait allusion à l'utilisation de widgets Flutter avancés et de fonctionnalités de thème pour améliorer l'apparence et la fonctionnalité de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、講師がモジュールで構築されるアプリケーション、つまり経費プランナーを紹介します。このアプリを使用すると、ユーザーは牛乳や靴などのアイテムの購入などの経費を追加し、これらの経費をリストで追跡し、過去 1 週間の支出をまとめたグラフを表示できます。講師は、支出のグラフ、取引のリスト、新しいアイテムを追加するためのボタン、既存のページで新しいモードをトリガーするためのフローティング アクション ボタンなど、iPhone または Android フォンでのアプリ レイアウトの視覚的な表現を提供します。このビデオでは、高度な Flutter ウィジェットとテーマ設定機能を使用してアプリの外観と機能を強化する方法について説明しています。",
                                // Korean
                                "한국인": "이 영상에서 강사는 모듈에 내장될 비용 플래너인 애플리케이션을 소개합니다. 이 앱을 사용하면 사용자가 우유나 신발과 같은 품목의 구매와 같은 비용을 추가하고, 목록에서 이러한 비용을 추적하고, 지난주 지출을 요약한 차트를 표시할 수 있습니다. 강사는 지출 차트, 거래 목록, 새 항목을 추가하는 버튼, 기존 페이지에서 새 모드를 트리거하는 플로팅 작업 버튼을 포함하여 iPhone 또는 Android 휴대폰에서 앱 레이아웃의 시각적 표현을 제공합니다. 이 영상은 고급 Flutter 위젯과 테마 기능을 사용하여 앱의 모양과 기능을 향상시키는 방법을 암시합니다.",
                                // Spanish
                                "Español": "En este video, el instructor presenta la aplicación que se creará en el módulo, que es un planificador de gastos. La aplicación permitirá a los usuarios agregar gastos, como compras de artículos como leche o zapatos, realizar un seguimiento de estos gastos en una lista y mostrar un gráfico que resume los gastos de la última semana. El instructor proporciona una representación visual del diseño de la aplicación en un teléfono iPhone o Android, que incluye un gráfico de gastos, una lista de transacciones, además de botones para agregar nuevos artículos y un botón de acción flotante para activar un nuevo modo en la página existente. El video sugiere cómo usar widgets avanzados de Flutter y funciones de temas para mejorar la apariencia y la funcionalidad de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक उस एप्लिकेशन का परिचय देता है जिसे मॉड्यूल में बनाया जाएगा, जो एक व्यय योजनाकार है। ऐप उपयोगकर्ताओं को दूध या जूते जैसी वस्तुओं की खरीद जैसे खर्चों को जोड़ने, सूची में इन खर्चों पर नज़र रखने और पिछले सप्ताह के खर्चों का सारांश दिखाने वाला चार्ट प्रदर्शित करने की अनुमति देगा। प्रशिक्षक iPhone या Android फ़ोन पर ऐप लेआउट का एक विज़ुअल प्रतिनिधित्व प्रदान करता है, जिसमें खर्च के लिए एक चार्ट, लेन-देन की एक सूची, साथ ही नए आइटम जोड़ने के लिए बटन और मौजूदा पृष्ठ पर एक नया मोड ट्रिगर करने के लिए एक फ़्लोटिंग एक्शन बटन शामिल है। वीडियो ऐप की उपस्थिति और कार्यक्षमता को बढ़ाने के लिए उन्नत फ़्लटर विजेट और थीमिंग सुविधाओं का उपयोग करने का संकेत देता है।",
                                // Portuguese
                                "Português": "Neste vídeo o instrutor apresenta a aplicação que será construída no módulo, que é um planeador de despesas. A aplicação permitirá aos utilizadores adicionar despesas como compras de artigos como leite ou sapatos, acompanhar essas despesas numa lista e exibir um gráfico que resume os gastos da última semana. O instrutor fornece uma representação visual do layout da aplicação num telefone iPhone ou Android, incluindo um gráfico de despesas, uma lista de transações, bem como botões para adicionar novos itens e um botão de ação flutuante para acionar um novo modo na página existente. O vídeo sugere a utilização de widgets avançados do Flutter e recursos de tema para melhorar a aparência e a funcionalidade da aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক সেই অ্যাপ্লিকেশনটির সাথে পরিচয় করিয়ে দিয়েছেন যা মডিউলে তৈরি করা হবে, যা একটি ব্যয় পরিকল্পনাকারী। অ্যাপটি ব্যবহারকারীদের দুধ বা জুতার মতো আইটেম কেনার মতো খরচ যোগ করতে, একটি তালিকায় এই খরচগুলির ট্র্যাক রাখতে এবং গত সপ্তাহে খরচের সংক্ষিপ্ত বিবরণী প্রদর্শন করার অনুমতি দেবে। প্রশিক্ষক একটি আইফোন বা অ্যান্ড্রয়েড ফোনে অ্যাপ লেআউটের একটি ভিজ্যুয়াল উপস্থাপনা প্রদান করে, যার মধ্যে খরচের জন্য একটি চার্ট, লেনদেনের একটি তালিকা, নতুন আইটেম যোগ করার জন্য বোতাম এবং বিদ্যমান পৃষ্ঠায় একটি নতুন মোড ট্রিগার করার জন্য একটি ফ্লোটিং অ্যাকশন বোতাম সহ। ভিডিওটি অ্যাপের চেহারা এবং কার্যকারিতা উন্নত করতে উন্নত ফ্লাটার উইজেট এবং থিমিং বৈশিষ্ট্যগুলি ব্যবহার করার ইঙ্গিত দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يقدم المدرب التطبيق الذي سيتم بناؤه في الوحدة، وهو مخطط للنفقات. سيسمح التطبيق للمستخدمين بإضافة نفقات مثل مشتريات سلع مثل الحليب أو الأحذية، وتتبع هذه النفقات في قائمة، وعرض مخطط يلخص الإنفاق على مدار الأسبوع الماضي. يقدم المدرب تمثيلًا مرئيًا لتخطيط التطبيق على هاتف iPhone أو Android، بما في ذلك مخطط للإنفاق، وقائمة بالمعاملات، بالإضافة إلى أزرار لإضافة عناصر جديدة، وزر إجراء عائم لتشغيل وضع جديد على الصفحة الحالية. يشير الفيديو إلى استخدام أدوات Flutter المتقدمة وميزات التصميم لتحسين مظهر التطبيق ووظائفه.",
                                // Persian
                                "فارسی": "در این ویدیو مدرس اپلیکیشنی که در ماژول ساخته می شود را معرفی می کند که برنامه ریز هزینه است. این برنامه به کاربران اجازه می‌دهد هزینه‌هایی مانند خرید اقلامی مانند شیر یا کفش را اضافه کنند، این هزینه‌ها را در فهرستی پیگیری کنند و نموداری را نشان دهند که هزینه‌های هفته گذشته را خلاصه می‌کند. مربی یک نمایش بصری از طرح‌بندی برنامه در گوشی آیفون یا اندروید ارائه می‌کند، از جمله نموداری برای هزینه‌ها، فهرستی از تراکنش‌ها، به‌علاوه دکمه‌هایی برای افزودن موارد جدید، و یک دکمه عمل شناور برای راه‌اندازی حالت جدید در صفحه موجود. این ویدئو به استفاده از ویجت‌های پیشرفته Flutter و ویژگی‌های موضوعی برای بهبود ظاهر و عملکرد برنامه اشاره می‌کند.",
                            },
                        },
                        // 62 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Combining Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor begins by setting up a basic Flutter project, cleaning up the homepage widget and preparing to build an application. The goal is to create an application with a chart and a list of transactions, starting with a column widget to contain these elements and using a card widget for styling. Different strategies are discussed for controlling the size and appearance of widgets, such as setting container widths and utilizing the parent-child relationship to adjust layout and styling. The instructor emphasizes the importance of experimenting and trying out different widget combinations to understand how they behave and achieve desired results in Flutter applications, highlighting that there are multiple ways to accomplish the same outcome. By actively exploring and testing widget interactions, users can gain a deeper understanding of Flutter's capabilities and effectively customize their app layouts.",
                                // German
                                "Deutsch": "In diesem Video beginnt der Kursleiter mit der Einrichtung eines einfachen Flutter-Projekts, bereinigt das Homepage-Widget und bereitet die Erstellung einer Anwendung vor. Ziel ist die Erstellung einer Anwendung mit einem Diagramm und einer Liste von Transaktionen, beginnend mit einem Spalten-Widget, das diese Elemente enthält, und mit einem Karten-Widget für die Gestaltung. Es werden verschiedene Strategien zur Steuerung der Größe und des Erscheinungsbilds von Widgets besprochen, z. B. das Festlegen der Containerbreite und die Nutzung der Eltern-Kind-Beziehung zum Anpassen von Layout und Gestaltung. Der Kursleiter betont, wie wichtig es ist, zu experimentieren und verschiedene Widget-Kombinationen auszuprobieren, um zu verstehen, wie sie sich in Flutter-Anwendungen verhalten und die gewünschten Ergebnisse erzielen, und hebt hervor, dass es mehrere Möglichkeiten gibt, dasselbe Ergebnis zu erzielen. Durch aktives Erkunden und Testen von Widget-Interaktionen können Benutzer ein tieferes Verständnis der Funktionen von Flutter erlangen und ihre App-Layouts effektiv anpassen.",
                                // Chinese
                                "中国人": "在本视频中，讲师首先设置一个基本的 Flutter 项目，清理主页小部件并准备构建应用程序。目标是创建一个包含图表和交易列表的应用程序，首先使用列小部件来包含这些元素，然后使用卡片小部件进行样式设置。讨论了控制小部件大小和外观的不同策略，例如设置容器宽度和利用父子关系来调整布局和样式。讲师强调了试验和尝试不同小部件组合的重要性，以了解它们在 Flutter 应用程序中的行为方式并实现预期结果，并强调有多种方法可以实现相同的结果。通过积极探索和测试小部件交互，用户可以更深入地了解 Flutter 的功能并有效地自定义其应用布局。",
                                // Russian
                                "Русский": "В этом видео инструктор начинает с настройки базового проекта Flutter, очистки виджета домашней страницы и подготовки к созданию приложения. Цель состоит в том, чтобы создать приложение с диаграммой и списком транзакций, начиная с виджета столбца, чтобы содержать эти элементы, и используя виджет карточки для стилизации. Обсуждаются различные стратегии для управления размером и внешним видом виджетов, такие как настройка ширины контейнера и использование родительско-дочерних отношений для настройки макета и стиля. Инструктор подчеркивает важность экспериментов и опробования различных комбинаций виджетов, чтобы понять, как они ведут себя, и достичь желаемых результатов в приложениях Flutter, подчеркивая, что существует несколько способов достижения того же результата. Активно исследуя и тестируя взаимодействия виджетов, пользователи могут глубже понять возможности Flutter и эффективно настраивать макеты своих приложений.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur commence par configurer un projet Flutter de base, nettoyer le widget de la page d'accueil et se préparer à créer une application. L'objectif est de créer une application avec un graphique et une liste de transactions, en commençant par un widget de colonne pour contenir ces éléments et en utilisant un widget de carte pour le style. Différentes stratégies sont abordées pour contrôler la taille et l'apparence des widgets, telles que la définition des largeurs de conteneur et l'utilisation de la relation parent-enfant pour ajuster la mise en page et le style. L'instructeur souligne l'importance d'expérimenter et d'essayer différentes combinaisons de widgets pour comprendre comment ils se comportent et obtenir les résultats souhaités dans les applications Flutter, soulignant qu'il existe plusieurs façons d'obtenir le même résultat. En explorant et en testant activement les interactions des widgets, les utilisateurs peuvent acquérir une compréhension plus approfondie des capacités de Flutter et personnaliser efficacement la mise en page de leurs applications.",
                                // Japanese
                                "日本語": "このビデオでは、講師がまず基本的な Flutter プロジェクトを設定し、ホームページ ウィジェットをクリーンアップして、アプリケーションを構築する準備をします。目標は、チャートとトランザクション リストを含むアプリケーションを作成することです。まず、これらの要素を含む列ウィジェットから始め、カード ウィジェットを使用してスタイルを設定します。コンテナの幅の設定や親子関係を利用したレイアウトとスタイルの調整など、ウィジェットのサイズと外観を制御するためのさまざまな戦略について説明します。講師は、Flutter アプリケーションでウィジェットがどのように動作し、望ましい結果を達成するかを理解するために、さまざまなウィジェットの組み合わせを試して実験することの重要性を強調し、同じ結果を達成する方法が複数あることを強調します。ウィジェットのインタラクションを積極的に調査してテストすることで、ユーザーは Flutter の機能をより深く理解し、アプリのレイアウトを効果的にカスタマイズできます。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 기본적인 Flutter 프로젝트를 설정하고, 홈페이지 위젯을 정리하고, 애플리케이션을 빌드할 준비를 하는 것으로 시작합니다. 목표는 차트와 거래 목록이 있는 애플리케이션을 만드는 것이며, 이러한 요소를 포함하는 열 위젯으로 시작하고, 스타일을 지정하기 위해 카드 위젯을 사용합니다. 컨테이너 너비를 설정하고 부모-자식 관계를 활용하여 레이아웃과 스타일을 조정하는 것과 같이 위젯의 ​​크기와 모양을 제어하기 위한 다양한 전략에 대해 설명합니다. 강사는 다양한 위젯 조합을 실험하고 시도하여 Flutter 애플리케이션에서 위젯이 어떻게 동작하고 원하는 결과를 얻는지 이해하는 것의 중요성을 강조하며, 동일한 결과를 달성하는 여러 가지 방법이 있다는 점을 강조합니다. 위젯 상호 작용을 적극적으로 탐색하고 테스트함으로써 사용자는 Flutter의 기능을 더 깊이 이해하고 앱 레이아웃을 효과적으로 사용자 지정할 수 있습니다.",
                                // Spanish
                                "Español": "En este video, el instructor comienza configurando un proyecto básico de Flutter, limpiando el widget de la página de inicio y preparándose para crear una aplicación. El objetivo es crear una aplicación con un gráfico y una lista de transacciones, comenzando con un widget de columna para contener estos elementos y usando un widget de tarjeta para el estilo. Se analizan diferentes estrategias para controlar el tamaño y la apariencia de los widgets, como configurar el ancho de los contenedores y utilizar la relación padre-hijo para ajustar el diseño y el estilo. El instructor enfatiza la importancia de experimentar y probar diferentes combinaciones de widgets para comprender cómo se comportan y lograr los resultados deseados en las aplicaciones de Flutter, destacando que existen múltiples formas de lograr el mismo resultado. Al explorar y probar activamente las interacciones de los widgets, los usuarios pueden obtener una comprensión más profunda de las capacidades de Flutter y personalizar de manera efectiva los diseños de sus aplicaciones.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक एक बुनियादी फ़्लटर प्रोजेक्ट सेट अप करके, होमपेज विजेट को साफ करके और एक एप्लिकेशन बनाने की तैयारी करके शुरू करता है। लक्ष्य एक चार्ट और लेन-देन की सूची के साथ एक एप्लिकेशन बनाना है, इन तत्वों को शामिल करने के लिए एक कॉलम विजेट से शुरू करना और स्टाइलिंग के लिए कार्ड विजेट का उपयोग करना। विजेट के आकार और उपस्थिति को नियंत्रित करने के लिए विभिन्न रणनीतियों पर चर्चा की जाती है, जैसे कि कंटेनर की चौड़ाई निर्धारित करना और लेआउट और स्टाइलिंग को समायोजित करने के लिए पैरेंट-चाइल्ड संबंध का उपयोग करना। प्रशिक्षक फ़्लटर एप्लिकेशन में उनके व्यवहार और वांछित परिणाम प्राप्त करने के तरीके को समझने के लिए विभिन्न विजेट संयोजनों का प्रयोग करने और आज़माने के महत्व पर ज़ोर देता है, इस बात पर प्रकाश डालता है कि एक ही परिणाम को प्राप्त करने के कई तरीके हैं। विजेट इंटरैक्शन को सक्रिय रूप से एक्सप्लोर और टेस्ट करके, उपयोगकर्ता फ़्लटर की क्षमताओं की गहरी समझ प्राप्त कर सकते हैं और अपने ऐप लेआउट को प्रभावी ढंग से कस्टमाइज़ कर सकते हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor começa por configurar um projeto Flutter básico, limpando o widget da página inicial e preparando-se para construir uma aplicação. O objetivo é criar uma aplicação com um gráfico e uma lista de transações, começando com um widget de coluna para conter esses elementos e utilizando um widget de cartão para estilizar. São discutidas diferentes estratégias para controlar o tamanho e a aparência dos widgets, como definir larguras de contentores e utilizar a relação pai-filho para ajustar o layout e o estilo. O instrutor realça a importância de experimentar e experimentar diferentes combinações de widgets para compreender como se comportam e alcançar os resultados desejados em aplicações Flutter, salientando que existem várias formas de alcançar o mesmo resultado. Ao explorar e testar ativamente as interações dos widgets, os utilizadores podem obter uma compreensão mais profunda das capacidades do Flutter e personalizar eficazmente os layouts das suas aplicações.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক একটি বেসিক ফ্লাটার প্রজেক্ট সেট আপ করে, হোমপেজ উইজেট পরিষ্কার করে এবং একটি অ্যাপ্লিকেশন তৈরি করার প্রস্তুতি শুরু করে। লক্ষ্য হল একটি চার্ট এবং লেনদেনের একটি তালিকা সহ একটি অ্যাপ্লিকেশন তৈরি করা, এই উপাদানগুলিকে ধারণ করার জন্য একটি কলাম উইজেট দিয়ে শুরু করা এবং স্টাইলিং করার জন্য একটি কার্ড উইজেট ব্যবহার করা৷ উইজেটগুলির আকার এবং চেহারা নিয়ন্ত্রণের জন্য বিভিন্ন কৌশল নিয়ে আলোচনা করা হয়েছে, যেমন ধারক প্রস্থ নির্ধারণ করা এবং বিন্যাস এবং স্টাইলিং সামঞ্জস্য করতে পিতামাতা-সন্তানের সম্পর্ককে ব্যবহার করা। প্রশিক্ষক ফ্লাটার অ্যাপ্লিকেশনগুলিতে তারা কীভাবে আচরণ করে এবং পছন্দসই ফলাফল অর্জন করে তা বোঝার জন্য বিভিন্ন উইজেট সংমিশ্রণগুলি পরীক্ষা করার এবং চেষ্টা করার গুরুত্বের উপর জোর দেয়, একই ফলাফল অর্জনের একাধিক উপায় রয়েছে তা হাইলাইট করে। সক্রিয়ভাবে উইজেট ইন্টারঅ্যাকশনগুলি অন্বেষণ এবং পরীক্ষা করে, ব্যবহারকারীরা ফ্লটারের ক্ষমতা সম্পর্কে গভীর জ্ঞান অর্জন করতে পারে এবং কার্যকরভাবে তাদের অ্যাপ লেআউটগুলি কাস্টমাইজ করতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يبدأ المدرب بإعداد مشروع Flutter أساسي وتنظيف عنصر واجهة المستخدم في الصفحة الرئيسية والاستعداد لبناء تطبيق. والهدف هو إنشاء تطبيق يحتوي على مخطط وقائمة معاملات، بدءًا بعنصر واجهة مستخدم عمودي لاحتواء هذه العناصر واستخدام عنصر واجهة مستخدم بطاقة للتصميم. تتم مناقشة استراتيجيات مختلفة للتحكم في حجم ومظهر عناصر واجهة المستخدم، مثل ضبط عرض الحاوية والاستفادة من علاقة الوالد والطفل لضبط التصميم والتصميم. يؤكد المدرب على أهمية تجربة مجموعات عناصر واجهة المستخدم المختلفة لفهم كيفية تصرفها وتحقيق النتائج المرجوة في تطبيقات Flutter، مع تسليط الضوء على وجود طرق متعددة لتحقيق نفس النتيجة. من خلال استكشاف تفاعلات عناصر واجهة المستخدم واختبارها بشكل نشط، يمكن للمستخدمين اكتساب فهم أعمق لقدرات Flutter وتخصيص تخطيطات تطبيقاتهم بشكل فعال.",
                                // Persian
                                "فارسی": "در این ویدئو، مربی با راه اندازی یک پروژه پایه فلاتر، پاکسازی ویجت صفحه اصلی و آماده شدن برای ساخت یک برنامه شروع می کند. هدف این است که یک برنامه کاربردی با نمودار و لیستی از تراکنش ها ایجاد کنید که با یک ویجت ستونی شروع می شود تا این عناصر را در خود جای دهد و از ویجت کارت برای یک ظاهر طراحی شده استفاده می کند. استراتژی‌های مختلفی برای کنترل اندازه و ظاهر ویجت‌ها مورد بحث قرار می‌گیرد، مانند تنظیم عرض ظرف و استفاده از رابطه والد-فرزند برای تنظیم چیدمان و استایل. مدرس بر اهمیت آزمایش و آزمایش ترکیب‌های مختلف ویجت برای درک نحوه رفتار و دستیابی به نتایج دلخواه در برنامه‌های Flutter تاکید می‌کند و تاکید می‌کند که راه‌های متعددی برای دستیابی به یک نتیجه وجود دارد. با کاوش و آزمایش فعال تعاملات ویجت ها، کاربران می توانند درک عمیق تری از قابلیت های Flutter به دست آورند و به طور موثر طرح بندی برنامه های خود را سفارشی کنند.",
                            },
                        },
                        // 63 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Understanding Column Alignment",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor explores the column widget in Flutter by adjusting the alignment settings of items within a column layout. The importance of main axis alignment and cross axis alignment is highlighted, as these properties allow for precise positioning of widgets within a column or row. By demonstrating various alignment options such as start, end, center, SpaceBetween, SpaceAround, and stretch, the instructor showcases how these settings affect the placement of items in the layout. The video emphasizes the significance of experimenting with alignment settings to gain a better understanding of how to position widgets effectively in Flutter applications using column and row widgets.",
                                // German
                                "Deutsch": "In diesem Video erkundet der Kursleiter das Spalten-Widget in Flutter, indem er die Ausrichtungseinstellungen von Elementen innerhalb eines Spaltenlayouts anpasst. Die Bedeutung der Ausrichtung der Hauptachse und der Ausrichtung über die Achse wird hervorgehoben, da diese Eigenschaften eine präzise Positionierung von Widgets innerhalb einer Spalte oder Zeile ermöglichen. Durch die Demonstration verschiedener Ausrichtungsoptionen wie Start, Ende, Mitte, SpaceBetween, SpaceAround und Stretch zeigt der Kursleiter, wie sich diese Einstellungen auf die Platzierung von Elementen im Layout auswirken. Das Video betont die Bedeutung des Experimentierens mit Ausrichtungseinstellungen, um ein besseres Verständnis dafür zu erlangen, wie Widgets mithilfe von Spalten- und Zeilen-Widgets in Flutter-Anwendungen effektiv positioniert werden können.",
                                // Chinese
                                "中国人": "在本视频中，讲师通过调整列布局中项目的对齐设置来探索 Flutter 中的列小部件。重点强调了主轴对齐和横轴对齐的重要性，因为这些属性允许在列或行内精确定位小部件。通过演示各种对齐选项（例如开始、结束、中心、SpaceBetween、SpaceAround 和拉伸），讲师展示了这些设置如何影响布局中项目的位置。该视频强调了尝试对齐设置的重要性，以便更好地了解如何使用列和行小部件在 Flutter 应用程序中有效地定位小部件。",
                                // Russian
                                "Русский": "В этом видео инструктор изучает виджет столбца во Flutter, настраивая параметры выравнивания элементов в макете столбца. Подчеркивается важность выравнивания по главной оси и выравнивания по поперечной оси, поскольку эти свойства позволяют точно позиционировать виджеты в столбце или строке. Демонстрируя различные параметры выравнивания, такие как начало, конец, центр, SpaceBetween, SpaceAround и растяжение, инструктор показывает, как эти параметры влияют на размещение элементов в макете. Видео подчеркивает важность экспериментов с параметрами выравнивания для лучшего понимания того, как эффективно позиционировать виджеты в приложениях Flutter с использованием виджетов столбцов и строк.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur explore le widget de colonne dans Flutter en ajustant les paramètres d'alignement des éléments dans une disposition de colonne. L'importance de l'alignement de l'axe principal et de l'alignement de l'axe transversal est soulignée, car ces propriétés permettent un positionnement précis des widgets dans une colonne ou une ligne. En démontrant diverses options d'alignement telles que début, fin, centre, SpaceBetween, SpaceAround et étirement, l'instructeur montre comment ces paramètres affectent le placement des éléments dans la disposition. La vidéo souligne l'importance d'expérimenter les paramètres d'alignement pour mieux comprendre comment positionner efficacement les widgets dans les applications Flutter à l'aide de widgets de colonne et de ligne.",
                                // Japanese
                                "日本語": "このビデオでは、講師が列レイアウト内のアイテムの配置設定を調整することで、Flutter の列ウィジェットについて学習します。主軸配置と交差軸配置の重要性が強調されています。これらのプロパティにより、列または行内でウィジェットを正確に配置できます。講師は、start、end、center、SpaceBetween、SpaceAround、stretch などのさまざまな配置オプションを実演することで、これらの設定がレイアウト内のアイテムの配置にどのように影響するかを示します。このビデオでは、列ウィジェットと行ウィジェットを使用して Flutter アプリケーションでウィジェットを効果的に配置する方法をより深く理解するために、配置設定を試してみることの重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 열 레이아웃 내 항목의 정렬 설정을 조정하여 Flutter의 열 위젯을 살펴봅니다. 주축 정렬과 교차축 정렬의 중요성이 강조되는데, 이러한 속성을 사용하면 열이나 행 내에서 위젯을 정확하게 배치할 수 있기 때문입니다. 시작, 끝, 가운데, SpaceBetween, SpaceAround, stretch와 같은 다양한 정렬 옵션을 보여줌으로써 강사는 이러한 설정이 레이아웃에서 항목의 배치에 어떤 영향을 미치는지 보여줍니다. 이 비디오는 열 및 행 위젯을 사용하여 Flutter 애플리케이션에서 위젯을 효과적으로 배치하는 방법을 더 잘 이해하기 위해 정렬 설정을 실험하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el instructor explora el widget de columna en Flutter ajustando la configuración de alineación de los elementos dentro de un diseño de columna. Se destaca la importancia de la alineación del eje principal y la alineación del eje transversal, ya que estas propiedades permiten un posicionamiento preciso de los widgets dentro de una columna o fila. Al demostrar varias opciones de alineación, como inicio, fin, centro, espacio entre, espacio alrededor y estiramiento, el instructor muestra cómo estas configuraciones afectan la ubicación de los elementos en el diseño. El video enfatiza la importancia de experimentar con las configuraciones de alineación para comprender mejor cómo posicionar los widgets de manera efectiva en las aplicaciones de Flutter utilizando widgets de columna y fila.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक कॉलम लेआउट के भीतर आइटम की संरेखण सेटिंग्स को समायोजित करके फ़्लटर में कॉलम विजेट का पता लगाता है। मुख्य अक्ष संरेखण और क्रॉस अक्ष संरेखण के महत्व पर प्रकाश डाला गया है, क्योंकि ये गुण कॉलम या पंक्ति के भीतर विजेट की सटीक स्थिति की अनुमति देते हैं। स्टार्ट, एंड, सेंटर, स्पेसबीटवीन, स्पेसअराउंड और स्ट्रेच जैसे विभिन्न संरेखण विकल्पों का प्रदर्शन करके, प्रशिक्षक दिखाता है कि ये सेटिंग्स लेआउट में आइटम की स्थिति को कैसे प्रभावित करती हैं। वीडियो कॉलम और पंक्ति विजेट का उपयोग करके फ़्लटर अनुप्रयोगों में विजेट को प्रभावी ढंग से कैसे रखा जाए, इसकी बेहतर समझ हासिल करने के लिए संरेखण सेटिंग्स के साथ प्रयोग करने के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor explora o widget de colunas no Flutter ajustando as definições de alinhamento dos itens num esquema de colunas. É realçada a importância do alinhamento do eixo principal e do alinhamento do eixo cruzado, uma vez que estas propriedades permitem o posicionamento preciso dos widgets dentro de uma coluna ou linha. Ao demonstrar várias opções de alinhamento, como início, fim, centro, SpaceBetween, SpaceAround e stretch, o instrutor mostra como estas definições afetam o posicionamento dos itens no layout. O vídeo enfatiza a importância de experimentar as definições de alinhamento para obter uma melhor compreensão de como posicionar widgets de forma eficaz em aplicações Flutter utilizando widgets de coluna e linha.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক একটি কলাম লেআউটের মধ্যে আইটেমগুলির প্রান্তিককরণ সেটিংস সামঞ্জস্য করে ফ্লটারে কলাম উইজেটটি অন্বেষণ করেন। প্রধান অক্ষ প্রান্তিককরণ এবং ক্রস অক্ষ প্রান্তিককরণের গুরুত্ব হাইলাইট করা হয়েছে, কারণ এই বৈশিষ্ট্যগুলি একটি কলাম বা সারির মধ্যে উইজেটগুলির সুনির্দিষ্ট অবস্থানের জন্য অনুমতি দেয়। শুরু, শেষ, কেন্দ্র, SpaceBetween, SpaceAround এবং স্ট্রেচের মতো বিভিন্ন প্রান্তিককরণ বিকল্পগুলি প্রদর্শন করে, প্রশিক্ষক প্রদর্শন করে যে কীভাবে এই সেটিংস বিন্যাসে আইটেমগুলির স্থান নির্ধারণকে প্রভাবিত করে। ভিডিওটি কলাম এবং সারি উইজেটগুলি ব্যবহার করে ফ্লটার অ্যাপ্লিকেশনগুলিতে কীভাবে কার্যকরভাবে উইজেটগুলিকে অবস্থান করতে হয় সে সম্পর্কে আরও ভাল বোঝার জন্য সারিবদ্ধকরণ সেটিংস নিয়ে পরীক্ষা করার তাত্পর্যের উপর জোর দেয়৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يستكشف المدرب أداة العمود في Flutter من خلال ضبط إعدادات محاذاة العناصر داخل تخطيط العمود. يتم تسليط الضوء على أهمية محاذاة المحور الرئيسي ومحاذاة المحور المتقاطع، حيث تسمح هذه الخصائص بتحديد موضع الأدوات بدقة داخل العمود أو الصف. من خلال إظهار خيارات المحاذاة المختلفة مثل البداية والنهاية والمركز والمسافة بين العناصر والمسافة حولها والامتداد، يوضح المدرب كيف تؤثر هذه الإعدادات على وضع العناصر في التخطيط. يؤكد الفيديو على أهمية تجربة إعدادات المحاذاة للحصول على فهم أفضل لكيفية تحديد موضع الأدوات بشكل فعال في تطبيقات Flutter باستخدام أدوات العمود والصف.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس ویجت ستون را در Flutter با تنظیم تنظیمات تراز آیتم ها در طرح بندی ستون بررسی می کند. اهمیت تراز محوری اصلی و تراز محوری متقاطع برجسته شده است، زیرا این ویژگی ها امکان قرارگیری دقیق ویجت ها را در یک ستون یا ردیف فراهم می کند. با نشان دادن گزینه های مختلف هم ترازی مانند شروع، پایان، مرکز، SpaceBetween، SpaceAround و کشش، مربی نشان می دهد که چگونه این تنظیمات بر قرار دادن آیتم ها در چیدمان تأثیر می گذارد. این ویدئو بر اهمیت آزمایش با تنظیمات تراز برای به دست آوردن درک بهتری از نحوه قرارگیری موثر ویجت ها در برنامه های Flutter با استفاده از ویجت های ستون و ردیف تاکید می کند.",
                            },
                        },
                        // 64 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Not a Widget_ Adding a Transaction Model & Transaction Data",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker discusses creating a blueprint for a transaction class in a Flutter application. The transaction class includes properties such as ID, title, amount, and date. The speaker explains how to add a constructor with named arguments for creating new transaction objects and how to import the transaction class into the main.dart file. Examples of creating transactions with specific details are provided, along with the importance of marking properties as final and using the @required decorator. The video concludes with the creation of a list of transactions for display in the application.",
                                // German
                                "Deutsch": "In diesem Video bespricht der Sprecher die Erstellung einer Blaupause für eine Transaktionsklasse in einer Flutter-Anwendung. Die Transaktionsklasse umfasst Eigenschaften wie ID, Titel, Betrag und Datum. Der Sprecher erklärt, wie man einen Konstruktor mit benannten Argumenten zum Erstellen neuer Transaktionsobjekte hinzufügt und wie man die Transaktionsklasse in die Datei main.dart importiert. Es werden Beispiele zum Erstellen von Transaktionen mit bestimmten Details bereitgestellt, zusammen mit der Bedeutung, Eigenschaften als endgültig zu markieren und den Dekorator @required zu verwenden. Das Video endet mit der Erstellung einer Liste von Transaktionen zur Anzeige in der Anwendung.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了如何在 Flutter 应用程序中创建交易类的蓝图。交易类包括 ID、标题、金额和日期等属性。演讲者解释了如何添加带有命名参数的构造函数来创建新的交易对象，以及如何将交易类导入 main.dart 文件。提供了创建具有特定详细信息的交易的示例，以及将属性标记为 final 和使用 @required 装饰器的重要性。视频最后创建了一个交易列表以在应用程序中显示。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает создание чертежа для класса транзакции в приложении Flutter. Класс транзакции включает такие свойства, как идентификатор, заголовок, сумма и дата. Докладчик объясняет, как добавить конструктор с именованными аргументами для создания новых объектов транзакции и как импортировать класс транзакции в файл main.dart. Приводятся примеры создания транзакций с определенными подробностями, а также важность маркировки свойств как окончательных и использования декоратора @required. Видео завершается созданием списка транзакций для отображения в приложении.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique comment créer un plan pour une classe de transaction dans une application Flutter. La classe de transaction comprend des propriétés telles que l'ID, le titre, le montant et la date. L'intervenant explique comment ajouter un constructeur avec des arguments nommés pour créer de nouveaux objets de transaction et comment importer la classe de transaction dans le fichier main.dart. Des exemples de création de transactions avec des détails spécifiques sont fournis, ainsi que l'importance de marquer les propriétés comme finales et d'utiliser le décorateur @required. La vidéo se termine par la création d'une liste de transactions à afficher dans l'application.",
                                // Japanese
                                "日本語": "このビデオでは、スピーカーが Flutter アプリケーションでトランザクション クラスのブループリントを作成する方法について説明します。トランザクション クラスには、ID、タイトル、金額、日付などのプロパティが含まれます。スピーカーは、新しいトランザクション オブジェクトを作成するための名前付き引数を持つコンストラクターを追加する方法と、トランザクション クラスを main.dart ファイルにインポートする方法について説明します。具体的な詳細を含むトランザクションの作成例が示され、プロパティを final としてマークすることと @required デコレータを使用することの重要性も説明されています。ビデオは、アプリケーションに表示するトランザクションのリストの作成で終わります。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 애플리케이션에서 트랜잭션 클래스에 대한 청사진을 만드는 방법을 논의합니다. 트랜잭션 클래스에는 ID, 제목, 금액, 날짜와 같은 속성이 포함됩니다. 발표자는 새 트랜잭션 객체를 만들기 위해 명명된 인수가 있는 생성자를 추가하는 방법과 트랜잭션 클래스를 main.dart 파일에 가져오는 방법을 설명합니다. 특정 세부 정보가 있는 트랜잭션을 만드는 예와 속성을 final로 표시하고 @required 데코레이터를 사용하는 것의 중요성이 제공됩니다. 이 영상은 애플리케이션에 표시할 트랜잭션 목록을 만드는 것으로 마무리됩니다.",
                                // Spanish
                                "Español": "En este video, el orador analiza la creación de un modelo para una clase de transacción en una aplicación Flutter. La clase de transacción incluye propiedades como ID, título, monto y fecha. El orador explica cómo agregar un constructor con argumentos con nombre para crear nuevos objetos de transacción y cómo importar la clase de transacción al archivo main.dart. Se brindan ejemplos de creación de transacciones con detalles específicos, junto con la importancia de marcar propiedades como finales y usar el decorador @required. El video concluye con la creación de una lista de transacciones para mostrar en la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर एप्लिकेशन में ट्रांज़ैक्शन क्लास के लिए ब्लूप्रिंट बनाने पर चर्चा करता है। ट्रांज़ैक्शन क्लास में ID, शीर्षक, राशि और दिनांक जैसे गुण शामिल होते हैं। वक्ता बताता है कि नए ट्रांज़ैक्शन ऑब्जेक्ट बनाने के लिए नामित तर्कों के साथ एक कंस्ट्रक्टर कैसे जोड़ा जाए और ट्रांज़ैक्शन क्लास को main.dart फ़ाइल में कैसे आयात किया जाए। विशिष्ट विवरणों के साथ ट्रांज़ैक्शन बनाने के उदाहरण दिए गए हैं, साथ ही गुणों को अंतिम के रूप में चिह्नित करने और @required डेकोरेटर का उपयोग करने के महत्व के बारे में भी बताया गया है। वीडियो एप्लिकेशन में प्रदर्शित करने के लिए ट्रांज़ैक्शन की सूची बनाने के साथ समाप्त होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador aborda a criação de um blueprint para uma classe de transação numa aplicação Flutter. A classe de transação inclui propriedades como ID, título, valor e data. O orador explica como adicionar um construtor com argumentos nomeados para criar novos objetos de transação e como importar a classe de transação para o ficheiro main.dart. São fornecidos exemplos de criação de transações com detalhes específicos, juntamente com a importância de marcar as propriedades como finais e utilizar o decorador @required. O vídeo termina com a criação de uma lista de transações para exibição na aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি ফ্লাটার অ্যাপ্লিকেশনে একটি লেনদেন ক্লাসের জন্য একটি ব্লুপ্রিন্ট তৈরি করার বিষয়ে আলোচনা করেছেন৷ লেনদেনের শ্রেণীতে আইডি, শিরোনাম, পরিমাণ এবং তারিখের মতো বৈশিষ্ট্য অন্তর্ভুক্ত থাকে। স্পিকার ব্যাখ্যা করে কিভাবে নতুন লেনদেন অবজেক্ট তৈরি করার জন্য নামযুক্ত আর্গুমেন্ট সহ একটি কনস্ট্রাক্টর যোগ করতে হয় এবং কিভাবে main.dart ফাইলে লেনদেন ক্লাস আমদানি করতে হয়। নির্দিষ্ট বিশদ বিবরণ সহ লেনদেন তৈরির উদাহরণ প্রদান করা হয়েছে, বৈশিষ্ট্যগুলিকে চূড়ান্ত হিসাবে চিহ্নিত করার এবং @ প্রয়োজনীয় ডেকোরেটর ব্যবহার করার গুরুত্ব সহ। ভিডিওটি অ্যাপ্লিকেশনটিতে প্রদর্শনের জন্য লেনদেনের একটি তালিকা তৈরির সাথে শেষ হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث إنشاء مخطط لفئة معاملة في تطبيق Flutter. تتضمن فئة المعاملة خصائص مثل المعرف والعنوان والمبلغ والتاريخ. يشرح المتحدث كيفية إضافة منشئ بحجج مسماة لإنشاء كائنات معاملة جديدة وكيفية استيراد فئة المعاملة إلى ملف main.dart. يتم توفير أمثلة لإنشاء معاملات بتفاصيل محددة، إلى جانب أهمية وضع علامة على الخصائص على أنها نهائية واستخدام الديكور @required. ويختتم الفيديو بإنشاء قائمة بالمعاملات لعرضها في التطبيق.",
                                // Persian
                                "فارسی": "در این ویدئو، سخنران در مورد ایجاد یک طرح اولیه برای کلاس تراکنش در یک برنامه Flutter بحث می کند. کلاس تراکنش شامل ویژگی هایی مانند شناسه، عنوان، مبلغ و تاریخ است. سخنران نحوه اضافه کردن یک سازنده با آرگومان های نامگذاری شده برای ایجاد اشیاء تراکنش جدید و نحوه وارد کردن کلاس تراکنش را در فایل main.dart توضیح می دهد. نمونه هایی از ایجاد تراکنش با جزئیات خاص همراه با اهمیت علامت گذاری خواص به عنوان نهایی و با استفاده از دکوراتور @required ارائه شده است. این ویدئو با ایجاد لیستی از تراکنش ها برای نمایش در برنامه به پایان می رسد.",
                            },
                        },
                        // 65 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Mapping Data Into Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker demonstrates how to output a list of transactions in a Flutter application by mapping each transaction into a widget. Instead of hardcoding individual cards for each transaction, the speaker uses the map method to transform the list of transaction objects into a list of widgets, with each widget representing a transaction. The speaker explains how to access properties of a transaction object, such as the title, and output them within a card widget. By using a custom class for transactions, the speaker showcases the convenience of auto-completion when accessing object properties. The video concludes with the successful transformation of the list of transactions into a list of cards displaying transaction titles, setting the foundation for further customization in future lectures.",
                                // German
                                "Deutsch": "In diesem Video demonstriert der Sprecher, wie man eine Liste von Transaktionen in einer Flutter-Anwendung ausgibt, indem man jede Transaktion einem Widget zuordnet. Anstatt für jede Transaktion einzelne Karten fest zu codieren, verwendet der Sprecher die Map-Methode, um die Liste der Transaktionsobjekte in eine Liste von Widgets umzuwandeln, wobei jedes Widget eine Transaktion darstellt. Der Sprecher erklärt, wie man auf Eigenschaften eines Transaktionsobjekts, wie etwa den Titel, zugreift und diese in einem Karten-Widget ausgibt. Durch die Verwendung einer benutzerdefinierten Klasse für Transaktionen demonstriert der Sprecher die praktische automatische Vervollständigung beim Zugriff auf Objekteigenschaften. Das Video endet mit der erfolgreichen Umwandlung der Liste der Transaktionen in eine Liste von Karten, die Transaktionstitel anzeigen, und legt damit den Grundstein für weitere Anpassungen in zukünftigen Vorträgen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者演示了如何通过将每笔交易映射到小部件中来在 Flutter 应用程序中输出交易列表。演讲者没有为每笔交易硬编码单独的卡片，而是使用 map 方法将交易对象列表转换为小部件列表，每个小部件代表一笔交易。演讲者解释了如何访问交易对象的属性（例如标题）并将其输出到卡片小部件中。通过使用交易的自定义类，演讲者展示了访问对象属性时自动完成的便利性。视频最后成功将交易列表转换为显示交易标题的卡片列表，为未来讲座中的进一步定制奠定了基础。",
                                // Russian
                                "Русский": "В этом видео докладчик демонстрирует, как вывести список транзакций в приложении Flutter, сопоставив каждую транзакцию с виджетом. Вместо того, чтобы жестко кодировать отдельные карточки для каждой транзакции, докладчик использует метод map для преобразования списка объектов транзакций в список виджетов, где каждый виджет представляет транзакцию. Докладчик объясняет, как получить доступ к свойствам объекта транзакции, таким как заголовок, и вывести их в виджете карточки. Используя пользовательский класс для транзакций, докладчик демонстрирует удобство автодополнения при доступе к свойствам объекта. Видео завершается успешным преобразованием списка транзакций в список карточек, отображающих заголовки транзакций, что закладывает основу для дальнейшей настройки в будущих лекциях.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant montre comment générer une liste de transactions dans une application Flutter en mappant chaque transaction dans un widget. Au lieu de coder en dur des cartes individuelles pour chaque transaction, l'intervenant utilise la méthode map pour transformer la liste des objets de transaction en une liste de widgets, chaque widget représentant une transaction. L'intervenant explique comment accéder aux propriétés d'un objet de transaction, comme le titre, et les générer dans un widget de carte. En utilisant une classe personnalisée pour les transactions, l'intervenant montre la commodité de la saisie semi-automatique lors de l'accès aux propriétés d'un objet. La vidéo se termine par la transformation réussie de la liste de transactions en une liste de cartes affichant les titres des transactions, jetant ainsi les bases d'une personnalisation plus poussée dans les conférences futures.",
                                // Japanese
                                "日本語": "このビデオでは、各トランザクションをウィジェットにマッピングすることで、Flutter アプリケーションでトランザクションのリストを出力する方法を講演者が実演します。各トランザクションの個別のカードをハードコーディングする代わりに、講演者はマップ メソッドを使用して、トランザクション オブジェクトのリストをウィジェットのリストに変換します。各ウィジェットはトランザクションを表します。講演者は、タイトルなどのトランザクション オブジェクトのプロパティにアクセスし、カード ウィジェット内に出力する方法を説明します。講演者は、トランザクションのカスタム クラスを使用することで、オブジェクトのプロパティにアクセスする際の自動補完の利便性を紹介します。ビデオの最後には、トランザクションのリストをトランザクションのタイトルを表示するカードのリストに変換することに成功し、今後の講義でさらにカスタマイズするための基礎が確立されます。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 각 거래를 위젯에 매핑하여 Flutter 애플리케이션에서 거래 목록을 출력하는 방법을 보여줍니다. 각 거래에 대해 개별 카드를 하드코딩하는 대신 발표자는 map 메서드를 사용하여 거래 객체 목록을 위젯 목록으로 변환하고 각 위젯은 거래를 나타냅니다. 발표자는 제목과 같은 거래 객체의 속성에 액세스하고 카드 위젯 내에서 이를 출력하는 방법을 설명합니다. 거래에 대한 사용자 정의 클래스를 사용하여 발표자는 객체 속성에 액세스할 때 자동 완성의 편의성을 보여줍니다. 이 비디오는 거래 목록을 거래 제목을 표시하는 카드 목록으로 성공적으로 변환하는 것으로 마무리되며, 이는 향후 강의에서 추가 사용자 정의를 위한 기반을 마련합니다.",
                                // Spanish
                                "Español": "En este video, el orador demuestra cómo generar una lista de transacciones en una aplicación Flutter al asignar cada transacción a un widget. En lugar de codificar tarjetas individuales para cada transacción, el orador usa el método map para transformar la lista de objetos de transacción en una lista de widgets, donde cada widget representa una transacción. El orador explica cómo acceder a las propiedades de un objeto de transacción, como el título, y generarlas dentro de un widget de tarjeta. Al usar una clase personalizada para transacciones, el orador muestra la conveniencia del autocompletado al acceder a las propiedades de los objetos. El video concluye con la transformación exitosa de la lista de transacciones en una lista de tarjetas que muestran los títulos de las transacciones, lo que sienta las bases para una mayor personalización en futuras conferencias.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता प्रत्येक लेनदेन को विजेट में मैप करके फ़्लटर एप्लिकेशन में लेनदेन की सूची आउटपुट करने का तरीका प्रदर्शित करता है। प्रत्येक लेनदेन के लिए अलग-अलग कार्ड को हार्डकोड करने के बजाय, वक्ता लेनदेन ऑब्जेक्ट की सूची को विजेट की सूची में बदलने के लिए मैप विधि का उपयोग करता है, जिसमें प्रत्येक विजेट एक लेनदेन का प्रतिनिधित्व करता है। वक्ता बताता है कि किसी लेनदेन ऑब्जेक्ट के गुणों, जैसे शीर्षक, तक कैसे पहुँचें और उन्हें कार्ड विजेट के भीतर आउटपुट करें। लेनदेन के लिए एक कस्टम क्लास का उपयोग करके, वक्ता ऑब्जेक्ट गुणों तक पहुँचने पर ऑटो-पूर्णता की सुविधा को प्रदर्शित करता है। वीडियो लेनदेन की सूची को लेनदेन शीर्षक प्रदर्शित करने वाले कार्ड की सूची में सफलतापूर्वक बदलने के साथ समाप्त होता है, जो भविष्य के व्याख्यानों में आगे के अनुकूलन के लिए आधार तैयार करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador demonstra como gerar uma lista de transações numa aplicação Flutter mapeando cada transação num widget. Em vez de codificar cartões individuais para cada transação, o orador utiliza o método map para transformar a lista de objetos de transação numa lista de widgets, sendo que cada widget representa uma transação. O orador explica como aceder às propriedades de um objeto de transação, como o título, e exibi-las num widget de cartão. Ao utilizar uma classe personalizada para transações, o orador mostra a conveniência do preenchimento automático ao aceder às propriedades do objeto. O vídeo termina com a transformação bem-sucedida da lista de transações numa lista de cartões que exibem títulos de transações, estabelecendo a base para uma maior personalização em palestras futuras.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার প্রদর্শন করে যে কীভাবে প্রতিটি লেনদেনকে একটি উইজেটে ম্যাপ করে একটি ফ্লাটার অ্যাপ্লিকেশনে লেনদেনের একটি তালিকা আউটপুট করতে হয়। প্রতিটি লেনদেনের জন্য পৃথক কার্ড হার্ডকোড করার পরিবর্তে, স্পিকার লেনদেনের বস্তুর তালিকাকে উইজেটের তালিকায় রূপান্তর করতে মানচিত্র পদ্ধতি ব্যবহার করে, প্রতিটি উইজেট একটি লেনদেনের প্রতিনিধিত্ব করে। স্পিকার ব্যাখ্যা করে যে কীভাবে একটি লেনদেন বস্তুর বৈশিষ্ট্যগুলি অ্যাক্সেস করতে হয়, যেমন শিরোনাম, এবং একটি কার্ড উইজেটের মধ্যে তাদের আউটপুট। লেনদেনের জন্য একটি কাস্টম ক্লাস ব্যবহার করে, স্পিকার বস্তুর বৈশিষ্ট্যগুলি অ্যাক্সেস করার সময় স্বয়ংক্রিয়-সম্পূর্ণতার সুবিধার প্রদর্শন করে। ভিডিওটি লেনদেনের শিরোনাম প্রদর্শনকারী কার্ডের তালিকায় লেনদেনের তালিকার সফল রূপান্তরের মাধ্যমে শেষ হয়েছে, যা ভবিষ্যতের বক্তৃতায় আরও কাস্টমাইজেশনের ভিত্তি স্থাপন করবে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المتحدث كيفية إخراج قائمة من المعاملات في تطبيق Flutter من خلال تعيين كل معاملة في عنصر واجهة مستخدم. بدلاً من ترميز بطاقات فردية لكل معاملة، يستخدم المتحدث طريقة الخريطة لتحويل قائمة كائنات المعاملات إلى قائمة من عناصر واجهة المستخدم، حيث تمثل كل عنصر واجهة مستخدم معاملة. يشرح المتحدث كيفية الوصول إلى خصائص كائن المعاملة، مثل العنوان، وإخراجها داخل عنصر واجهة مستخدم للبطاقة. من خلال استخدام فئة مخصصة للمعاملات، يعرض المتحدث راحة الإكمال التلقائي عند الوصول إلى خصائص الكائن. ويختتم الفيديو بالتحويل الناجح لقائمة المعاملات إلى قائمة من البطاقات التي تعرض عناوين المعاملات، مما يضع الأساس لمزيد من التخصيص في المحاضرات المستقبلية.",
                                // Persian
                                "فارسی": "در این ویدیو، بلندگو نحوه خروجی لیست تراکنش ها در یک برنامه Flutter را با نگاشت هر تراکنش در یک ویجت نشان می دهد. گوینده به جای رمزگذاری کارت های جداگانه برای هر تراکنش، از روش نقشه استفاده می کند تا لیست اشیاء تراکنش را به فهرستی از ویجت ها تبدیل کند که هر ویجت نشان دهنده یک تراکنش است. سخنران نحوه دسترسی به ویژگی های یک شی تراکنش، مانند عنوان، و خروجی آنها را در ویجت کارت توضیح می دهد. با استفاده از یک کلاس سفارشی برای تراکنش ها، بلندگو راحتی تکمیل خودکار را هنگام دسترسی به ویژگی های شی نشان می دهد. این ویدئو با تبدیل موفقیت‌آمیز فهرست تراکنش‌ها به فهرستی از کارت‌هایی که عناوین تراکنش‌ها را نشان می‌دهند، به پایان می‌رسد و پایه‌ای را برای سفارشی‌سازی بیشتر در سخنرانی‌های آینده ایجاد می‌کند.",
                            },
                        },
                        // 66 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Building a Custom List Item",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker discusses how to improve the appearance of transaction cards in a mobile app using Flutter. The speaker suggests structuring each transaction with the price in a box on the left, the title in bold text next to it, and the date below. The speaker explains how to achieve this layout using rows, containers, and columns in Flutter code. The tutorial demonstrates converting numbers to strings for display and arranging the elements to create a visually appealing transaction card layout.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial erläutert der Sprecher, wie sich das Erscheinungsbild von Transaktionskarten in einer mobilen App mithilfe von Flutter verbessern lässt. Der Sprecher schlägt vor, jede Transaktion so zu strukturieren, dass der Preis in einem Feld auf der linken Seite, der Titel in Fettschrift daneben und das Datum darunter stehen. Der Sprecher erklärt, wie sich dieses Layout mithilfe von Zeilen, Containern und Spalten im Flutter-Code erreichen lässt. Das Tutorial zeigt, wie Zahlen zur Anzeige in Zeichenfolgen umgewandelt und die Elemente so angeordnet werden, dass ein optisch ansprechendes Transaktionskarten-Layout entsteht.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者讨论了如何使用 Flutter 改善移动应用中交易卡的外观。演讲者建议将每笔交易的结构化为：价格在左侧的方框中，标题用粗体文本放在旁边，日期放在下方。演讲者解释了如何使用 Flutter 代码中的行、容器和列来实现这种布局。本教程演示了如何将数字转换为字符串以进行显示，以及如何排列元素以创建具有视觉吸引力的交易卡布局。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик обсуждает, как улучшить внешний вид карточек транзакций в мобильном приложении с помощью Flutter. Докладчик предлагает структурировать каждую транзакцию с ценой в поле слева, заголовком жирным шрифтом рядом с ним и датой ниже. Докладчик объясняет, как добиться этого макета с помощью строк, контейнеров и столбцов в коде Flutter. В руководстве демонстрируется преобразование чисел в строки для отображения и упорядочивание элементов для создания визуально привлекательного макета карточки транзакции.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant explique comment améliorer l'apparence des cartes de transaction dans une application mobile à l'aide de Flutter. L'intervenant suggère de structurer chaque transaction avec le prix dans une case à gauche, le titre en gras à côté et la date en dessous. L'intervenant explique comment réaliser cette mise en page en utilisant des lignes, des conteneurs et des colonnes dans le code Flutter. Le didacticiel montre comment convertir des nombres en chaînes pour l'affichage et organiser les éléments pour créer une mise en page de carte de transaction visuellement attrayante.",
                                // Japanese
                                "日本語": "このビデオ チュートリアルでは、Flutter を使用してモバイル アプリの取引カードの外観を改善する方法について説明します。各取引を左側のボックスに価格、その横に太字のタイトル、その下に日付を配置するように構成することを提案しています。また、Flutter コードの行、コンテナー、列を使用してこのレイアウトを実現する方法について説明します。このチュートリアルでは、数字を文字列に変換して表示し、要素を配置して視覚的に魅力的な取引カード レイアウトを作成する方法を示します。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 Flutter를 사용하여 모바일 앱에서 거래 카드의 모양을 개선하는 방법을 설명합니다. 발표자는 각 거래를 왼쪽 상자에 가격, 그 옆에 굵은 글씨로 제목, 그리고 아래에 날짜로 구조화할 것을 제안합니다. 발표자는 Flutter 코드에서 행, 컨테이너, 열을 사용하여 이 레이아웃을 구현하는 방법을 설명합니다. 이 튜토리얼은 숫자를 문자열로 변환하여 표시하고 요소를 배열하여 시각적으로 매력적인 거래 카드 레이아웃을 만드는 방법을 보여줍니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador explica cómo mejorar la apariencia de las tarjetas de transacción en una aplicación móvil con Flutter. El orador sugiere estructurar cada transacción con el precio en un cuadro a la izquierda, el título en negrita al lado y la fecha debajo. El orador explica cómo lograr este diseño usando filas, contenedores y columnas en el código de Flutter. El tutorial demuestra cómo convertir números en cadenas para su visualización y organizar los elementos para crear un diseño de tarjeta de transacción visualmente atractivo.",
                                // Hindi
                                "हिंदी": "در این آموزش تصویری، سخنران به نحوه بهبود ظاهر کارت های تراکنش در اپلیکیشن موبایل با استفاده از فلاتر می پردازد. گوینده پیشنهاد می کند که ساختار هر تراکنش را با قیمت در کادری در سمت چپ، عنوان با متن پررنگ در کنار آن و تاریخ زیر تنظیم کنید. سخنران نحوه دستیابی به این طرح را با استفاده از سطرها، کانتینرها و ستون ها در کد فلاتر توضیح می دهد. این آموزش تبدیل اعداد به رشته ها را برای نمایش و مرتب کردن عناصر برای ایجاد یک طرح کارت تراکنش جذاب بصری نشان می دهد.",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador discute como melhorar a aparência dos cartões de transação numa aplicação móvel utilizando Flutter. O orador sugere estruturar cada transação com o preço numa caixa à esquerda, o título a negrito ao lado e a data abaixo. O orador explica como conseguir este layout utilizando linhas, contentores e colunas no código Flutter. O tutorial demonstra a conversão de números em strings para exibição e a organização dos elementos para criar um layout de cartão de transação visualmente apelativo.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার আলোচনা করেছেন কিভাবে ফ্লটার ব্যবহার করে মোবাইল অ্যাপে লেনদেন কার্ডের চেহারা উন্নত করা যায়। স্পিকার বাম দিকে একটি বাক্সে মূল্য সহ প্রতিটি লেনদেন গঠন করার পরামর্শ দেন, এর পাশে গাঢ় পাঠে শিরোনাম এবং নীচের তারিখ। ফ্লাটার কোডে সারি, কন্টেনার এবং কলাম ব্যবহার করে কীভাবে এই লেআউটটি অর্জন করা যায় তা স্পিকার ব্যাখ্যা করেন। টিউটোরিয়ালটি প্রদর্শনের জন্য সংখ্যাগুলিকে স্ট্রিংগুলিতে রূপান্তরিত করে এবং একটি দৃশ্যত আকর্ষণীয় লেনদেন কার্ড লেআউট তৈরি করতে উপাদানগুলিকে সাজিয়ে দেখায়৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يناقش المتحدث كيفية تحسين مظهر بطاقات المعاملات في تطبيق جوال باستخدام Flutter. يقترح المتحدث هيكلة كل معاملة بالسعر في مربع على اليسار، والعنوان بخط غامق بجواره، والتاريخ أدناه. يشرح المتحدث كيفية تحقيق هذا التخطيط باستخدام الصفوف والحاويات والأعمدة في كود Flutter. يوضح البرنامج التعليمي تحويل الأرقام إلى سلاسل للعرض وترتيب العناصر لإنشاء تخطيط بطاقة معاملة جذاب بصريًا.",
                                // Persian
                                "فارسی": "در این آموزش تصویری، سخنران به نحوه بهبود ظاهر کارت های تراکنش در اپلیکیشن موبایل با استفاده از فلاتر می پردازد. گوینده پیشنهاد می کند که ساختار هر تراکنش را با قیمت در کادری در سمت چپ، عنوان با متن پررنگ در کنار آن و تاریخ زیر تنظیم کنید. سخنران نحوه دستیابی به این طرح را با استفاده از سطرها، کانتینرها و ستون ها در کد فلاتر توضیح می دهد. این آموزش تبدیل اعداد به رشته ها را برای نمایش و مرتب کردن عناصر برای ایجاد یک طرح کارت تراکنش جذاب بصری نشان می دهد.",
                            },
                        },
                        // 67 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Styling a Container",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker explains how to enhance the appearance of a transaction card in a Flutter mobile app by focusing on styling. The speaker discusses how styling in Flutter is achieved through the arguments passed to widgets, contrasting it with CSS in web development. The tutorial demonstrates using containers to add spacing and background color to elements, as well as incorporating EdgeInsets and BoxDecoration to create borders and padding. The speaker emphasizes the flexibility of styling using different Flutter classes and provides step-by-step guidance on adjusting text styles and appearance within the app layout.",
                                // German
                                "Deutsch": "In diesem Tutorial erklärt der Sprecher, wie man das Erscheinungsbild einer Transaktionskarte in einer Flutter-Mobil-App durch Fokussierung auf das Styling verbessern kann. Der Sprecher erläutert, wie das Styling in Flutter durch die an Widgets übergebenen Argumente erreicht wird, und vergleicht es mit CSS in der Webentwicklung. Das Tutorial zeigt die Verwendung von Containern, um Elementen Abstand und Hintergrundfarbe hinzuzufügen, sowie die Einbindung von EdgeInsets und BoxDecoration zum Erstellen von Rahmen und Polsterung. Der Sprecher betont die Flexibilität des Stylings mithilfe verschiedener Flutter-Klassen und bietet eine Schritt-für-Schritt-Anleitung zum Anpassen von Textstilen und Erscheinungsbild innerhalb des App-Layouts.",
                                // Chinese
                                "中国人": "在本教程中，演讲者将重点介绍如何通过样式来增强 Flutter 移动应用中交易卡的外观。演讲者讨论了 Flutter 中如何通过传递给小部件的参数来实现样式，并将其与 Web 开发中的 CSS 进行了对比。本教程演示了如何使用容器为元素添加间距和背景颜色，以及如何结合使用 EdgeInsets 和 BoxDecoration 来创建边框和填充。演讲者强调了使用不同 Flutter 类进行样式设置的灵活性，并提供了在应用布局中调整文本样式和外观的分步指导。",
                                // Russian
                                "Русский": "В этом уроке докладчик объясняет, как улучшить внешний вид карточки транзакции в мобильном приложении Flutter, сосредоточившись на стилизации. Докладчик обсуждает, как стилизация во Flutter достигается с помощью аргументов, передаваемых виджетам, противопоставляя это CSS в веб-разработке. В уроке демонстрируется использование контейнеров для добавления интервалов и цвета фона к элементам, а также включение EdgeInsets и BoxDecoration для создания границ и отступов. Докладчик подчеркивает гибкость стилизации с использованием различных классов Flutter и дает пошаговые инструкции по настройке стилей текста и внешнего вида в макете приложения.",
                                // French
                                "Français": "Dans ce tutoriel, l'intervenant explique comment améliorer l'apparence d'une carte de transaction dans une application mobile Flutter en se concentrant sur le style. L'intervenant explique comment le style dans Flutter est obtenu grâce aux arguments passés aux widgets, en le comparant au CSS dans le développement Web. Le tutoriel montre comment utiliser des conteneurs pour ajouter de l'espacement et de la couleur d'arrière-plan aux éléments, ainsi que l'intégration d'EdgeInsets et de BoxDecoration pour créer des bordures et un remplissage. L'intervenant met l'accent sur la flexibilité du style à l'aide de différentes classes Flutter et fournit des conseils étape par étape sur l'ajustement des styles de texte et de l'apparence dans la mise en page de l'application.",
                                // Japanese
                                "日本語": "このチュートリアルでは、スタイル設定に焦点を当てて、Flutter モバイル アプリの取引カードの外観を向上させる方法について説明します。また、ウィジェットに渡される引数によって Flutter のスタイル設定がどのように実現されるかについて説明し、Web 開発の CSS と対比します。このチュートリアルでは、コンテナーを使用して要素にスペースと背景色を追加する方法、および EdgeInsets と BoxDecoration を組み込んで境界線とパディングを作成する方法を示します。さまざまな Flutter クラスを使用したスタイルの柔軟性を強調し、アプリ レイアウト内でテキスト スタイルと外観を調整する手順を段階的に説明します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 스타일링에 초점을 맞춰 Flutter 모바일 앱에서 거래 카드의 모양을 개선하는 방법을 설명합니다. 발표자는 Flutter에서 스타일링이 위젯에 전달된 인수를 통해 어떻게 달성되는지 논의하고 웹 개발에서 CSS와 대조합니다. 이 튜토리얼에서는 컨테이너를 사용하여 요소에 간격과 배경색을 추가하는 방법과 EdgeInsets와 BoxDecoration을 통합하여 테두리와 패딩을 만드는 방법을 보여줍니다. 발표자는 다양한 Flutter 클래스를 사용하여 스타일링의 유연성을 강조하고 앱 레이아웃 내에서 텍스트 스타일과 모양을 조정하는 방법에 대한 단계별 지침을 제공합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador explica cómo mejorar la apariencia de una tarjeta de transacción en una aplicación móvil de Flutter centrándose en el estilo. El orador analiza cómo se logra el estilo en Flutter a través de los argumentos que se pasan a los widgets, comparándolo con CSS en el desarrollo web. El tutorial demuestra el uso de contenedores para agregar espaciado y color de fondo a los elementos, así como la incorporación de EdgeInsets y BoxDecoration para crear bordes y relleno. El orador enfatiza la flexibilidad del estilo utilizando diferentes clases de Flutter y brinda una guía paso a paso sobre cómo ajustar los estilos de texto y la apariencia dentro del diseño de la aplicación.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता स्टाइलिंग पर ध्यान केंद्रित करके फ़्लटर मोबाइल ऐप में ट्रांज़ेक्शन कार्ड की उपस्थिति को बढ़ाने का तरीका बताता है। वक्ता चर्चा करता है कि फ़्लटर में स्टाइलिंग को विजेट्स को दिए गए तर्कों के माध्यम से कैसे प्राप्त किया जाता है, इसे वेब डेवलपमेंट में CSS के साथ तुलना करते हुए। ट्यूटोरियल कंटेनर का उपयोग करके तत्वों में स्पेसिंग और बैकग्राउंड रंग जोड़ने के साथ-साथ बॉर्डर और पैडिंग बनाने के लिए EdgeInsets और BoxDecoration को शामिल करने का प्रदर्शन करता है। वक्ता अलग-अलग फ़्लटर क्लास का उपयोग करके स्टाइलिंग के लचीलेपन पर ज़ोर देता है और ऐप लेआउट के भीतर टेक्स्ट स्टाइल और उपस्थिति को समायोजित करने पर चरण-दर-चरण मार्गदर्शन प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador explica como melhorar a aparência de um cartão de transação numa aplicação móvel Flutter, concentrando-se no estilo. O orador discute como o estilo no Flutter é conseguido através dos argumentos passados ​​aos widgets, contrastando-o com o CSS no desenvolvimento web. O tutorial demonstra a utilização de contentores para adicionar espaçamento e cor de fundo aos elementos, bem como a incorporação de EdgeInsets e BoxDecoration para criar margens e preenchimento. O orador enfatiza a flexibilidade do estilo utilizando diferentes classes Flutter e fornece orientação passo a passo sobre como ajustar os estilos de texto e a aparência no layout da aplicação.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার ব্যাখ্যা করেছেন যে কীভাবে স্টাইলিংয়ে ফোকাস করে একটি ফ্লাটার মোবাইল অ্যাপে একটি লেনদেন কার্ডের উপস্থিতি বাড়ানো যায়। স্পিকার আলোচনা করেন যে কীভাবে ফ্লটারে স্টাইলিং উইজেটগুলিতে পাস করা আর্গুমেন্টের মাধ্যমে অর্জন করা হয়, এটি ওয়েব ডেভেলপমেন্টে CSS এর সাথে বৈপরীত্য করে। টিউটোরিয়ালটি উপাদানগুলিতে ব্যবধান এবং পটভূমির রঙ যোগ করার জন্য কন্টেইনার ব্যবহার করে, পাশাপাশি সীমানা এবং প্যাডিং তৈরি করতে EdgeInsets এবং BoxDecoration অন্তর্ভুক্ত করে। স্পিকার বিভিন্ন ফ্লটার ক্লাস ব্যবহার করে স্টাইলিং এর নমনীয়তার উপর জোর দেয় এবং অ্যাপ লেআউটের মধ্যে পাঠ্য শৈলী এবং চেহারা সামঞ্জস্য করার জন্য ধাপে ধাপে নির্দেশনা প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يشرح المتحدث كيفية تحسين مظهر بطاقة المعاملات في تطبيق Flutter للجوال من خلال التركيز على التصميم. يناقش المتحدث كيفية تحقيق التصميم في Flutter من خلال الوسائط التي يتم تمريرها إلى عناصر واجهة المستخدم، ومقارنتها بـ CSS في تطوير الويب. يوضح البرنامج التعليمي استخدام الحاويات لإضافة المسافات ولون الخلفية إلى العناصر، بالإضافة إلى دمج EdgeInsets وBoxDecoration لإنشاء الحدود والحشو. يؤكد المتحدث على مرونة التصميم باستخدام فئات Flutter المختلفة ويقدم إرشادات خطوة بخطوة حول ضبط أنماط النص ومظهره داخل تخطيط التطبيق.",
                                // Persian
                                "فارسی": "در این آموزش، سخنران نحوه بهبود ظاهر کارت تراکنش را در اپلیکیشن موبایل فلاتر با تمرکز بر استایل توضیح می دهد. سخنران در مورد اینکه چگونه استایل کردن در Flutter از طریق آرگومان های ارسال شده به ویجت ها به دست می آید و آن را با CSS در توسعه وب مقایسه می کند، بحث می کند. این آموزش استفاده از کانتینرها را برای افزودن فاصله و رنگ پس‌زمینه به عناصر، و همچنین ترکیب EdgeInsets و BoxDecoration برای ایجاد حاشیه‌ها و padding نشان می‌دهد. بلندگو بر انعطاف پذیری استایل با استفاده از کلاس های مختلف فلاتر تأکید می کند و راهنمایی های گام به گام در مورد تنظیم سبک متن و ظاهر در طرح بندی برنامه ارائه می دهد.",
                            },
                        },
                        // 68 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Styling Text",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker demonstrates how to customize the appearance of text elements in a Flutter app using text styles. By accessing the text style properties, the speaker shows how to adjust the font weight to bold and increase the font size for a more visually appealing text display. Additionally, the speaker changes the text color to purple and explains how to modify the border color of the container to match. The tutorial emphasizes the flexibility of adjusting text styles in Flutter and encourages viewers to explore similar style adjustments for other elements like titles and dates, providing guidance on making the text visually appealing and properly formatted within the app layout.",
                                // German
                                "Deutsch": "In diesem Tutorial demonstriert der Sprecher, wie man das Erscheinungsbild von Textelementen in einer Flutter-App mithilfe von Textstilen anpasst. Durch Zugriff auf die Textstileigenschaften zeigt der Sprecher, wie man die Schriftstärke auf Fett ändert und die Schriftgröße vergrößert, um eine optisch ansprechendere Textanzeige zu erhalten. Darüber hinaus ändert der Sprecher die Textfarbe in Lila und erklärt, wie man die Rahmenfarbe des Containers entsprechend ändert. Das Tutorial betont die Flexibilität bei der Anpassung von Textstilen in Flutter und ermutigt die Zuschauer, ähnliche Stilanpassungen für andere Elemente wie Titel und Daten auszuprobieren, und bietet Anleitungen, wie man den Text optisch ansprechend und im App-Layout richtig formatiert.",
                                // Chinese
                                "中国人": "在本教程中，演讲者演示了如何使用文本样式自定义 Flutter 应用中文本元素的外观。通过访问文本样式属性，演讲者展示了如何将字体粗细调整为粗体并增加字体大小，以获得更具视觉吸引力的文本显示。此外，演讲者将文本颜色更改为紫色，并解释了如何修改容器的边框颜色以匹配。本教程强调了在 Flutter 中调整文本样式的灵活性，并鼓励观众探索对标题和日期等其他元素进行类似的样式调整，并提供了有关使文本在应用布局中具有视觉吸引力和正确格式化的指导。",
                                // Russian
                                "Русский": "В этом руководстве докладчик демонстрирует, как настраивать внешний вид текстовых элементов в приложении Flutter с помощью стилей текста. Используя свойства стиля текста, докладчик показывает, как настроить жирность шрифта на полужирный и увеличить размер шрифта для более визуально привлекательного отображения текста. Кроме того, докладчик меняет цвет текста на фиолетовый и объясняет, как изменить цвет границы контейнера для соответствия. В руководстве подчеркивается гибкость настройки стилей текста во Flutter и предлагается зрителям изучить аналогичные настройки стилей для других элементов, таких как заголовки и даты, предоставляя рекомендации по созданию визуально привлекательного и правильно отформатированного текста в макете приложения.",
                                // French
                                "Français": "Dans ce didacticiel, l'intervenant montre comment personnaliser l'apparence des éléments de texte dans une application Flutter à l'aide de styles de texte. En accédant aux propriétés de style de texte, l'intervenant montre comment ajuster le poids de la police en gras et augmenter la taille de la police pour un affichage de texte plus attrayant visuellement. De plus, l'intervenant change la couleur du texte en violet et explique comment modifier la couleur de la bordure du conteneur pour qu'elle corresponde. Le didacticiel met l'accent sur la flexibilité de réglage des styles de texte dans Flutter et encourage les spectateurs à explorer des ajustements de style similaires pour d'autres éléments tels que les titres et les dates, en fournissant des conseils pour rendre le texte visuellement attrayant et correctement formaté dans la mise en page de l'application.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講師がテキスト スタイルを使用して Flutter アプリのテキスト要素の外観をカスタマイズする方法を紹介します。テキスト スタイルのプロパティにアクセスして、フォントの太さを太字に調整し、フォント サイズを大きくして、より見栄えの良いテキスト表示にする方法を紹介します。さらに、講師はテキストの色を紫に変更し、それに合わせてコンテナーの境界線の色を変更する方法を説明します。このチュートリアルでは、Flutter でテキスト スタイルを調整する柔軟性を強調し、タイトルや日付などの他の要素でも同様のスタイル調整を試すように視聴者に勧め、テキストを視覚的に魅力的にし、アプリ レイアウト内で適切にフォーマットするためのガイダンスを提供します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 텍스트 스타일을 사용하여 Flutter 앱에서 텍스트 요소의 모양을 사용자 지정하는 방법을 보여줍니다. 발표자는 텍스트 스타일 속성에 액세스하여 글꼴 두께를 굵게 조정하고 글꼴 크기를 늘려 시각적으로 더 매력적인 텍스트 표시를 하는 방법을 보여줍니다. 또한 발표자는 텍스트 색상을 보라색으로 변경하고 컨테이너의 테두리 색상을 수정하여 일치시키는 방법을 설명합니다. 이 튜토리얼은 Flutter에서 텍스트 스타일을 조정하는 것의 유연성을 강조하고 시청자가 제목 및 날짜와 같은 다른 요소에 대해 유사한 스타일 조정을 탐색하도록 장려하여 텍스트를 시각적으로 매력적으로 만들고 앱 레이아웃 내에서 적절하게 포맷하는 방법에 대한 지침을 제공합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador demuestra cómo personalizar la apariencia de los elementos de texto en una aplicación Flutter usando estilos de texto. Al acceder a las propiedades de estilo de texto, el orador muestra cómo ajustar el grosor de la fuente a negrita y aumentar el tamaño de la fuente para una visualización de texto más atractiva visualmente. Además, el orador cambia el color del texto a violeta y explica cómo modificar el color del borde del contenedor para que coincida. El tutorial enfatiza la flexibilidad de ajustar los estilos de texto en Flutter y alienta a los espectadores a explorar ajustes de estilo similares para otros elementos como títulos y fechas, brindando orientación sobre cómo hacer que el texto sea visualmente atractivo y tenga el formato adecuado dentro del diseño de la aplicación.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता यह दर्शाता है कि टेक्स्ट स्टाइल का उपयोग करके फ़्लटर ऐप में टेक्स्ट तत्वों की उपस्थिति को कैसे अनुकूलित किया जाए। टेक्स्ट स्टाइल गुणों तक पहुँचकर, वक्ता दिखाता है कि फ़ॉन्ट वज़न को बोल्ड में कैसे समायोजित किया जाए और अधिक दृश्यमान रूप से आकर्षक टेक्स्ट डिस्प्ले के लिए फ़ॉन्ट आकार को कैसे बढ़ाया जाए। इसके अतिरिक्त, वक्ता टेक्स्ट के रंग को बैंगनी में बदलता है और बताता है कि कंटेनर के बॉर्डर के रंग को कैसे बदला जाए। ट्यूटोरियल फ़्लटर में टेक्स्ट स्टाइल को समायोजित करने की लचीलेपन पर जोर देता है और दर्शकों को शीर्षकों और तिथियों जैसे अन्य तत्वों के लिए समान स्टाइल समायोजन का पता लगाने के लिए प्रोत्साहित करता है, जो ऐप लेआउट के भीतर टेक्स्ट को दृश्यमान रूप से आकर्षक और उचित रूप से फ़ॉर्मेट करने पर मार्गदर्शन प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador demonstra como personalizar a aparência dos elementos de texto numa aplicação Flutter utilizando estilos de texto. Ao aceder às propriedades de estilo de texto, o orador mostra como ajustar a espessura da fonte para negrito e aumentar o tamanho da fonte para uma apresentação de texto mais visualmente apelativa. Além disso, o orador altera a cor do texto para roxo e explica como modificar a cor da borda do contentor para que corresponda. O tutorial enfatiza a flexibilidade de ajustar os estilos de texto no Flutter e incentiva os espectadores a explorar ajustes de estilo semelhantes para outros elementos, como títulos e datas, fornecendo orientações sobre como tornar o texto visualmente apelativo e devidamente formatado no layout da aplicação.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার টেক্সট শৈলী ব্যবহার করে একটি ফ্লাটার অ্যাপে টেক্সট উপাদানের উপস্থিতি কাস্টমাইজ করার পদ্ধতি প্রদর্শন করে। পাঠ্য শৈলী বৈশিষ্ট্যগুলি অ্যাক্সেস করে, স্পিকার দেখায় কিভাবে ফন্টের ওজনকে বোল্ডে সামঞ্জস্য করা যায় এবং আরও দৃষ্টিকটু আকর্ষণীয় পাঠ্য প্রদর্শনের জন্য ফন্টের আকার বাড়াতে হয়। উপরন্তু, স্পিকার পাঠ্যের রঙ বেগুনিতে পরিবর্তন করে এবং ধারকটির সীমানা রঙটি মেলে কীভাবে পরিবর্তন করতে হয় তা ব্যাখ্যা করে। টিউটোরিয়ালটি ফ্লটারে পাঠ্য শৈলী সামঞ্জস্য করার নমনীয়তার উপর জোর দেয় এবং দর্শকদের শিরোনাম এবং তারিখের মতো অন্যান্য উপাদানগুলির জন্য অনুরূপ শৈলী সামঞ্জস্যগুলি অন্বেষণ করতে উত্সাহিত করে, পাঠ্যটিকে দৃশ্যত আকর্ষণীয় এবং অ্যাপ লেআউটের মধ্যে সঠিকভাবে ফর্ম্যাট করার বিষয়ে নির্দেশিকা প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يوضح المتحدث كيفية تخصيص مظهر عناصر النص في تطبيق Flutter باستخدام أنماط النص. من خلال الوصول إلى خصائص نمط النص، يوضح المتحدث كيفية ضبط وزن الخط ليكون غامقًا وزيادة حجم الخط لعرض نص أكثر جاذبية بصريًا. بالإضافة إلى ذلك، يغير المتحدث لون النص إلى اللون الأرجواني ويشرح كيفية تعديل لون حدود الحاوية لتتناسب معه. يؤكد البرنامج التعليمي على مرونة ضبط أنماط النص في Flutter ويشجع المشاهدين على استكشاف تعديلات نمط مماثلة لعناصر أخرى مثل العناوين والتاريخ، مما يوفر إرشادات حول جعل النص جذابًا بصريًا ومنسقًا بشكل صحيح داخل تخطيط التطبيق.",
                                // Persian
                                "فارسی": "در این آموزش، سخنران نحوه سفارشی کردن ظاهر عناصر متنی در برنامه Flutter را با استفاده از سبک های متن نشان می دهد. با دسترسی به ویژگی های سبک متن، بلندگو نشان می دهد که چگونه وزن قلم را به صورت پررنگ تنظیم کنید و اندازه قلم را برای نمایش متن جذاب تر از نظر بصری افزایش دهید. علاوه بر این، بلندگو رنگ متن را به بنفش تغییر می‌دهد و نحوه تغییر رنگ حاشیه ظرف را توضیح می‌دهد تا مطابقت داشته باشد. این آموزش بر انعطاف‌پذیری تنظیم سبک‌های متن در Flutter تأکید می‌کند و بینندگان را تشویق می‌کند تا تنظیمات سبک مشابه را برای عناصر دیگر مانند عناوین و تاریخ‌ها بررسی کنند، و راهنمایی‌هایی را برای جذاب‌تر کردن متن از نظر بصری و قالب‌بندی مناسب در طرح‌بندی برنامه ارائه می‌دهد.",
                            },
                        },
                        // 69 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "More Styling!",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker guides viewers through adjusting the alignment, text styles, and colors of transaction items in a Flutter app. The tutorial starts by modifying the left-to-right positioning of elements in a column using cross-axis alignment. The speaker then demonstrates how to set the font size and font weight for the title, creating a visually appealing appearance. Additionally, the date text is formatted with a gray color using text styles. The tutorial emphasizes the importance of these style adjustments in enhancing the transaction items within the app layout, encouraging viewers to further refine the elements for an improved overall design.",
                                // German
                                "Deutsch": "In diesem Tutorial führt der Sprecher die Zuschauer durch die Anpassung der Ausrichtung, Textstile und Farben von Transaktionselementen in einer Flutter-App. Das Tutorial beginnt mit der Änderung der Links-Rechts-Positionierung von Elementen in einer Spalte mithilfe der achsenübergreifenden Ausrichtung. Der Sprecher demonstriert dann, wie man die Schriftgröße und -stärke für den Titel einstellt, um ein optisch ansprechendes Erscheinungsbild zu erzielen. Darüber hinaus wird der Datumstext mithilfe von Textstilen in Grau formatiert. Das Tutorial betont die Bedeutung dieser Stilanpassungen bei der Verbesserung der Transaktionselemente im App-Layout und ermutigt die Zuschauer, die Elemente weiter zu verfeinern, um ein verbessertes Gesamtdesign zu erzielen.",
                                // Chinese
                                "中国人": "在本教程中，演讲者将指导观众调整 Flutter 应用中交易项目的对齐方式、文本样式和颜色。本教程首先使用横轴对齐修改列中元素从左到右的定位。然后，演讲者演示如何设置标题的字体大小和字体粗细，以创建视觉上吸引人的外观。此外，使用文本样式将日期文本格式化为灰色。本教程强调了这些样式调整对于增强应用布局中的交易项目的重要性，鼓励观众进一步优化元素以改进整体设计。",
                                // Russian
                                "Русский": "В этом руководстве докладчик проводит зрителей через настройку выравнивания, стилей текста и цветов элементов транзакций в приложении Flutter. Руководство начинается с изменения расположения элементов слева направо в столбце с использованием выравнивания по поперечной оси. Затем докладчик демонстрирует, как задать размер и начертание шрифта для заголовка, создавая визуально привлекательный вид. Кроме того, текст даты форматируется серым цветом с использованием стилей текста. Руководство подчеркивает важность этих настроек стиля для улучшения элементов транзакций в макете приложения, побуждая зрителей к дальнейшей доработке элементов для улучшения общего дизайна.",
                                // French
                                "Français": "Dans ce didacticiel, l'intervenant guide les spectateurs dans le réglage de l'alignement, des styles de texte et des couleurs des éléments de transaction dans une application Flutter. Le didacticiel commence par modifier le positionnement de gauche à droite des éléments d'une colonne à l'aide de l'alignement sur les axes transversaux. L'intervenant montre ensuite comment définir la taille et le poids de la police du titre, créant ainsi une apparence visuellement attrayante. De plus, le texte de la date est formaté avec une couleur grise à l'aide de styles de texte. Le didacticiel souligne l'importance de ces ajustements de style pour améliorer les éléments de transaction dans la mise en page de l'application, encourageant les spectateurs à affiner davantage les éléments pour une conception globale améliorée.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講演者が視聴者に Flutter アプリのトランザクション項目の配置、テキスト スタイル、および色の調整方法を案内します。チュートリアルは、交差軸配置を使用して列内の要素の左から右への配置を変更することから始まります。次に、講演者はタイトルのフォント サイズとフォントの太さを設定し、視覚的に魅力的な外観を作成する方法を示します。さらに、日付のテキストはテキスト スタイルを使用して灰色でフォーマットされます。このチュートリアルでは、アプリ レイアウト内のトランザクション項目を強化するためのこれらのスタイル調整の重要性を強調し、視聴者に要素をさらに改良して全体的なデザインを改善するよう促します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 시청자에게 Flutter 앱에서 거래 항목의 정렬, 텍스트 스타일 및 색상을 조정하는 방법을 안내합니다. 이 튜토리얼은 교차 축 정렬을 사용하여 열의 요소를 왼쪽에서 오른쪽으로 배치하는 것으로 시작합니다. 그런 다음 발표자는 제목의 글꼴 크기와 글꼴 두께를 설정하여 시각적으로 매력적인 모양을 만드는 방법을 보여줍니다. 또한 날짜 텍스트는 텍스트 스타일을 사용하여 회색으로 서식이 지정됩니다. 이 튜토리얼은 앱 레이아웃 내에서 거래 항목을 향상시키는 데 있어 이러한 스타일 조정의 중요성을 강조하여 시청자가 전반적인 디자인을 개선하기 위해 요소를 더욱 세부적으로 조정하도록 권장합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador guía a los espectadores a través del ajuste de la alineación, los estilos de texto y los colores de los elementos de transacción en una aplicación Flutter. El tutorial comienza modificando la posición de izquierda a derecha de los elementos en una columna mediante la alineación de eje transversal. Luego, el orador demuestra cómo configurar el tamaño y el grosor de la fuente para el título, creando una apariencia visualmente atractiva. Además, el texto de la fecha se formatea con un color gris mediante estilos de texto. El tutorial enfatiza la importancia de estos ajustes de estilo para mejorar los elementos de transacción dentro del diseño de la aplicación, lo que alienta a los espectadores a refinar aún más los elementos para lograr un diseño general mejorado.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता दर्शकों को फ़्लटर ऐप में लेन-देन आइटम के संरेखण, टेक्स्ट शैलियों और रंगों को समायोजित करने के बारे में मार्गदर्शन करता है। ट्यूटोरियल क्रॉस-एक्सिस संरेखण का उपयोग करके कॉलम में तत्वों की बाएँ से दाएँ स्थिति को संशोधित करके शुरू होता है। फिर वक्ता प्रदर्शित करता है कि शीर्षक के लिए फ़ॉन्ट आकार और फ़ॉन्ट वज़न कैसे सेट करें, जिससे एक आकर्षक रूप बनता है। इसके अतिरिक्त, टेक्स्ट शैलियों का उपयोग करके दिनांक टेक्स्ट को ग्रे रंग से फ़ॉर्मेट किया जाता है। ट्यूटोरियल ऐप लेआउट के भीतर लेन-देन आइटम को बढ़ाने में इन शैली समायोजनों के महत्व पर जोर देता है, दर्शकों को बेहतर समग्र डिज़ाइन के लिए तत्वों को और अधिक परिष्कृत करने के लिए प्रोत्साहित करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador orienta os visualizadores no ajuste do alinhamento, estilos de texto e cores dos itens de transação numa aplicação Flutter. O tutorial começa por modificar o posicionamento da esquerda para a direita dos elementos numa coluna utilizando o alinhamento de eixos cruzados. O orador demonstra então como definir o tamanho e a espessura da fonte para o título, criando um aspeto visualmente apelativo. Além disso, o texto da data é formatado a cinzento através de estilos de texto. O tutorial enfatiza a importância destes ajustes de estilo no melhoramento dos itens de transação no layout da aplicação, incentivando os espectadores a refinar ainda mais os elementos para obter um design geral melhorado.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার একটি ফ্লাটার অ্যাপে সারিবদ্ধকরণ, পাঠ্য শৈলী এবং লেনদেনের আইটেমগুলির রঙ সামঞ্জস্য করার মাধ্যমে দর্শকদের গাইড করে। টিউটোরিয়ালটি ক্রস-অক্ষ প্রান্তিককরণ ব্যবহার করে একটি কলামে উপাদানগুলির বাম-থেকে-ডান অবস্থান পরিবর্তন করে শুরু হয়। স্পিকার তারপর দেখান কিভাবে শিরোনামের জন্য ফন্টের আকার এবং ফন্টের ওজন সেট করতে হয়, একটি দৃশ্যমান আকর্ষণীয় চেহারা তৈরি করে। উপরন্তু, টেক্সট শৈলী ব্যবহার করে তারিখের পাঠ্য একটি ধূসর রঙ দিয়ে ফরম্যাট করা হয়। টিউটোরিয়ালটি অ্যাপ লেআউটের মধ্যে লেনদেন আইটেমগুলিকে উন্নত করতে এই শৈলী সমন্বয়গুলির গুরুত্বের উপর জোর দেয়, একটি উন্নত সামগ্রিক ডিজাইনের জন্য উপাদানগুলিকে আরও পরিমার্জিত করতে দর্শকদের উত্সাহিত করে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يرشد المتحدث المشاهدين خلال تعديل محاذاة وأنماط النص وألوان عناصر المعاملات في تطبيق Flutter. يبدأ البرنامج التعليمي بتعديل وضع العناصر من اليسار إلى اليمين في عمود باستخدام محاذاة المحور المتقاطع. ثم يوضح المتحدث كيفية ضبط حجم الخط ووزن الخط للعنوان، مما يخلق مظهرًا جذابًا بصريًا. بالإضافة إلى ذلك، يتم تنسيق نص التاريخ بلون رمادي باستخدام أنماط النص. يؤكد البرنامج التعليمي على أهمية تعديلات الأسلوب هذه في تحسين عناصر المعاملات داخل تخطيط التطبيق، مما يشجع المشاهدين على تحسين العناصر بشكل أكبر للحصول على تصميم عام محسّن.",
                                // Persian
                                "فارسی": "در این آموزش، بلندگو بینندگان را از طریق تنظیم تراز، سبک متن و رنگ موارد تراکنش در یک برنامه Flutter راهنمایی می کند. این آموزش با تغییر موقعیت چپ به راست عناصر در یک ستون با استفاده از تراز محوری شروع می شود. سپس بلندگو نحوه تنظیم اندازه فونت و وزن قلم را برای عنوان نشان می دهد و ظاهر بصری جذابی ایجاد می کند. علاوه بر این، متن تاریخ با استفاده از سبک های متن با رنگ خاکستری قالب بندی می شود. این آموزش بر اهمیت این تنظیمات سبک در افزایش موارد تراکنش در طرح‌بندی برنامه تأکید می‌کند و بینندگان را تشویق می‌کند تا عناصر را برای طراحی کلی بهبود یافته اصلاح کنند.",
                            },
                        },
                        // 70 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Containers vs Columns vs Rows",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker emphasizes the importance of understanding the functionalities and differences between containers, columns, and rows in Flutter app development. The tutorial highlights that containers offer rich alignment and styling options, making them perfect for custom styling, alignment, and sizing, while columns and rows are essential for organizing widgets next to or above each other. The speaker explains that these three widgets are crucial building blocks in Flutter and can be combined and mixed to create flexible user interfaces. By demonstrating the unique features and use cases of containers, columns, and rows, the tutorial provides viewers with valuable insights on utilizing these widgets effectively in app design.",
                                // German
                                "Deutsch": "In diesem Tutorial betont der Sprecher, wie wichtig es ist, die Funktionen und Unterschiede zwischen Containern, Spalten und Zeilen bei der Entwicklung von Flutter-Apps zu verstehen. Das Tutorial hebt hervor, dass Container umfangreiche Ausrichtungs- und Gestaltungsoptionen bieten, wodurch sie sich perfekt für benutzerdefinierte Gestaltung, Ausrichtung und Größenanpassung eignen, während Spalten und Zeilen für die Anordnung von Widgets nebeneinander oder übereinander unerlässlich sind. Der Sprecher erklärt, dass diese drei Widgets entscheidende Bausteine ​​in Flutter sind und kombiniert und gemischt werden können, um flexible Benutzeroberflächen zu erstellen. Durch die Demonstration der einzigartigen Funktionen und Anwendungsfälle von Containern, Spalten und Zeilen bietet das Tutorial den Zuschauern wertvolle Einblicke in die effektive Nutzung dieser Widgets beim App-Design.",
                                // Chinese
                                "中国人": "在本教程中，演讲者强调了在 Flutter 应用开发中了解容器、列和行之间的功能和差异的重要性。本教程强调容器提供了丰富的对齐和样式选项，非常适合自定义样式、对齐和大小，而列和行对于将小部件并排或上下组织至关重要。演讲者解释说，这三个小部件是 Flutter 中的关键构建块，可以组合和混合使用以创建灵活的用户界面。通过演示容器、列和行的独特功能和用例，本教程为观众提供了在应用设计中有效利用这些小部件的宝贵见解。",
                                // Russian
                                "Русский": "В этом руководстве докладчик подчеркивает важность понимания функциональности и различий между контейнерами, столбцами и строками при разработке приложений Flutter. В руководстве подчеркивается, что контейнеры предлагают богатые возможности выравнивания и стилизации, что делает их идеальными для индивидуального стиля, выравнивания и изменения размера, в то время как столбцы и строки необходимы для организации виджетов рядом или друг над другом. Докладчик объясняет, что эти три виджета являются важнейшими строительными блоками во Flutter и могут быть объединены и смешаны для создания гибких пользовательских интерфейсов. Демонстрируя уникальные функции и варианты использования контейнеров, столбцов и строк, руководство предоставляет зрителям ценную информацию об эффективном использовании этих виджетов в дизайне приложений.",
                                // French
                                "Français": "Dans ce tutoriel, l'intervenant souligne l'importance de comprendre les fonctionnalités et les différences entre les conteneurs, les colonnes et les lignes dans le développement d'applications Flutter. Le tutoriel souligne que les conteneurs offrent de riches options d'alignement et de style, ce qui les rend parfaits pour le style, l'alignement et le dimensionnement personnalisés, tandis que les colonnes et les lignes sont essentielles pour organiser les widgets les uns à côté des autres ou les uns au-dessus des autres. L'intervenant explique que ces trois widgets sont des éléments de base essentiels dans Flutter et peuvent être combinés et mélangés pour créer des interfaces utilisateur flexibles. En démontrant les fonctionnalités uniques et les cas d'utilisation des conteneurs, des colonnes et des lignes, le tutoriel fournit aux spectateurs des informations précieuses sur l'utilisation efficace de ces widgets dans la conception d'applications.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講演者は Flutter アプリ開発におけるコンテナ、列、行の機能と違いを理解することの重要性を強調しています。チュートリアルでは、コンテナには豊富な配置とスタイルのオプションがあり、カスタム スタイル、配置、サイズ設定に最適である一方、列と行はウィジェットを隣り合わせまたは上下に並べるために不可欠であることを強調しています。講演者は、これら 3 つのウィジェットが Flutter の重要な構成要素であり、組み合わせて混合することで柔軟なユーザー インターフェースを作成できることを説明しています。コンテナ、列、行の独自の機能と使用例を紹介することで、チュートリアルでは、アプリ設計でこれらのウィジェットを効果的に活用するための貴重な洞察を視聴者に提供します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 Flutter 앱 개발에서 컨테이너, 열, 행 간의 기능과 차이점을 이해하는 것의 중요성을 강조합니다. 이 튜토리얼은 컨테이너가 풍부한 정렬 및 스타일 옵션을 제공하여 사용자 지정 스타일, 정렬 및 크기에 적합한 반면 열과 행은 위젯을 나란히 또는 위에 구성하는 데 필수적이라고 강조합니다. 발표자는 이 세 가지 위젯이 Flutter에서 중요한 구성 요소이며 결합하고 혼합하여 유연한 사용자 인터페이스를 만들 수 있다고 설명합니다. 컨테이너, 열, 행의 고유한 기능과 사용 사례를 보여줌으로써 이 튜토리얼은 시청자에게 앱 디자인에서 이러한 위젯을 효과적으로 활용하는 데 대한 귀중한 통찰력을 제공합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador enfatiza la importancia de comprender las funcionalidades y las diferencias entre los contenedores, las columnas y las filas en el desarrollo de aplicaciones Flutter. El tutorial destaca que los contenedores ofrecen opciones de alineación y estilo enriquecidas, lo que los hace perfectos para el estilo, la alineación y el tamaño personalizados, mientras que las columnas y las filas son esenciales para organizar los widgets uno al lado del otro o uno encima del otro. El orador explica que estos tres widgets son bloques de construcción cruciales en Flutter y se pueden combinar y mezclar para crear interfaces de usuario flexibles. Al demostrar las características y los casos de uso únicos de los contenedores, las columnas y las filas, el tutorial proporciona a los espectadores información valiosa sobre cómo utilizar estos widgets de manera eficaz en el diseño de aplicaciones.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता फ़्लटर ऐप डेवलपमेंट में कंटेनर, कॉलम और पंक्तियों के बीच की कार्यक्षमता और अंतर को समझने के महत्व पर ज़ोर देता है। ट्यूटोरियल इस बात पर प्रकाश डालता है कि कंटेनर समृद्ध संरेखण और स्टाइलिंग विकल्प प्रदान करते हैं, जो उन्हें कस्टम स्टाइलिंग, संरेखण और आकार देने के लिए एकदम सही बनाते हैं, जबकि कॉलम और पंक्तियाँ एक दूसरे के बगल में या ऊपर विजेट को व्यवस्थित करने के लिए आवश्यक हैं। वक्ता बताते हैं कि ये तीन विजेट फ़्लटर में महत्वपूर्ण बिल्डिंग ब्लॉक हैं और लचीले उपयोगकर्ता इंटरफ़ेस बनाने के लिए इन्हें संयोजित और मिश्रित किया जा सकता है। कंटेनर, कॉलम और पंक्तियों की अनूठी विशेषताओं और उपयोग के मामलों का प्रदर्शन करके, ट्यूटोरियल दर्शकों को ऐप डिज़ाइन में इन विजेट का प्रभावी ढंग से उपयोग करने के बारे में मूल्यवान जानकारी प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador realça a importância de compreender as funcionalidades e as diferenças entre contentores, colunas e linhas no desenvolvimento de aplicações Flutter. O tutorial destaca que os contentores oferecem opções avançadas de alinhamento e estilo, tornando-os perfeitos para estilo, alinhamento e dimensionamento personalizados, enquanto as colunas e linhas são essenciais para organizar widgets próximos ou acima uns dos outros. O orador explica que estes três widgets são blocos de construção cruciais no Flutter e podem ser combinados e misturados para criar interfaces de utilizador flexíveis. Ao demonstrar as características únicas e os casos de utilização de contentores, colunas e linhas, o tutorial fornece aos visualizadores informações valiosas sobre a utilização eficaz destes widgets no design de aplicações.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার ফ্লাটার অ্যাপ ডেভেলপমেন্টে কন্টেইনার, কলাম এবং সারিগুলির মধ্যে কার্যকারিতা এবং পার্থক্য বোঝার গুরুত্বের উপর জোর দিয়েছেন। টিউটোরিয়াল হাইলাইট করে যে কন্টেইনারগুলি সমৃদ্ধ সারিবদ্ধকরণ এবং স্টাইলিং বিকল্পগুলি অফার করে, যা তাদের কাস্টম স্টাইলিং, প্রান্তিককরণ এবং আকার দেওয়ার জন্য নিখুঁত করে তোলে, যখন কলাম এবং সারিগুলি একে অপরের পাশে বা উপরে উইজেটগুলি সংগঠিত করার জন্য অপরিহার্য। স্পিকার ব্যাখ্যা করেছেন যে এই তিনটি উইজেট হল ফ্লটারে গুরুত্বপূর্ণ বিল্ডিং ব্লক এবং নমনীয় ব্যবহারকারী ইন্টারফেস তৈরি করতে একত্রিত এবং মিশ্রিত করা যেতে পারে। কন্টেনার, কলাম এবং সারিগুলির অনন্য বৈশিষ্ট্য এবং ব্যবহারের ক্ষেত্রে প্রদর্শন করে, টিউটোরিয়ালটি দর্শকদের অ্যাপ ডিজাইনে কার্যকরভাবে এই উইজেটগুলি ব্যবহার করার বিষয়ে মূল্যবান অন্তর্দৃষ্টি প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يؤكد المتحدث على أهمية فهم الوظائف والاختلافات بين الحاويات والأعمدة والصفوف في تطوير تطبيقات Flutter. يسلط البرنامج التعليمي الضوء على أن الحاويات توفر خيارات محاذاة وتصميم غنية، مما يجعلها مثالية للتصميم والمحاذاة والحجم المخصص، في حين أن الأعمدة والصفوف ضرورية لتنظيم عناصر واجهة المستخدم بجوار بعضها البعض أو فوق بعضها البعض. يشرح المتحدث أن هذه العناصر الثلاثة هي لبنات بناء أساسية في Flutter ويمكن دمجها وخلطها لإنشاء واجهات مستخدم مرنة. من خلال إظهار الميزات الفريدة وحالات الاستخدام للحاويات والأعمدة والصفوف، يوفر البرنامج التعليمي للمشاهدين رؤى قيمة حول استخدام هذه العناصر بشكل فعال في تصميم التطبيق.",
                                // Persian
                                "فارسی": "در این آموزش، سخنران بر اهمیت درک عملکردها و تفاوت‌های بین کانتینرها، ستون‌ها و ردیف‌ها در توسعه اپلیکیشن Flutter تاکید می‌کند. این آموزش بر این نکته تاکید می‌کند که کانتینرها گزینه‌های چیدمان و استایل غنی را ارائه می‌دهند، و آنها را برای استایل‌بندی، هم‌ترازی و اندازه‌بندی سفارشی عالی می‌کند، در حالی که ستون‌ها و ردیف‌ها برای سازمان‌دهی ویجت‌ها در کنار یا بالای یکدیگر ضروری هستند. سخنران توضیح می‌دهد که این سه ویجت، بلوک‌های سازنده حیاتی در Flutter هستند و می‌توانند برای ایجاد رابط کاربری انعطاف‌پذیر با هم ترکیب و ترکیب شوند. این آموزش با نشان دادن ویژگی‌های منحصر به فرد و موارد استفاده کانتینرها، ستون‌ها و ردیف‌ها، بینش‌های ارزشمندی را در مورد استفاده مؤثر از این ویجت‌ها در طراحی اپلیکیشن به بینندگان ارائه می‌دهد.",
                            },
                        },
                        // 71 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Using String Interpolation",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker demonstrates how to manipulate and format output data in a Flutter app by adding a dollar sign in front of the price amount. Initially outputting the amount using the to string method, the speaker explains how to concatenate strings to include the dollar sign. However, encountering an issue with special characters like the dollar sign, the speaker introduces string interpolation syntax in Dart to overcome this challenge. By using the dollar sign followed by curly braces to reference variables within strings, the speaker effectively adds the dollar sign to the price amount, showcasing the significance of understanding special characters and syntax in string manipulation for app development.",
                                // German
                                "Deutsch": "In diesem Tutorial zeigt der Sprecher, wie Ausgabedaten in einer Flutter-App bearbeitet und formatiert werden, indem vor den Preisbetrag ein Dollarzeichen gesetzt wird. Zunächst gibt der Sprecher den Betrag mit der Methode „to string“ aus und erklärt, wie Zeichenfolgen verknüpft werden, um das Dollarzeichen einzuschließen. Da jedoch ein Problem mit Sonderzeichen wie dem Dollarzeichen auftritt, stellt der Sprecher die Zeichenfolgeninterpolationssyntax in Dart vor, um dieses Problem zu lösen. Indem der Sprecher das Dollarzeichen gefolgt von geschweiften Klammern verwendet, um Variablen innerhalb von Zeichenfolgen zu referenzieren, fügt er dem Preisbetrag effektiv das Dollarzeichen hinzu und zeigt, wie wichtig es ist, Sonderzeichen und Syntax bei der Zeichenfolgenmanipulation für die App-Entwicklung zu verstehen.",
                                // Chinese
                                "中国人": "在本教程中，演讲者演示了如何在 Flutter 应用中通过在价格金额前添加美元符号来操作和格式化输出数据。首先使用 to string 方法输出金额，演讲者解释了如何连接字符串以包含美元符号。但是，遇到美元符号等特殊字符的问题时，演讲者在 Dart 中引入了字符串插值语法来克服这一挑战。通过使用美元符号后跟花括号来引用字符串中的变量，演讲者有效地将美元符号添加到价格金额中，展示了了解字符串操作中的特殊字符和语法对于应用开发的重要性。",
                                // Russian
                                "Русский": "В этом уроке докладчик демонстрирует, как обрабатывать и форматировать выходные данные в приложении Flutter, добавляя знак доллара перед суммой цены. Первоначально выводя сумму с помощью метода to string, докладчик объясняет, как объединять строки, чтобы включить знак доллара. Однако, столкнувшись с проблемой со специальными символами, такими как знак доллара, докладчик представляет синтаксис интерполяции строк в Dart, чтобы преодолеть эту проблему. Используя знак доллара, за которым следуют фигурные скобки для ссылки на переменные в строках, докладчик фактически добавляет знак доллара к сумме цены, демонстрируя важность понимания специальных символов и синтаксиса при обработке строк для разработки приложений.",
                                // French
                                "Français": "Dans ce didacticiel, l'intervenant montre comment manipuler et formater les données de sortie dans une application Flutter en ajoutant un signe dollar devant le montant du prix. En générant initialement le montant à l'aide de la méthode to string, l'intervenant explique comment concaténer des chaînes pour inclure le signe dollar. Cependant, rencontrant un problème avec des caractères spéciaux comme le signe dollar, l'intervenant introduit la syntaxe d'interpolation de chaîne dans Dart pour surmonter ce défi. En utilisant le signe dollar suivi d'accolades pour référencer des variables dans des chaînes, l'intervenant ajoute efficacement le signe dollar au montant du prix, montrant l'importance de comprendre les caractères spéciaux et la syntaxe dans la manipulation de chaînes pour le développement d'applications.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講演者は、価格の前にドル記号を追加することで、Flutter アプリで出力データを操作およびフォーマットする方法を説明します。最初に to string メソッドを使用して金額を出力し、講演者は文字列を連結してドル記号を含める方法を説明します。ただし、ドル記号などの特殊文字で問題が発生したため、講演者はこの課題を克服するために Dart の文字列補間構文を紹介します。講演者は、ドル記号の後に中括弧を付けて文字列内の変数を参照することで、価格にドル記号を効果的に追加し、アプリ開発における文字列操作で特殊文字と構文を理解することの重要性を示します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 Flutter 앱에서 가격 금액 앞에 달러 기호를 추가하여 출력 데이터를 조작하고 포맷하는 방법을 보여줍니다. 처음에 to string 메서드를 사용하여 금액을 출력한 후, 발표자는 달러 기호를 포함하도록 문자열을 연결하는 방법을 설명합니다. 그러나 달러 기호와 같은 특수 문자에 문제가 발생하면 발표자는 이 문제를 해결하기 위해 Dart에서 문자열 보간 구문을 소개합니다. 달러 기호 뒤에 중괄호를 사용하여 문자열 내의 변수를 참조함으로써 발표자는 효과적으로 가격 금액에 달러 기호를 추가하여 앱 개발을 위한 문자열 조작에서 특수 문자와 구문을 이해하는 것의 중요성을 보여줍니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador demuestra cómo manipular y formatear los datos de salida en una aplicación Flutter agregando un signo de dólar delante del monto del precio. Inicialmente, generando el monto con el método to string, el orador explica cómo concatenar cadenas para incluir el signo de dólar. Sin embargo, al encontrar un problema con caracteres especiales como el signo de dólar, el orador presenta la sintaxis de interpolación de cadenas en Dart para superar este desafío. Al usar el signo de dólar seguido de llaves para hacer referencia a variables dentro de cadenas, el orador agrega efectivamente el signo de dólar al monto del precio, lo que demuestra la importancia de comprender los caracteres especiales y la sintaxis en la manipulación de cadenas para el desarrollo de aplicaciones.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता मूल्य राशि के सामने डॉलर चिह्न जोड़कर फ़्लटर ऐप में आउटपुट डेटा में हेरफेर और फ़ॉर्मेटिंग करने का तरीका प्रदर्शित करता है। स्ट्रिंग विधि का उपयोग करके राशि को शुरू में आउटपुट करते हुए, वक्ता बताता है कि डॉलर चिह्न को शामिल करने के लिए स्ट्रिंग को कैसे संयोजित किया जाए। हालाँकि, डॉलर चिह्न जैसे विशेष वर्णों के साथ एक समस्या का सामना करते हुए, वक्ता इस चुनौती को दूर करने के लिए डार्ट में स्ट्रिंग इंटरपोलेशन सिंटैक्स पेश करता है। स्ट्रिंग के भीतर चर को संदर्भित करने के लिए कर्ली ब्रेसिज़ के बाद डॉलर चिह्न का उपयोग करके, वक्ता प्रभावी रूप से मूल्य राशि में डॉलर चिह्न जोड़ता है, जो ऐप विकास के लिए स्ट्रिंग हेरफेर में विशेष वर्णों और सिंटैक्स को समझने के महत्व को प्रदर्शित करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador demonstra como manipular e formatar dados de saída numa aplicação Flutter, adicionando um cifrão à frente do valor do preço. Exibindo inicialmente o valor através do método to string, o orador explica como concatenar strings para incluir o cifrão. No entanto, ao encontrar um problema com caracteres especiais como o cifrão, o orador introduz a sintaxe de interpolação de strings no Dart para superar este desafio. Ao utilizar o cifrão seguido de chaves para referenciar variáveis ​​dentro de strings, o orador adiciona efetivamente o cifrão ao valor do preço, mostrando a importância de compreender caracteres especiais e sintaxe na manipulação de strings para o desenvolvimento de aplicações.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার প্রদর্শন করে যে কীভাবে মূল্যের পরিমাণের সামনে একটি ডলার চিহ্ন যুক্ত করে একটি ফ্লাটার অ্যাপে আউটপুট ডেটা ম্যানিপুলেট এবং ফর্ম্যাট করা যায়। প্রাথমিকভাবে টু স্ট্রিং পদ্ধতি ব্যবহার করে পরিমাণ আউটপুট করে, স্পিকার ব্যাখ্যা করেন কীভাবে ডলার চিহ্ন অন্তর্ভুক্ত করতে স্ট্রিংগুলিকে সংযুক্ত করতে হয়। যাইহোক, ডলার চিহ্নের মতো বিশেষ অক্ষরগুলির সাথে একটি সমস্যার সম্মুখীন হলে, স্পিকার এই চ্যালেঞ্জটি কাটিয়ে উঠতে ডার্টে স্ট্রিং ইন্টারপোলেশন সিনট্যাক্স প্রবর্তন করেন। স্ট্রিং-এর মধ্যে ভেরিয়েবল রেফারেন্স করার জন্য ডলার চিহ্নের পরে কোঁকড়া ধনুর্বন্ধনী ব্যবহার করে, স্পিকার কার্যকরভাবে দামের পরিমাণে ডলার চিহ্ন যোগ করে, অ্যাপ ডেভেলপমেন্টের জন্য স্ট্রিং ম্যানিপুলেশনে বিশেষ অক্ষর এবং সিনট্যাক্স বোঝার তাত্পর্য প্রদর্শন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يوضح المتحدث كيفية التعامل مع بيانات الإخراج وتنسيقها في تطبيق Flutter عن طريق إضافة علامة الدولار أمام مبلغ السعر. في البداية، يقوم بإخراج المبلغ باستخدام طريقة السلسلة إلى، ويشرح المتحدث كيفية ربط السلاسل لتضمين علامة الدولار. ومع ذلك، عند مواجهة مشكلة مع الأحرف الخاصة مثل علامة الدولار، يقدم المتحدث بناء جملة استيفاء السلسلة في Dart للتغلب على هذا التحدي. من خلال استخدام علامة الدولار متبوعة بأقواس متعرجة للإشارة إلى المتغيرات داخل السلاسل، يضيف المتحدث بشكل فعال علامة الدولار إلى مبلغ السعر، مما يوضح أهمية فهم الأحرف الخاصة وبناء الجملة في التعامل مع السلاسل لتطوير التطبيقات.",
                                // Persian
                                "فارسی": "در این آموزش، بلندگو نحوه دستکاری و قالب‌بندی داده‌های خروجی را در یک برنامه Flutter با افزودن یک علامت دلار در مقابل مقدار قیمت نشان می‌دهد. در ابتدا با استفاده از روش to string مقدار را خروجی می‌کند، گوینده نحوه به هم پیوستن رشته‌ها را برای گنجاندن علامت دلار توضیح می‌دهد. با این حال، گوینده با مشکلی در کاراکترهای خاص مانند علامت دلار، نحو درون یابی رشته ای را در دارت معرفی می کند تا بر این چالش غلبه کند. با استفاده از علامت دلار به دنبال پرانتزهای فرفری برای متغیرهای مرجع در رشته‌ها، گوینده به طور موثر علامت دلار را به مقدار قیمت اضافه می‌کند و اهمیت درک کاراکترهای خاص و نحو را در دستکاری رشته برای توسعه برنامه نشان می‌دهد.",
                            },
                        },
                        // 72 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Installing External Packages & Formatting Dates",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker introduces the concept of string interpolation and demonstrates how to format dates using an external package in a Flutter app. Discussing the benefits of string interpolation for optimizing code efficiency, the speaker then explains the limitations of default date formatting options in Dart and Flutter, leading to the recommendation of using the intl package for enhanced date formatting. By demonstrating the process of installing the package through the pub.dev site and importing it into the code, the speaker showcases how to utilize the date format object to create human-readable date strings. Further explaining different ways to customize date formats using pattern strings and preconfigured constructors within the intl package, the tutorial offers viewers valuable insights on effectively formatting dates in their app projects.",
                                // German
                                "Deutsch": "In diesem Tutorial stellt der Sprecher das Konzept der String-Interpolation vor und zeigt, wie man Daten mithilfe eines externen Pakets in einer Flutter-App formatiert. Der Sprecher erörtert die Vorteile der String-Interpolation zur Optimierung der Code-Effizienz und erläutert dann die Einschränkungen der standardmäßigen Datumsformatierungsoptionen in Dart und Flutter. Dies führt zu der Empfehlung, das intl-Paket für eine verbesserte Datumsformatierung zu verwenden. Indem der Sprecher den Installationsprozess des Pakets über die pub.dev-Site und den Import in den Code demonstriert, zeigt er, wie man das Datumsformatobjekt verwendet, um menschenlesbare Datumszeichenfolgen zu erstellen. Das Tutorial erklärt außerdem verschiedene Möglichkeiten zum Anpassen von Datumsformaten mithilfe von Musterzeichenfolgen und vorkonfigurierten Konstruktoren innerhalb des intl-Pakets und bietet den Zuschauern wertvolle Einblicke in die effektive Formatierung von Daten in ihren App-Projekten.",
                                // Chinese
                                "中国人": "在本教程中，演讲者介绍了字符串插值的概念，并演示了如何在 Flutter 应用中使用外部包来格式化日期。演讲者讨论了字符串插值对优化代码效率的好处，然后解释了 Dart 和 Flutter 中默认日期格式化选项的局限性，并推荐使用 intl 包来增强日期格式化。通过演示通过 pub.dev 网站安装包并将其导入代码的过程，演讲者展示了如何利用日期格式对象创建人类可读的日期字符串。本教程进一步解释了使用 intl 包中的模式字符串和预配置构造函数自定义日期格式的不同方法，为观众提供了在其应用项目中有效格式化日期的宝贵见解。",
                                // Russian
                                "Русский": "В этом руководстве докладчик знакомит с концепцией интерполяции строк и демонстрирует, как форматировать даты с помощью внешнего пакета в приложении Flutter. Обсуждая преимущества интерполяции строк для оптимизации эффективности кода, докладчик затем объясняет ограничения параметров форматирования дат по умолчанию в Dart и Flutter, что приводит к рекомендации использовать пакет intl для расширенного форматирования дат. Демонстрируя процесс установки пакета через сайт pub.dev и импорта его в код, докладчик показывает, как использовать объект формата даты для создания понятных человеку строк даты. Далее объясняя различные способы настройки форматов дат с помощью строк шаблонов и предварительно настроенных конструкторов в пакете intl, руководство предлагает зрителям ценную информацию об эффективном форматировании дат в своих проектах приложений.",
                                // French
                                "Français": "Dans ce didacticiel, l'intervenant présente le concept d'interpolation de chaîne et montre comment formater des dates à l'aide d'un package externe dans une application Flutter. Après avoir discuté des avantages de l'interpolation de chaîne pour optimiser l'efficacité du code, l'intervenant explique ensuite les limites des options de formatage de date par défaut dans Dart et Flutter, ce qui conduit à la recommandation d'utiliser le package intl pour un formatage de date amélioré. En démontrant le processus d'installation du package via le site pub.dev et en l'important dans le code, l'intervenant montre comment utiliser l'objet de format de date pour créer des chaînes de date lisibles par l'homme. En expliquant plus en détail les différentes manières de personnaliser les formats de date à l'aide de chaînes de modèle et de constructeurs préconfigurés dans le package intl, le didacticiel offre aux utilisateurs des informations précieuses sur le formatage efficace des dates dans leurs projets d'application.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講演者が文字列補間の概念を紹介し、Flutter アプリで外部パッケージを使用して日付をフォーマットする方法を示します。コード効率を最適化するための文字列補間の利点について説明した後、講演者は Dart と Flutter のデフォルトの日付フォーマット オプションの制限について説明し、日付フォーマットを強化するために intl パッケージを使用することを推奨します。pub.dev サイトからパッケージをインストールしてコードにインポートするプロセスを実演することで、講演者は日付フォーマット オブジェクトを使用して人間が読める日付文字列を作成する方法を紹介します。さらに、intl パッケージ内のパターン文字列と事前構成されたコンストラクターを使用して日付フォーマットをカスタマイズするさまざまな方法について説明し、チュートリアルは視聴者にアプリ プロジェクトで日付を効果的にフォーマットするための貴重な洞察を提供します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 문자열 보간의 개념을 소개하고 Flutter 앱에서 외부 패키지를 사용하여 날짜를 형식화하는 방법을 보여줍니다. 코드 효율성을 최적화하기 위한 문자열 보간의 이점에 대해 논의한 후, 발표자는 Dart와 Flutter에서 기본 날짜 형식 옵션의 한계를 설명하여 향상된 날짜 형식을 위해 intl 패키지를 사용하는 것이 좋습니다. 발표자는 pub.dev 사이트를 통해 패키지를 설치하고 코드로 가져오는 프로세스를 보여줌으로써 날짜 형식 객체를 사용하여 사람이 읽을 수 있는 날짜 문자열을 만드는 방법을 보여줍니다. intl 패키지 내의 패턴 문자열과 미리 구성된 생성자를 사용하여 날짜 형식을 사용자 지정하는 다양한 방법을 추가로 설명하면서, 이 튜토리얼은 시청자에게 앱 프로젝트에서 날짜를 효과적으로 형식화하는 방법에 대한 귀중한 통찰력을 제공합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador presenta el concepto de interpolación de cadenas y demuestra cómo formatear fechas usando un paquete externo en una aplicación Flutter. Luego de analizar los beneficios de la interpolación de cadenas para optimizar la eficiencia del código, el orador explica las limitaciones de las opciones de formato de fecha predeterminadas en Dart y Flutter, lo que lleva a la recomendación de usar el paquete intl para un formato de fecha mejorado. Al demostrar el proceso de instalación del paquete a través del sitio pub.dev e importarlo al código, el orador muestra cómo utilizar el objeto de formato de fecha para crear cadenas de fecha legibles para humanos. Además, explica diferentes formas de personalizar formatos de fecha usando cadenas de patrones y constructores preconfigurados dentro del paquete intl, el tutorial ofrece a los espectadores información valiosa sobre cómo formatear fechas de manera eficaz en sus proyectos de aplicaciones.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता स्ट्रिंग इंटरपोलेशन की अवधारणा का परिचय देता है और प्रदर्शित करता है कि फ़्लटर ऐप में बाहरी पैकेज का उपयोग करके तिथियों को कैसे फ़ॉर्मेट किया जाए। कोड दक्षता को अनुकूलित करने के लिए स्ट्रिंग इंटरपोलेशन के लाभों पर चर्चा करते हुए, वक्ता डार्ट और फ़्लटर में डिफ़ॉल्ट दिनांक फ़ॉर्मेटिंग विकल्पों की सीमाओं को समझाता है, जिससे बेहतर दिनांक फ़ॉर्मेटिंग के लिए intl पैकेज का उपयोग करने की अनुशंसा की जाती है। pub.dev साइट के माध्यम से पैकेज को इंस्टॉल करने और इसे कोड में आयात करने की प्रक्रिया का प्रदर्शन करके, वक्ता दिखाता है कि मानव-पठनीय दिनांक स्ट्रिंग बनाने के लिए दिनांक फ़ॉर्मेट ऑब्जेक्ट का उपयोग कैसे करें। intl पैकेज के भीतर पैटर्न स्ट्रिंग और प्रीकॉन्फ़िगर किए गए कंस्ट्रक्टर का उपयोग करके दिनांक फ़ॉर्मेट को कस्टमाइज़ करने के विभिन्न तरीकों को आगे समझाते हुए, ट्यूटोरियल दर्शकों को उनके ऐप प्रोजेक्ट में प्रभावी ढंग से दिनांक फ़ॉर्मेट करने पर मूल्यवान जानकारी प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador apresenta o conceito de interpolação de strings e demonstra como formatar datas utilizando um pacote externo numa aplicação Flutter. Discutindo os benefícios da interpolação de strings para otimizar a eficiência do código, o orador explica as limitações das opções de formatação de data padrão no Dart e no Flutter, levando à recomendação de utilizar o pacote intl para uma formatação de data melhorada. Ao demonstrar o processo de instalação do pacote através do site pub.dev e ao importá-lo para o código, o orador mostra como utilizar o objeto de formato de data para criar strings de data legíveis por humanos. Explicando ainda mais as diferentes formas de personalizar os formatos de data utilizando strings de padrão e construtores pré-configurados dentro do pacote intl, o tutorial oferece aos visualizadores informações valiosas sobre como formatar datas de forma eficaz nos seus projetos de aplicação.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার স্ট্রিং ইন্টারপোলেশনের ধারণাটি প্রবর্তন করে এবং একটি ফ্লাটার অ্যাপে একটি বাহ্যিক প্যাকেজ ব্যবহার করে তারিখগুলি কীভাবে ফর্ম্যাট করা যায় তা প্রদর্শন করে। কোড দক্ষতা অপ্টিমাইজ করার জন্য স্ট্রিং ইন্টারপোলেশনের সুবিধাগুলি নিয়ে আলোচনা করে, স্পিকার তারপরে ডার্ট এবং ফ্লাটারে ডিফল্ট তারিখ বিন্যাস বিকল্পগুলির সীমাবদ্ধতা ব্যাখ্যা করে, যার ফলে উন্নত তারিখ বিন্যাসকরণের জন্য intl প্যাকেজ ব্যবহার করার সুপারিশ করা হয়। pub.dev সাইটের মাধ্যমে প্যাকেজটি ইনস্টল করার প্রক্রিয়া প্রদর্শন করে এবং কোডে এটি আমদানি করে, স্পিকার প্রদর্শন করে কিভাবে তারিখ বিন্যাস অবজেক্ট ব্যবহার করে মানব-পাঠযোগ্য তারিখ স্ট্রিং তৈরি করতে হয়। intl প্যাকেজের মধ্যে প্যাটার্ন স্ট্রিং এবং প্রি-কনফিগার করা কনস্ট্রাক্টর ব্যবহার করে তারিখ ফর্ম্যাটগুলি কাস্টমাইজ করার বিভিন্ন উপায় ব্যাখ্যা করে, টিউটোরিয়ালটি দর্শকদের তাদের অ্যাপ প্রকল্পগুলিতে কার্যকরভাবে তারিখগুলি ফর্ম্যাট করার বিষয়ে মূল্যবান অন্তর্দৃষ্টি প্রদান করে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يقدم المتحدث مفهوم استيفاء السلسلة ويوضح كيفية تنسيق التواريخ باستخدام حزمة خارجية في تطبيق Flutter. يناقش المتحدث فوائد استيفاء السلسلة لتحسين كفاءة الكود، ثم يشرح القيود المفروضة على خيارات تنسيق التاريخ الافتراضية في Dart وFlutter، مما يؤدي إلى التوصية باستخدام حزمة intl لتحسين تنسيق التاريخ. من خلال توضيح عملية تثبيت الحزمة من خلال موقع pub.dev واستيرادها إلى الكود، يعرض المتحدث كيفية استخدام كائن تنسيق التاريخ لإنشاء سلاسل تاريخ يمكن قراءتها بواسطة الإنسان. من خلال شرح المزيد من الطرق المختلفة لتخصيص تنسيقات التاريخ باستخدام سلاسل الأنماط والمنشئين المهيأين مسبقًا داخل حزمة intl، يقدم البرنامج التعليمي للمشاهدين رؤى قيمة حول تنسيق التواريخ بشكل فعال في مشاريع تطبيقاتهم.",
                                // Persian
                                "فارسی": "در این آموزش، سخنران مفهوم درون یابی رشته ای را معرفی می کند و نحوه قالب بندی تاریخ ها را با استفاده از یک بسته خارجی در یک برنامه فلاتر نشان می دهد. سخنران با بحث در مورد مزایای درونیابی رشته برای بهینه‌سازی کارایی کد، محدودیت‌های گزینه‌های قالب‌بندی پیش‌فرض تاریخ در Dart و Flutter را توضیح می‌دهد که منجر به توصیه استفاده از بسته بین‌المللی برای قالب‌بندی پیشرفته تاریخ می‌شود. با نشان دادن فرآیند نصب بسته از طریق سایت pub.dev و وارد کردن آن به کد، گوینده نحوه استفاده از شی قالب تاریخ را برای ایجاد رشته های تاریخ قابل خواندن توسط انسان نشان می دهد. علاوه بر توضیح بیشتر روش‌های مختلف برای سفارشی‌سازی قالب‌های تاریخ با استفاده از رشته‌های الگو و سازنده‌های از پیش تنظیم‌شده در بسته بین‌المللی، این آموزش بینش‌های ارزشمندی را در مورد قالب‌بندی مؤثر تاریخ‌ها در پروژه‌های برنامه‌شان به بینندگان ارائه می‌دهد.",
                            },
                        },
                        // 73 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Adding Text Input Widgets (TextField)",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker discusses adding a new input area for users to enter transaction data in a Flutter app. They demonstrate using the text field widget to create multiple text input fields within a card widget, and show how to add padding and labels to improve the layout and styling of the input area. The speaker also explains various configuration options for the text field widget, such as autocorrect and autofocus, and emphasizes the importance of experimenting with these settings and exploring the official documentation for further understanding.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial bespricht der Sprecher das Hinzufügen eines neuen Eingabebereichs, in den Benutzer Transaktionsdaten in einer Flutter-App eingeben können. Er demonstriert die Verwendung des Textfeld-Widgets zum Erstellen mehrerer Texteingabefelder innerhalb eines Karten-Widgets und zeigt, wie man Auffüllungen und Beschriftungen hinzufügt, um das Layout und den Stil des Eingabebereichs zu verbessern. Der Sprecher erklärt auch verschiedene Konfigurationsoptionen für das Textfeld-Widget, wie z. B. Autokorrektur und Autofokus, und betont, wie wichtig es ist, mit diesen Einstellungen zu experimentieren und die offizielle Dokumentation zum besseren Verständnis zu lesen.",
                                // Chinese
                                "中国人": "在此视频教程中，演讲者讨论了如何在 Flutter 应用中添加新的输入区域，供用户输入交易数据。他们演示了如何使用文本字段小部件在卡片小部件中创建多个文本输入字段，并展示了如何添加填充和标签以改善输入区域的布局和样式。演讲者还解释了文本字段小部件的各种配置选项，例如自动更正和自动对焦，并强调了尝试这些设置和探索官方文档以进一步理解的重要性。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик обсуждает добавление новой области ввода для пользователей, чтобы вводить данные транзакций в приложении Flutter. Они демонстрируют использование виджета текстового поля для создания нескольких полей ввода текста в виджете карточки и показывают, как добавлять отступы и метки для улучшения макета и стиля области ввода. Докладчик также объясняет различные параметры конфигурации для виджета текстового поля, такие как автокоррекция и автофокус, и подчеркивает важность экспериментов с этими настройками и изучения официальной документации для дальнейшего понимания.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant explique comment ajouter une nouvelle zone de saisie pour que les utilisateurs puissent saisir des données de transaction dans une application Flutter. Il montre comment utiliser le widget de champ de texte pour créer plusieurs champs de saisie de texte dans un widget de carte et comment ajouter du remplissage et des étiquettes pour améliorer la mise en page et le style de la zone de saisie. L'intervenant explique également diverses options de configuration pour le widget de champ de texte, telles que la correction automatique et la mise au point automatique, et souligne l'importance d'expérimenter ces paramètres et d'explorer la documentation officielle pour une meilleure compréhension.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、講演者が、Flutter アプリでユーザーが取引データを入力するための新しい入力領域を追加する方法について説明します。テキスト フィールド ウィジェットを使用してカード ウィジェット内に複数のテキスト入力フィールドを作成する方法と、パディングとラベルを追加して入力領域のレイアウトとスタイルを改善する方法を示します。講演者は、テキスト フィールド ウィジェットの自動修正や自動フォーカスなどのさまざまな構成オプションについても説明し、これらの設定を試して公式ドキュメントを調べて理解を深めることの重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 Flutter 앱에서 사용자가 거래 데이터를 입력할 수 있는 새로운 입력 영역을 추가하는 방법을 설명합니다. 발표자는 텍스트 필드 위젯을 사용하여 카드 위젯 내에 여러 텍스트 입력 필드를 만드는 방법을 보여주고, 패딩과 레이블을 추가하여 입력 영역의 레이아웃과 스타일을 개선하는 방법을 보여줍니다. 발표자는 또한 자동 수정 및 자동 초점과 같은 텍스트 필드 위젯의 다양한 구성 옵션을 설명하고, 이러한 설정을 실험하고 더 자세히 이해하기 위해 공식 문서를 탐색하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador analiza cómo agregar una nueva área de entrada para que los usuarios ingresen datos de transacciones en una aplicación Flutter. Demuestra cómo usar el widget de campo de texto para crear múltiples campos de entrada de texto dentro de un widget de tarjeta y muestra cómo agregar relleno y etiquetas para mejorar el diseño y el estilo del área de entrada. El orador también explica varias opciones de configuración para el widget de campo de texto, como autocorrección y enfoque automático, y enfatiza la importancia de experimentar con estas configuraciones y explorar la documentación oficial para comprender mejor.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता फ़्लटर ऐप में लेनदेन डेटा दर्ज करने के लिए उपयोगकर्ताओं के लिए एक नया इनपुट क्षेत्र जोड़ने पर चर्चा करता है। वे कार्ड विजेट के भीतर कई टेक्स्ट इनपुट फ़ील्ड बनाने के लिए टेक्स्ट फ़ील्ड विजेट का उपयोग करके प्रदर्शन करते हैं, और इनपुट क्षेत्र के लेआउट और स्टाइलिंग को बेहतर बनाने के लिए पैडिंग और लेबल जोड़ने का तरीका दिखाते हैं। वक्ता टेक्स्ट फ़ील्ड विजेट के लिए विभिन्न कॉन्फ़िगरेशन विकल्पों, जैसे ऑटोकरेक्ट और ऑटोफ़ोकस के बारे में भी बताते हैं, और इन सेटिंग्स के साथ प्रयोग करने और आगे की समझ के लिए आधिकारिक दस्तावेज़ों की खोज करने के महत्व पर ज़ोर देते हैं।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador discute a adição de uma nova área de entrada para os utilizadores introduzirem dados de transações numa aplicação Flutter. Demonstram a utilização do widget de campo de texto para criar vários campos de entrada de texto num widget de cartão e mostram como adicionar preenchimento e etiquetas para melhorar o layout e o estilo da área de entrada. O orador explica ainda várias opções de configuração do widget de campo de texto, como a correção automática e a focagem automática, e sublinha a importância de experimentar estas definições e explorar a documentação oficial para uma maior compreensão.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার একটি Flutter অ্যাপে লেনদেনের ডেটা প্রবেশ করার জন্য ব্যবহারকারীদের জন্য একটি নতুন ইনপুট এলাকা যোগ করার বিষয়ে আলোচনা করেছে। তারা একটি কার্ড উইজেটের মধ্যে একাধিক পাঠ্য ইনপুট ক্ষেত্র তৈরি করতে পাঠ্য ক্ষেত্র উইজেট ব্যবহার করে প্রদর্শন করে এবং ইনপুট এলাকার বিন্যাস এবং স্টাইলিং উন্নত করতে কীভাবে প্যাডিং এবং লেবেল যুক্ত করতে হয় তা দেখায়। স্পিকার পাঠ্য ক্ষেত্রের উইজেটের জন্য বিভিন্ন কনফিগারেশন বিকল্পগুলিও ব্যাখ্যা করে, যেমন স্বয়ংক্রিয় সংশোধন এবং অটোফোকাস, এবং এই সেটিংসগুলির সাথে পরীক্ষা করার এবং আরও বোঝার জন্য অফিসিয়াল ডকুমেন্টেশন অন্বেষণ করার গুরুত্বের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يناقش المتحدث إضافة منطقة إدخال جديدة للمستخدمين لإدخال بيانات المعاملات في تطبيق Flutter. ويوضحون استخدام عنصر واجهة المستخدم لحقل النص لإنشاء حقول إدخال نص متعددة داخل عنصر واجهة مستخدم للبطاقة، ويوضحون كيفية إضافة الحشو والعلامات لتحسين تخطيط منطقة الإدخال وأسلوبها. ويشرح المتحدث أيضًا خيارات التكوين المختلفة لعنصر واجهة مستخدم حقل النص، مثل التصحيح التلقائي والتركيز التلقائي، ويؤكد على أهمية تجربة هذه الإعدادات واستكشاف الوثائق الرسمية لمزيد من الفهم.",
                                // Persian
                                "فارسی": "در این آموزش ویدیویی، سخنران درباره افزودن یک ناحیه ورودی جدید برای کاربران برای وارد کردن داده‌های تراکنش در برنامه Flutter بحث می‌کند. آنها استفاده از ویجت فیلد متن را برای ایجاد چندین فیلد ورودی متن در یک ویجت کارت نشان می‌دهند و نشان می‌دهند که چگونه می‌توان بالشتک و برچسب‌ها را برای بهبود طرح‌بندی و استایل ناحیه ورودی اضافه کرد. سخنران همچنین گزینه‌های پیکربندی مختلف برای ویجت فیلد متن، مانند تصحیح خودکار و فوکوس خودکار را توضیح می‌دهد و بر اهمیت آزمایش با این تنظیمات و کاوش در اسناد رسمی برای درک بیشتر تأکید می‌کند.",
                            },
                        },
                        // 74 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Fetching User Input",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this informative video, the speaker explains the process of collecting user input in a Flutter app to add a new transaction. They discuss two ways to capture user input - manually saving it with each keystroke or using Flutter's built-in mechanism with text editing controllers. The speaker demonstrates how to set up text editing controllers for the title and amount input fields, allowing for easier access to the user's input. They emphasize the importance of transitioning to a stateful widget to update the list of transactions and display new transaction cards on the user interface. Throughout the tutorial, the speaker provides detailed explanations and practical examples to help viewers understand and implement the concepts effectively.",
                                // German
                                "Deutsch": "In diesem informativen Video erklärt der Sprecher den Vorgang des Erfassens von Benutzereingaben in einer Flutter-App, um eine neue Transaktion hinzuzufügen. Er bespricht zwei Möglichkeiten zum Erfassen von Benutzereingaben – das manuelle Speichern bei jedem Tastendruck oder die Verwendung des in Flutter integrierten Mechanismus mit Textbearbeitungs-Controllern. Der Sprecher demonstriert, wie Textbearbeitungs-Controller für die Eingabefelder für Titel und Betrag eingerichtet werden, um einen einfacheren Zugriff auf die Benutzereingaben zu ermöglichen. Er betont die Bedeutung des Übergangs zu einem Stateful-Widget, um die Liste der Transaktionen zu aktualisieren und neue Transaktionskarten auf der Benutzeroberfläche anzuzeigen. Während des gesamten Tutorials liefert der Sprecher detaillierte Erklärungen und praktische Beispiele, um den Zuschauern zu helfen, die Konzepte zu verstehen und effektiv umzusetzen.",
                                // Chinese
                                "中国人": "在这个信息丰富的视频中，演讲者解释了在 Flutter 应用中收集用户输入以添加新交易的过程。他们讨论了两种捕获用户输入的方法 - 每次击键时手动保存，或使用 Flutter 内置的文本编辑控制器机制。演讲者演示了如何为标题和金额输入字段设置文本编辑控制器，以便更轻松地访问用户的输入。他们强调了过渡到有状态小部件以更新交易列表并在用户界面上显示新交易卡的重要性。在整个教程中，演讲者提供了详细的解释和实际示例，以帮助观众理解和有效地实施这些概念。",
                                // Russian
                                "Русский": "В этом информативном видео докладчик объясняет процесс сбора пользовательского ввода в приложении Flutter для добавления новой транзакции. Они обсуждают два способа сбора пользовательского ввода — сохранение его вручную при каждом нажатии клавиши или использование встроенного механизма Flutter с контроллерами редактирования текста. Докладчик демонстрирует, как настроить контроллеры редактирования текста для полей ввода заголовка и суммы, что позволяет упростить доступ к вводу пользователя. Они подчеркивают важность перехода к виджету с отслеживанием состояния для обновления списка транзакций и отображения новых карточек транзакций в пользовательском интерфейсе. На протяжении всего руководства докладчик дает подробные объяснения и практические примеры, чтобы помочь зрителям понять и эффективно реализовать концепции.",
                                // French
                                "Français": "Dans cette vidéo informative, l'intervenant explique le processus de collecte des entrées utilisateur dans une application Flutter pour ajouter une nouvelle transaction. Il présente deux façons de capturer les entrées utilisateur : en les enregistrant manuellement à chaque frappe de touche ou en utilisant le mécanisme intégré de Flutter avec des contrôleurs d'édition de texte. L'intervenant montre comment configurer des contrôleurs d'édition de texte pour les champs de saisie du titre et du montant, ce qui permet un accès plus facile aux entrées de l'utilisateur. Il souligne l'importance de passer à un widget avec état pour mettre à jour la liste des transactions et afficher les nouvelles cartes de transaction sur l'interface utilisateur. Tout au long du didacticiel, l'intervenant fournit des explications détaillées et des exemples pratiques pour aider les spectateurs à comprendre et à mettre en œuvre efficacement les concepts.",
                                // Japanese
                                "日本語": "この有益なビデオでは、講演者が Flutter アプリでユーザー入力を収集して新しいトランザクションを追加するプロセスについて説明します。ユーザー入力をキャプチャする 2 つの方法について説明しています。キー入力ごとに手動で保存する方法と、テキスト編集コントローラーを備えた Flutter の組み込みメカニズムを使用する方法です。講演者は、タイトルと金額の入力フィールドにテキスト編集コントローラーを設定し、ユーザーの入力に簡単にアクセスできるようにする方法を示します。また、トランザクションのリストを更新し、ユーザー インターフェースに新しいトランザクション カードを表示するには、ステートフル ウィジェットに移行することの重要性を強調しています。チュートリアル全体を通して、講演者は詳細な説明と実用的な例を示し、視聴者が概念を効果的に理解して実装できるようにします。",
                                // Korean
                                "한국인": "이 유익한 비디오에서 발표자는 Flutter 앱에서 사용자 입력을 수집하여 새 거래를 추가하는 프로세스를 설명합니다. 발표자는 사용자 입력을 캡처하는 두 가지 방법, 즉 각 키 입력으로 수동으로 저장하거나 텍스트 편집 컨트롤러와 함께 Flutter의 기본 제공 메커니즘을 사용하는 방법을 논의합니다. 발표자는 제목 및 금액 입력 필드에 텍스트 편집 컨트롤러를 설정하는 방법을 보여 주며, 이를 통해 사용자 입력에 더 쉽게 액세스할 수 있습니다. 발표자는 거래 목록을 업데이트하고 사용자 인터페이스에 새 거래 카드를 표시하기 위해 상태 저장 위젯으로 전환하는 것의 중요성을 강조합니다. 발표자는 튜토리얼 전반에 걸쳐 자세한 설명과 실제 예를 제공하여 시청자가 개념을 효과적으로 이해하고 구현할 수 있도록 돕습니다.",
                                // Spanish
                                "Español": "En este video informativo, el orador explica el proceso de recopilación de información del usuario en una aplicación Flutter para agregar una nueva transacción. Analiza dos formas de capturar la información del usuario: guardándola manualmente con cada pulsación de tecla o utilizando el mecanismo integrado de Flutter con controladores de edición de texto. El orador demuestra cómo configurar controladores de edición de texto para los campos de entrada de título y monto, lo que permite un acceso más fácil a la información del usuario. Destaca la importancia de realizar la transición a un widget con estado para actualizar la lista de transacciones y mostrar nuevas tarjetas de transacciones en la interfaz de usuario. A lo largo del tutorial, el orador proporciona explicaciones detalladas y ejemplos prácticos para ayudar a los espectadores a comprender e implementar los conceptos de manera eficaz.",
                                // Hindi
                                "हिंदी": "इस जानकारीपूर्ण वीडियो में, वक्ता फ़्लटर ऐप में नया लेनदेन जोड़ने के लिए उपयोगकर्ता इनपुट एकत्र करने की प्रक्रिया के बारे में बताते हैं। वे उपयोगकर्ता इनपुट को कैप्चर करने के दो तरीकों पर चर्चा करते हैं - प्रत्येक कीस्ट्रोक के साथ इसे मैन्युअल रूप से सहेजना या टेक्स्ट एडिटिंग कंट्रोलर के साथ फ़्लटर के अंतर्निहित तंत्र का उपयोग करना। वक्ता प्रदर्शित करता है कि शीर्षक और राशि इनपुट फ़ील्ड के लिए टेक्स्ट एडिटिंग कंट्रोलर कैसे सेट करें, जिससे उपयोगकर्ता के इनपुट तक आसान पहुँच हो सके। वे लेनदेन की सूची को अपडेट करने और उपयोगकर्ता इंटरफ़ेस पर नए लेनदेन कार्ड प्रदर्शित करने के लिए स्टेटफुल विजेट में संक्रमण के महत्व पर ज़ोर देते हैं। पूरे ट्यूटोरियल में, वक्ता दर्शकों को अवधारणाओं को प्रभावी ढंग से समझने और लागू करने में मदद करने के लिए विस्तृत स्पष्टीकरण और व्यावहारिक उदाहरण प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo informativo, o orador explica o processo de recolha de entrada do utilizador numa aplicação Flutter para adicionar uma nova transação. Discutem duas formas de capturar a entrada do utilizador: guardando-a manualmente a cada pressão de tecla ou utilizando o motor integrado do Flutter com controladores de edição de texto. O orador demonstra como configurar controladores de edição de texto para os campos de entrada de título e quantidade, permitindo um acesso mais fácil à entrada do utilizador. Realçam a importância da transição para um widget com estado para atualizar a lista de transações e exibir novos cartões de transação na interface do utilizador. Ao longo do tutorial, o orador fornece explicações detalhadas e exemplos práticos para ajudar os espectadores a compreender e implementar os conceitos de forma eficaz.",
                                // Bengali
                                "বাংলা": "এই তথ্যপূর্ণ ভিডিওতে, স্পিকার একটি নতুন লেনদেন যোগ করার জন্য একটি ফ্লাটার অ্যাপে ব্যবহারকারীর ইনপুট সংগ্রহ করার প্রক্রিয়া ব্যাখ্যা করেছেন। তারা ব্যবহারকারীর ইনপুট ক্যাপচার করার দুটি উপায় নিয়ে আলোচনা করে - প্রতিটি কীস্ট্রোকের সাথে ম্যানুয়ালি সংরক্ষণ করা বা টেক্সট এডিটিং কন্ট্রোলারের সাথে ফ্লটারের অন্তর্নির্মিত মেকানিজম ব্যবহার করে। স্পিকার প্রদর্শন করে কিভাবে শিরোনাম এবং পরিমাণ ইনপুট ক্ষেত্রের জন্য পাঠ্য সম্পাদনা নিয়ন্ত্রক সেট আপ করতে হয়, ব্যবহারকারীর ইনপুটে সহজে অ্যাক্সেসের অনুমতি দেয়। তারা লেনদেনের তালিকা আপডেট করতে এবং ব্যবহারকারী ইন্টারফেসে নতুন লেনদেন কার্ড প্রদর্শন করতে একটি রাষ্ট্রীয় উইজেটে রূপান্তরের গুরুত্বের উপর জোর দেয়। টিউটোরিয়াল জুড়ে, স্পিকার দর্শকদের ধারণাগুলিকে কার্যকরভাবে বুঝতে এবং বাস্তবায়ন করতে সাহায্য করার জন্য বিস্তারিত ব্যাখ্যা এবং ব্যবহারিক উদাহরণ প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو الإرشادي، يشرح المتحدث عملية جمع مدخلات المستخدم في تطبيق Flutter لإضافة معاملة جديدة. ويناقشون طريقتين لالتقاط مدخلات المستخدم - حفظها يدويًا مع كل ضغطة مفتاح أو استخدام آلية Flutter المضمنة مع وحدات تحكم تحرير النص. ويوضح المتحدث كيفية إعداد وحدات تحكم تحرير النص لحقول إدخال العنوان والمبلغ، مما يسمح بسهولة الوصول إلى مدخلات المستخدم. ويؤكد على أهمية الانتقال إلى عنصر واجهة مستخدم بحالة لتحديث قائمة المعاملات وعرض بطاقات المعاملات الجديدة على واجهة المستخدم. ويقدم المتحدث طوال البرنامج التعليمي تفسيرات مفصلة وأمثلة عملية لمساعدة المشاهدين على فهم المفاهيم وتنفيذها بشكل فعال.",
                                // Persian
                                "فارسی": "در این ویدیوی آموزنده، سخنران فرآیند جمع آوری ورودی کاربر در یک برنامه Flutter را برای افزودن تراکنش جدید توضیح می دهد. آنها دو راه را برای گرفتن ورودی کاربر مورد بحث قرار می دهند - ذخیره دستی آن با هر بار زدن کلید یا استفاده از مکانیزم داخلی Flutter با کنترلرهای ویرایش متن. بلندگو نحوه تنظیم کنترل‌کننده‌های ویرایش متن را برای فیلدهای ورودی عنوان و مقدار نشان می‌دهد که امکان دسترسی آسان‌تر به ورودی کاربر را فراهم می‌کند. آنها بر اهمیت انتقال به یک ویجت حالت دار برای به روز رسانی لیست تراکنش ها و نمایش کارت های تراکنش جدید در رابط کاربری تاکید می کنند. در طول دوره آموزشی، سخنران توضیحات مفصل و مثال های عملی ارائه می دهد تا به بینندگان کمک کند تا مفاهیم را به طور موثر درک کنند و پیاده سازی کنند.",
                            },
                        },
                        // 75 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Splitting the App Into Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial video, the speaker introduces the concept of lifting state up in Flutter by reorganizing the widget tree to enhance readability, maintenance, and performance. They demonstrate splitting the main widget into separate widgets such as new_transaction.dart and user_transactions.dart to manage text input and transaction lists efficiently. By creating stateful and stateless widgets, importing necessary dependencies, and restructuring the widget hierarchy, the speaker shows how to effectively manage state and pass data between widgets for seamless interaction and improved code organization. Throughout the video, detailed explanations and practical examples are provided to guide viewers through the process of structuring Flutter apps for optimal performance and maintainability.",
                                // German
                                "Deutsch": "In diesem Tutorial-Video stellt der Sprecher das Konzept vor, den Status in Flutter zu verbessern, indem er den Widget-Baum neu organisiert, um Lesbarkeit, Wartung und Leistung zu verbessern. Er demonstriert die Aufteilung des Haupt-Widgets in separate Widgets wie new_transaction.dart und user_transactions.dart, um Texteingaben und Transaktionslisten effizient zu verwalten. Durch die Erstellung von zustandsbehafteten und zustandslosen Widgets, das Importieren notwendiger Abhängigkeiten und die Umstrukturierung der Widget-Hierarchie zeigt der Sprecher, wie man den Status effektiv verwaltet und Daten zwischen Widgets übergibt, um eine nahtlose Interaktion und eine verbesserte Code-Organisation zu gewährleisten. Im gesamten Video werden detaillierte Erklärungen und praktische Beispiele bereitgestellt, um die Zuschauer durch den Prozess der Strukturierung von Flutter-Apps für optimale Leistung und Wartbarkeit zu führen.",
                                // Chinese
                                "中国人": "在本教程视频中，演讲者介绍了 Flutter 中通过重新组织小部件树来提升状态的概念，以提高可读性、维护性和性能。他们演示了将主小部件拆分为单独的小部件（例如 new_transaction.dart 和 user_transactions.dart），以有效管理文本输入和交易列表。通过创建有状态和无状态的小部件、导入必要的依赖项以及重构小部件层次结构，演讲者展示了如何有效地管理状态并在小部件之间传递数据，以实现无缝交互和改进代码组织。在整个视频中，提供了详细的解释和实际示例，以指导观看者完成构建 Flutter 应用以获得最佳性能和可维护性的过程。",
                                // Russian
                                "Русский": "В этом обучающем видео докладчик представляет концепцию подъема состояния во Flutter путем реорганизации дерева виджетов для улучшения читаемости, обслуживания и производительности. Они демонстрируют разделение основного виджета на отдельные виджеты, такие как new_transaction.dart и user_transactions.dart, для эффективного управления вводом текста и списками транзакций. Создавая виджеты с состоянием и без состояния, импортируя необходимые зависимости и реструктурируя иерархию виджетов, докладчик показывает, как эффективно управлять состоянием и передавать данные между виджетами для бесперебойного взаимодействия и улучшенной организации кода. На протяжении всего видео приводятся подробные объяснения и практические примеры, чтобы провести зрителей через процесс структурирования приложений Flutter для оптимальной производительности и обслуживания.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant présente le concept de rehaussement d'état dans Flutter en réorganisant l'arborescence des widgets pour améliorer la lisibilité, la maintenance et les performances. Il montre comment diviser le widget principal en widgets distincts tels que new_transaction.dart et user_transactions.dart pour gérer efficacement la saisie de texte et les listes de transactions. En créant des widgets avec et sans état, en important les dépendances nécessaires et en restructurant la hiérarchie des widgets, l'intervenant montre comment gérer efficacement l'état et transmettre des données entre les widgets pour une interaction transparente et une meilleure organisation du code. Tout au long de la vidéo, des explications détaillées et des exemples pratiques sont fournis pour guider les spectateurs dans le processus de structuration des applications Flutter pour des performances et une maintenabilité optimales.",
                                // Japanese
                                "日本語": "このチュートリアル ビデオでは、ウィジェット ツリーを再編成して読みやすさ、メンテナンス性、パフォーマンスを向上させることで、Flutter で状態を引き上げることの概念を紹介しています。メイン ウィジェットを new_transaction.dart や user_transactions.dart などの個別のウィジェットに分割して、テキスト入力とトランザクション リストを効率的に管理する方法を実演しています。ステートフル ウィジェットとステートレス ウィジェットを作成し、必要な依存関係をインポートし、ウィジェット階層を再構築することで、状態を効果的に管理し、ウィジェット間でデータを渡し、シームレスなインタラクションとコード構成の改善を実現する方法を示しています。ビデオ全体を通して、詳細な説明と実用的な例が提供され、最適なパフォーマンスとメンテナンス性を実現する Flutter アプリの構造化プロセスを視聴者が理解できるようになります。",
                                // Korean
                                "한국인": "이 튜토리얼 비디오에서 발표자는 가독성, 유지 관리 및 성능을 향상시키기 위해 위젯 트리를 재구성하여 Flutter에서 상태를 끌어올리는 개념을 소개합니다. 발표자는 텍스트 입력 및 거래 목록을 효율적으로 관리하기 위해 기본 위젯을 new_transaction.dart 및 user_transactions.dart와 같은 별도의 위젯으로 분할하는 방법을 보여줍니다. 발표자는 상태 있는 위젯과 상태 없는 위젯을 만들고, 필요한 종속성을 가져오고, 위젯 계층 구조를 재구성하여 원활한 상호 작용과 향상된 코드 구성을 위해 위젯 간에 상태를 효과적으로 관리하고 데이터를 전달하는 방법을 보여줍니다. 비디오 전체에서 자세한 설명과 실제 예를 제공하여 시청자가 최적의 성능과 유지 관리를 위해 Flutter 앱을 구성하는 과정을 안내합니다.",
                                // Spanish
                                "Español": "En este video tutorial, el orador presenta el concepto de elevar el estado en Flutter mediante la reorganización del árbol de widgets para mejorar la legibilidad, el mantenimiento y el rendimiento. Demuestra cómo dividir el widget principal en widgets separados, como new_transaction.dart y user_transactions.dart, para administrar la entrada de texto y las listas de transacciones de manera eficiente. Al crear widgets con estado y sin estado, importar las dependencias necesarias y reestructurar la jerarquía de widgets, el orador muestra cómo administrar de manera efectiva el estado y pasar datos entre widgets para lograr una interacción fluida y una mejor organización del código. A lo largo del video, se brindan explicaciones detalladas y ejemplos prácticos para guiar a los espectadores a través del proceso de estructuración de aplicaciones Flutter para lograr un rendimiento y una capacidad de mantenimiento óptimos.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल वीडियो में, वक्ता पठनीयता, रखरखाव और प्रदर्शन को बढ़ाने के लिए विजेट ट्री को पुनर्गठित करके फ़्लटर में स्टेट को ऊपर उठाने की अवधारणा का परिचय देता है। वे मुख्य विजेट को अलग-अलग विजेट जैसे new_transaction.dart और user_transactions.dart में विभाजित करके प्रदर्शित करते हैं ताकि टेक्स्ट इनपुट और ट्रांजेक्शन सूचियों को कुशलतापूर्वक प्रबंधित किया जा सके। स्टेटफुल और स्टेटलेस विजेट बनाकर, आवश्यक निर्भरताओं को आयात करके और विजेट पदानुक्रम को पुनर्गठित करके, वक्ता दिखाता है कि सहज बातचीत और बेहतर कोड संगठन के लिए विजेट के बीच स्टेट को प्रभावी ढंग से कैसे प्रबंधित किया जाए और डेटा कैसे पास किया जाए। पूरे वीडियो में, दर्शकों को इष्टतम प्रदर्शन और रखरखाव के लिए फ़्लटर ऐप्स को संरचित करने की प्रक्रिया के माध्यम से मार्गदर्शन करने के लिए विस्तृत स्पष्टीकरण और व्यावहारिक उदाहरण दिए गए हैं।",
                                // Portuguese
                                "Português": "Neste vídeo tutorial, o orador apresenta o conceito de elevação do estado no Flutter, reorganizando a árvore de widgets para melhorar a legibilidade, a manutenção e o desempenho. Demonstram a divisão do widget principal em widgets separados, como new_transaction.dart e user_transactions.dart, para gerir a introdução de texto e listas de transações de forma eficiente. Ao criar widgets com e sem estado, importar as dependências necessárias e reestruturar a hierarquia de widgets, o orador mostra como gerir eficazmente o estado e passar dados entre widgets para uma interação perfeita e uma melhor organização do código. Ao longo do vídeo, são fornecidas explicações detalhadas e exemplos práticos para orientar os espectadores no processo de estruturação das aplicações Flutter para um desempenho e manutenção ideais.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়াল ভিডিওতে, স্পিকার পঠনযোগ্যতা, রক্ষণাবেক্ষণ এবং কার্যকারিতা বাড়াতে উইজেট ট্রিকে পুনর্গঠন করে ফ্লটারে অবস্থাকে উপরে তোলার ধারণাটি উপস্থাপন করেছেন। তারা টেক্সট ইনপুট এবং লেনদেন তালিকা দক্ষতার সাথে পরিচালনা করতে প্রধান উইজেটটিকে new_transaction.dart এবং user_transactions.dart-এর মতো আলাদা উইজেটগুলিতে বিভক্ত করার প্রদর্শন করে। রাষ্ট্রীয় এবং রাষ্ট্রহীন উইজেট তৈরি করে, প্রয়োজনীয় নির্ভরতা আমদানি করে এবং উইজেট শ্রেণিবিন্যাসের পুনর্গঠন করে, স্পিকার দেখায় কীভাবে কার্যকরভাবে রাষ্ট্র পরিচালনা করা যায় এবং বিরামহীন মিথস্ক্রিয়া এবং উন্নত কোড সংস্থার জন্য উইজেটগুলির মধ্যে ডেটা পাস করা যায়। ভিডিও জুড়ে, সর্বোত্তম কর্মক্ষমতা এবং রক্ষণাবেক্ষণের জন্য ফ্লাটার অ্যাপ গঠনের প্রক্রিয়ার মাধ্যমে দর্শকদের গাইড করার জন্য বিস্তারিত ব্যাখ্যা এবং বাস্তব উদাহরণ প্রদান করা হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في مقطع الفيديو التعليمي هذا، يقدم المتحدث مفهوم رفع الحالة في Flutter من خلال إعادة تنظيم شجرة الأدوات لتحسين قابلية القراءة والصيانة والأداء. كما يوضح تقسيم الأداة الرئيسية إلى أدوات منفصلة مثل new_transaction.dart وuser_transactions.dart لإدارة إدخال النص وقوائم المعاملات بكفاءة. من خلال إنشاء أدوات ذات حالة وأخرى بدون حالة، واستيراد التبعيات الضرورية، وإعادة هيكلة التسلسل الهرمي للأدوات، يوضح المتحدث كيفية إدارة الحالة بشكل فعال وتمرير البيانات بين الأدوات لتحقيق تفاعل سلس وتنظيم كود محسّن. طوال الفيديو، يتم توفير تفسيرات مفصلة وأمثلة عملية لتوجيه المشاهدين خلال عملية هيكلة تطبيقات Flutter لتحقيق الأداء الأمثل وقابلية الصيانة.",
                                // Persian
                                "فارسی": "در این ویدیوی آموزشی، سخنران با سازماندهی مجدد درخت ویجت به منظور افزایش خوانایی، نگهداری و عملکرد، مفهوم بالا بردن حالت در فلاتر را معرفی می کند. آنها تقسیم ویجت اصلی را به ویجت‌های جداگانه مانند new_transaction.dart و user_transactions.dart نشان می‌دهند تا فهرست‌های ورودی متن و تراکنش را به طور موثر مدیریت کنند. با ایجاد ویجت‌های حالت‌دار و بدون حالت، وارد کردن وابستگی‌های لازم و بازسازی سلسله‌مراتب ویجت، سخنران نحوه مدیریت مؤثر حالت و انتقال داده‌ها بین ویجت‌ها را برای تعامل یکپارچه و سازمان‌دهی کد بهبود یافته نشان می‌دهد. در سرتاسر ویدیو، توضیحات دقیق و مثال‌های عملی ارائه شده است تا بینندگان را در فرآیند ساختاردهی برنامه‌های Flutter برای عملکرد و نگهداری بهینه راهنمایی کند.",
                            },
                        },
                        // 76 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Connecting Widgets & Managing Data _ State",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker demonstrates how to incorporate user input to add new transactions in a Flutter app. By creating a method named 'add new transaction' in the user transactions file, which manages a list of transactions, viewers learn to pass arguments for the title and amount of a new transaction. The speaker explains the use of the dateTime class to generate unique IDs for each transaction and illustrates how to call the set state method to update the user interface and reflect the addition of a new transaction in the list. Furthermore, viewers are guided on organizing the widget hierarchy and importing necessary dependencies to handle the interaction between different widgets efficiently. Throughout the tutorial, detailed explanations are provided to help viewers understand the process of adding and managing transactions effectively in the Flutter app.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial zeigt der Sprecher, wie Benutzereingaben integriert werden, um neue Transaktionen in einer Flutter-App hinzuzufügen. Durch Erstellen einer Methode namens „add new transaction“ in der Benutzertransaktionsdatei, die eine Liste von Transaktionen verwaltet, lernen die Zuschauer, Argumente für den Titel und den Betrag einer neuen Transaktion zu übergeben. Der Sprecher erklärt die Verwendung der dateTime-Klasse zum Generieren eindeutiger IDs für jede Transaktion und veranschaulicht, wie die Methode „set state“ aufgerufen wird, um die Benutzeroberfläche zu aktualisieren und das Hinzufügen einer neuen Transaktion in der Liste anzuzeigen. Darüber hinaus werden die Zuschauer angeleitet, die Widget-Hierarchie zu organisieren und die erforderlichen Abhängigkeiten zu importieren, um die Interaktion zwischen verschiedenen Widgets effizient zu handhaben. Im gesamten Tutorial werden detaillierte Erklärungen bereitgestellt, damit die Zuschauer den Prozess des effektiven Hinzufügens und Verwaltens von Transaktionen in der Flutter-App verstehen.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者演示了如何整合用户输入以在 Flutter 应用中添加新交易。通过在用户交易文件中创建一个名为“添加新交易”的方法（用于管理交易列表），观众可以学习如何传递新交易的标题和金额的参数。演讲者解释了如何使用 dateTime 类为每个交易生成唯一 ID，并说明了如何调用设置状态方法来更新用户界面并反映列表中新交易的添加。此外，还指导观众组织小部件层次结构并导入必要的依赖项，以有效处理不同小部件之间的交互。在整个教程中，提供了详细的解释，以帮助观众了解在 Flutter 应用中有效添加和管理交易的过程。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик демонстрирует, как включить пользовательский ввод для добавления новых транзакций в приложение Flutter. Создав метод с именем «добавить новую транзакцию» в файле пользовательских транзакций, который управляет списком транзакций, зрители учатся передавать аргументы для заголовка и суммы новой транзакции. Докладчик объясняет использование класса dateTime для генерации уникальных идентификаторов для каждой транзакции и иллюстрирует, как вызвать метод set state для обновления пользовательского интерфейса и отражения добавления новой транзакции в список. Кроме того, зрители получают указания по организации иерархии виджетов и импорту необходимых зависимостей для эффективной обработки взаимодействия между различными виджетами. На протяжении всего руководства предоставляются подробные объяснения, чтобы помочь зрителям понять процесс добавления и эффективного управления транзакциями в приложении Flutter.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant montre comment intégrer la saisie utilisateur pour ajouter de nouvelles transactions dans une application Flutter. En créant une méthode nommée « add new transaction » dans le fichier de transactions utilisateur, qui gère une liste de transactions, les utilisateurs apprennent à transmettre des arguments pour le titre et le montant d'une nouvelle transaction. L'intervenant explique l'utilisation de la classe dateTime pour générer des identifiants uniques pour chaque transaction et illustre comment appeler la méthode set state pour mettre à jour l'interface utilisateur et refléter l'ajout d'une nouvelle transaction dans la liste. De plus, les utilisateurs sont guidés dans l'organisation de la hiérarchie des widgets et l'importation des dépendances nécessaires pour gérer efficacement l'interaction entre les différents widgets. Tout au long du didacticiel, des explications détaillées sont fournies pour aider les utilisateurs à comprendre le processus d'ajout et de gestion efficace des transactions dans l'application Flutter.",
                                // Japanese
                                "日本語": "このビデオ チュートリアルでは、スピーカーがユーザー入力を組み込んで Flutter アプリに新しいトランザクションを追加する方法を説明します。トランザクションのリストを管理するユーザー トランザクション ファイルに「add new transaction」というメソッドを作成することで、視聴者は新しいトランザクションのタイトルと金額の引数を渡す方法を学びます。スピーカーは、dateTime クラスを使用して各トランザクションに一意の ID を生成する方法を説明し、set state メソッドを呼び出してユーザー インターフェイスを更新し、リストに新しいトランザクションが追加されたことを反映する方法を示します。さらに、ウィジェット階層を整理し、異なるウィジェット間のやり取りを効率的に処理するために必要な依存関係をインポートする方法についても視聴者に説明します。チュートリアル全体を通して、Flutter アプリでトランザクションを効果的に追加および管理するプロセスを視聴者が理解できるように、詳細な説明が提供されます。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 사용자 입력을 통합하여 Flutter 앱에 새 거래를 추가하는 방법을 보여줍니다. 사용자 거래 파일에 '새 거래 추가'라는 이름의 메서드를 만들어 거래 목록을 관리함으로써 시청자는 새 거래의 제목과 금액에 대한 인수를 전달하는 방법을 배웁니다. 발표자는 dateTime 클래스를 사용하여 각 거래에 대한 고유 ID를 생성하는 방법을 설명하고, 사용자 인터페이스를 업데이트하고 목록에 새 거래가 추가되었음을 반영하기 위해 set state 메서드를 호출하는 방법을 보여줍니다. 또한, 시청자는 위젯 계층을 구성하고 다양한 위젯 간의 상호 작용을 효율적으로 처리하는 데 필요한 종속성을 가져오는 방법에 대해 안내를 받습니다. 튜토리얼 전체에서 자세한 설명을 제공하여 시청자가 Flutter 앱에서 거래를 효과적으로 추가하고 관리하는 프로세스를 이해하는 데 도움이 됩니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador demuestra cómo incorporar la entrada del usuario para agregar nuevas transacciones en una aplicación Flutter. Al crear un método llamado 'agregar nueva transacción' en el archivo de transacciones del usuario, que administra una lista de transacciones, los espectadores aprenden a pasar argumentos para el título y el monto de una nueva transacción. El orador explica el uso de la clase dateTime para generar identificadores únicos para cada transacción e ilustra cómo llamar al método set state para actualizar la interfaz de usuario y reflejar la adición de una nueva transacción en la lista. Además, se guía a los espectadores sobre cómo organizar la jerarquía de widgets e importar las dependencias necesarias para manejar la interacción entre diferentes widgets de manera eficiente. A lo largo del tutorial, se brindan explicaciones detalladas para ayudar a los espectadores a comprender el proceso de agregar y administrar transacciones de manera efectiva en la aplicación Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता यह दर्शाता है कि फ़्लटर ऐप में नए लेनदेन जोड़ने के लिए उपयोगकर्ता इनपुट को कैसे शामिल किया जाए। उपयोगकर्ता लेनदेन फ़ाइल में 'नया लेनदेन जोड़ें' नामक विधि बनाकर, जो लेनदेन की सूची प्रबंधित करता है, दर्शक नए लेनदेन के शीर्षक और राशि के लिए तर्क पारित करना सीखते हैं। वक्ता प्रत्येक लेनदेन के लिए अद्वितीय आईडी उत्पन्न करने के लिए dateTime वर्ग के उपयोग की व्याख्या करता है और उपयोगकर्ता इंटरफ़ेस को अपडेट करने और सूची में एक नए लेनदेन के जोड़ को दर्शाने के लिए सेट स्टेट विधि को कॉल करने का तरीका बताता है। इसके अलावा, दर्शकों को विजेट पदानुक्रम को व्यवस्थित करने और विभिन्न विजेट के बीच बातचीत को कुशलतापूर्वक संभालने के लिए आवश्यक निर्भरताओं को आयात करने के बारे में निर्देशित किया जाता है। पूरे ट्यूटोरियल में, दर्शकों को फ़्लटर ऐप में लेनदेन को प्रभावी ढंग से जोड़ने और प्रबंधित करने की प्रक्रिया को समझने में मदद करने के लिए विस्तृत स्पष्टीकरण दिए गए हैं।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador demonstra como incorporar a entrada do utilizador para adicionar novas transações numa aplicação Flutter. Ao criar um método chamado 'adicionar nova transação' no ficheiro de transações do utilizador, que gere uma lista de transações, os visualizadores aprendem a passar argumentos para o título e o valor de uma nova transação. O orador explica a utilização da classe dateTime para gerar IDs únicos para cada transação e ilustra como chamar o método set state para atualizar a interface do utilizador e refletir a adição de uma nova transação na lista. Além disso, os visualizadores são orientados na organização da hierarquia de widgets e na importação das dependências necessárias para lidar com a interação entre diferentes widgets de forma eficiente. Ao longo do tutorial, são fornecidas explicações detalhadas para ajudar os espectadores a compreender o processo de adição e gestão eficaz de transações na aplicação Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার প্রদর্শন করে যে কীভাবে একটি ফ্লাটার অ্যাপে নতুন লেনদেন যোগ করতে ব্যবহারকারীর ইনপুট অন্তর্ভুক্ত করতে হয়। ব্যবহারকারী লেনদেন ফাইলে 'নতুন লেনদেন যোগ করুন' নামে একটি পদ্ধতি তৈরি করে, যা লেনদেনের একটি তালিকা পরিচালনা করে, দর্শকরা একটি নতুন লেনদেনের শিরোনাম এবং পরিমাণের জন্য আর্গুমেন্ট পাস করতে শেখে। স্পিকার প্রতিটি লেনদেনের জন্য অনন্য আইডি তৈরি করতে dateTime ক্লাসের ব্যবহার ব্যাখ্যা করে এবং ব্যবহারকারী ইন্টারফেস আপডেট করতে এবং তালিকায় একটি নতুন লেনদেনের সংযোজন প্রতিফলিত করার জন্য সেট স্টেট মেথডকে কীভাবে কল করতে হয় তা ব্যাখ্যা করে। উপরন্তু, দর্শকদের উইজেট শ্রেণিবিন্যাস সংগঠিত করার এবং বিভিন্ন উইজেটের মধ্যে মিথস্ক্রিয়া দক্ষতার সাথে পরিচালনা করার জন্য প্রয়োজনীয় নির্ভরতা আমদানি করার বিষয়ে নির্দেশিত হয়। টিউটোরিয়াল জুড়ে, দর্শকদের ফ্লাটার অ্যাপে কার্যকরভাবে লেনদেন যোগ এবং পরিচালনা করার প্রক্রিয়া বুঝতে সাহায্য করার জন্য বিস্তারিত ব্যাখ্যা প্রদান করা হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يوضح المتحدث كيفية دمج إدخال المستخدم لإضافة معاملات جديدة في تطبيق Flutter. من خلال إنشاء طريقة تسمى 'إضافة معاملة جديدة' في ملف معاملات المستخدم، والتي تدير قائمة المعاملات، يتعلم المشاهدون كيفية تمرير الوسائط لعنوان ومبلغ المعاملة الجديدة. يشرح المتحدث استخدام فئة dateTime لإنشاء معرفات فريدة لكل معاملة ويوضح كيفية استدعاء طريقة set state لتحديث واجهة المستخدم وعكس إضافة معاملة جديدة في القائمة. علاوة على ذلك، يتم توجيه المشاهدين حول تنظيم التسلسل الهرمي للأدوات واستيراد التبعيات الضرورية للتعامل مع التفاعل بين الأدوات المختلفة بكفاءة. طوال البرنامج التعليمي، يتم توفير تفسيرات مفصلة لمساعدة المشاهدين على فهم عملية إضافة المعاملات وإدارتها بشكل فعال في تطبيق Flutter.",
                                // Persian
                                "فارسی": "در این آموزش ویدیویی، بلندگو نحوه ترکیب ورودی کاربر برای افزودن تراکنش‌های جدید در برنامه فلاتر را نشان می‌دهد. با ایجاد روشی به نام «افزودن تراکنش جدید» در فایل تراکنش‌های کاربر، که فهرستی از تراکنش‌ها را مدیریت می‌کند، بینندگان یاد می‌گیرند که آرگومان‌هایی را برای عنوان و مبلغ تراکنش جدید ارسال کنند. سخنران استفاده از کلاس dateTime برای تولید شناسه های منحصر به فرد برای هر تراکنش را توضیح می دهد و نحوه فراخوانی روش set state را برای به روز رسانی رابط کاربری و منعکس کردن اضافه شدن تراکنش جدید در لیست نشان می دهد. علاوه بر این، بینندگان در سازماندهی سلسله مراتب ویجت و وارد کردن وابستگی های لازم برای مدیریت موثر تعامل بین ویجت های مختلف راهنمایی می شوند. در طول آموزش، توضیحات مفصلی ارائه شده است تا به بینندگان کمک کند تا فرآیند افزودن و مدیریت مؤثر تراکنش‌ها را در برنامه Flutter درک کنند.",
                            },
                        },
                        // 77 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Adding User Transactions to the List",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial video, the speaker guides viewers on wiring up the 'add new transaction' method in Flutter by calling the method in the new transaction file's onPressed function. By passing the function pointer down from the user transactions, viewers learn to successfully execute the addTx function in the new transaction widget. The speaker explains the necessity of handling data types correctly, such as converting string inputs to doubles for amount values using double.parse. Through a step-by-step demonstration, viewers are shown how to add new transactions, handling error scenarios, and ensuring valid number inputs for successful addition to the transaction list. Additionally, the video addresses potential issues such as the inability to scroll through the transaction list and hints at resolving these issues in the following lecture.",
                                // German
                                "Deutsch": "In diesem Tutorial-Video führt der Sprecher die Zuschauer durch die Verkabelung der Methode „Neue Transaktion hinzufügen“ in Flutter, indem er die Methode in der Funktion onPressed der neuen Transaktionsdatei aufruft. Durch die Weitergabe des Funktionszeigers von den Benutzertransaktionen lernen die Zuschauer, die Funktion addTx im neuen Transaktions-Widget erfolgreich auszuführen. Der Sprecher erklärt die Notwendigkeit, Datentypen richtig zu handhaben, z. B. das Konvertieren von Zeichenfolgeneingaben in Doubles für Betragswerte mithilfe von double.parse. In einer schrittweisen Demonstration wird den Zuschauern gezeigt, wie sie neue Transaktionen hinzufügen, Fehlerszenarien behandeln und gültige Zahleneingaben sicherstellen, um sie erfolgreich zur Transaktionsliste hinzuzufügen. Darüber hinaus behandelt das Video potenzielle Probleme wie die Unfähigkeit, durch die Transaktionsliste zu scrollen, und gibt Hinweise zur Lösung dieser Probleme in der folgenden Vorlesung.",
                                // Chinese
                                "中国人": "在本教程视频中，演讲者指导观众在 Flutter 中通过调用新交易文件的 onPressed 函数中的方法来连接“添加新交易”方法。通过将函数指针从用户交易中向下传递，观众可以学习如何在新交易小部件中成功执行 addTx 函数。演讲者解释了正确处理数据类型的必要性，例如使用 double.parse 将字符串输入转换为金额值的双精度数。通过分步演示，向观众展示了如何添加新交易、处理错误情况以及确保输入有效的数字以成功添加到交易列表中。此外，视频还解决了无法滚动浏览交易列表等潜在问题，并提示在后续讲座中解决这些问题。",
                                // Russian
                                "Русский": "В этом обучающем видео докладчик рассказывает зрителям о подключении метода «добавить новую транзакцию» во Flutter, вызывая метод в функции onPressed нового файла транзакции. Передавая указатель функции вниз из пользовательских транзакций, зрители учатся успешно выполнять функцию addTx в новом виджете транзакции. Докладчик объясняет необходимость правильной обработки типов данных, например, преобразования строковых входных данных в значения двойной точности для значений сумм с помощью double.parse. С помощью пошаговой демонстрации зрителям показывают, как добавлять новые транзакции, обрабатывать сценарии ошибок и обеспечивать допустимые входные данные чисел для успешного добавления в список транзакций. Кроме того, в видео рассматриваются потенциальные проблемы, такие как невозможность прокрутки списка транзакций, и даются намеки на решение этих проблем в следующей лекции.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant guide les spectateurs sur la manière de connecter la méthode « ajouter une nouvelle transaction » dans Flutter en appelant la méthode dans la fonction onPressed du nouveau fichier de transaction. En transmettant le pointeur de fonction depuis les transactions utilisateur, les spectateurs apprennent à exécuter avec succès la fonction addTx dans le nouveau widget de transaction. L'intervenant explique la nécessité de gérer correctement les types de données, comme la conversion des entrées de chaîne en doubles pour les valeurs de montant à l'aide de double.parse. Grâce à une démonstration étape par étape, les spectateurs apprennent à ajouter de nouvelles transactions, à gérer les scénarios d'erreur et à garantir des entrées de nombres valides pour un ajout réussi à la liste des transactions. De plus, la vidéo aborde les problèmes potentiels tels que l'impossibilité de faire défiler la liste des transactions et donne des conseils sur la résolution de ces problèmes dans la conférence suivante.",
                                // Japanese
                                "日本語": "このチュートリアル ビデオでは、講演者が視聴者に、新しいトランザクション ファイルの onPressed 関数でメソッドを呼び出すことによって、Flutter で「新しいトランザクションを追加」メソッドを配線する方法を説明します。視聴者は、ユーザー トランザクションから関数ポインターを渡すことにより、新しいトランザクション ウィジェットで addTx 関数を正常に実行する方法を学びます。講演者は、double.parse を使用して文字列入力を金額値の double に変換するなど、データ型を正しく処理する必要性について説明します。ステップ バイ ステップのデモンストレーションを通じて、視聴者は新しいトランザクションを追加する方法、エラー シナリオを処理する方法、トランザクション リストに正常に追加するために有効な数値入力を確認する方法を確認できます。さらに、このビデオでは、トランザクション リストをスクロールできないなどの潜在的な問題を取り上げ、次の講義でこれらの問題を解決するためのヒントを示します。",
                                // Korean
                                "한국인": "이 튜토리얼 비디오에서 발표자는 새로운 트랜잭션 파일의 onPressed 함수에서 메서드를 호출하여 Flutter에서 '새로운 트랜잭션 추가' 메서드를 연결하는 방법을 시청자에게 안내합니다. 사용자 트랜잭션에서 함수 포인터를 전달하여 시청자는 새로운 트랜잭션 위젯에서 addTx 함수를 성공적으로 실행하는 방법을 배웁니다. 발표자는 double.parse를 사용하여 문자열 입력을 금액 값의 double로 변환하는 것과 같이 데이터 유형을 올바르게 처리하는 것의 필요성을 설명합니다. 단계별 데모를 통해 시청자는 새로운 트랜잭션을 추가하고, 오류 시나리오를 처리하고, 트랜잭션 목록에 성공적으로 추가하기 위해 유효한 숫자 입력을 보장하는 방법을 보여줍니다. 또한 이 비디오는 트랜잭션 목록을 스크롤할 수 없는 것과 같은 잠재적인 문제를 다루고 다음 강의에서 이러한 문제를 해결하는 방법에 대한 힌트를 제공합니다.",
                                // Spanish
                                "Español": "En este video tutorial, el orador guía a los espectadores sobre cómo conectar el método 'agregar nueva transacción' en Flutter llamando al método en la función onPressed del nuevo archivo de transacción. Al pasar el puntero de función hacia abajo desde las transacciones del usuario, los espectadores aprenden a ejecutar correctamente la función addTx en el nuevo widget de transacción. El orador explica la necesidad de manejar los tipos de datos correctamente, como convertir las entradas de cadena en dobles para los valores de monto usando double.parse. A través de una demostración paso a paso, se muestra a los espectadores cómo agregar nuevas transacciones, manejar escenarios de error y garantizar entradas de números válidos para una adición exitosa a la lista de transacciones. Además, el video aborda problemas potenciales como la incapacidad de desplazarse por la lista de transacciones y sugiere cómo resolver estos problemas en la siguiente lección.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल वीडियो में, वक्ता दर्शकों को नई ट्रांजेक्शन फ़ाइल के onPressed फ़ंक्शन में विधि को कॉल करके फ़्लटर में 'नया ट्रांजेक्शन जोड़ें' विधि को वायरिंग करने के बारे में मार्गदर्शन करता है। उपयोगकर्ता ट्रांजेक्शन से फ़ंक्शन पॉइंटर को नीचे भेजकर, दर्शक नए ट्रांजेक्शन विजेट में addTx फ़ंक्शन को सफलतापूर्वक निष्पादित करना सीखते हैं। वक्ता डेटा प्रकारों को सही ढंग से संभालने की आवश्यकता को समझाता है, जैसे कि double.parse का उपयोग करके राशि मानों के लिए स्ट्रिंग इनपुट को डबल्स में बदलना। चरण-दर-चरण प्रदर्शन के माध्यम से, दर्शकों को दिखाया जाता है कि नए ट्रांजेक्शन कैसे जोड़ें, त्रुटि परिदृश्यों को कैसे संभालें, और ट्रांजेक्शन सूची में सफलतापूर्वक जोड़ने के लिए वैध संख्या इनपुट सुनिश्चित करें। इसके अतिरिक्त, वीडियो संभावित मुद्दों जैसे कि ट्रांजेक्शन सूची के माध्यम से स्क्रॉल करने में असमर्थता को संबोधित करता है और निम्नलिखित व्याख्यान में इन मुद्दों को हल करने के संकेत देता है।",
                                // Portuguese
                                "Português": "Neste vídeo tutorial, o orador orienta os espectadores sobre como ligar o método 'adicionar nova transação' no Flutter, chamando o método na função onPressed do novo ficheiro de transação. Ao passar o ponteiro de função para baixo nas transações do utilizador, os visualizadores aprendem a executar com êxito a função addTx no novo widget de transação. O orador explica a necessidade de lidar corretamente com os tipos de dados, como converter entradas de string em doubles para valores de quantidade usando double.parse. Através de uma demonstração passo a passo, os espectadores aprendem como adicionar novas transações, lidar com cenários de erro e garantir entradas de números válidos para uma adição bem-sucedida à lista de transações. Além disso, o vídeo aborda possíveis problemas, como a incapacidade de percorrer a lista de transações, e dá dicas sobre como resolver estes problemas na palestra que se segue.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়াল ভিডিওতে, স্পিকার নতুন লেনদেন ফাইলের অনপ্রেসড ফাংশনে মেথডটিকে কল করার মাধ্যমে ফ্লটারে 'নতুন লেনদেন যোগ করুন' পদ্ধতির ওয়্যারিং আপ করার বিষয়ে দর্শকদের গাইড করে। ব্যবহারকারীর লেনদেন থেকে ফাংশন পয়েন্টারকে নিচে দিয়ে, দর্শকরা নতুন লেনদেন উইজেটে addTx ফাংশন সফলভাবে চালাতে শিখে। স্পিকার সঠিকভাবে ডাটা টাইপ পরিচালনা করার প্রয়োজনীয়তা ব্যাখ্যা করে, যেমন double.parse ব্যবহার করে পরিমাণের মানগুলির জন্য স্ট্রিং ইনপুটগুলিকে দ্বিগুণে রূপান্তর করা। একটি ধাপে ধাপে প্রদর্শনের মাধ্যমে, দর্শকদের দেখানো হয় কিভাবে নতুন লেনদেন যোগ করতে হয়, ত্রুটির পরিস্থিতি পরিচালনা করতে হয় এবং লেনদেনের তালিকায় সফল সংযোজনের জন্য বৈধ নম্বর ইনপুট নিশ্চিত করতে হয়। উপরন্তু, ভিডিওটি সম্ভাব্য সমস্যা যেমন লেনদেন তালিকার মাধ্যমে স্ক্রোল করতে না পারা এবং নিম্নলিখিত লেকচারে এই সমস্যাগুলির সমাধান করার ইঙ্গিত দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في مقطع الفيديو التعليمي هذا، يرشد المتحدث المشاهدين إلى كيفية توصيل طريقة 'إضافة معاملة جديدة' في Flutter من خلال استدعاء الطريقة في دالة onPressed لملف المعاملة الجديدة. من خلال تمرير مؤشر الوظيفة لأسفل من معاملات المستخدم، يتعلم المشاهدون كيفية تنفيذ دالة addTx بنجاح في عنصر واجهة المستخدم للمعاملة الجديدة. يشرح المتحدث ضرورة التعامل مع أنواع البيانات بشكل صحيح، مثل تحويل مدخلات السلسلة إلى مضاعفات لقيم المبلغ باستخدام double.parse. من خلال عرض توضيحي خطوة بخطوة، يتم عرض كيفية إضافة معاملات جديدة للمشاهدين، والتعامل مع سيناريوهات الخطأ، وضمان إدخالات أرقام صالحة للإضافة الناجحة إلى قائمة المعاملات. بالإضافة إلى ذلك، يتناول الفيديو المشكلات المحتملة مثل عدم القدرة على التمرير عبر قائمة المعاملات ويشير إلى حل هذه المشكلات في المحاضرة التالية.",
                                // Persian
                                "فارسی": "در این ویدیوی آموزشی، بلندگو با فراخوانی روش موجود در تابع onPressed فایل تراکنش جدید، بینندگان را در سیم‌کشی روش «افزودن تراکنش جدید» در Flutter راهنمایی می‌کند. با ارسال نشانگر تابع به پایین از تراکنش های کاربر، بینندگان یاد می گیرند که عملکرد addTx را با موفقیت در ویجت تراکنش جدید اجرا کنند. بلندگو ضرورت مدیریت انواع داده ها را به درستی توضیح می دهد، مانند تبدیل ورودی های رشته به دو برابر برای مقادیر مقدار با استفاده از double.parse. از طریق نمایش گام به گام، به بینندگان نشان داده می‌شود که چگونه تراکنش‌های جدید را اضافه کنند، سناریوهای خطا را مدیریت کنند، و از ورودی‌های عدد معتبر برای افزودن موفقیت‌آمیز به فهرست تراکنش اطمینان حاصل کنند. علاوه بر این، ویدئو به مسائل احتمالی مانند عدم توانایی در پیمایش در لیست تراکنش‌ها می‌پردازد و در سخنرانی زیر به حل این مشکلات اشاره می‌کند.",
                            },
                        },
                        // 78 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Making the List Scrollable!",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker addresses the issue of ensuring scrollability within the Flutter app's content by explaining the default behavior of column and row widgets in Flutter. Upon recognizing that the content is not scrollable, the speaker introduces the solution of wrapping the content within a SingleChildScrollView widget to enable scrolling functionality. By incorporating SingleChildScrollView around the overall column of content, users can successfully scroll through the content even when the soft keyboard is in use. Through a step-by-step demonstration, viewers learn how to implement this solution effectively to prevent layout issues and ensure proper functionality within the app, ultimately improving the user experience by allowing seamless scrolling of the content. Additionally, the tutorial offers insights into the technical aspects of how Flutter handles scrolling and adjustments for different screen sizes.",
                                // German
                                "Deutsch": "In diesem Tutorial geht der Sprecher auf die Frage ein, wie die Scrollbarkeit innerhalb des Inhalts der Flutter-App sichergestellt werden kann, indem er das Standardverhalten von Spalten- und Zeilen-Widgets in Flutter erklärt. Nachdem festgestellt wurde, dass der Inhalt nicht scrollbar ist, stellt der Sprecher die Lösung vor, den Inhalt in ein SingleChildScrollView-Widget einzuschließen, um die Scrollfunktion zu ermöglichen. Durch die Einbindung von SingleChildScrollView um die gesamte Inhaltsspalte können Benutzer erfolgreich durch den Inhalt scrollen, selbst wenn die Bildschirmtastatur verwendet wird. In einer schrittweisen Demonstration lernen die Zuschauer, wie sie diese Lösung effektiv implementieren können, um Layoutprobleme zu vermeiden und die ordnungsgemäße Funktionalität innerhalb der App sicherzustellen. Dies verbessert letztendlich das Benutzererlebnis, indem ein nahtloses Scrollen des Inhalts ermöglicht wird. Darüber hinaus bietet das Tutorial Einblicke in die technischen Aspekte, wie Flutter mit Scrollen und Anpassungen für unterschiedliche Bildschirmgrößen umgeht.",
                                // Chinese
                                "中国人": "在本教程中，演讲者通过解释 Flutter 中列和行小部件的默认行为来解决确保 Flutter 应用内容可滚动的问题。在意识到内容不可滚动后，演讲者介绍了将内容包装在 SingleChildScrollView 小部件中以启用滚动功能的解决方案。通过将 SingleChildScrollView 纳入整个内容列周围，用户即使在使用软键盘时也可以成功滚动内容。通过分步演示，观众可以了解如何有效地实施此解决方案以防止布局问题并确保应用内的正常功能，最终通过允许无缝滚动内容来改善用户体验。此外，本教程还深入了解了 Flutter 如何处理滚动和针对不同屏幕尺寸进行调整的技术方面。",
                                // Russian
                                "Русский": "В этом руководстве докладчик рассматривает вопрос обеспечения прокручиваемости в содержимом приложения Flutter, объясняя поведение по умолчанию виджетов столбцов и строк во Flutter. Осознав, что содержимое не прокручивается, докладчик представляет решение, заключающееся в обертывании содержимого в виджет SingleChildScrollView для включения функциональности прокрутки. Включив SingleChildScrollView вокруг всего столбца содержимого, пользователи могут успешно прокручивать содержимое даже при использовании экранной клавиатуры. С помощью пошаговой демонстрации зрители узнают, как эффективно реализовать это решение для предотвращения проблем с макетом и обеспечения надлежащей функциональности в приложении, в конечном итоге улучшая пользовательский опыт, позволяя плавно прокручивать содержимое. Кроме того, руководство дает представление о технических аспектах того, как Flutter обрабатывает прокрутку и корректировки для разных размеров экрана.",
                                // French
                                "Français": "Dans ce didacticiel, l'intervenant aborde la question de la garantie de défilement dans le contenu de l'application Flutter en expliquant le comportement par défaut des widgets de colonnes et de lignes dans Flutter. Après avoir reconnu que le contenu n'est pas défilable, l'intervenant présente la solution consistant à envelopper le contenu dans un widget SingleChildScrollView pour activer la fonctionnalité de défilement. En incorporant SingleChildScrollView autour de la colonne globale de contenu, les utilisateurs peuvent faire défiler le contenu avec succès même lorsque le clavier logiciel est utilisé. Grâce à une démonstration étape par étape, les spectateurs apprennent à mettre en œuvre efficacement cette solution pour éviter les problèmes de mise en page et garantir une fonctionnalité appropriée dans l'application, améliorant ainsi l'expérience utilisateur en permettant un défilement transparent du contenu. De plus, le didacticiel offre un aperçu des aspects techniques de la manière dont Flutter gère le défilement et les ajustements pour différentes tailles d'écran.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講演者は Flutter の列ウィジェットと行ウィジェットのデフォルトの動作を説明して、Flutter アプリのコンテンツ内でスクロール可能性を確保するという問題に対処します。コンテンツがスクロール可能ではないことを認識すると、講演者はコンテンツを SingleChildScrollView ウィジェット内にラップしてスクロール機能を有効にするという解決策を紹介します。コンテンツの列全体に SingleChildScrollView を組み込むことで、ユーザーはソフト キーボードを使用しているときでもコンテンツを正常にスクロールできます。視聴者は、ステップ バイ ステップのデモンストレーションを通じて、レイアウトの問題を防ぎ、アプリ内で適切な機能を確保し、最終的にコンテンツをシームレスにスクロールできるようにすることでユーザー エクスペリエンスを向上させるために、このソリューションを効果的に実装する方法を学びます。さらに、このチュートリアルでは、Flutter がさまざまな画面サイズのスクロールと調整を処理する技術的な側面についての洞察を提供します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 Flutter에서 열 및 행 위젯의 기본 동작을 설명하여 Flutter 앱 콘텐츠 내에서 스크롤 가능성을 보장하는 문제를 다룹니다. 콘텐츠가 스크롤 가능하지 않다는 것을 인식한 발표자는 스크롤 기능을 활성화하기 위해 SingleChildScrollView 위젯 내에서 콘텐츠를 래핑하는 솔루션을 소개합니다. 콘텐츠의 전체 열 주위에 SingleChildScrollView를 통합함으로써 사용자는 소프트 키보드를 사용 중일 때에도 콘텐츠를 성공적으로 스크롤할 수 있습니다. 단계별 데모를 통해 시청자는 레이아웃 문제를 방지하고 앱 내에서 적절한 기능을 보장하는 이 솔루션을 효과적으로 구현하는 방법을 배우고 궁극적으로 콘텐츠의 원활한 스크롤을 허용하여 사용자 경험을 개선합니다. 또한 이 튜토리얼은 Flutter가 스크롤을 처리하는 방법의 기술적 측면과 다양한 화면 크기에 대한 조정에 대한 통찰력을 제공합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador aborda la cuestión de garantizar la capacidad de desplazamiento dentro del contenido de la aplicación Flutter al explicar el comportamiento predeterminado de los widgets de columnas y filas en Flutter. Al reconocer que el contenido no es desplazable, el orador presenta la solución de envolver el contenido dentro de un widget SingleChildScrollView para habilitar la función de desplazamiento. Al incorporar SingleChildScrollView alrededor de la columna general de contenido, los usuarios pueden desplazarse correctamente por el contenido incluso cuando se utiliza el teclado virtual. A través de una demostración paso a paso, los espectadores aprenden a implementar esta solución de manera efectiva para evitar problemas de diseño y garantizar una funcionalidad adecuada dentro de la aplicación, lo que en última instancia mejora la experiencia del usuario al permitir un desplazamiento sin problemas del contenido. Además, el tutorial ofrece información sobre los aspectos técnicos de cómo Flutter maneja el desplazamiento y los ajustes para diferentes tamaños de pantalla.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता फ़्लटर में कॉलम और रो विजेट के डिफ़ॉल्ट व्यवहार को समझाकर फ़्लटर ऐप की सामग्री के भीतर स्क्रॉल करने की क्षमता सुनिश्चित करने के मुद्दे को संबोधित करता है। यह पहचानने पर कि सामग्री स्क्रॉल करने योग्य नहीं है, वक्ता स्क्रॉलिंग कार्यक्षमता को सक्षम करने के लिए सामग्री को SingleChildScrollView विजेट के भीतर लपेटने का समाधान प्रस्तुत करता है। सामग्री के समग्र कॉलम के चारों ओर SingleChildScrollView को शामिल करके, उपयोगकर्ता सॉफ्ट कीबोर्ड के उपयोग में होने पर भी सामग्री को सफलतापूर्वक स्क्रॉल कर सकते हैं। चरण-दर-चरण प्रदर्शन के माध्यम से, दर्शक लेआउट समस्याओं को रोकने और ऐप के भीतर उचित कार्यक्षमता सुनिश्चित करने के लिए इस समाधान को प्रभावी ढंग से लागू करना सीखते हैं, अंततः सामग्री की सहज स्क्रॉलिंग की अनुमति देकर उपयोगकर्ता अनुभव में सुधार करते हैं। इसके अतिरिक्त, ट्यूटोरियल फ़्लटर द्वारा स्क्रॉलिंग और विभिन्न स्क्रीन आकारों के लिए समायोजन को संभालने के तकनीकी पहलुओं में अंतर्दृष्टि प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador aborda a questão de garantir a rolagem no conteúdo da aplicação Flutter, explicando o comportamento padrão dos widgets de coluna e linha no Flutter. Ao reconhecer que o conteúdo não é rolável, o orador apresenta a solução de agrupar o conteúdo num widget SingleChildScrollView para ativar a funcionalidade de scroll. Ao incorporar o SingleChildScrollView em torno da coluna geral de conteúdo, os utilizadores podem percorrer o conteúdo com êxito, mesmo quando o teclado virtual está a ser utilizado. Através de uma demonstração passo a passo, os espectadores aprendem como implementar esta solução de forma eficaz para evitar problemas de layout e garantir a funcionalidade adequada dentro da aplicação, melhorando em última análise a experiência do utilizador, permitindo a rolagem contínua do conteúdo. Além disso, o tutorial oferece informações sobre os aspetos técnicos de como o Flutter lida com a rolagem e os ajustes para diferentes tamanhos de ecrã.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার ফ্লটারে কলাম এবং সারি উইজেটগুলির ডিফল্ট আচরণ ব্যাখ্যা করে ফ্লটার অ্যাপের বিষয়বস্তুর মধ্যে স্ক্রোলযোগ্যতা নিশ্চিত করার সমস্যাটির সমাধান করেছেন। বিষয়বস্তুটি স্ক্রোলযোগ্য নয় তা স্বীকার করার পরে, স্পিকার স্ক্রোলিং কার্যকারিতা সক্ষম করতে একটি SingleChildScrollView উইজেটের মধ্যে সামগ্রীটি মোড়ানোর সমাধান উপস্থাপন করে। কন্টেন্টের সামগ্রিক কলামের চারপাশে SingleChildScrollView অন্তর্ভুক্ত করার মাধ্যমে, সফট কীবোর্ড ব্যবহার করা হলেও ব্যবহারকারীরা সফলভাবে বিষয়বস্তুর মাধ্যমে স্ক্রোল করতে পারেন। ধাপে ধাপে প্রদর্শনের মাধ্যমে, দর্শকরা লেআউট সমস্যাগুলি প্রতিরোধ করতে এবং অ্যাপের মধ্যে সঠিক কার্যকারিতা নিশ্চিত করতে এই সমাধানটি কার্যকরভাবে কীভাবে কার্যকর করতে হয় তা শিখে, শেষ পর্যন্ত সামগ্রীর নির্বিঘ্ন স্ক্রোলিংয়ের অনুমতি দিয়ে ব্যবহারকারীর অভিজ্ঞতাকে উন্নত করে। উপরন্তু, টিউটোরিয়ালটি বিভিন্ন স্ক্রীন মাপের জন্য ফ্লাটার কীভাবে স্ক্রলিং এবং সামঞ্জস্য পরিচালনা করে তার প্রযুক্তিগত দিকগুলির অন্তর্দৃষ্টি প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يتناول المتحدث قضية ضمان إمكانية التمرير داخل محتوى تطبيق Flutter من خلال شرح السلوك الافتراضي لعناصر واجهة المستخدم العمودية والصفية في Flutter. بعد إدراك أن المحتوى غير قابل للتمرير، يقدم المتحدث حلاً لتغليف المحتوى داخل عنصر واجهة مستخدم SingleChildScrollView لتمكين وظيفة التمرير. من خلال دمج SingleChildScrollView حول العمود الإجمالي للمحتوى، يمكن للمستخدمين التمرير بنجاح عبر المحتوى حتى عند استخدام لوحة المفاتيح الناعمة. من خلال عرض توضيحي خطوة بخطوة، يتعلم المشاهدون كيفية تنفيذ هذا الحل بشكل فعال لمنع مشكلات التخطيط وضمان الوظائف المناسبة داخل التطبيق، مما يؤدي في النهاية إلى تحسين تجربة المستخدم من خلال السماح بالتمرير السلس للمحتوى. بالإضافة إلى ذلك، يقدم البرنامج التعليمي رؤى حول الجوانب الفنية لكيفية تعامل Flutter مع التمرير والتعديلات لأحجام شاشات مختلفة.",
                                // Persian
                                "فارسی": "در این آموزش، سخنران با توضیح رفتار پیش‌فرض ویجت‌های ستون و ردیف در Flutter، به موضوع اطمینان از قابلیت اسکرول در محتوای برنامه Flutter می‌پردازد. با تشخیص اینکه محتوا قابل پیمایش نیست، گوینده راه حل بسته بندی محتوا در ویجت SingleChildScrollView را برای فعال کردن عملکرد پیمایش معرفی می کند. با ترکیب SingleChildScrollView در اطراف ستون کلی محتوا، کاربران می توانند با موفقیت در محتوا حرکت کنند حتی زمانی که صفحه کلید نرم افزاری در حال استفاده است. از طریق نمایش گام به گام، بینندگان یاد می‌گیرند که چگونه این راه‌حل را به طور مؤثر پیاده‌سازی کنند تا از مشکلات طرح‌بندی جلوگیری کنند و از عملکرد مناسب در برنامه اطمینان حاصل کنند، در نهایت تجربه کاربر را با امکان پیمایش یکپارچه محتوا بهبود می‌بخشند. علاوه بر این، این آموزش بینش‌هایی را در مورد جنبه‌های فنی نحوه مدیریت فلاتر اسکرول و تنظیمات برای اندازه‌های مختلف صفحه ارائه می‌دهد.",
                            },
                        },
                        // 79 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Working with ListViews",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker explains how to use ListView widget in Flutter instead of a column with a single child scroll view to create a scrollable list of items. The ListView widget is essentially a column with a single child scroll view, but has optimizations in place to improve performance, especially for long lists. The video also covers the ListView builder which only renders visible items, saving memory and improving performance for large lists. The ListView builder requires an item builder function to dynamically load and render list items. By using ListView builder, developers can create efficient and high-performance lists in Flutter.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Sprecher, wie man in Flutter anstelle einer Spalte mit einer einzelnen untergeordneten Scroll-Ansicht das ListView-Widget verwendet, um eine scrollbare Liste von Elementen zu erstellen. Das ListView-Widget ist im Wesentlichen eine Spalte mit einer einzelnen untergeordneten Scroll-Ansicht, verfügt jedoch über Optimierungen zur Verbesserung der Leistung, insbesondere bei langen Listen. Das Video behandelt auch den ListView-Builder, der nur sichtbare Elemente rendert, wodurch Speicher gespart und die Leistung bei großen Listen verbessert wird. Der ListView-Builder erfordert eine Element-Builder-Funktion zum dynamischen Laden und Rendern von Listenelementen. Mithilfe des ListView-Builders können Entwickler effiziente und leistungsstarke Listen in Flutter erstellen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者解释了如何在 Flutter 中使用 ListView 小部件（而不是带有单个子滚动视图的列）来创建可滚动的项目列表。ListView 小部件本质上是带有单个子滚动视图的列，但已进行优化以提高性能，尤其是对于长列表。视频还介绍了 ListView 构建器，它仅渲染可见项目，从而节省内存并提高大型列表的性能。ListView 构建器需要一个项目构建器函数来动态加载和渲染列表项。通过使用 ListView 构建器，开发人员可以在 Flutter 中创建高效且高性能的列表。",
                                // Russian
                                "Русский": "В этом видео докладчик объясняет, как использовать виджет ListView во Flutter вместо столбца с одним дочерним прокручиваемым представлением для создания прокручиваемого списка элементов. Виджет ListView по сути является столбцом с одним дочерним прокручиваемым представлением, но имеет оптимизации для повышения производительности, особенно для длинных списков. Видео также охватывает конструктор ListView, который отображает только видимые элементы, экономя память и повышая производительность для больших списков. Конструктору ListView требуется функция конструктора элементов для динамической загрузки и отображения элементов списка. Используя конструктор ListView, разработчики могут создавать эффективные и высокопроизводительные списки во Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique comment utiliser le widget ListView dans Flutter au lieu d'une colonne avec une seule vue de défilement enfant pour créer une liste déroulante d'éléments. Le widget ListView est essentiellement une colonne avec une seule vue de défilement enfant, mais dispose d'optimisations pour améliorer les performances, en particulier pour les longues listes. La vidéo présente également le générateur ListView qui ne rend que les éléments visibles, économisant ainsi de la mémoire et améliorant les performances des grandes listes. Le générateur ListView nécessite une fonction de création d'éléments pour charger et restituer dynamiquement les éléments de la liste. En utilisant le générateur ListView, les développeurs peuvent créer des listes efficaces et performantes dans Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が、スクロール可能なアイテムのリストを作成するために、1 つの子スクロール ビューを持つ列の代わりに Flutter の ListView ウィジェットを使用する方法について説明します。ListView ウィジェットは基本的に 1 つの子スクロール ビューを持つ列ですが、特に長いリストの場合にパフォーマンスを向上させるために最適化されています。ビデオでは、表示されているアイテムのみをレンダリングしてメモリを節約し、大きなリストのパフォーマンスを向上させる ListView ビルダーについても説明します。ListView ビルダーには、リスト アイテムを動的にロードしてレンダリングするためのアイテム ビルダー関数が必要です。ListView ビルダーを使用すると、開発者は Flutter で効率的でパフォーマンスの高いリストを作成できます。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter에서 단일 자식 스크롤 뷰가 있는 열 대신 ListView 위젯을 사용하여 스크롤 가능한 항목 목록을 만드는 방법을 설명합니다. ListView 위젯은 기본적으로 단일 자식 스크롤 뷰가 있는 열이지만, 특히 긴 목록의 경우 성능을 개선하기 위해 최적화되어 있습니다. 이 영상에서는 표시되는 항목만 렌더링하여 메모리를 절약하고 큰 목록의 성능을 개선하는 ListView 빌더도 다룹니다. ListView 빌더는 목록 항목을 동적으로 로드하고 렌더링하기 위한 항목 빌더 함수가 필요합니다. ListView 빌더를 사용하면 개발자는 Flutter에서 효율적이고 고성능 목록을 만들 수 있습니다.",
                                // Spanish
                                "Español": "En este video, el orador explica cómo usar el widget ListView en Flutter en lugar de una columna con una sola vista de desplazamiento secundaria para crear una lista desplazable de elementos. El widget ListView es esencialmente una columna con una sola vista de desplazamiento secundaria, pero tiene optimizaciones implementadas para mejorar el rendimiento, especialmente para listas largas. El video también cubre el generador ListView que solo muestra los elementos visibles, lo que ahorra memoria y mejora el rendimiento para listas grandes. El generador ListView requiere una función de generador de elementos para cargar y mostrar dinámicamente los elementos de la lista. Al usar el generador ListView, los desarrolladores pueden crear listas eficientes y de alto rendimiento en Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता बताता है कि आइटम की स्क्रॉल करने योग्य सूची बनाने के लिए एकल चाइल्ड स्क्रॉल व्यू वाले कॉलम के बजाय फ़्लटर में ListView विजेट का उपयोग कैसे करें। ListView विजेट अनिवार्य रूप से एकल चाइल्ड स्क्रॉल व्यू वाला एक कॉलम है, लेकिन इसमें प्रदर्शन को बेहतर बनाने के लिए अनुकूलन हैं, खासकर लंबी सूचियों के लिए। वीडियो में ListView बिल्डर को भी शामिल किया गया है जो केवल दृश्यमान आइटम प्रस्तुत करता है, मेमोरी बचाता है और बड़ी सूचियों के लिए प्रदर्शन में सुधार करता है। ListView बिल्डर को सूची आइटम को गतिशील रूप से लोड और प्रस्तुत करने के लिए आइटम बिल्डर फ़ंक्शन की आवश्यकता होती है। ListView बिल्डर का उपयोग करके, डेवलपर्स फ़्लटर में कुशल और उच्च-प्रदर्शन सूचियाँ बना सकते हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador explica como utilizar o widget ListView no Flutter em vez de uma coluna com uma única vista de rolagem secundária para criar uma lista de itens que pode ser percorrida. O widget ListView é essencialmente uma coluna com uma única vista de rolagem secundária, mas tem otimizações para melhorar o desempenho, especialmente para listas longas. O vídeo aborda também o construtor ListView, que renderiza apenas itens visíveis, poupando memória e melhorando o desempenho de listas grandes. O construtor ListView requer uma função de construtor de itens para carregar e renderizar itens de lista dinamicamente. Ao utilizar o construtor ListView, os programadores podem criar listas eficientes e de alto desempenho no Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার ব্যাখ্যা করেছেন যে কীভাবে আইটেমগুলির একটি স্ক্রোলযোগ্য তালিকা তৈরি করতে একটি একক চাইল্ড স্ক্রোল ভিউ সহ একটি কলামের পরিবর্তে ফ্লটারে লিস্টভিউ উইজেট ব্যবহার করবেন৷ লিস্টভিউ উইজেটটি মূলত একটি একক চাইল্ড স্ক্রোল ভিউ সহ একটি কলাম, তবে কর্মক্ষমতা উন্নত করার জন্য অপ্টিমাইজেশন রয়েছে, বিশেষ করে দীর্ঘ তালিকার জন্য। ভিডিওটি লিস্টভিউ বিল্ডারকেও কভার করে যা শুধুমাত্র দৃশ্যমান আইটেমগুলিকে রেন্ডার করে, মেমরি সংরক্ষণ করে এবং বড় তালিকার জন্য কর্মক্ষমতা উন্নত করে। তালিকা আইটেমগুলিকে গতিশীলভাবে লোড এবং রেন্ডার করার জন্য লিস্টভিউ নির্মাতার একটি আইটেম নির্মাতা ফাংশন প্রয়োজন৷ লিস্টভিউ বিল্ডার ব্যবহার করে, ডেভেলপাররা ফ্লটারে দক্ষ এবং উচ্চ-কার্যক্ষমতার তালিকা তৈরি করতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المتحدث كيفية استخدام عنصر واجهة المستخدم ListView في Flutter بدلاً من عمود بعرض تمرير فرعي واحد لإنشاء قائمة قابلة للتمرير من العناصر. عنصر واجهة المستخدم ListView هو في الأساس عمود بعرض تمرير فرعي واحد، ولكنه يحتوي على تحسينات لتحسين الأداء، وخاصة للقوائم الطويلة. يغطي الفيديو أيضًا منشئ ListView الذي يعرض العناصر المرئية فقط، مما يوفر الذاكرة ويحسن الأداء للقوائم الكبيرة. يتطلب منشئ ListView وظيفة منشئ العناصر لتحميل وعرض عناصر القائمة ديناميكيًا. باستخدام منشئ ListView، يمكن للمطورين إنشاء قوائم فعالة وعالية الأداء في Flutter.",
                                // Persian
                                "فارسی": "در این ویدیو، سخنران نحوه استفاده از ویجت ListView در Flutter را به جای ستونی با نمایش اسکرول تک فرزند برای ایجاد لیست قابل پیمایش از آیتم ها توضیح می دهد. ویجت ListView اساساً یک ستون با یک نمای اسکرول فرزند است، اما دارای بهینه‌سازی‌هایی برای بهبود عملکرد، به‌ویژه برای لیست‌های طولانی است. این ویدیو همچنین سازنده ListView را پوشش می دهد که فقط موارد قابل مشاهده را ارائه می دهد، حافظه را ذخیره می کند و عملکرد را برای لیست های بزرگ بهبود می بخشد. سازنده ListView به یک تابع سازنده آیتم برای بارگذاری پویا و رندر آیتم های لیست نیاز دارد. با استفاده از سازنده ListView، توسعه دهندگان می توانند لیست های کارآمد و با کارایی بالا را در Flutter ایجاد کنند.",
                            },
                        },
                        // 80 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Further Input & Output Styling and Configuration",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker demonstrates how to implement improvements in a Flutter app for adding transactions. The enhancements include setting up a number keyboard for entering amounts, ensuring data is submitted only when title and amount values are provided, displaying amounts with exactly two decimal places using the 'toStringAsFixed' method, and implementing basic validation to prevent negative amounts or empty fields. The speaker also discusses the concept of using anonymous functions and underscores in code, optimizing code reusability by refactoring functions, and ensuring proper execution of functions in different scenarios within the app. By following these steps, the app's user interface is enhanced for better user experience and functionality.",
                                // German
                                "Deutsch": "In diesem Video zeigt der Sprecher, wie man Verbesserungen in einer Flutter-App zum Hinzufügen von Transaktionen implementiert. Die Verbesserungen umfassen das Einrichten einer Zifferntastatur zum Eingeben von Beträgen, das Sicherstellen, dass Daten nur übermittelt werden, wenn Titel- und Betragswerte angegeben sind, das Anzeigen von Beträgen mit genau zwei Dezimalstellen mithilfe der Methode „toStringAsFixed“ und das Implementieren einer grundlegenden Validierung, um negative Beträge oder leere Felder zu verhindern. Der Sprecher bespricht auch das Konzept der Verwendung anonymer Funktionen und Unterstriche im Code, das Optimieren der Wiederverwendbarkeit von Code durch Refactoring von Funktionen und das Sicherstellen der ordnungsgemäßen Ausführung von Funktionen in verschiedenen Szenarien innerhalb der App. Durch Befolgen dieser Schritte wird die Benutzeroberfläche der App für ein besseres Benutzererlebnis und eine bessere Funktionalität verbessert.",
                                // Chinese
                                "中国人": "在本视频中，演讲者演示了如何在 Flutter 应用中实现改进以添加交易。增强功能包括设置数字键盘以输入金额、确保仅在提供标题和金额值时提交数据、使用“toStringAsFixed”方法显示精确两位小数的金额以及实施基本验证以防止出现负数金额或空字段。演讲者还讨论了在代码中使用匿名函数和下划线的概念、通过重构函数优化代码可重用性以及确保在应用内的不同场景中正确执行函数。通过遵循这些步骤，可以增强应用的用户界面，从而获得更好的用户体验和功能。",
                                // Russian
                                "Русский": "В этом видео докладчик демонстрирует, как реализовать улучшения в приложении Flutter для добавления транзакций. Улучшения включают настройку числовой клавиатуры для ввода сумм, обеспечение отправки данных только при предоставлении значений заголовка и суммы, отображение сумм с точностью до двух знаков после запятой с помощью метода 'toStringAsFixed' и реализацию базовой проверки для предотвращения отрицательных сумм или пустых полей. Докладчик также обсуждает концепцию использования анонимных функций и подчеркиваний в коде, оптимизацию повторного использования кода путем рефакторинга функций и обеспечение надлежащего выполнения функций в различных сценариях в приложении. Выполнение этих шагов улучшает пользовательский интерфейс приложения для лучшего пользовательского опыта и функциональности.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant montre comment mettre en œuvre des améliorations dans une application Flutter pour ajouter des transactions. Les améliorations incluent la configuration d'un clavier numérique pour la saisie des montants, la garantie que les données ne sont soumises que lorsque les valeurs de titre et de montant sont fournies, l'affichage des montants avec exactement deux décimales à l'aide de la méthode « toStringAsFixed » et la mise en œuvre d'une validation de base pour éviter les montants négatifs ou les champs vides. L'intervenant discute également du concept d'utilisation de fonctions anonymes et de traits de soulignement dans le code, l'optimisation de la réutilisabilité du code en refactorisant les fonctions et la garantie d'une exécution correcte des fonctions dans différents scénarios au sein de l'application. En suivant ces étapes, l'interface utilisateur de l'application est améliorée pour une meilleure expérience utilisateur et de meilleures fonctionnalités.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が Flutter アプリでトランザクションを追加するための改善を実装する方法を実演します。強化内容には、金額を入力するための数字キーボードの設定、タイトルと金額の値が指定されている場合にのみデータが送信されるようにすること、'toStringAsFixed' メソッドを使用して小数点以下 2 桁で金額を表示すること、負の金額や空のフィールドを防ぐための基本的な検証を実装することなどが含まれます。講演者はまた、コードで匿名関数とアンダースコアを使用する概念、関数をリファクタリングしてコードの再利用性を最適化すること、アプリ内のさまざまなシナリオで関数が適切に実行されるようにすることについても説明します。これらの手順に従うことで、アプリのユーザー インターフェースが強化され、ユーザー エクスペリエンスと機能が向上します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 앱에서 거래를 추가하기 위한 개선 사항을 구현하는 방법을 보여줍니다. 개선 사항에는 금액을 입력하기 위한 숫자 키보드 설정, 제목 및 금액 값이 제공될 때만 데이터가 제출되도록 보장, 'toStringAsFixed' 메서드를 사용하여 정확히 두 자리 소수점까지 금액을 표시, 음수 금액이나 빈 필드를 방지하기 위한 기본 검증 구현이 포함됩니다. 발표자는 또한 코드에서 익명 함수와 밑줄을 사용하는 개념, 함수를 리팩토링하여 코드 재사용성을 최적화하는 것, 앱 내의 다양한 시나리오에서 함수가 제대로 실행되는지 보장하는 것에 대해서도 설명합니다. 이러한 단계를 따르면 앱의 사용자 인터페이스가 개선되어 더 나은 사용자 경험과 기능이 제공됩니다.",
                                // Spanish
                                "Español": "En este video, el orador demuestra cómo implementar mejoras en una aplicación Flutter para agregar transacciones. Las mejoras incluyen configurar un teclado numérico para ingresar montos, garantizar que los datos se envíen solo cuando se proporcionen los valores de título y monto, mostrar montos con exactamente dos decimales mediante el método 'toStringAsFixed' e implementar una validación básica para evitar montos negativos o campos vacíos. El orador también analiza el concepto de usar funciones anónimas y guiones bajos en el código, optimizar la reutilización del código mediante la refactorización de funciones y garantizar la ejecución adecuada de las funciones en diferentes escenarios dentro de la aplicación. Al seguir estos pasos, se mejora la interfaz de usuario de la aplicación para brindar una mejor experiencia y funcionalidad al usuario.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता यह दर्शाता है कि लेन-देन जोड़ने के लिए फ़्लटर ऐप में सुधार कैसे लागू किया जाए। संवर्द्धन में राशि दर्ज करने के लिए एक नंबर कीबोर्ड सेट करना, यह सुनिश्चित करना कि डेटा केवल तभी सबमिट किया जाए जब शीर्षक और राशि मान प्रदान किए गए हों, 'toStringAsFixed' विधि का उपयोग करके ठीक दो दशमलव स्थानों के साथ राशि प्रदर्शित करना और नकारात्मक राशि या खाली फ़ील्ड को रोकने के लिए बुनियादी सत्यापन लागू करना शामिल है। वक्ता कोड में अनाम फ़ंक्शन और अंडरस्कोर का उपयोग करने, फ़ंक्शन को रीफ़ैक्टर करके कोड पुन: प्रयोज्यता को अनुकूलित करने और ऐप के भीतर विभिन्न परिदृश्यों में फ़ंक्शन के उचित निष्पादन को सुनिश्चित करने की अवधारणा पर भी चर्चा करता है। इन चरणों का पालन करके, बेहतर उपयोगकर्ता अनुभव और कार्यक्षमता के लिए ऐप का उपयोगकर्ता इंटरफ़ेस बढ़ाया जाता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador demonstra como implementar melhorias numa aplicação Flutter para adição de transações. As melhorias incluem a configuração de um teclado numérico para introduzir valores, garantir que os dados são enviados apenas quando os valores de título e valor são fornecidos, exibir valores com exatamente duas casas decimais utilizando o método 'toStringAsFixed' e implementar validação básica para evitar valores negativos ou campos vazios . O orador discute ainda o conceito de utilização de funções anónimas e sublinhados no código, otimizando a reutilização do código através da refatoração de funções e garantindo a execução adequada das funções em diferentes cenários dentro da aplicação. Seguindo estes passos, a interface do utilizador da aplicação é melhorada para uma melhor experiência e funcionalidade do utilizador.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার দেখান কিভাবে লেনদেন যোগ করার জন্য একটি ফ্লাটার অ্যাপে উন্নতি বাস্তবায়ন করতে হয়। পরিমানগুলি প্রবেশের জন্য একটি সংখ্যা কীবোর্ড সেট আপ করা, শিরোনাম এবং পরিমাণের মান প্রদান করা হলেই ডেটা জমা দেওয়া নিশ্চিত করা, 'toStringAsFixed' পদ্ধতি ব্যবহার করে ঠিক দুই দশমিক স্থানের সাথে পরিমাণ প্রদর্শন করা এবং ঋণাত্মক পরিমাণ বা খালি ক্ষেত্রগুলি রোধ করতে মৌলিক বৈধতা প্রয়োগ করা অন্তর্ভুক্ত। . স্পিকার বেনামী ফাংশন ব্যবহার করার ধারণা এবং কোডে আন্ডারস্কোর, রিফ্যাক্টরিং ফাংশন দ্বারা কোড পুনঃব্যবহারযোগ্যতা অপ্টিমাইজ করা এবং অ্যাপের মধ্যে বিভিন্ন পরিস্থিতিতে ফাংশনগুলির যথাযথ সম্পাদন নিশ্চিত করার ধারণা নিয়েও আলোচনা করেন। এই পদক্ষেপগুলি অনুসরণ করে, অ্যাপটির ব্যবহারকারী ইন্টারফেস উন্নত ব্যবহারকারীর অভিজ্ঞতা এবং কার্যকারিতার জন্য উন্নত করা হয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المتحدث كيفية تنفيذ التحسينات في تطبيق Flutter لإضافة المعاملات. تتضمن التحسينات إعداد لوحة مفاتيح رقمية لإدخال المبالغ، والتأكد من إرسال البيانات فقط عند توفير قيم العنوان والمبلغ، وعرض المبالغ بمنزلتين عشريتين بالضبط باستخدام طريقة 'toStringAsFixed'، وتنفيذ التحقق الأساسي لمنع المبالغ السلبية أو الحقول الفارغة. يناقش المتحدث أيضًا مفهوم استخدام الدوال المجهولة والشرطات السفلية في الكود، وتحسين إمكانية إعادة استخدام الكود من خلال إعادة صياغة الدوال، وضمان التنفيذ السليم للدوال في سيناريوهات مختلفة داخل التطبيق. باتباع هذه الخطوات، يتم تحسين واجهة مستخدم التطبيق لتحسين تجربة المستخدم والوظائف.",
                                // Persian
                                "فارسی": "در این ویدئو، بلندگو نحوه اجرای بهبود در اپلیکیشن فلاتر برای افزودن تراکنش ها را نشان می دهد. پیشرفت‌ها شامل راه‌اندازی صفحه‌کلید اعداد برای وارد کردن مقادیر، اطمینان از ارسال داده‌ها تنها زمانی که مقادیر عنوان و مقدار ارائه می‌شوند، نمایش مقادیر دقیقاً با دو رقم اعشار با استفاده از روش 'toStringAsFixed' و اجرای اعتبارسنجی اولیه برای جلوگیری از مقادیر منفی یا فیلدهای خالی است. . سخنران همچنین در مورد مفهوم استفاده از توابع ناشناس و زیرخط در کد، بهینه سازی قابلیت استفاده مجدد کد با بازآفرینی توابع، و اطمینان از اجرای صحیح توابع در سناریوهای مختلف در برنامه بحث می کند. با انجام این مراحل، رابط کاربری برنامه برای تجربه و عملکرد بهتر کاربر بهبود می یابد.",
                            },
                        },
                        // 81 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Adding AppBar Buttons & Floating Action Buttons",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker focuses on implementing buttons in a Flutter app to control the visibility of the text input area. The 'app bar' is enhanced by adding icon buttons that utilize the IconButton widget and the icons class provided by Flutter, allowing for the addition of icons to the app bar. The speaker demonstrates setting up a floating action button, using the FloatingActionButton widget, and how to configure its position on the page. By adding buttons to the app bar and a floating action button, the speaker sets the stage for creating functionality where pressing these buttons triggers the appearance of a bottom sheet, providing a smooth user experience for accessing and entering text input.",
                                // German
                                "Deutsch": "In diesem Video konzentriert sich der Sprecher auf die Implementierung von Schaltflächen in einer Flutter-App, um die Sichtbarkeit des Texteingabebereichs zu steuern. Die „App-Leiste“ wird durch das Hinzufügen von Symbolschaltflächen erweitert, die das IconButton-Widget und die von Flutter bereitgestellte Symbolklasse verwenden, wodurch das Hinzufügen von Symbolen zur App-Leiste ermöglicht wird. Der Sprecher demonstriert das Einrichten einer schwebenden Aktionsschaltfläche mithilfe des FloatingActionButton-Widgets und wie man ihre Position auf der Seite konfiguriert. Durch das Hinzufügen von Schaltflächen zur App-Leiste und einer schwebenden Aktionsschaltfläche bereitet der Sprecher die Bühne für die Erstellung einer Funktion, bei der das Drücken dieser Schaltflächen das Erscheinen eines unteren Blatts auslöst und so ein reibungsloses Benutzererlebnis beim Zugreifen auf und Eingeben von Texteingaben bietet.",
                                // Chinese
                                "中国人": "在本视频中，演讲者重点介绍了如何在 Flutter 应用中实现按钮以控制文本输入区域的可见性。通过添加利用 IconButton 小部件和 Flutter 提供的图标类的图标按钮，可以增强“应用栏”，从而允许向应用栏添加图标。演讲者演示了如何使用 FloatingActionButton 小部件设置浮动操作按钮以及如何配置其在页面上的位置。通过向应用栏添加按钮和浮动操作按钮，演讲者为创建功能奠定了基础，按下这些按钮会触发底部表单的出现，从而为访问和输入文本提供流畅的用户体验。",
                                // Russian
                                "Русский": "В этом видео докладчик фокусируется на реализации кнопок в приложении Flutter для управления видимостью области ввода текста. «Панель приложений» улучшена путем добавления кнопок-значков, которые используют виджет IconButton и класс значков, предоставляемый Flutter, что позволяет добавлять значки на панель приложений. Докладчик демонстрирует настройку плавающей кнопки действия с помощью виджета FloatingActionButton и то, как настроить ее положение на странице. Добавляя кнопки на панель приложений и плавающую кнопку действия, докладчик закладывает основу для создания функциональности, где нажатие этих кнопок вызывает появление нижнего листа, обеспечивая плавный пользовательский интерфейс для доступа и ввода текста.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant se concentre sur la mise en œuvre de boutons dans une application Flutter pour contrôler la visibilité de la zone de saisie de texte. La « barre d'applications » est améliorée par l'ajout de boutons d'icônes qui utilisent le widget IconButton et la classe d'icônes fournie par Flutter, permettant l'ajout d'icônes à la barre d'applications. L'intervenant montre comment configurer un bouton d'action flottant, à l'aide du widget FloatingActionButton, et comment configurer sa position sur la page. En ajoutant des boutons à la barre d'applications et un bouton d'action flottant, l'intervenant prépare le terrain pour la création d'une fonctionnalité où le fait d'appuyer sur ces boutons déclenche l'apparition d'une feuille inférieure, offrant une expérience utilisateur fluide pour accéder et saisir du texte.",
                                // Japanese
                                "日本語": "このビデオでは、スピーカーは、テキスト入力領域の表示を制御するために Flutter アプリにボタンを実装することに焦点を当てています。Flutter が提供する IconButton ウィジェットと icons クラスを利用するアイコン ボタンを追加することで、「アプリ バー」が強化され、アプリ バーにアイコンを追加できるようになります。スピーカーは、FloatingActionButton ウィジェットを使用してフローティング アクション ボタンを設定する方法と、ページ上での位置を構成する方法を示します。スピーカーは、アプリ バーにボタンとフローティング アクション ボタンを追加することで、これらのボタンを押すと下部のシートが表示される機能を作成するための準備を整え、テキスト入力にアクセスして入力するためのスムーズなユーザー エクスペリエンスを提供します。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 앱에서 텍스트 입력 영역의 가시성을 제어하기 위한 버튼을 구현하는 데 중점을 둡니다. Flutter에서 제공하는 IconButton 위젯과 아이콘 클래스를 활용하는 아이콘 버튼을 추가하여 '앱 바'를 개선하고, 앱 바에 아이콘을 추가할 수 있습니다. 발표자는 FloatingActionButton 위젯을 사용하여 플로팅 액션 버튼을 설정하고 페이지에서 해당 버튼의 위치를 ​​구성하는 방법을 보여줍니다. 앱 바와 플로팅 액션 버튼에 버튼을 추가하여 발표자는 이러한 버튼을 누르면 바텀 시트가 나타나 텍스트 입력에 액세스하고 입력하기 위한 원활한 사용자 경험을 제공하는 기능을 만드는 단계를 설정합니다.",
                                // Spanish
                                "Español": "En este video, el orador se centra en la implementación de botones en una aplicación Flutter para controlar la visibilidad del área de entrada de texto. La 'barra de la aplicación' se mejora agregando botones de íconos que utilizan el widget IconButton y la clase de íconos proporcionada por Flutter, lo que permite agregar íconos a la barra de la aplicación. El orador demuestra cómo configurar un botón de acción flotante, utilizando el widget FloatingActionButton, y cómo configurar su posición en la página. Al agregar botones a la barra de la aplicación y un botón de acción flotante, el orador prepara el escenario para crear una funcionalidad en la que al presionar estos botones se activa la apariencia de una hoja inferior, lo que brinda una experiencia de usuario fluida para acceder e ingresar texto.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता टेक्स्ट इनपुट क्षेत्र की दृश्यता को नियंत्रित करने के लिए फ़्लटर ऐप में बटन लागू करने पर ध्यान केंद्रित करता है। 'ऐप बार' को आइकन बटन जोड़कर बढ़ाया जाता है जो फ़्लटर द्वारा प्रदान किए गए आइकन वर्ग और आइकनबटन विजेट का उपयोग करते हैं, जिससे ऐप बार में आइकन जोड़ने की अनुमति मिलती है। वक्ता फ़्लोटिंग एक्शन बटन सेट अप करना, फ़्लोटिंगएक्शनबटन विजेट का उपयोग करना और पृष्ठ पर इसकी स्थिति को कॉन्फ़िगर करना प्रदर्शित करता है। ऐप बार में बटन और फ़्लोटिंग एक्शन बटन जोड़कर, वक्ता कार्यक्षमता बनाने के लिए मंच तैयार करता है जहाँ इन बटनों को दबाने से नीचे की शीट दिखाई देती है, जो टेक्स्ट इनपुट तक पहुँचने और दर्ज करने के लिए एक सहज उपयोगकर्ता अनुभव प्रदान करती है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador foca-se na implementação de botões numa aplicação Flutter para controlar a visibilidade da área de introdução de texto. A 'barra de aplicações' é melhorada com a adição de botões de ícones que utilizam o widget IconButton e a classe de ícones fornecida pelo Flutter, permitindo a adição de ícones à barra de aplicações. O orador demonstra a configuração de um botão de ação flutuante, utilizando o widget FloatingActionButton, e como configurar a sua posição na página. Ao adicionar botões à barra de aplicações e um botão de ação flutuante, o altifalante prepara o terreno para a criação de funcionalidades em que pressionar estes botões aciona a aparência de uma folha inferior, proporcionando uma experiência de utilizador tranquila para aceder e inserir a entrada de texto.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার পাঠ্য ইনপুট এলাকার দৃশ্যমানতা নিয়ন্ত্রণ করতে একটি ফ্লাটার অ্যাপে বোতামগুলি প্রয়োগ করার উপর ফোকাস করে৷ 'অ্যাপ বার' আইকন বোতাম যোগ করে উন্নত করা হয় যা আইকন বোতাম উইজেট এবং ফ্লটার দ্বারা প্রদত্ত আইকন ক্লাস ব্যবহার করে, অ্যাপ বারে আইকন যোগ করার অনুমতি দেয়। স্পিকার ফ্লোটিং অ্যাকশন বোতাম উইজেট ব্যবহার করে একটি ফ্লোটিং অ্যাকশন বোতাম সেট আপ করে এবং কীভাবে পৃষ্ঠায় তার অবস্থান কনফিগার করতে হয় তা প্রদর্শন করে। অ্যাপ বারে বোতাম এবং একটি ফ্লোটিং অ্যাকশন বোতাম যোগ করে, স্পিকার কার্যকারিতা তৈরি করার পর্যায় সেট করে যেখানে এই বোতামগুলি টিপলে নীচের শীটের উপস্থিতি ট্রিগার হয়, পাঠ্য ইনপুট অ্যাক্সেস এবং প্রবেশ করার জন্য একটি মসৃণ ব্যবহারকারীর অভিজ্ঞতা প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يركز المتحدث على تنفيذ الأزرار في تطبيق Flutter للتحكم في رؤية منطقة إدخال النص. يتم تحسين 'شريط التطبيق' من خلال إضافة أزرار أيقونات تستخدم عنصر واجهة المستخدم IconButton وفئة الأيقونات التي يوفرها Flutter، مما يسمح بإضافة أيقونات إلى شريط التطبيق. يوضح المتحدث إعداد زر إجراء عائم، باستخدام عنصر واجهة المستخدم FloatingActionButton، وكيفية تكوين موضعه على الصفحة. من خلال إضافة أزرار إلى شريط التطبيق وزر إجراء عائم، يمهد المتحدث الطريق لإنشاء وظيفة حيث يؤدي الضغط على هذه الأزرار إلى ظهور ورقة سفلية، مما يوفر تجربة مستخدم سلسة للوصول إلى إدخال النص وإدخاله.",
                                // Persian
                                "فارسی": "در این ویدیو، اسپیکر بر روی پیاده سازی دکمه ها در یک برنامه Flutter تمرکز می کند تا دید ناحیه ورودی متن را کنترل کند. 'نوار برنامه' با افزودن دکمه‌های آیکونی که از ویجت IconButton و کلاس آیکون‌های ارائه‌شده توسط Flutter استفاده می‌کنند، بهبود می‌یابد و امکان افزودن آیکون‌ها به نوار برنامه را فراهم می‌کند. بلندگو تنظیم یک دکمه اکشن شناور را با استفاده از ویجت FloatingActionButton و نحوه پیکربندی موقعیت آن در صفحه را نشان می دهد. با افزودن دکمه‌ها به نوار برنامه و یک دکمه عمل شناور، بلندگو زمینه را برای ایجاد عملکرد فراهم می‌کند که در آن فشار دادن این دکمه‌ها ظاهر صفحه پایینی را ایجاد می‌کند و تجربه کاربری نرمی را برای دسترسی و وارد کردن ورودی متن فراهم می‌کند.",
                            },
                        },
                        // 82 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Showing a Modal Bottom Sheet",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video provides a tutorial on how to implement a bottom modal sheet in Flutter using the showModalBottomSheet function. The speaker demonstrates how to create a method called startAddNewTransaction that triggers the modal sheet to appear when called. By passing the context and a builder function to showModalBottomSheet, the speaker explains how to display the desired widget within the modal sheet. The process involves restructuring code and transitioning from a stateless widget to a stateful widget in order to manage state and functionality effectively. Additionally, the speaker discusses the use of GestureDetector to prevent the modal sheet from closing when tapping on it, providing a solution for a potential issue. Through these steps, viewers can learn how to integrate a bottom modal sheet into their Flutter applications for improved user interaction.",
                                // German
                                "Deutsch": "Dieses Video bietet ein Tutorial zur Implementierung eines unteren Modalblatts in Flutter mithilfe der Funktion showModalBottomSheet. Der Sprecher demonstriert, wie eine Methode namens startAddNewTransaction erstellt wird, die bei Aufruf das Erscheinen des Modalblatts auslöst. Durch Übergeben des Kontexts und einer Builder-Funktion an showModalBottomSheet erklärt der Sprecher, wie das gewünschte Widget innerhalb des Modalblatts angezeigt wird. Der Prozess umfasst die Umstrukturierung des Codes und den Übergang von einem zustandslosen Widget zu einem zustandsbehafteten Widget, um Status und Funktionalität effektiv zu verwalten. Darüber hinaus erörtert der Sprecher die Verwendung von GestureDetector, um zu verhindern, dass das Modalblatt beim Antippen geschlossen wird, und bietet so eine Lösung für ein potenzielles Problem. Durch diese Schritte können die Zuschauer lernen, wie sie ein unteres Modalblatt in ihre Flutter-Anwendungen integrieren, um die Benutzerinteraktion zu verbessern.",
                                // Chinese
                                "中国人": "本视频提供了如何使用 showModalBottomSheet 函数在 Flutter 中实现底部模式表的教程。演讲者演示了如何创建一个名为 startAddNewTransaction 的方法，该方法在调用时触发模式表的出现。通过将上下文和构建器函数传递给 showModalBottomSheet，演讲者解释了如何在模式表中显示所需的小部件。该过程涉及重构代码以及从无状态小部件转换为有状态小部件，以便有效地管理状态和功能。此外，演讲者还讨论了使用 GestureDetector 来防止在点击模式表时关闭模式表，从而为潜在问题提供了解决方案。通过这些步骤，观众可以了解如何将底部模式表集成到他们的 Flutter 应用程序中以改善用户交互。",
                                // Russian
                                "Русский": "В этом видео представлено руководство по реализации нижнего модального листа во Flutter с помощью функции showModalBottomSheet. Докладчик демонстрирует, как создать метод startAddNewTransaction, который запускает появление модального листа при вызове. Передавая контекст и функцию-конструктор в showModalBottomSheet, докладчик объясняет, как отобразить нужный виджет в модальном листе. Процесс включает реструктуризацию кода и переход от виджета без состояния к виджету с состоянием для эффективного управления состоянием и функциональностью. Кроме того, докладчик обсуждает использование GestureDetector для предотвращения закрытия модального листа при нажатии на него, предлагая решение потенциальной проблемы. С помощью этих шагов зрители могут узнать, как интегрировать нижний модальный лист в свои приложения Flutter для улучшения взаимодействия с пользователем.",
                                // French
                                "Français": "Cette vidéo fournit un didacticiel sur la façon d'implémenter une feuille modale inférieure dans Flutter à l'aide de la fonction showModalBottomSheet. L'intervenant montre comment créer une méthode appelée startAddNewTransaction qui déclenche l'apparition de la feuille modale lorsqu'elle est appelée. En transmettant le contexte et une fonction de création à showModalBottomSheet, l'intervenant explique comment afficher le widget souhaité dans la feuille modale. Le processus implique la restructuration du code et la transition d'un widget sans état vers un widget avec état afin de gérer efficacement l'état et les fonctionnalités. De plus, l'intervenant discute de l'utilisation de GestureDetector pour empêcher la fermeture de la feuille modale lorsque l'on appuie dessus, offrant ainsi une solution à un problème potentiel. Grâce à ces étapes, les spectateurs peuvent apprendre à intégrer une feuille modale inférieure dans leurs applications Flutter pour une meilleure interaction avec l'utilisateur.",
                                // Japanese
                                "日本語": "この動画では、showModalBottomSheet 関数を使用して Flutter で下部モーダル シートを実装する方法についてチュートリアルを提供します。講演者は、呼び出されたときにモーダル シートが表示されるようにトリガーする startAddNewTransaction というメソッドを作成する方法を示します。講演者は、コンテキストとビルダー関数を showModalBottomSheet に渡すことで、モーダル シート内に目的のウィジェットを表示する方法について説明します。このプロセスでは、状態と機能を効果的に管理するために、コードを再構築し、ステートレス ウィジェットからステートフル ウィジェットに移行します。さらに、講演者は、モーダル シートをタップしたときに閉じないようにするための GestureDetector の使用について説明し、潜在的な問題の解決策を提供します。これらの手順を通じて、視聴者は、ユーザー インタラクションを改善するために、Flutter アプリケーションに下部モーダル シートを統合する方法を学習できます。",
                                // Korean
                                "한국인": "이 비디오는 showModalBottomSheet 함수를 사용하여 Flutter에서 하단 모달 시트를 구현하는 방법에 대한 튜토리얼을 제공합니다. 발표자는 호출 시 모달 시트가 나타나도록 트리거하는 startAddNewTransaction이라는 메서드를 만드는 방법을 보여줍니다. 발표자는 컨텍스트와 빌더 함수를 showModalBottomSheet에 전달하여 모달 시트 내에 원하는 위젯을 표시하는 방법을 설명합니다. 이 프로세스에는 코드를 재구성하고 상태와 기능을 효과적으로 관리하기 위해 상태 없는 위젯에서 상태 있는 위젯으로 전환하는 작업이 포함됩니다. 또한 발표자는 GestureDetector를 사용하여 모달 시트를 탭할 때 닫히지 않도록 하는 방법을 설명하여 잠재적인 문제에 대한 솔루션을 제공합니다. 이러한 단계를 통해 시청자는 사용자 상호 작용을 개선하기 위해 하단 모달 시트를 Flutter 애플리케이션에 통합하는 방법을 배울 수 있습니다.",
                                // Spanish
                                "Español": "Este video ofrece un tutorial sobre cómo implementar una hoja modal inferior en Flutter usando la función showModalBottomSheet. El orador demuestra cómo crear un método llamado startAddNewTransaction que activa la aparición de la hoja modal cuando se lo llama. Al pasar el contexto y una función de creación a showModalBottomSheet, el orador explica cómo mostrar el widget deseado dentro de la hoja modal. El proceso implica la reestructuración del código y la transición de un widget sin estado a un widget con estado para administrar el estado y la funcionalidad de manera efectiva. Además, el orador analiza el uso de GestureDetector para evitar que la hoja modal se cierre al tocarla, lo que brinda una solución para un problema potencial. A través de estos pasos, los espectadores pueden aprender a integrar una hoja modal inferior en sus aplicaciones Flutter para mejorar la interacción del usuario.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर में showModalBottomSheet फ़ंक्शन का उपयोग करके बॉटम मोडल शीट को लागू करने के तरीके पर एक ट्यूटोरियल प्रदान करता है। वक्ता दर्शाता है कि startAddNewTransaction नामक विधि कैसे बनाई जाए जो कॉल किए जाने पर मोडल शीट को ट्रिगर करती है। संदर्भ और बिल्डर फ़ंक्शन को showModalBottomSheet में पास करके, वक्ता बताता है कि मोडल शीट के भीतर वांछित विजेट कैसे प्रदर्शित किया जाए। इस प्रक्रिया में कोड को पुनर्गठित करना और स्टेटलेस विजेट से स्टेटफुल विजेट में संक्रमण करना शामिल है ताकि स्थिति और कार्यक्षमता को प्रभावी ढंग से प्रबंधित किया जा सके। इसके अतिरिक्त, वक्ता संभावित समस्या के लिए समाधान प्रदान करते हुए मोडल शीट को टैप करने पर बंद होने से रोकने के लिए जेस्चर डिटेक्टर के उपयोग पर चर्चा करता है। इन चरणों के माध्यम से, दर्शक सीख सकते हैं कि बेहतर उपयोगकर्ता इंटरैक्शन के लिए अपने फ़्लटर अनुप्रयोगों में बॉटम मोडल शीट को कैसे एकीकृत किया जाए।",
                                // Portuguese
                                "Português": "Este vídeo fornece um tutorial sobre como implementar uma folha modal inferior no Flutter utilizando a função showModalBottomSheet. O orador demonstra como criar um método chamado startAddNewTransaction que faz com que a folha de cálculo modal apareça quando é chamada. Ao passar o contexto e uma função construtora para showModalBottomSheet, o orador explica como exibir o widget pretendido na folha modal. O processo envolve a reestruturação do código e a transição de um widget sem estado para um widget com estado, de forma a gerir o estado e a funcionalidade de forma eficaz. Além disso, o orador discute a utilização do GestureDetector para evitar que a folha modal feche ao tocar nela, fornecendo uma solução para um possível problema. Através destas etapas, os visualizadores podem aprender como integrar uma folha modal inferior nas suas aplicações Flutter para melhorar a interação do utilizador.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি showModalBottomSheet ফাংশন ব্যবহার করে ফ্লটারে একটি নীচের মডেল শীট কীভাবে প্রয়োগ করা যায় তার একটি টিউটোরিয়াল প্রদান করে। স্পিকার দেখায় কিভাবে startAddNewTransaction নামক একটি পদ্ধতি তৈরি করতে হয় যা কল করার সময় মডেল শীটটিকে ট্রিগার করে। ModalBottomSheet দেখানোর জন্য প্রসঙ্গ এবং একটি বিল্ডার ফাংশন পাস করে, স্পিকার ব্যাখ্যা করে কিভাবে মডেল শীটের মধ্যে পছন্দসই উইজেটটি প্রদর্শন করতে হয়। প্রক্রিয়াটির মধ্যে রয়েছে পুনর্গঠন কোড এবং রাষ্ট্রবিহীন উইজেট থেকে রাষ্ট্রীয় উইজেটে রূপান্তর যাতে কার্যকরভাবে রাষ্ট্র এবং কার্যকারিতা পরিচালনা করা যায়। উপরন্তু, স্পিকার একটি সম্ভাব্য সমস্যার জন্য একটি সমাধান প্রদান করে, এটিতে ট্যাপ করার সময় মডেল শীটটি বন্ধ হওয়া থেকে বিরত রাখতে GestureDetector এর ব্যবহার নিয়ে আলোচনা করে। এই পদক্ষেপগুলির মাধ্যমে, দর্শকরা উন্নত ব্যবহারকারীর ইন্টারঅ্যাকশনের জন্য তাদের ফ্লাটার অ্যাপ্লিকেশনগুলিতে একটি নীচের মডেল শীটকে কীভাবে সংহত করতে হয় তা শিখতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "يوفر هذا الفيديو برنامجًا تعليميًا حول كيفية تنفيذ ورقة نموذجية سفلية في Flutter باستخدام دالة showModalBottomSheet. يوضح المتحدث كيفية إنشاء طريقة تسمى startAddNewTransaction تعمل على تشغيل ورقة النموذجية للظهور عند استدعائها. من خلال تمرير السياق ووظيفة البناء إلى showModalBottomSheet، يشرح المتحدث كيفية عرض الأداة المطلوبة داخل ورقة النموذجية. تتضمن العملية إعادة هيكلة الكود والانتقال من أداة بدون حالة إلى أداة بحالة من أجل إدارة الحالة والوظائف بشكل فعال. بالإضافة إلى ذلك، يناقش المتحدث استخدام GestureDetector لمنع ورقة النموذجية من الإغلاق عند النقر عليها، مما يوفر حلاً لمشكلة محتملة. من خلال هذه الخطوات، يمكن للمشاهدين تعلم كيفية دمج ورقة نموذجية سفلية في تطبيقات Flutter الخاصة بهم لتحسين تفاعل المستخدم.",
                                // Persian
                                "فارسی": "در این ویدیو آموزشی نحوه پیاده سازی یک صفحه مودال پایین در Flutter با استفاده از تابع showModalBottomSheet ارائه شده است. بلندگو نحوه ایجاد روشی به نام startAddNewTransaction را نشان می دهد که باعث می شود صفحه مدال هنگام فراخوانی ظاهر شود. با انتقال متن و تابع سازنده به showModalBottomSheet، بلندگو نحوه نمایش ویجت مورد نظر را در صفحه مدال توضیح می دهد. این فرآیند شامل بازسازی کد و انتقال از یک ویجت بدون حالت به یک ویجت حالت دار به منظور مدیریت مؤثر وضعیت و عملکرد است. علاوه بر این، سخنران درباره استفاده از GestureDetector برای جلوگیری از بسته شدن صفحه مدال هنگام ضربه زدن روی آن بحث می کند و راه حلی برای یک مشکل احتمالی ارائه می دهد. از طریق این مراحل، بینندگان می توانند یاد بگیرند که چگونه یک صفحه مدال پایین را در برنامه های Flutter خود برای تعامل بهتر با کاربر ادغام کنند.",
                            },
                        },
                        // 83 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Improving & Styling the Modal Bottom Sheet",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker addresses an issue in their Flutter application where data is lost when switching between input fields in a modal sheet. The solution involves converting the Neutron's action widget from a stateless widget to a stateful widget, allowing the internal state to be maintained and preventing data loss upon re-evaluation by Flutter. The speaker explains the importance of separating data and UI in stateful widgets, ensuring that user input is persistent even when widgets are re-evaluated. Additionally, the speaker demonstrates how to automatically close the modal sheet upon submitting new transaction data by utilizing the Navigator class and the context property within the state class. The speaker highlights the significance of these changes in improving the functionality and user experience of the application.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial spricht der Sprecher ein Problem in seiner Flutter-Anwendung an, bei dem Daten verloren gehen, wenn zwischen Eingabefeldern in einem modalen Blatt gewechselt wird. Die Lösung besteht darin, das Aktions-Widget von Neutron von einem zustandslosen Widget in ein zustandsbehaftetes Widget umzuwandeln, sodass der interne Zustand erhalten bleibt und Datenverlust bei einer Neubewertung durch Flutter vermieden wird. Der Sprecher erklärt, wie wichtig es ist, Daten und Benutzeroberfläche in zustandsbehafteten Widgets zu trennen, um sicherzustellen, dass die Benutzereingabe auch bei einer Neubewertung der Widgets erhalten bleibt. Darüber hinaus demonstriert der Sprecher, wie das modale Blatt beim Senden neuer Transaktionsdaten automatisch geschlossen wird, indem die Navigator-Klasse und die Kontexteigenschaft innerhalb der Statusklasse verwendet werden. Der Sprecher betont die Bedeutung dieser Änderungen für die Verbesserung der Funktionalität und Benutzererfahrung der Anwendung.",
                                // Chinese
                                "中国人": "在此视频教程中，演讲者解决了 Flutter 应用程序中的一个问题，即在模式表中切换输入字段时数据会丢失。解决方案包括将 Neutron 的操作小部件从无状态小部件转换为有状态小部件，从而可以维护内部状态并防止 Flutter 重新评估时数据丢失。演讲者解释了在有状态小部件中分离数据和 UI 的重要性，确保即使重新评估小部件时用户输入也是持久的。此外，演讲者还演示了如何利用 Navigator 类和状态类中的 context 属性在提交新交易数据时自动关闭模式表。演讲者强调了这些变化对于改善应用程序的功能和用户体验的重要性。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик рассматривает проблему в своем приложении Flutter, где данные теряются при переключении между полями ввода в модальном листе. Решение включает преобразование виджета действий Neutron из виджета без состояния в виджет с состоянием, что позволяет поддерживать внутреннее состояние и предотвращает потерю данных при повторной оценке Flutter. Докладчик объясняет важность разделения данных и пользовательского интерфейса в виджетах с состоянием, гарантируя, что пользовательский ввод будет постоянным даже при повторной оценке виджетов. Кроме того, докладчик демонстрирует, как автоматически закрыть модальный лист при отправке новых данных транзакции, используя класс Navigator и свойство context в классе состояния. Докладчик подчеркивает важность этих изменений для улучшения функциональности и пользовательского опыта приложения.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant aborde un problème dans son application Flutter où les données sont perdues lors du basculement entre les champs de saisie dans une feuille modale. La solution consiste à convertir le widget d'action de Neutron d'un widget sans état en un widget avec état, ce qui permet de maintenir l'état interne et d'éviter la perte de données lors de la réévaluation par Flutter. L'intervenant explique l'importance de séparer les données et l'interface utilisateur dans les widgets avec état, en garantissant que la saisie de l'utilisateur est persistante même lorsque les widgets sont réévalués. De plus, l'intervenant montre comment fermer automatiquement la feuille modale lors de la soumission de nouvelles données de transaction en utilisant la classe Navigator et la propriété context dans la classe state. L'intervenant souligne l'importance de ces changements dans l'amélioration de la fonctionnalité et de l'expérience utilisateur de l'application.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、講演者が、モーダルシートの入力フィールドを切り替えるとデータが失われるという Flutter アプリケーションの問題に対処します。解決策としては、Neutron のアクションウィジェットをステートレスウィジェットからステートフルウィジェットに変換し、内部状態を維持できるようにして、Flutter による再評価時にデータが失われないようにします。講演者は、ステートフルウィジェットでデータと UI を分離し、ウィジェットが再評価されてもユーザー入力が維持されるようにすることの重要性について説明します。さらに、講演者は、Navigator クラスと状態クラス内のコンテキストプロパティを利用して、新しいトランザクションデータを送信したときにモーダルシートを自動的に閉じる方法を示します。講演者は、アプリケーションの機能とユーザーエクスペリエンスを向上させる上でのこれらの変更の重要性を強調します。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 모달 시트에서 입력 필드 간에 전환할 때 데이터가 손실되는 Flutter 애플리케이션의 문제를 다룹니다. 이 솔루션은 Neutron의 액션 위젯을 상태 없는 위젯에서 상태 있는 위젯으로 변환하여 내부 상태를 유지하고 Flutter에서 다시 평가할 때 데이터 손실을 방지하는 것을 포함합니다. 발표자는 상태 있는 위젯에서 데이터와 UI를 분리하여 위젯을 다시 평가하더라도 사용자 입력이 지속되도록 하는 것의 중요성을 설명합니다. 또한 발표자는 Navigator 클래스와 상태 클래스 내의 컨텍스트 속성을 활용하여 새 트랜잭션 데이터를 제출할 때 모달 시트를 자동으로 닫는 방법을 보여줍니다. 발표자는 이러한 변경 사항이 애플리케이션의 기능과 사용자 경험을 개선하는 데 얼마나 중요한지 강조합니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador aborda un problema en su aplicación Flutter en el que se pierden datos al cambiar entre campos de entrada en una hoja modal. La solución implica convertir el widget de acción de Neutron de un widget sin estado a un widget con estado, lo que permite mantener el estado interno y evitar la pérdida de datos tras la reevaluación por parte de Flutter. El orador explica la importancia de separar los datos y la interfaz de usuario en los widgets con estado, lo que garantiza que la entrada del usuario sea persistente incluso cuando se reevalúen los widgets. Además, el orador demuestra cómo cerrar automáticamente la hoja modal al enviar nuevos datos de transacción utilizando la clase Navigator y la propiedad de contexto dentro de la clase de estado. El orador destaca la importancia de estos cambios para mejorar la funcionalidad y la experiencia del usuario de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता अपने फ़्लटर एप्लिकेशन में एक समस्या को संबोधित करता है जहाँ मोडल शीट में इनपुट फ़ील्ड के बीच स्विच करते समय डेटा खो जाता है। समाधान में न्यूट्रॉन के एक्शन विजेट को स्टेटलेस विजेट से स्टेटफुल विजेट में बदलना शामिल है, जिससे आंतरिक स्थिति को बनाए रखा जा सके और फ़्लटर द्वारा पुनर्मूल्यांकन पर डेटा हानि को रोका जा सके। वक्ता स्टेटफुल विजेट में डेटा और UI को अलग करने के महत्व को समझाता है, यह सुनिश्चित करता है कि विजेट के पुनर्मूल्यांकन के बाद भी उपयोगकर्ता इनपुट स्थिर रहे। इसके अतिरिक्त, वक्ता यह प्रदर्शित करता है कि स्टेट क्लास के भीतर नेविगेटर क्लास और संदर्भ संपत्ति का उपयोग करके नए लेनदेन डेटा सबमिट करने पर मोडल शीट को स्वचालित रूप से कैसे बंद किया जाए। वक्ता एप्लिकेशन की कार्यक्षमता और उपयोगकर्ता अनुभव को बेहतर बनाने में इन परिवर्तनों के महत्व पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador aborda um problema na sua aplicação Flutter em que os dados são perdidos ao alternar entre campos de entrada numa folha de cálculo modal. A solução passa pela conversão do widget de ação do Neutron de um widget sem estado para um widget com estado, permitindo que o estado interno seja mantido e evitando a perda de dados após a reavaliação pelo Flutter. O orador explica a importância de separar os dados e a UI em widgets com estado, garantindo que a entrada do utilizador é persistente mesmo quando os widgets são reavaliados. Além disso, o orador demonstra como fechar automaticamente a folha de cálculo modal ao enviar novos dados de transação, utilizando a classe Navigator e a propriedade context dentro da classe state. O orador destaca a importância destas mudanças na melhoria da funcionalidade e da experiência do utilizador da aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার তাদের ফ্লাটার অ্যাপ্লিকেশনে একটি সমস্যার সমাধান করে যেখানে একটি মডেল শীটে ইনপুট ক্ষেত্রগুলির মধ্যে স্যুইচ করার সময় ডেটা হারিয়ে যায়। সমাধানের মধ্যে রয়েছে নিউট্রনের অ্যাকশন উইজেটকে স্টেটলেস উইজেট থেকে স্টেটফুল উইজেটে রূপান্তর করা, অভ্যন্তরীণ অবস্থা বজায় রাখা এবং ফ্লটার দ্বারা পুনঃমূল্যায়ন করার পরে ডেটা ক্ষতি রোধ করা। স্পিকার স্টেটফুল উইজেটগুলিতে ডেটা এবং UI আলাদা করার গুরুত্ব ব্যাখ্যা করে, উইজেটগুলি পুনঃমূল্যায়ন করা হলেও ব্যবহারকারীর ইনপুট স্থায়ী হয় তা নিশ্চিত করে৷ অতিরিক্তভাবে, স্পিকার প্রদর্শন করে কিভাবে স্বয়ংক্রিয়ভাবে ন্যাভিগেটর ক্লাস এবং রাজ্য শ্রেণীর মধ্যে প্রসঙ্গ সম্পত্তি ব্যবহার করে নতুন লেনদেনের ডেটা জমা দেওয়ার পরে মডেল শীটটি বন্ধ করা যায়। স্পিকার অ্যাপ্লিকেশনটির কার্যকারিতা এবং ব্যবহারকারীর অভিজ্ঞতার উন্নতিতে এই পরিবর্তনগুলির তাত্পর্য হাইলাইট করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يتناول المتحدث مشكلة في تطبيق Flutter حيث يتم فقد البيانات عند التبديل بين حقول الإدخال في ورقة نموذجية. يتضمن الحل تحويل عنصر واجهة المستخدم Action الخاص بـ Neutron من عنصر واجهة مستخدم بدون حالة إلى عنصر واجهة مستخدم بحالة، مما يسمح بالحفاظ على الحالة الداخلية ومنع فقد البيانات عند إعادة التقييم بواسطة Flutter. يشرح المتحدث أهمية فصل البيانات وواجهة المستخدم في عناصر واجهة المستخدم بحالة، مما يضمن استمرار إدخال المستخدم حتى عند إعادة تقييم عناصر واجهة المستخدم. بالإضافة إلى ذلك، يوضح المتحدث كيفية إغلاق ورقة النموذج تلقائيًا عند إرسال بيانات معاملة جديدة باستخدام فئة Navigator وخاصية السياق داخل فئة الحالة. يسلط المتحدث الضوء على أهمية هذه التغييرات في تحسين وظائف التطبيق وتجربة المستخدم.",
                                // Persian
                                "فارسی": "در این آموزش ویدیویی، بلندگو به مشکلی در برنامه Flutter خود می پردازد که در آن داده ها هنگام جابجایی بین فیلدهای ورودی در یک صفحه مدال از بین می رود. راه حل شامل تبدیل ویجت عمل نوترون از یک ویجت بدون حالت به یک ویجت حالت دار است که اجازه می دهد حالت داخلی حفظ شود و از از دست رفتن داده ها در صورت ارزیابی مجدد توسط فلاتر جلوگیری شود. سخنران اهمیت جداسازی داده ها و رابط کاربری در ویجت های حالت دار را توضیح می دهد و اطمینان می دهد که ورودی کاربر حتی زمانی که ویجت ها دوباره ارزیابی می شوند، پایدار است. علاوه بر این، بلندگو نشان می دهد که چگونه می توان به صورت خودکار صفحه مدال را پس از ارسال داده های تراکنش جدید با استفاده از کلاس Navigator و ویژگی متن در کلاس state بسته کرد. سخنران اهمیت این تغییرات را در بهبود عملکرد و تجربه کاربری برنامه برجسته می کند.",
                            },
                        },
                        // 84 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Configuring & Using Themes",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker addresses the lack of uniform style in their Flutter application by implementing a global theme using the concept of theming. By setting up an application theme in the main.dart file within the MaterialApp widget, the speaker defines a theme data object with arguments such as primary swatch and accent color to establish a consistent color scheme and text styles throughout the entire application. By accessing the theme through the context property, the speaker demonstrates how to utilize the primary color and accent color defined in the theme to automatically style various UI elements. The advantages of using a global theme for centralized color definition and easy customization are emphasized, showcasing the importance and convenience of theming in Flutter app development.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial geht der Sprecher auf den Mangel an einheitlichem Stil in seiner Flutter-Anwendung ein, indem er mithilfe des Konzepts des Theming ein globales Design implementiert. Indem er ein Anwendungsdesign in der Datei main.dart im MaterialApp-Widget einrichtet, definiert der Sprecher ein Designdatenobjekt mit Argumenten wie Primärfarbfeld und Akzentfarbe, um ein einheitliches Farbschema und Textstile in der gesamten Anwendung festzulegen. Indem er über die Kontexteigenschaft auf das Design zugreift, demonstriert der Sprecher, wie die im Design definierte Primärfarbe und Akzentfarbe verwendet werden können, um verschiedene UI-Elemente automatisch zu gestalten. Die Vorteile der Verwendung eines globalen Designs für eine zentrale Farbdefinition und einfache Anpassung werden hervorgehoben, wodurch die Bedeutung und Benutzerfreundlichkeit des Theming bei der Entwicklung von Flutter-Apps aufgezeigt wird.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者通过使用主题概念实现全局主题来解决 Flutter 应用程序中缺乏统一样式的问题。通过在 MaterialApp 小部件中的 main.dart 文件中设置应用程序主题，演讲者定义了一个主题数据对象，其中包含主色板和强调色等参数，以在整个应用程序中建立一致的配色方案和文本样式。通过 context 属性访问主题，演讲者演示了如何利用主题中定义的主色和强调色自动设置各种 UI 元素的样式。强调了使用全局主题进行集中颜色定义和轻松自定义的优势，展示了主题在 Flutter 应用程序开发中的重要性和便利性。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик решает проблему отсутствия единого стиля в своем приложении Flutter, внедряя глобальную тему с использованием концепции тематизации. Настраивая тему приложения в файле main.dart в виджете MaterialApp, докладчик определяет объект данных темы с такими аргументами, как основной образец и акцентный цвет, чтобы установить согласованную цветовую схему и стили текста во всем приложении. Получая доступ к теме через свойство context, докладчик демонстрирует, как использовать основной цвет и акцентный цвет, определенные в теме, для автоматического стилизации различных элементов пользовательского интерфейса. Подчеркиваются преимущества использования глобальной темы для централизованного определения цвета и легкой настройки, демонстрируя важность и удобство тематизации при разработке приложений Flutter.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant aborde le manque de style uniforme dans son application Flutter en implémentant un thème global à l'aide du concept de thème. En configurant un thème d'application dans le fichier main.dart au sein du widget MaterialApp, l'intervenant définit un objet de données de thème avec des arguments tels que l'échantillon principal et la couleur d'accentuation pour établir un jeu de couleurs et des styles de texte cohérents dans toute l'application. En accédant au thème via la propriété context, l'intervenant montre comment utiliser la couleur principale et la couleur d'accentuation définies dans le thème pour styliser automatiquement divers éléments de l'interface utilisateur. Les avantages de l'utilisation d'un thème global pour la définition centralisée des couleurs et la personnalisation facile sont soulignés, mettant en évidence l'importance et la commodité de la thématisation dans le développement d'applications Flutter.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、テーマ設定の概念を使用してグローバルテーマを実装することで、Flutter アプリケーションでの統一されたスタイルの欠如に対処します。MaterialApp ウィジェット内の main.dart ファイルにアプリケーションテーマを設定することで、プライマリスウォッチやアクセントカラーなどの引数を持つテーマデータオブジェクトを定義し、アプリケーション全体で一貫した配色とテキストスタイルを確立します。コンテキストプロパティを介してテーマにアクセスすることで、テーマで定義されたプライマリカラーとアクセントカラーを使用して、さまざまな UI 要素を自動的にスタイル設定する方法を実演します。グローバルテーマを使用して一元的な色定義と簡単なカスタマイズを行う利点が強調され、Flutter アプリ開発におけるテーマ設定の重要性と利便性が示されています。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 테마 개념을 사용하여 글로벌 테마를 구현하여 Flutter 애플리케이션에서 균일한 스타일이 부족한 문제를 해결합니다. MaterialApp 위젯 내의 main.dart 파일에 애플리케이션 테마를 설정하여 발표자는 기본 스와치 및 강조 색상과 같은 인수를 사용하여 테마 데이터 객체를 정의하여 전체 애플리케이션에서 일관된 색상 구성표와 텍스트 스타일을 설정합니다. 발표자는 컨텍스트 속성을 통해 테마에 액세스하여 테마에 정의된 기본 색상과 강조 색상을 사용하여 다양한 UI 요소에 자동으로 스타일을 지정하는 방법을 보여줍니다. 중앙 집중식 색상 정의 및 쉬운 사용자 정의를 위한 글로벌 테마 사용의 이점을 강조하여 Flutter 앱 개발에서 테마의 중요성과 편의성을 보여줍니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador aborda la falta de un estilo uniforme en su aplicación Flutter mediante la implementación de un tema global utilizando el concepto de tematización. Al configurar un tema de aplicación en el archivo main.dart dentro del widget MaterialApp, el orador define un objeto de datos de tema con argumentos como la muestra principal y el color de acento para establecer un esquema de color y estilos de texto consistentes en toda la aplicación. Al acceder al tema a través de la propiedad de contexto, el orador demuestra cómo utilizar el color principal y el color de acento definidos en el tema para diseñar automáticamente varios elementos de la interfaz de usuario. Se enfatizan las ventajas de usar un tema global para la definición centralizada del color y la personalización sencilla, lo que muestra la importancia y la conveniencia de la tematización en el desarrollo de aplicaciones Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता थीमिंग की अवधारणा का उपयोग करके एक वैश्विक थीम को लागू करके अपने फ़्लटर एप्लिकेशन में एक समान शैली की कमी को संबोधित करता है। मटीरियलऐप विजेट के भीतर main.dart फ़ाइल में एक एप्लिकेशन थीम सेट करके, वक्ता पूरे एप्लिकेशन में एक सुसंगत रंग योजना और टेक्स्ट शैलियों को स्थापित करने के लिए प्राथमिक स्वैच और उच्चारण रंग जैसे तर्कों के साथ एक थीम डेटा ऑब्जेक्ट को परिभाषित करता है। संदर्भ संपत्ति के माध्यम से थीम तक पहुँचने से, वक्ता प्रदर्शित करता है कि विभिन्न UI तत्वों को स्वचालित रूप से स्टाइल करने के लिए थीम में परिभाषित प्राथमिक रंग और उच्चारण रंग का उपयोग कैसे किया जाए। केंद्रीकृत रंग परिभाषा और आसान अनुकूलन के लिए एक वैश्विक थीम का उपयोग करने के लाभों पर जोर दिया जाता है, जो फ़्लटर ऐप विकास में थीमिंग के महत्व और सुविधा को प्रदर्शित करता है।",
                                // Portuguese
                                "Português": "Neste vídeo tutorial, o orador aborda a falta de estilo uniforme na sua aplicação Flutter implementando um tema global utilizando o conceito de tematização. Ao configurar um tema de aplicação no ficheiro main.dart dentro do widget MaterialApp, o orador define um objeto de dados de tema com argumentos como amostra primária e cor de destaque para estabelecer um esquema de cores e estilos de texto consistentes em toda a aplicação. Ao aceder ao tema através da propriedade context, o orador demonstra como utilizar a cor primária e a cor de destaque definidas no tema para estilizar automaticamente vários elementos da interface do utilizador. São enfatizadas as vantagens da utilização de um tema global para definição centralizada de cores e fácil personalização, mostrando a importância e conveniência da temática no desenvolvimento de aplicações Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার থিমিং ধারণা ব্যবহার করে একটি বিশ্বব্যাপী থিম বাস্তবায়নের মাধ্যমে তাদের ফ্লটার অ্যাপ্লিকেশনে অভিন্ন শৈলীর অভাবকে সমাধান করে। MaterialApp উইজেটের মধ্যে main.dart ফাইলে একটি অ্যাপ্লিকেশন থিম সেট আপ করে, স্পিকার পুরো অ্যাপ্লিকেশন জুড়ে একটি সামঞ্জস্যপূর্ণ রঙের স্কিম এবং পাঠ্য শৈলী স্থাপন করতে প্রাথমিক সোয়াচ এবং অ্যাকসেন্ট রঙের মতো আর্গুমেন্ট সহ একটি থিম ডেটা অবজেক্টকে সংজ্ঞায়িত করে। প্রসঙ্গ সম্পত্তির মাধ্যমে থিম অ্যাক্সেস করে, স্পিকার বিভিন্ন UI উপাদানগুলিকে স্বয়ংক্রিয়ভাবে স্টাইল করতে থিমে সংজ্ঞায়িত প্রাথমিক রঙ এবং উচ্চারণ রঙ কীভাবে ব্যবহার করতে হয় তা প্রদর্শন করে। কেন্দ্রীভূত রঙের সংজ্ঞা এবং সহজ কাস্টমাইজেশনের জন্য একটি গ্লোবাল থিম ব্যবহার করার সুবিধাগুলিকে জোর দেওয়া হয়েছে, ফ্লটার অ্যাপ ডেভেলপমেন্টে থিমিংয়ের গুরুত্ব এবং সুবিধার প্রদর্শন করে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يتناول المتحدث مشكلة عدم وجود نمط موحد في تطبيق Flutter الخاص به من خلال تنفيذ سمة عالمية باستخدام مفهوم التصميم. من خلال إعداد سمة تطبيق في ملف main.dart داخل عنصر واجهة المستخدم MaterialApp، يحدد المتحدث كائن بيانات السمة باستخدام وسيطات مثل العينة الأساسية ولون التمييز لإنشاء مخطط ألوان وأنماط نصية متسقة في جميع أنحاء التطبيق بالكامل. من خلال الوصول إلى السمة من خلال خاصية السياق، يوضح المتحدث كيفية الاستفادة من اللون الأساسي ولون التمييز المحددين في السمة لتصميم عناصر واجهة المستخدم المختلفة تلقائيًا. يتم التأكيد على مزايا استخدام سمة عالمية لتحديد اللون المركزي والتخصيص السهل، مما يوضح أهمية وراحة التصميم في تطوير تطبيقات Flutter.",
                                // Persian
                                "فارسی": "در این آموزش ویدیویی، سخنران با پیاده سازی یک تم جهانی با استفاده از مفهوم تم، به عدم وجود سبک یکنواخت در برنامه Flutter خود می پردازد. با تنظیم یک طرح زمینه برنامه در فایل main.dart در ابزارک MaterialApp، گوینده یک شی داده تم را با آرگومان هایی مانند نمونه اولیه و رنگ تاکیدی تعریف می کند تا یک طرح رنگی و سبک های متنی ثابت را در کل برنامه ایجاد کند. با دسترسی به تم از طریق ویژگی زمینه، گوینده نشان می دهد که چگونه از رنگ اصلی و رنگ تاکیدی تعریف شده در طرح زمینه برای استایل دادن به عناصر مختلف UI به طور خودکار استفاده کند. مزایای استفاده از یک تم جهانی برای تعریف متمرکز رنگ و سفارشی‌سازی آسان مورد تأکید قرار گرفته است و اهمیت و راحتی موضوع‌بندی را در توسعه برنامه Flutter نشان می‌دهد.",
                            },
                        },
                        // 85 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Custom Fonts & Working with Text Themes",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker demonstrates how to add custom fonts to a Flutter application to achieve a more personalized and consistent design. The process involves creating a folder for assets and fonts in the project directory, importing font files, and configuring the pubspec.yaml file to include the font families. By defining font families and their corresponding file paths in the pubspec.yaml file, the custom fonts are unlocked for use in the application. The speaker then explains how to set a global font family in the theme data to apply the custom font styles throughout the app. Additionally, the speaker showcases how to define custom text themes for specific elements, such as app bars and titles, using the text theme property in the ThemeData class. By accessing the theme data and text themes, developers can easily customize and apply font styles to various text elements in their Flutter application for a cohesive and professional design.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial zeigt der Sprecher, wie man einer Flutter-Anwendung benutzerdefinierte Schriftarten hinzufügt, um ein persönlicheres und einheitlicheres Design zu erzielen. Der Vorgang umfasst das Erstellen eines Ordners für Assets und Schriftarten im Projektverzeichnis, das Importieren von Schriftartdateien und das Konfigurieren der Datei pubspec.yaml zum Einschließen der Schriftartfamilien. Durch das Definieren von Schriftartfamilien und ihren entsprechenden Dateipfaden in der Datei pubspec.yaml werden die benutzerdefinierten Schriftarten für die Verwendung in der Anwendung freigegeben. Der Sprecher erklärt dann, wie man eine globale Schriftartfamilie in den Designdaten einstellt, um die benutzerdefinierten Schriftarten in der gesamten App anzuwenden. Darüber hinaus zeigt der Sprecher, wie man benutzerdefinierte Textdesigns für bestimmte Elemente wie App-Leisten und Titel definiert, indem man die Textdesigneigenschaft in der Klasse ThemeData verwendet. Durch den Zugriff auf die Designdaten und Textdesigns können Entwickler Schriftarten für verschiedene Textelemente in ihrer Flutter-Anwendung einfach anpassen und anwenden, um ein einheitliches und professionelles Design zu erzielen.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者演示了如何向 Flutter 应用程序添加自定义字体，以实现更加个性化和一致的设计。该过程包括在项目目录中为资产和字体创建文件夹、导入字体文件以及配置 pubspec.yaml 文件以包含字体系列。通过在 pubspec.yaml 文件中定义字体系列及其相应的文件路径，自定义字体将被解锁以供在应用程序中使用。然后，演讲者解释了如何在主题数据中设置全局字体系列，以在整个应用程序中应用自定义字体样式。此外，演讲者还展示了如何使用 ThemeData 类中的文本主题属性为特定元素（例如应用栏和标题）定义自定义文本主题。通过访问主题数据和文本主题，开发人员可以轻松自定义字体样式并将其应用于 Flutter 应用程序中的各种文本元素，以实现统一而专业的设计。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик демонстрирует, как добавлять пользовательские шрифты в приложение Flutter для достижения более персонализированного и последовательного дизайна. Процесс включает создание папки для ресурсов и шрифтов в каталоге проекта, импорт файлов шрифтов и настройку файла pubspec.yaml для включения семейств шрифтов. Определив семейства шрифтов и соответствующие им пути к файлам в файле pubspec.yaml, пользовательские шрифты разблокируются для использования в приложении. Затем докладчик объясняет, как задать глобальное семейство шрифтов в данных темы, чтобы применить пользовательские стили шрифтов во всем приложении. Кроме того, докладчик демонстрирует, как определять пользовательские темы текста для определенных элементов, таких как панели и заголовки приложений, с помощью свойства темы текста в классе ThemeData. Получая доступ к данным темы и темам текста, разработчики могут легко настраивать и применять стили шрифтов к различным текстовым элементам в своем приложении Flutter для получения целостного и профессионального дизайна.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant montre comment ajouter des polices personnalisées à une application Flutter pour obtenir une conception plus personnalisée et plus cohérente. Le processus implique la création d'un dossier pour les ressources et les polices dans le répertoire du projet, l'importation de fichiers de polices et la configuration du fichier pubspec.yaml pour inclure les familles de polices. En définissant les familles de polices et leurs chemins de fichiers correspondants dans le fichier pubspec.yaml, les polices personnalisées sont déverrouillées pour être utilisées dans l'application. L'intervenant explique ensuite comment définir une famille de polices globale dans les données de thème pour appliquer les styles de police personnalisés dans toute l'application. De plus, l'intervenant montre comment définir des thèmes de texte personnalisés pour des éléments spécifiques, tels que les barres d'application et les titres, à l'aide de la propriété de thème de texte dans la classe ThemeData. En accédant aux données de thème et aux thèmes de texte, les développeurs peuvent facilement personnaliser et appliquer des styles de police à divers éléments de texte dans leur application Flutter pour une conception cohérente et professionnelle.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、講演者が Flutter アプリケーションにカスタムフォントを追加して、よりパーソナライズされた一貫性のあるデザインを実現する方法を紹介します。プロセスには、プロジェクトディレクトリにアセットとフォントのフォルダを作成し、フォントファイルをインポートし、pubspec.yaml ファイルを構成してフォントファミリを含めることが含まれます。pubspec.yaml ファイルでフォントファミリとそれに対応するファイルパスを定義すると、カスタムフォントがロック解除され、アプリケーションで使用できるようになります。次に、テーマデータでグローバルフォントファミリを設定し、カスタムフォントスタイルをアプリ全体に適用する方法を説明します。さらに、ThemeData クラスのテキストテーマプロパティを使用して、アプリバーやタイトルなどの特定の要素にカスタムテキストテーマを定義する方法を紹介します。テーマデータとテキストテーマにアクセスすることで、開発者は Flutter アプリケーション内のさまざまなテキスト要素にフォントスタイルを簡単にカスタマイズして適用し、統一感のあるプロフェッショナルなデザインを実現できます。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 Flutter 애플리케이션에 사용자 정의 글꼴을 추가하여 보다 개인화되고 일관된 디자인을 구현하는 방법을 보여줍니다. 이 프로세스에는 프로젝트 디렉토리에 자산 및 글꼴 폴더를 만들고, 글꼴 파일을 가져오고, 글꼴 패밀리를 포함하도록 pubspec.yaml 파일을 구성하는 것이 포함됩니다. pubspec.yaml 파일에서 글꼴 패밀리와 해당 파일 경로를 정의하면 사용자 정의 글꼴이 애플리케이션에서 사용할 수 있도록 잠금 해제됩니다. 그런 다음 발표자는 테마 데이터에서 글로벌 글꼴 패밀리를 설정하여 앱 전체에 사용자 정의 글꼴 스타일을 적용하는 방법을 설명합니다. 또한 발표자는 ThemeData 클래스의 텍스트 테마 속성을 사용하여 앱 바 및 제목과 같은 특정 요소에 대한 사용자 정의 텍스트 테마를 정의하는 방법을 보여줍니다. 테마 데이터와 텍스트 테마에 액세스하면 개발자는 Flutter 애플리케이션의 다양한 텍스트 요소에 글꼴 스타일을 쉽게 사용자 정의하고 적용하여 일관되고 전문적인 디자인을 만들 수 있습니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador demuestra cómo agregar fuentes personalizadas a una aplicación Flutter para lograr un diseño más personalizado y consistente. El proceso implica crear una carpeta para los recursos y las fuentes en el directorio del proyecto, importar archivos de fuentes y configurar el archivo pubspec.yaml para incluir las familias de fuentes. Al definir las familias de fuentes y sus rutas de archivo correspondientes en el archivo pubspec.yaml, las fuentes personalizadas se desbloquean para su uso en la aplicación. Luego, el orador explica cómo configurar una familia de fuentes global en los datos del tema para aplicar los estilos de fuente personalizados en toda la aplicación. Además, el orador muestra cómo definir temas de texto personalizados para elementos específicos, como barras y títulos de la aplicación, utilizando la propiedad de tema de texto en la clase ThemeData. Al acceder a los datos del tema y los temas de texto, los desarrolladores pueden personalizar y aplicar fácilmente estilos de fuente a varios elementos de texto en su aplicación Flutter para lograr un diseño cohesivo y profesional.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता यह दर्शाता है कि फ़्लटर एप्लिकेशन में कस्टम फ़ॉन्ट कैसे जोड़ें ताकि अधिक व्यक्तिगत और सुसंगत डिज़ाइन प्राप्त किया जा सके। इस प्रक्रिया में प्रोजेक्ट निर्देशिका में एसेट्स और फ़ॉन्ट के लिए एक फ़ोल्डर बनाना, फ़ॉन्ट फ़ाइलें आयात करना और फ़ॉन्ट परिवारों को शामिल करने के लिए pubspec.yaml फ़ाइल को कॉन्फ़िगर करना शामिल है। pubspec.yaml फ़ाइल में फ़ॉन्ट परिवारों और उनके संबंधित फ़ाइल पथों को परिभाषित करके, कस्टम फ़ॉन्ट को एप्लिकेशन में उपयोग के लिए अनलॉक किया जाता है। फिर वक्ता बताता है कि पूरे ऐप में कस्टम फ़ॉन्ट शैलियों को लागू करने के लिए थीम डेटा में वैश्विक फ़ॉन्ट परिवार कैसे सेट किया जाए। इसके अतिरिक्त, वक्ता ThemeData वर्ग में टेक्स्ट थीम प्रॉपर्टी का उपयोग करके ऐप बार और शीर्षक जैसे विशिष्ट तत्वों के लिए कस्टम टेक्स्ट थीम को परिभाषित करने का तरीका दिखाता है। थीम डेटा और टेक्स्ट थीम तक पहुँचकर, डेवलपर्स आसानी से अपने फ़्लटर एप्लिकेशन में विभिन्न टेक्स्ट तत्वों पर फ़ॉन्ट शैलियों को अनुकूलित और लागू कर सकते हैं ताकि एक सुसंगत और पेशेवर डिज़ाइन तैयार हो सके।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador demonstra como adicionar tipos de letra personalizados a uma aplicação Flutter para obter um design mais personalizado e consistente. O processo envolve a criação de uma pasta para os ativos e fontes no diretório do projeto, a importação de ficheiros de fontes e a configuração do ficheiro pubspec.yaml para incluir as famílias de fontes. Ao definir famílias de fontes e os seus caminhos de ficheiro correspondentes no ficheiro pubspec.yaml, as fontes personalizadas são desbloqueadas para utilização na aplicação. O orador explica então como definir uma família de tipos de letra global nos dados do tema para aplicar os estilos de tipos de letra personalizados em toda a aplicação. Além disso, o orador mostra como definir temas de texto personalizados para elementos específicos, como barras de aplicações e títulos, utilizando a propriedade de tema de texto na classe ThemeData. Ao aceder aos dados do tema e aos temas de texto, os programadores podem facilmente personalizar e aplicar estilos de fonte a vários elementos de texto na sua aplicação Flutter para obter um design coeso e profissional.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার আরও ব্যক্তিগতকৃত এবং সামঞ্জস্যপূর্ণ নকশা অর্জনের জন্য একটি ফ্লাটার অ্যাপ্লিকেশনে কীভাবে কাস্টম ফন্ট যুক্ত করতে হয় তা প্রদর্শন করে। প্রক্রিয়াটির মধ্যে রয়েছে প্রোজেক্ট ডিরেক্টরিতে সম্পদ এবং ফন্টের জন্য একটি ফোল্ডার তৈরি করা, ফন্ট ফাইল আমদানি করা, এবং pubspec.yaml ফাইলটি ফন্ট পরিবারগুলিকে অন্তর্ভুক্ত করার জন্য কনফিগার করা। pubspec.yaml ফাইলে ফন্ট পরিবার এবং তাদের সংশ্লিষ্ট ফাইল পাথগুলি সংজ্ঞায়িত করে, কাস্টম ফন্টগুলি অ্যাপ্লিকেশনে ব্যবহারের জন্য আনলক করা হয়। স্পিকার তারপর ব্যাখ্যা করে কিভাবে থিম ডেটাতে একটি গ্লোবাল ফন্ট ফ্যামিলি সেট করতে হয় যাতে পুরো অ্যাপ জুড়ে কাস্টম ফন্ট শৈলী প্রয়োগ করা যায়। উপরন্তু, স্পিকার থিমডেটা ক্লাসে টেক্সট থিম প্রপার্টি ব্যবহার করে অ্যাপ বার এবং শিরোনামের মতো নির্দিষ্ট উপাদানগুলির জন্য কাস্টম টেক্সট থিম কীভাবে সংজ্ঞায়িত করতে হয় তা প্রদর্শন করে। থিম ডেটা এবং টেক্সট থিম অ্যাক্সেস করার মাধ্যমে, ডেভেলপাররা একটি সমন্বিত এবং পেশাদার ডিজাইনের জন্য তাদের ফ্লাটার অ্যাপ্লিকেশনে বিভিন্ন পাঠ্য উপাদানগুলিতে সহজেই কাস্টমাইজ এবং ফন্ট শৈলী প্রয়োগ করতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يوضح المتحدث كيفية إضافة خطوط مخصصة إلى تطبيق Flutter لتحقيق تصميم أكثر تخصيصًا وتناسقًا. تتضمن العملية إنشاء مجلد للأصول والخطوط في دليل المشروع، واستيراد ملفات الخطوط، وتكوين ملف pubspec.yaml لتضمين عائلات الخطوط. من خلال تحديد عائلات الخطوط ومسارات الملفات المقابلة لها في ملف pubspec.yaml، يتم فتح قفل الخطوط المخصصة للاستخدام في التطبيق. ثم يشرح المتحدث كيفية تعيين عائلة خطوط عالمية في بيانات السمة لتطبيق أنماط الخطوط المخصصة في جميع أنحاء التطبيق. بالإضافة إلى ذلك، يعرض المتحدث كيفية تحديد سمات نص مخصصة لعناصر معينة، مثل أشرطة التطبيق والعناوين، باستخدام خاصية سمة النص في فئة ThemeData. من خلال الوصول إلى بيانات السمة وسمات النص، يمكن للمطورين تخصيص أنماط الخطوط وتطبيقها بسهولة على عناصر نصية مختلفة في تطبيق Flutter الخاص بهم للحصول على تصميم متماسك واحترافي.",
                                // Persian
                                "فارسی": "در این آموزش ویدیویی، بلندگو نحوه اضافه کردن فونت های سفارشی به برنامه Flutter را برای دستیابی به طراحی شخصی تر و سازگارتر نشان می دهد. این فرآیند شامل ایجاد یک پوشه برای دارایی‌ها و فونت‌ها در فهرست پروژه، وارد کردن فایل‌های فونت و پیکربندی فایل pubspec.yaml برای گنجاندن خانواده‌های فونت است. با تعریف خانواده فونت ها و مسیرهای فایل مربوط به آنها در فایل pubspec.yaml، فونت های سفارشی برای استفاده در برنامه باز می شوند. سپس سخنران نحوه تنظیم یک خانواده فونت جهانی در داده های موضوعی را برای اعمال سبک های فونت سفارشی در سراسر برنامه توضیح می دهد. به‌علاوه، بلندگو نحوه تعریف تم‌های متن سفارشی برای عناصر خاص، مانند نوارها و عناوین برنامه‌ها را با استفاده از ویژگی text theme در کلاس ThemeData نشان می‌دهد. با دسترسی به داده‌های تم و مضامین متن، توسعه‌دهندگان می‌توانند به راحتی سبک‌های فونت را برای عناصر متنی مختلف در برنامه Flutter خود برای طراحی منسجم و حرفه‌ای شخصی‌سازی و اعمال کنند.",
                            },
                        },
                        // 86 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Adding Images to the App",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker demonstrates the process of integrating custom images into a Flutter application as a user-friendly way to indicate the absence of content. By commenting out default transactions in the main.dart file, viewers learn how to display a custom image when there is no data present. The speaker guides through the steps of adding the image file to the assets folder, updating the pubspec.yaml file to include the image asset, and using the Image widget to render the image in the app layout. To ensure proper image sizing within the container, the speaker introduces the BoxFit property and suggests wrapping the image widget in a container with a defined height. Additionally, the implementation of the SizedBox widget helps create space between the text and image elements, resulting in a visually appealing layout that dynamically adjusts based on the presence of transaction data.",
                                // German
                                "Deutsch": "In diesem Tutorial demonstriert der Sprecher den Prozess der Integration benutzerdefinierter Bilder in eine Flutter-Anwendung als benutzerfreundliche Möglichkeit, das Fehlen von Inhalten anzuzeigen. Durch das Auskommentieren von Standardtransaktionen in der Datei main.dart lernen die Zuschauer, wie sie ein benutzerdefiniertes Bild anzeigen, wenn keine Daten vorhanden sind. Der Sprecher führt durch die Schritte zum Hinzufügen der Bilddatei zum Assets-Ordner, zum Aktualisieren der Datei pubspec.yaml, um das Bild-Asset einzuschließen, und zum Verwenden des Bild-Widgets zum Rendern des Bilds im App-Layout. Um die richtige Bildgröße innerhalb des Containers sicherzustellen, stellt der Sprecher die BoxFit-Eigenschaft vor und schlägt vor, das Bild-Widget in einen Container mit einer definierten Höhe einzuschließen. Darüber hinaus hilft die Implementierung des SizedBox-Widgets dabei, Platz zwischen den Text- und Bildelementen zu schaffen, was zu einem optisch ansprechenden Layout führt, das sich dynamisch an das Vorhandensein von Transaktionsdaten anpasst.",
                                // Chinese
                                "中国人": "在本教程中，演讲者演示了将自定义图像集成到 Flutter 应用程序中的过程，这是一种用户友好的方式来指示内容缺失。通过在 main.dart 文件中注释掉默认交易，观众可以学习如何在没有数据的情况下显示自定义图像。演讲者指导将图像文件添加到资产文件夹、更新 pubspec.yaml 文件以包含图像资产以及使用 Image 小部件在应用程序布局中渲染图像的步骤。为了确保容器内的图像大小合适，演讲者介绍了 BoxFit 属性并建议将图像小部件包装在具有定义高度的容器中。此外，SizedBox 小部件的实现有助于在文本和图像元素之间创建空间，从而产生视觉上吸引人的布局，该布局可根据交易数据的存在进行动态调整。",
                                // Russian
                                "Русский": "В этом уроке докладчик демонстрирует процесс интеграции пользовательских изображений в приложение Flutter как удобный способ указания отсутствия контента. Комментируя транзакции по умолчанию в файле main.dart, зрители узнают, как отображать пользовательское изображение при отсутствии данных. Докладчик проводит по шагам добавления файла изображения в папку assets, обновления файла pubspec.yaml для включения ресурса изображения и использования виджета Image для визуализации изображения в макете приложения. Чтобы обеспечить правильный размер изображения в контейнере, докладчик представляет свойство BoxFit и предлагает обернуть виджет изображения в контейнер с определенной высотой. Кроме того, реализация виджета SizedBox помогает создать пространство между элементами текста и изображения, что приводит к визуально привлекательному макету, который динамически подстраивается в зависимости от наличия данных транзакции.",
                                // French
                                "Français": "Dans ce didacticiel, l'intervenant montre le processus d'intégration d'images personnalisées dans une application Flutter comme moyen convivial d'indiquer l'absence de contenu. En commentant les transactions par défaut dans le fichier main.dart, les utilisateurs apprennent à afficher une image personnalisée lorsqu'aucune donnée n'est présente. L'intervenant guide les étapes d'ajout du fichier image au dossier assets, de mise à jour du fichier pubspec.yaml pour inclure l'image et d'utilisation du widget Image pour restituer l'image dans la mise en page de l'application. Pour garantir un dimensionnement correct de l'image dans le conteneur, l'intervenant présente la propriété BoxFit et suggère d'envelopper le widget image dans un conteneur avec une hauteur définie. De plus, l'implémentation du widget SizedBox permet de créer de l'espace entre les éléments texte et image, ce qui donne une mise en page visuellement attrayante qui s'ajuste de manière dynamique en fonction de la présence de données de transaction.",
                                // Japanese
                                "日本語": "このチュートリアルでは、コンテンツが存在しないことを示すユーザーフレンドリーな方法として、Flutter アプリケーションにカスタム画像を統合するプロセスを講師が実演します。main.dart ファイルのデフォルトのトランザクションをコメント アウトすることで、データが存在しない場合にカスタム画像を表示する方法を視聴者は学習します。講師は、画像ファイルをアセット フォルダーに追加し、pubspec.yaml ファイルを更新して画像アセットを含め、画像ウィジェットを使用してアプリ レイアウトで画像をレンダリングする手順をガイドします。コンテナ内で画像のサイズが適切に調整されるように、講師は BoxFit プロパティを紹介し、高さが定義されたコンテナで画像ウィジェットをラップすることを提案します。さらに、SizedBox ウィジェットを実装すると、テキスト要素と画像要素の間にスペースが作成され、トランザクション データの有無に基づいて動的に調整される視覚的に魅力的なレイアウトが実現します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 사용자 친화적인 방식으로 콘텐츠가 없음을 나타내는 방법으로 사용자 정의 이미지를 Flutter 애플리케이션에 통합하는 프로세스를 보여줍니다. main.dart 파일에서 기본 트랜잭션을 주석 처리하여 시청자는 데이터가 없을 때 사용자 정의 이미지를 표시하는 방법을 배웁니다. 발표자는 assets 폴더에 이미지 파일을 추가하고, pubspec.yaml 파일을 업데이트하여 이미지 자산을 포함하고, Image 위젯을 사용하여 앱 레이아웃에서 이미지를 렌더링하는 단계를 안내합니다. 컨테이너 내에서 적절한 이미지 크기를 보장하기 위해 발표자는 BoxFit 속성을 소개하고 정의된 높이의 컨테이너에 이미지 위젯을 래핑하는 것을 제안합니다. 또한 SizedBox 위젯을 구현하면 텍스트와 이미지 요소 사이에 공간을 만드는 데 도움이 되므로 트랜잭션 데이터의 존재 여부에 따라 동적으로 조정되는 시각적으로 매력적인 레이아웃이 생성됩니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador demuestra el proceso de integración de imágenes personalizadas en una aplicación Flutter como una forma sencilla de indicar la ausencia de contenido. Al comentar las transacciones predeterminadas en el archivo main.dart, los espectadores aprenden a mostrar una imagen personalizada cuando no hay datos presentes. El orador guía a través de los pasos para agregar el archivo de imagen a la carpeta de activos, actualizar el archivo pubspec.yaml para incluir el activo de imagen y usar el widget Image para representar la imagen en el diseño de la aplicación. Para garantizar el tamaño adecuado de la imagen dentro del contenedor, el orador presenta la propiedad BoxFit y sugiere envolver el widget de imagen en un contenedor con una altura definida. Además, la implementación del widget SizedBox ayuda a crear espacio entre los elementos de texto e imagen, lo que da como resultado un diseño visualmente atractivo que se ajusta dinámicamente en función de la presencia de datos de transacción.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता सामग्री की अनुपस्थिति को इंगित करने के लिए उपयोगकर्ता के अनुकूल तरीके के रूप में फ़्लटर एप्लिकेशन में कस्टम छवियों को एकीकृत करने की प्रक्रिया को प्रदर्शित करता है। Main.dart फ़ाइल में डिफ़ॉल्ट लेनदेन पर टिप्पणी करके, दर्शक सीखते हैं कि जब कोई डेटा मौजूद नहीं होता है तो कस्टम छवि कैसे प्रदर्शित करें। वक्ता छवि फ़ाइल को संपत्ति फ़ोल्डर में जोड़ने, छवि संपत्ति को शामिल करने के लिए pubspec.yaml फ़ाइल को अपडेट करने और ऐप लेआउट में छवि को प्रस्तुत करने के लिए छवि विजेट का उपयोग करने के चरणों के माध्यम से मार्गदर्शन करता है। कंटेनर के भीतर उचित छवि आकार सुनिश्चित करने के लिए, वक्ता BoxFit गुण का परिचय देता है और एक परिभाषित ऊंचाई के साथ कंटेनर में छवि विजेट को लपेटने का सुझाव देता है। इसके अतिरिक्त, SizedBox विजेट का कार्यान्वयन पाठ और छवि तत्वों के बीच स्थान बनाने में मदद करता है, जिसके परिणामस्वरूप एक आकर्षक लेआउट होता है जो लेनदेन डेटा की उपस्थिति के आधार पर गतिशील रूप से समायोजित होता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador demonstra o processo de integração de imagens personalizadas numa aplicação Flutter como uma forma amigável de indicar a ausência de conteúdo. Ao comentar as transações padrão no ficheiro main.dart, os visualizadores aprendem como apresentar uma imagem personalizada quando não há dados presentes. O orador orienta os passos de adição do ficheiro de imagem à pasta de ativos, atualização do ficheiro pubspec.yaml para incluir o ativo de imagem e utilização do widget Imagem para renderizar a imagem no layout da aplicação. Para garantir o dimensionamento adequado da imagem dentro do contentor, o orador apresenta a propriedade BoxFit e sugere agrupar o widget de imagem num contentor com uma altura definida. Além disso, a implementação do widget SizedBox ajuda a criar espaço entre os elementos de texto e imagem, resultando num layout visualmente apelativo que se ajusta dinamicamente com base na presença de dados de transação.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার কন্টেন্টের অনুপস্থিতি নির্দেশ করার জন্য ব্যবহারকারী-বান্ধব উপায় হিসাবে একটি ফ্লাটার অ্যাপ্লিকেশনে কাস্টম চিত্রগুলিকে একীভূত করার প্রক্রিয়া প্রদর্শন করে। main.dart ফাইলে ডিফল্ট লেনদেন সম্পর্কে মন্তব্য করার মাধ্যমে, দর্শকরা শেখে কিভাবে একটি কাস্টম ইমেজ প্রদর্শন করতে হয় যখন কোন ডেটা উপস্থিত থাকে না। স্পিকার অ্যাসেট ফোল্ডারে ইমেজ ফাইল যোগ করার, ইমেজ অ্যাসেট অন্তর্ভুক্ত করার জন্য pubspec.yaml ফাইল আপডেট করা এবং অ্যাপ লেআউটে ইমেজ রেন্ডার করার জন্য ইমেজ উইজেট ব্যবহার করার ধাপগুলো নির্দেশ করে। কন্টেইনারের মধ্যে সঠিক ইমেজ সাইজিং নিশ্চিত করতে, স্পিকার বক্সফিট প্রপার্টি পরিচয় করিয়ে দেয় এবং ইমেজ উইজেটটিকে একটি নির্দিষ্ট উচ্চতা সহ একটি পাত্রে মোড়ানোর পরামর্শ দেয়। অতিরিক্তভাবে, সাইজডবক্স উইজেটের বাস্তবায়ন পাঠ্য এবং চিত্র উপাদানগুলির মধ্যে স্থান তৈরি করতে সাহায্য করে, যার ফলে একটি দৃশ্যমান আকর্ষণীয় বিন্যাস তৈরি হয় যা লেনদেন ডেটার উপস্থিতির উপর ভিত্তি করে গতিশীলভাবে সামঞ্জস্য করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يوضح المتحدث عملية دمج الصور المخصصة في تطبيق Flutter كطريقة سهلة الاستخدام للإشارة إلى عدم وجود محتوى. من خلال التعليق على المعاملات الافتراضية في ملف main.dart، يتعلم المشاهدون كيفية عرض صورة مخصصة عندما لا توجد بيانات موجودة. يرشد المتحدث خلال خطوات إضافة ملف الصورة إلى مجلد الأصول، وتحديث ملف pubspec.yaml لتضمين أصل الصورة، واستخدام عنصر واجهة المستخدم Image لعرض الصورة في تخطيط التطبيق. لضمان تحديد حجم الصورة بشكل صحيح داخل الحاوية، يقدم المتحدث خاصية BoxFit ويقترح تغليف عنصر واجهة المستخدم Image في حاوية بارتفاع محدد. بالإضافة إلى ذلك، يساعد تنفيذ عنصر واجهة المستخدم SizedBox في إنشاء مساحة بين عناصر النص والصورة، مما يؤدي إلى تخطيط جذاب بصريًا يتم تعديله ديناميكيًا بناءً على وجود بيانات المعاملات.",
                                // Persian
                                "فارسی": "در این آموزش، سخنران فرآیند ادغام تصاویر سفارشی در برنامه فلاتر را به عنوان یک روش کاربرپسند برای نشان دادن عدم وجود محتوا نشان می دهد. با اظهار نظر در مورد تراکنش‌های پیش‌فرض در فایل main.dart، بینندگان یاد می‌گیرند که چگونه یک تصویر سفارشی را زمانی که هیچ داده‌ای وجود ندارد نمایش دهند. بلندگو مراحل افزودن فایل تصویری به پوشه دارایی ها، به روز رسانی فایل pubspec.yaml را برای گنجاندن دارایی تصویر و استفاده از ویجت Image برای ارائه تصویر در طرح بندی برنامه راهنمایی می کند. برای اطمینان از اندازه مناسب تصویر در ظرف، بلندگو ویژگی BoxFit را معرفی می‌کند و پیشنهاد می‌کند ویجت تصویر را در یک ظرف با ارتفاع مشخص قرار دهید. علاوه بر این، اجرای ویجت SizedBox به ایجاد فضای بین عناصر متن و تصویر کمک می‌کند و در نتیجه یک طرح بصری جذاب ایجاد می‌کند که به صورت پویا بر اساس وجود داده‌های تراکنش تنظیم می‌شود.",
                            },
                        },
                        // 87 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Planning the Chart Widget",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker focuses on implementing a chart widget within a Flutter application as a visual representation of recent transactions. The chart widget, named 'Chart', is designed to display a series of bars corresponding to the daily expenses for the last seven days. The speaker outlines the structure of the chart, with each bar representing a day's spending amount relative to the total for the week. The design includes labels for the days of the week, expenditure values, and a visual indicator showing the proportion of each day's spending within the weekly total. The tutorial covers the creation of the chart widget within a Card widget, emphasizing the layout and components required for a clear and informative visualization of transaction data.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial konzentriert sich der Sprecher auf die Implementierung eines Diagramm-Widgets in einer Flutter-Anwendung als visuelle Darstellung der letzten Transaktionen. Das Diagramm-Widget mit dem Namen „Chart“ ist so konzipiert, dass es eine Reihe von Balken anzeigt, die den täglichen Ausgaben der letzten sieben Tage entsprechen. Der Sprecher skizziert die Struktur des Diagramms, wobei jeder Balken die Ausgaben eines Tages im Verhältnis zum Gesamtbetrag der Woche darstellt. Das Design umfasst Beschriftungen für die Wochentage, Ausgabenwerte und einen visuellen Indikator, der den Anteil der Ausgaben jedes Tages am Gesamtbetrag der Woche zeigt. Das Tutorial behandelt die Erstellung des Diagramm-Widgets in einem Karten-Widget und betont das Layout und die Komponenten, die für eine klare und informative Visualisierung von Transaktionsdaten erforderlich sind.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者重点介绍了如何在 Flutter 应用程序中实现图表小部件，以直观的方式表示最近的交易。名为“图表”的图表小部件旨在显示一系列与过去七天的日常支出相对应的条形图。演讲者概述了图表的结构，每个条形图代表一天的支出金额与一周总额的相对比例。该设计包括一周中各天的标签、支出值以及显示每天支出在一周总额中所占比例的视觉指示器。本教程介绍了如何在卡片小部件中创建图表小部件，强调了清晰且信息丰富的交易数据可视化所需的布局和组件。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик фокусируется на внедрении виджета диаграммы в приложение Flutter в качестве визуального представления недавних транзакций. Виджет диаграммы, названный «Диаграмма», предназначен для отображения ряда столбцов, соответствующих ежедневным расходам за последние семь дней. Докладчик описывает структуру диаграммы, где каждый столбец представляет сумму расходов за день относительно общей суммы за неделю. Дизайн включает метки для дней недели, значения расходов и визуальный индикатор, показывающий долю расходов за каждый день в общей сумме за неделю. В руководстве рассматривается создание виджета диаграммы в виджете карты, подчеркивая макет и компоненты, необходимые для четкой и информативной визуализации данных транзакций.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant se concentre sur la mise en œuvre d'un widget graphique dans une application Flutter en tant que représentation visuelle des transactions récentes. Le widget graphique, appelé « Graphique », est conçu pour afficher une série de barres correspondant aux dépenses quotidiennes des sept derniers jours. L'intervenant décrit la structure du graphique, chaque barre représentant le montant des dépenses d'une journée par rapport au total de la semaine. La conception comprend des étiquettes pour les jours de la semaine, les valeurs des dépenses et un indicateur visuel indiquant la proportion des dépenses de chaque jour dans le total hebdomadaire. Le didacticiel couvre la création du widget graphique dans un widget de carte, en mettant l'accent sur la disposition et les composants requis pour une visualisation claire et informative des données de transaction.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、講演者は最近の取引を視覚的に表現するチャートウィジェットを Flutter アプリケーション内に実装することに焦点を当てています。「チャート」という名前のチャートウィジェットは、過去 7 日間の毎日の支出に対応する一連のバーを表示するように設計されています。講演者はチャートの構造を概説し、各バーは 1 日の支出額を週の合計と比較して表します。デザインには、曜日のラベル、支出額、および週の合計における各日の支出の割合を示す視覚的なインジケーターが含まれています。チュートリアルでは、カードウィジェット内のチャートウィジェットの作成について説明し、取引データを明確かつわかりやすく視覚化するために必要なレイアウトとコンポーネントに重点を置いています。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 최근 거래의 시각적 표현으로 Flutter 애플리케이션 내에서 차트 위젯을 구현하는 데 중점을 둡니다. '차트'라는 이름의 차트 위젯은 지난 7일 동안의 일일 지출에 해당하는 일련의 막대를 표시하도록 설계되었습니다. 발표자는 차트의 구조를 설명하며, 각 막대는 일주일 총액에 대한 일일 지출 금액을 나타냅니다. 이 디자인에는 요일 레이블, 지출 값, 주간 총액에서 각 일의 지출 비율을 보여주는 시각적 표시기가 포함됩니다. 이 튜토리얼은 카드 위젯 내에서 차트 위젯을 만드는 방법을 다루며, 거래 데이터를 명확하고 유익하게 시각화하는 데 필요한 레이아웃과 구성 요소를 강조합니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador se centra en la implementación de un widget gráfico dentro de una aplicación Flutter como una representación visual de transacciones recientes. El widget gráfico, llamado 'Gráfico', está diseñado para mostrar una serie de barras correspondientes a los gastos diarios de los últimos siete días. El orador describe la estructura del gráfico, donde cada barra representa el monto de gasto de un día en relación con el total de la semana. El diseño incluye etiquetas para los días de la semana, valores de gasto y un indicador visual que muestra la proporción del gasto de cada día dentro del total semanal. El tutorial cubre la creación del widget gráfico dentro de un widget de tarjeta, haciendo hincapié en el diseño y los componentes necesarios para una visualización clara e informativa de los datos de las transacciones.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता हाल के लेन-देन के दृश्य प्रतिनिधित्व के रूप में फ़्लटर एप्लिकेशन के भीतर एक चार्ट विजेट को लागू करने पर ध्यान केंद्रित करता है। 'चार्ट' नामक चार्ट विजेट को पिछले सात दिनों के दैनिक खर्चों के अनुरूप बार की एक श्रृंखला प्रदर्शित करने के लिए डिज़ाइन किया गया है। वक्ता चार्ट की संरचना को रेखांकित करता है, जिसमें प्रत्येक बार सप्ताह के कुल के सापेक्ष एक दिन की खर्च राशि का प्रतिनिधित्व करता है। डिज़ाइन में सप्ताह के दिनों के लिए लेबल, व्यय मूल्य और साप्ताहिक कुल के भीतर प्रत्येक दिन के खर्च का अनुपात दिखाने वाला एक दृश्य संकेतक शामिल है। ट्यूटोरियल कार्ड विजेट के भीतर चार्ट विजेट के निर्माण को कवर करता है, लेन-देन डेटा के स्पष्ट और सूचनात्मक दृश्य के लिए आवश्यक लेआउट और घटकों पर जोर देता है।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador foca-se na implementação de um widget de gráfico numa aplicação Flutter como uma representação visual de transações recentes. O widget de gráfico, denominado ‘Gráfico’, foi concebido para exibir uma série de barras correspondentes às despesas diárias dos últimos sete dias. O orador descreve a estrutura do gráfico, sendo que cada barra representa o valor gasto de um dia em relação ao total da semana. O design inclui etiquetas para os dias da semana, valores de gastos e um indicador visual que mostra a proporção dos gastos de cada dia no total semanal. O tutorial aborda a criação do widget gráfico dentro de um widget Cartão, enfatizando o layout e os componentes necessários para uma visualização clara e informativa dos dados da transação.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার সাম্প্রতিক লেনদেনের একটি ভিজ্যুয়াল উপস্থাপনা হিসাবে একটি ফ্লাটার অ্যাপ্লিকেশনের মধ্যে একটি চার্ট উইজেট বাস্তবায়নের উপর দৃষ্টি নিবদ্ধ করে। চার্ট উইজেট, 'চার্ট' নামে, গত সাত দিনের দৈনিক ব্যয়ের সাথে সম্পর্কিত বারগুলির একটি সিরিজ প্রদর্শন করার জন্য ডিজাইন করা হয়েছে। স্পিকার চার্টের কাঠামোর রূপরেখা দেয়, প্রতিটি বার সপ্তাহের মোটের তুলনায় একটি দিনের ব্যয়ের পরিমাণ উপস্থাপন করে। নকশায় সপ্তাহের দিনের জন্য লেবেল, ব্যয়ের মান এবং একটি চাক্ষুষ সূচক রয়েছে যা সাপ্তাহিক মোটের মধ্যে প্রতিটি দিনের ব্যয়ের অনুপাত দেখায়। টিউটোরিয়ালটি একটি কার্ড উইজেটের মধ্যে চার্ট উইজেট তৈরিকে কভার করে, লেনদেন ডেটার একটি পরিষ্কার এবং তথ্যপূর্ণ ভিজ্যুয়ালাইজেশনের জন্য প্রয়োজনীয় লেআউট এবং উপাদানগুলির উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يركز المتحدث على تنفيذ أداة رسم بياني داخل تطبيق Flutter كتمثيل مرئي للمعاملات الأخيرة. تم تصميم أداة الرسم البياني، المسماة 'الرسم البياني'، لعرض سلسلة من الأشرطة المقابلة للنفقات اليومية خلال الأيام السبعة الماضية. يحدد المتحدث هيكل الرسم البياني، حيث يمثل كل شريط مبلغ الإنفاق في اليوم نسبة إلى الإجمالي في الأسبوع. يتضمن التصميم تسميات لأيام الأسبوع وقيم الإنفاق ومؤشر مرئي يوضح نسبة الإنفاق في كل يوم ضمن الإجمالي الأسبوعي. يغطي البرنامج التعليمي إنشاء أداة الرسم البياني داخل أداة بطاقة، مع التركيز على التخطيط والمكونات المطلوبة لتصور واضح وغني بالمعلومات لبيانات المعاملات.",
                                // Persian
                                "فارسی": "در این آموزش ویدیویی، سخنران بر روی پیاده سازی یک ویجت نمودار در یک برنامه فلاتر به عنوان یک نمایش بصری از تراکنش های اخیر تمرکز می کند. ویجت نمودار، به نام 'نمودار'، برای نمایش یک سری از میله‌های مربوط به هزینه‌های روزانه هفت روز گذشته طراحی شده است. گوینده ساختار نمودار را مشخص می کند و هر نوار نشان دهنده مقدار هزینه یک روز نسبت به کل هفته است. این طرح شامل برچسب‌هایی برای روزهای هفته، ارزش هزینه‌ها و یک نشانگر بصری است که نسبت هزینه‌های هر روز را در مجموع هفتگی نشان می‌دهد. این آموزش ایجاد ویجت نمودار در ویجت کارت را پوشش می‌دهد و بر طرح‌بندی و اجزای مورد نیاز برای تجسم واضح و آموزنده داده‌های تراکنش تاکید می‌کند.",
                            },
                        },
                        // 88 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Looping Through Lists",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker demonstrates how to dynamically generate a row of bars in a chart widget, representing transaction values grouped by weekday. By creating a getter function called groupedTransactions to generate a list of maps, the speaker explains how to calculate the total amount spent on each weekday by summing up the transactions. The speaker also shows how to use a for loop to iterate through the transactions and filter out those that occurred on the specific weekday being processed. The video provides step-by-step guidance on how to implement the logic and print the results to ensure the chart widget functions correctly.",
                                // German
                                "Deutsch": "In diesem Video demonstriert der Sprecher, wie man in einem Diagramm-Widget dynamisch eine Reihe von Balken generiert, die nach Wochentagen gruppierte Transaktionswerte darstellen. Indem er eine Getter-Funktion namens „groupedTransactions“ erstellt, um eine Liste von Karten zu generieren, erklärt der Sprecher, wie man den Gesamtbetrag berechnet, der an jedem Wochentag ausgegeben wird, indem man die Transaktionen summiert. Der Sprecher zeigt auch, wie man mit einer For-Schleife die Transaktionen durchläuft und diejenigen herausfiltert, die an dem jeweiligen Wochentag aufgetreten sind, der gerade verarbeitet wird. Das Video bietet eine schrittweise Anleitung zum Implementieren der Logik und zum Drucken der Ergebnisse, um sicherzustellen, dass das Diagramm-Widget ordnungsgemäß funktioniert.",
                                // Chinese
                                "中国人": "在本视频中，演讲者演示了如何在图表小部件中动态生成一行条形图，以表示按工作日分组的交易值。通过创建一个名为 groupedTransactions 的 getter 函数来生成地图列表，演讲者解释了如何通过汇总交易来计算每个工作日的总支出金额。演讲者还展示了如何使用 for 循环遍历交易并过滤掉正在处理的特定工作日发生的交易。视频提供了有关如何实现逻辑和打印结果的分步指导，以确保图表小部件正常运行。",
                                // Russian
                                "Русский": "В этом видео докладчик демонстрирует, как динамически генерировать ряд столбцов в виджете диаграммы, представляющих значения транзакций, сгруппированные по дням недели. Создав функцию-получатель, называемую groupedTransactions, для генерации списка карт, докладчик объясняет, как рассчитать общую сумму, потраченную в каждый день недели, суммируя транзакции. Докладчик также показывает, как использовать цикл for для итерации транзакций и отфильтровывать те, которые произошли в определенный обрабатываемый день недели. Видео содержит пошаговые инструкции по реализации логики и печати результатов, чтобы убедиться, что виджет диаграммы функционирует правильно.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant montre comment générer dynamiquement une ligne de barres dans un widget graphique, représentant des valeurs de transaction regroupées par jour de la semaine. En créant une fonction getter appelée groupedTransactions pour générer une liste de cartes, l'intervenant explique comment calculer le montant total dépensé chaque jour de la semaine en additionnant les transactions. L'intervenant montre également comment utiliser une boucle for pour parcourir les transactions et filtrer celles qui se sont produites le jour de la semaine spécifique en cours de traitement. La vidéo fournit des instructions étape par étape sur la façon d'implémenter la logique et d'imprimer les résultats pour garantir le bon fonctionnement du widget graphique.",
                                // Japanese
                                "日本語": "このビデオでは、講演者がチャート ウィジェットに動的にバーの行を生成し、曜日ごとにグループ化されたトランザクション値を表す方法を説明します。講演者は、マップのリストを生成するために groupedTransactions という getter 関数を作成し、トランザクションを合計して各曜日に費やされた合計金額を計算する方法を説明します。講演者はまた、for ループを使用してトランザクションを反復処理し、処理中の特定の曜日に発生したトランザクションをフィルター処理する方法も示します。ビデオでは、チャート ウィジェットが正しく機能するようにロジックを実装して結果を印刷する方法について、ステップ バイ ステップで説明します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 차트 위젯에서 동적으로 막대 행을 생성하는 방법을 보여줍니다. 이는 평일별로 그룹화된 거래 값을 나타냅니다. 발표자는 groupedTransactions라는 게터 함수를 만들어 맵 목록을 생성함으로써 거래를 합산하여 각 평일에 사용된 총 금액을 계산하는 방법을 설명합니다. 발표자는 또한 for 루프를 사용하여 거래를 반복하고 처리 중인 특정 평일에 발생한 거래를 필터링하는 방법을 보여줍니다. 이 비디오는 로직을 구현하고 결과를 인쇄하여 차트 위젯이 올바르게 기능하도록 하는 방법에 대한 단계별 지침을 제공합니다.",
                                // Spanish
                                "Español": "En este video, el orador demuestra cómo generar dinámicamente una fila de barras en un widget gráfico, que representa valores de transacciones agrupados por día de la semana. Al crear una función de obtención llamada groupedTransactions para generar una lista de mapas, el orador explica cómo calcular el monto total gastado en cada día de la semana sumando las transacciones. El orador también muestra cómo usar un bucle for para iterar a través de las transacciones y filtrar aquellas que ocurrieron en el día de la semana específico que se está procesando. El video proporciona una guía paso a paso sobre cómo implementar la lógica e imprimir los resultados para garantizar que el widget gráfico funcione correctamente.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता यह दर्शाता है कि चार्ट विजेट में बार की एक पंक्ति को गतिशील रूप से कैसे उत्पन्न किया जाए, जो सप्ताह के दिनों के अनुसार समूहीकृत लेनदेन मूल्यों का प्रतिनिधित्व करता है। मैप्स की सूची बनाने के लिए ग्रुप्डट्रांज़ैक्शन नामक एक गेट्टर फ़ंक्शन बनाकर, वक्ता बताता है कि लेनदेन को जोड़कर प्रत्येक सप्ताह के दिन खर्च की गई कुल राशि की गणना कैसे की जाए। वक्ता यह भी दिखाता है कि लेनदेन के माध्यम से पुनरावृत्ति करने और संसाधित किए जा रहे विशिष्ट सप्ताह के दिन होने वाले लेनदेन को फ़िल्टर करने के लिए फ़ॉर लूप का उपयोग कैसे किया जाए। वीडियो तर्क को लागू करने और चार्ट विजेट को सही ढंग से काम करने के लिए परिणामों को प्रिंट करने के तरीके पर चरण-दर-चरण मार्गदर्शन प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador demonstra como gerar dinamicamente uma linha de barras num widget de gráfico, representando valores de transações agrupados por dia da semana. Ao criar uma função getter chamada groupedTransactions para gerar uma lista de mapas, o orador explica como calcular o valor total gasto em cada dia da semana somando as transações. O orador mostra ainda como utilizar um ciclo for para iterar pelas transações e filtrar aquelas que ocorreram no dia da semana específico que está a ser processado. O vídeo fornece orientações passo a passo sobre como implementar a lógica e imprimir os resultados para garantir que o widget de gráfico funciona corretamente.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার দেখান কিভাবে গতিশীলভাবে একটি চার্ট উইজেটে সারি সারি তৈরি করতে হয়, সপ্তাহের দিন অনুসারে লেনদেনের মানগুলিকে প্রতিনিধিত্ব করে৷ মানচিত্রের একটি তালিকা তৈরি করার জন্য গ্রুপড ট্রানজ্যাকশন নামে একটি গেটার ফাংশন তৈরি করে, স্পিকার ব্যাখ্যা করেন কিভাবে লেনদেনের সংকলন করে প্রতি সপ্তাহের দিনে ব্যয় করা মোট পরিমাণ গণনা করা যায়। স্পিকার আরও দেখায় যে কীভাবে লেনদেনের মাধ্যমে পুনরাবৃত্তি করার জন্য একটি লুপ ব্যবহার করতে হয় এবং নির্দিষ্ট সপ্তাহের দিনে প্রক্রিয়া করা হচ্ছে সেগুলি ফিল্টার করতে হয়। ভিডিওটি ধাপে ধাপে নির্দেশিকা প্রদান করে কিভাবে যুক্তি প্রয়োগ করতে হয় এবং চার্ট উইজেটের কার্যকারিতা সঠিকভাবে নিশ্চিত করতে ফলাফল প্রিন্ট করতে হয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المتحدث كيفية إنشاء صف من الأشرطة بشكل ديناميكي في عنصر واجهة مستخدم للرسم البياني، يمثل قيم المعاملات المجمعة حسب أيام الأسبوع. من خلال إنشاء دالة getter تسمى groupedTransactions لإنشاء قائمة بالخرائط، يشرح المتحدث كيفية حساب المبلغ الإجمالي الذي تم إنفاقه في كل يوم من أيام الأسبوع عن طريق جمع المعاملات. كما يوضح المتحدث كيفية استخدام حلقة for للتكرار خلال المعاملات وتصفية المعاملات التي حدثت في يوم الأسبوع المحدد الذي تتم معالجته. يوفر الفيديو إرشادات خطوة بخطوة حول كيفية تنفيذ المنطق وطباعة النتائج لضمان عمل عنصر واجهة المستخدم للرسم البياني بشكل صحيح.",
                                // Persian
                                "فارسی": "در این ویدئو، بلندگو نشان می‌دهد که چگونه می‌توان به صورت پویا ردیفی از میله‌ها را در یک ویجت نمودار تولید کرد که مقادیر تراکنش‌ها را بر اساس روزهای هفته نشان می‌دهد. با ایجاد یک تابع گیرنده به نام groupedTransactions برای تولید فهرستی از نقشه ها، سخنران نحوه محاسبه کل مبلغ هزینه شده در هر روز هفته را با جمع بندی تراکنش ها توضیح می دهد. بلندگو همچنین نحوه استفاده از یک حلقه for را برای تکرار تراکنش‌ها و فیلتر کردن مواردی که در روز کاری خاص در حال پردازش رخ داده‌اند، نشان می‌دهد. این ویدیو راهنمای گام به گام نحوه پیاده سازی منطق و چاپ نتایج را برای اطمینان از عملکرد صحیح ویجت نمودار ارائه می دهد.",
                            },
                        },
                        // 89 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Deriving Recent Transactions",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker explains how to integrate a chart widget into the main.dart file to display transaction data. By replacing a container with the chart widget and importing the necessary widget, the speaker demonstrates how to filter recent transactions from the last week using a getter called _recentTransactions. The speaker utilizes the where method on a list of transactions to filter out transactions older than a week, ensuring only recent transactions are included in the chart. After resolving an error related to the data type of transactions, the speaker prints and validates the grouped transaction values in the build method of the chart, confirming the successful generation of transaction data for different weekdays. Additional transactions are added and observed in the chart, showcasing the functionality of dynamically generating and displaying transaction data on the screen.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial erklärt der Sprecher, wie man ein Diagramm-Widget in die Datei main.dart integriert, um Transaktionsdaten anzuzeigen. Indem er einen Container durch das Diagramm-Widget ersetzt und das erforderliche Widget importiert, demonstriert der Sprecher, wie man mithilfe eines Getters namens _recentTransactions die jüngsten Transaktionen der letzten Woche filtert. Der Sprecher verwendet die Where-Methode für eine Liste von Transaktionen, um Transaktionen herauszufiltern, die älter als eine Woche sind, und stellt so sicher, dass nur jüngste Transaktionen im Diagramm enthalten sind. Nachdem ein Fehler im Zusammenhang mit dem Datentyp der Transaktionen behoben wurde, druckt und validiert der Sprecher die gruppierten Transaktionswerte in der Build-Methode des Diagramms und bestätigt so die erfolgreiche Generierung von Transaktionsdaten für verschiedene Wochentage. Zusätzliche Transaktionen werden hinzugefügt und im Diagramm beobachtet, wodurch die Funktionalität der dynamischen Generierung und Anzeige von Transaktionsdaten auf dem Bildschirm demonstriert wird.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者讲解了如何将图表小部件集成到 main.dart 文件中以显示交易数据。通过用图表小部件替换容器并导入必要的小部件，演讲者演示了如何使用名为 _recentTransactions 的 getter 过滤上周的近期交易。演讲者在交易列表中使用 where 方法过滤掉超过一周的交易，确保图表中仅包含近期交易。在解决与交易数据类型相关的错误后，演讲者在图表的 build 方法中打印并验证分组的交易值，确认已成功生成不同工作日的交易数据。图表中添加并观察了其他交易，展示了在屏幕上动态生成和显示交易数据的功能。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик объясняет, как интегрировать виджет диаграммы в файл main.dart для отображения данных транзакций. Заменив контейнер виджетом диаграммы и импортировав необходимый виджет, докладчик демонстрирует, как отфильтровать последние транзакции за последнюю неделю с помощью геттера _recentTransactions. Докладчик использует метод where в списке транзакций для фильтрации транзакций старше недели, гарантируя включение в диаграмму только последних транзакций. После устранения ошибки, связанной с типом данных транзакций, докладчик печатает и проверяет сгруппированные значения транзакций в методе build диаграммы, подтверждая успешное создание данных транзакций для разных дней недели. Дополнительные транзакции добавляются и наблюдаются в диаграмме, демонстрируя функциональность динамического создания и отображения данных транзакций на экране.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant explique comment intégrer un widget graphique dans le fichier main.dart pour afficher les données de transaction. En remplaçant un conteneur par le widget graphique et en important le widget nécessaire, l'intervenant montre comment filtrer les transactions récentes de la semaine dernière à l'aide d'un getter appelé _recentTransactions. L'intervenant utilise la méthode where sur une liste de transactions pour filtrer les transactions de plus d'une semaine, garantissant ainsi que seules les transactions récentes sont incluses dans le graphique. Après avoir résolu une erreur liée au type de données des transactions, l'intervenant imprime et valide les valeurs de transaction groupées dans la méthode build du graphique, confirmant la génération réussie des données de transaction pour différents jours de la semaine. Des transactions supplémentaires sont ajoutées et observées dans le graphique, illustrant la fonctionnalité de génération et d'affichage dynamiques des données de transaction à l'écran.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、チャートウィジェットを main.dart ファイルに統合してトランザクションデータを表示する方法について説明します。コンテナをチャートウィジェットに置き換え、必要なウィジェットをインポートすることで、_recentTransactions というゲッターを使用して、先週の最近のトランザクションをフィルター処理する方法を説明します。トランザクションのリストで where メソッドを使用して、1 週間以上前のトランザクションをフィルター処理し、最近のトランザクションのみがチャートに含まれるようにします。トランザクションのデータ型に関連するエラーを解決した後、チャートの build メソッドでグループ化されたトランザクション値を出力して検証し、さまざまな曜日のトランザクションデータが正常に生成されたことを確認します。追加のトランザクションがチャートに追加されて確認され、画面上でトランザクションデータを動的に生成して表示する機能が示されます。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 거래 데이터를 표시하기 위해 차트 위젯을 main.dart 파일에 통합하는 방법을 설명합니다. 컨테이너를 차트 위젯으로 바꾸고 필요한 위젯을 임포트하여 발표자는 _recentTransactions라는 게터를 사용하여 지난주 최근 거래를 필터링하는 방법을 보여줍니다. 발표자는 거래 목록에서 where 메서드를 사용하여 일주일 이상 된 거래를 필터링하여 최근 거래만 차트에 포함되도록 합니다. 거래의 데이터 유형과 관련된 오류를 해결한 후 발표자는 차트의 build 메서드에서 그룹화된 거래 값을 인쇄하고 검증하여 다른 요일에 대한 거래 데이터가 성공적으로 생성되었는지 확인합니다. 차트에 추가 거래가 추가되고 관찰되어 화면에 거래 데이터를 동적으로 생성하고 표시하는 기능을 보여줍니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador explica cómo integrar un widget de gráfico en el archivo main.dart para mostrar datos de transacciones. Al reemplazar un contenedor con el widget de gráfico e importar el widget necesario, el orador demuestra cómo filtrar transacciones recientes de la última semana utilizando un captador llamado _recentTransactions. El orador utiliza el método where en una lista de transacciones para filtrar transacciones anteriores a una semana, lo que garantiza que solo se incluyan transacciones recientes en el gráfico. Después de resolver un error relacionado con el tipo de datos de las transacciones, el orador imprime y valida los valores de transacción agrupados en el método de creación del gráfico, lo que confirma la generación exitosa de datos de transacciones para diferentes días de la semana. Se agregan transacciones adicionales y se observan en el gráfico, lo que muestra la funcionalidad de generar y mostrar dinámicamente datos de transacciones en la pantalla.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता बताता है कि लेन-देन डेटा प्रदर्शित करने के लिए main.dart फ़ाइल में चार्ट विजेट को कैसे एकीकृत किया जाए। कंटेनर को चार्ट विजेट से बदलकर और आवश्यक विजेट को आयात करके, वक्ता यह प्रदर्शित करता है कि _recentTransactions नामक गेटर का उपयोग करके पिछले सप्ताह के हाल के लेन-देन को कैसे फ़िल्टर किया जाए। वक्ता लेन-देन की सूची पर where विधि का उपयोग करके एक सप्ताह से पुराने लेन-देन को फ़िल्टर करता है, यह सुनिश्चित करता है कि चार्ट में केवल हाल के लेन-देन ही शामिल हों। लेन-देन के डेटा प्रकार से संबंधित त्रुटि को हल करने के बाद, वक्ता चार्ट की बिल्ड विधि में समूहीकृत लेन-देन मूल्यों को प्रिंट और मान्य करता है, जो विभिन्न कार्यदिवसों के लिए लेन-देन डेटा के सफल निर्माण की पुष्टि करता है। चार्ट में अतिरिक्त लेन-देन जोड़े और देखे जाते हैं, जो स्क्रीन पर लेन-देन डेटा को गतिशील रूप से उत्पन्न करने और प्रदर्शित करने की कार्यक्षमता को प्रदर्शित करते हैं।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador explica como integrar um widget gráfico no ficheiro main.dart para exibir dados de transações. Ao substituir um contentor pelo widget de gráfico e importar o widget necessário, o orador demonstra como filtrar as transações recentes da última semana utilizando um getter chamado _recentTransactions. O orador utiliza o método where numa lista de transações para filtrar as transações com mais de uma semana, garantindo que apenas as transações recentes são incluídas no gráfico. Após a resolução de um erro relativo ao tipo de dados das transações, o orador imprime e valida os valores das transações agrupadas no método de construção do gráfico, confirmando o sucesso da geração dos dados das transações para diferentes dias da semana. As transações adicionais são adicionadas e observadas no gráfico, mostrando a funcionalidade de geração e apresentação dinâmica de dados de transações no ecrã.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার ব্যাখ্যা করে যে কিভাবে একটি চার্ট উইজেটকে main.dart ফাইলে লেনদেনের ডেটা প্রদর্শন করতে হয়। চার্ট উইজেট দিয়ে একটি ধারক প্রতিস্থাপন করে এবং প্রয়োজনীয় উইজেট আমদানি করে, স্পিকার _recentTransactions নামক একটি গেটার ব্যবহার করে গত সপ্তাহের সাম্প্রতিক লেনদেনগুলিকে কীভাবে ফিল্টার করতে হয় তা প্রদর্শন করে৷ স্পিকার শুধুমাত্র সাম্প্রতিক লেনদেনগুলি চার্টে অন্তর্ভুক্ত করা হয়েছে তা নিশ্চিত করে এক সপ্তাহের বেশি পুরানো লেনদেনগুলিকে ফিল্টার করার জন্য লেনদেনের তালিকায় কোথায় পদ্ধতি ব্যবহার করে। লেনদেনের ডেটা প্রকারের সাথে সম্পর্কিত একটি ত্রুটি সমাধান করার পরে, স্পিকার চার্টের বিল্ড পদ্ধতিতে গোষ্ঠীবদ্ধ লেনদেনের মানগুলি মুদ্রণ করে এবং যাচাই করে, বিভিন্ন সপ্তাহের দিনের জন্য লেনদেন ডেটার সফল প্রজন্ম নিশ্চিত করে৷ অতিরিক্ত লেনদেনগুলি চার্টে যোগ করা হয় এবং পর্যবেক্ষণ করা হয়, যা গতিশীলভাবে লেনদেনের ডেটা তৈরি এবং স্ক্রিনে প্রদর্শনের কার্যকারিতা প্রদর্শন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يشرح المتحدث كيفية دمج عنصر واجهة مستخدم للرسم البياني في ملف main.dart لعرض بيانات المعاملات. من خلال استبدال حاوية بعنصر واجهة مستخدم للرسم البياني واستيراد العنصر المطلوب، يوضح المتحدث كيفية تصفية المعاملات الأخيرة من الأسبوع الماضي باستخدام أداة تسمى _recentTransactions. يستخدم المتحدث طريقة where في قائمة المعاملات لتصفية المعاملات الأقدم من أسبوع، مما يضمن تضمين المعاملات الأخيرة فقط في الرسم البياني. بعد حل خطأ يتعلق بنوع بيانات المعاملات، يطبع المتحدث قيم المعاملات المجمعة ويتحقق من صحتها في طريقة إنشاء الرسم البياني، مما يؤكد التوليد الناجح لبيانات المعاملات لأيام الأسبوع المختلفة. تتم إضافة معاملات إضافية ومراقبتها في الرسم البياني، مما يوضح وظيفة إنشاء بيانات المعاملات وعرضها ديناميكيًا على الشاشة.",
                                // Persian
                                "فارسی": "در این فیلم آموزشی، سخنران نحوه ادغام ویجت نمودار را در فایل main.dart برای نمایش داده های تراکنش توضیح می دهد. با جایگزین کردن یک ظرف با ویجت نمودار و وارد کردن ویجت لازم، سخنران نحوه فیلتر کردن تراکنش‌های اخیر هفته گذشته را با استفاده از گیرنده‌ای به نام _recentTransactions نشان می‌دهد. گوینده از روش Where در لیست تراکنش‌ها برای فیلتر کردن تراکنش‌های قدیمی‌تر از یک هفته استفاده می‌کند و مطمئن می‌شود که فقط تراکنش‌های اخیر در نمودار گنجانده شده‌اند. پس از رفع خطای مربوط به نوع داده تراکنش‌ها، بلندگو مقادیر تراکنش‌های گروه‌بندی‌شده را در روش ساخت نمودار چاپ و تأیید می‌کند و تولید موفق داده‌های تراکنش را برای روزهای مختلف هفته تأیید می‌کند. تراکنش‌های اضافی اضافه شده و در نمودار مشاهده می‌شوند که عملکرد تولید پویا و نمایش داده‌های تراکنش را روی صفحه نمایش می‌دهد.",
                            },
                        },
                        // 90 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Creating Bars for our Chart",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker focuses on creating a bar chart within the chart.dart file to display grouped and summed up transaction values. By generating the children for the row based on the grouped transaction values, the speaker highlights the need to create individual bars representing each weekday's transaction data. The speaker explains the logic behind converting the weekday abbreviation to a single character for display purposes, emphasizing the use of the substring method on the formatted weekday. Additionally, the speaker introduces the concept of creating a separate chart_bar.dart file within the widgets folder to define the structure of each bar in the chart. The speaker details the construction of the chart_bar stateless widget, specifying the required information such as label, spending amount, and spending percentage of the total. The speaker then demonstrates how to design the bar container by utilizing the stack widget to overlay elements and create a partially filled background. Finally, the speaker provides insights on setting the border, background color, and border radius for the container, showcasing the step-by-step process of building a visually appealing bar chart in Flutter.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial konzentriert sich der Sprecher auf die Erstellung eines Balkendiagramms innerhalb der Datei chart.dart, um gruppierte und zusammengefasste Transaktionswerte anzuzeigen. Indem er die untergeordneten Elemente für die Zeile basierend auf den gruppierten Transaktionswerten generiert, unterstreicht der Sprecher die Notwendigkeit, einzelne Balken zu erstellen, die die Transaktionsdaten jedes Wochentags darstellen. Der Sprecher erklärt die Logik hinter der Konvertierung der Wochentagsabkürzung in ein einzelnes Zeichen für Anzeigezwecke und betont die Verwendung der Teilzeichenfolgenmethode für den formatierten Wochentag. Darüber hinaus stellt der Sprecher das Konzept der Erstellung einer separaten Datei chart_bar.dart innerhalb des Ordners widgets vor, um die Struktur jedes Balkens im Diagramm zu definieren. Der Sprecher beschreibt detailliert die Konstruktion des zustandslosen Widgets chart_bar und gibt die erforderlichen Informationen wie Bezeichnung, Ausgabenbetrag und Ausgabenprozentsatz des Gesamtbetrags an. Der Sprecher demonstriert dann, wie der Balkencontainer gestaltet wird, indem das Stapel-Widget verwendet wird, um Elemente zu überlagern und einen teilweise gefüllten Hintergrund zu erstellen. Abschließend gibt der Sprecher Einblicke in das Festlegen von Rahmen, Hintergrundfarbe und Rahmenradius für den Container und demonstriert Schritt für Schritt die Erstellung eines optisch ansprechenden Balkendiagramms in Flutter.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者重点介绍了如何在 chart.dart 文件中创建条形图，以显示分组和汇总的交易值。通过根据分组的交易值生成行的子项，演讲者强调了创建代表每个工作日交易数据的单独条形图的必要性。演讲者解释了将工作日缩写转换为单个字符以供显示的逻辑，强调了对格式化的工作日使用子字符串方法。此外，演讲者还介绍了在 widgets 文件夹中创建单独的 chart_bar.dart 文件的概念，以定义图表中每个条形图的结构。演讲者详细介绍了 chart_bar 无状态小部件的构造，指定了所需的信息，例如标签、支出金额和总支出百分比。然后，演讲者演示了如何利用堆栈小部件叠加元素并创建部分填充的背景来设计条形图容器。最后，演讲者提供了有关设置容器边框、背景颜色和边框半径的见解，展示了在 Flutter 中构建视觉吸引力条形图的分步过程。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик фокусируется на создании столбчатой ​​диаграммы в файле chart.dart для отображения сгруппированных и суммированных значений транзакций. Создавая дочерние элементы для строки на основе сгруппированных значений транзакций, докладчик подчеркивает необходимость создания отдельных столбцов, представляющих данные транзакций каждого дня недели. Докладчик объясняет логику преобразования аббревиатуры дня недели в один символ для целей отображения, подчеркивая использование метода подстроки для отформатированного дня недели. Кроме того, докладчик представляет концепцию создания отдельного файла chart_bar.dart в папке виджетов для определения структуры каждого столбца в диаграмме. Докладчик подробно описывает конструкцию виджета без состояния chart_bar, указывая необходимую информацию, такую ​​как метка, сумма расходов и процент расходов от общей суммы. Затем докладчик демонстрирует, как спроектировать контейнер столбца, используя виджет стека для наложения элементов и создания частично заполненного фона. Наконец, докладчик дает советы по настройке границы, цвета фона и радиуса границы контейнера, демонстрируя пошаговый процесс создания визуально привлекательной столбчатой ​​диаграммы во Flutter.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant se concentre sur la création d'un graphique à barres dans le fichier chart.dart pour afficher les valeurs de transaction groupées et additionnées. En générant les enfants de la ligne en fonction des valeurs de transaction groupées, l'intervenant souligne la nécessité de créer des barres individuelles représentant les données de transaction de chaque jour de la semaine. L'intervenant explique la logique derrière la conversion de l'abréviation du jour de la semaine en un seul caractère à des fins d'affichage, en mettant l'accent sur l'utilisation de la méthode de sous-chaîne sur le jour de la semaine formaté. De plus, l'intervenant introduit le concept de création d'un fichier chart_bar.dart distinct dans le dossier widgets pour définir la structure de chaque barre du graphique. L'intervenant détaille la construction du widget sans état chart_bar, en spécifiant les informations requises telles que l'étiquette, le montant des dépenses et le pourcentage des dépenses du total. L'intervenant montre ensuite comment concevoir le conteneur de barres en utilisant le widget de pile pour superposer des éléments et créer un arrière-plan partiellement rempli. Enfin, l'intervenant fournit des informations sur la définition de la bordure, de la couleur d'arrière-plan et du rayon de la bordure du conteneur, en présentant le processus étape par étape de création d'un graphique à barres visuellement attrayant dans Flutter.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、講演者は、グループ化され合計されたトランザクション値を表示する棒グラフを chart.dart ファイル内に作成することに焦点を当てています。講演者は、グループ化されたトランザクション値に基づいて行の子を生成することにより、各曜日のトランザクションデータを表す個別の棒グラフを作成する必要性を強調しています。講演者は、表示目的で曜日の略語を 1 文字に変換するロジックを説明し、フォーマットされた曜日での部分文字列メソッドの使用を強調しています。さらに、講演者は、ウィジェット フォルダー内に別の chart_bar.dart ファイルを作成し、グラフ内の各棒グラフの構造を定義するという概念を紹介します。講演者は、ラベル、支出額、合計に対する支出の割合などの必要な情報を指定して、chart_bar ステートレス ウィジェットの構築を詳しく説明します。次に、スタック ウィジェットを使用して要素をオーバーレイし、部分的に塗りつぶされた背景を作成することにより、棒グラフ コンテナーを設計する方法を示します。最後に、講演者は、コンテナの境界線、背景色、境界線の半径の設定に関する洞察を提供し、Flutter で視覚的に魅力的な棒グラフを作成する手順を段階的に紹介します。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 chart.dart 파일 내에서 막대 차트를 만들어 그룹화되고 합산된 거래 값을 표시하는 데 중점을 둡니다. 발표자는 그룹화된 거래 값을 기반으로 행의 자식을 생성하여 각 요일의 거래 데이터를 나타내는 개별 막대를 만들어야 할 필요성을 강조합니다. 발표자는 표시 목적으로 요일 약어를 단일 문자로 변환하는 논리를 설명하며, 포맷된 요일에 하위 문자열 방법을 사용하는 것을 강조합니다. 또한 발표자는 차트의 각 막대 구조를 정의하기 위해 widgets 폴더 내에 별도의 chart_bar.dart 파일을 만드는 개념을 소개합니다. 발표자는 chart_bar 상태 없는 위젯의 구성을 자세히 설명하여 레이블, 지출 금액, 총 지출 비율과 같은 필수 정보를 지정합니다. 그런 다음 발표자는 스택 위젯을 사용하여 요소를 오버레이하고 부분적으로 채워진 배경을 만들어 막대 컨테이너를 디자인하는 방법을 보여줍니다. 마지막으로 발표자는 컨테이너의 테두리, 배경색, 테두리 반경을 설정하는 방법에 대한 통찰력을 제공하고 Flutter에서 시각적으로 매력적인 막대 차트를 만드는 단계별 프로세스를 보여줍니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador se centra en la creación de un gráfico de barras dentro del archivo chart.dart para mostrar los valores de las transacciones agrupadas y sumadas. Al generar los elementos secundarios de la fila en función de los valores de las transacciones agrupadas, el orador destaca la necesidad de crear barras individuales que representen los datos de las transacciones de cada día de la semana. El orador explica la lógica detrás de la conversión de la abreviatura del día de la semana a un solo carácter para fines de visualización, haciendo hincapié en el uso del método de subcadena en el día de la semana formateado. Además, el orador presenta el concepto de crear un archivo chart_bar.dart independiente dentro de la carpeta widgets para definir la estructura de cada barra del gráfico. El orador detalla la construcción del widget sin estado chart_bar, especificando la información requerida, como la etiqueta, el monto de gasto y el porcentaje de gasto del total. Luego, el orador demuestra cómo diseñar el contenedor de barras utilizando el widget de pila para superponer elementos y crear un fondo parcialmente relleno. Por último, el orador brinda información sobre cómo configurar el borde, el color de fondo y el radio del borde del contenedor, mostrando el proceso paso a paso de creación de un gráfico de barras visualmente atractivo en Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता चार्ट.डार्ट फ़ाइल के भीतर एक बार चार्ट बनाने पर ध्यान केंद्रित करता है ताकि समूहीकृत और सारांशित लेनदेन मूल्यों को प्रदर्शित किया जा सके। समूहीकृत लेनदेन मूल्यों के आधार पर पंक्ति के लिए बच्चों को उत्पन्न करके, वक्ता प्रत्येक सप्ताह के दिन के लेनदेन डेटा का प्रतिनिधित्व करने वाले अलग-अलग बार बनाने की आवश्यकता पर प्रकाश डालता है। वक्ता प्रदर्शन उद्देश्यों के लिए सप्ताह के दिन के संक्षिप्त नाम को एकल वर्ण में बदलने के पीछे के तर्क को समझाता है, प्रारूपित सप्ताह के दिन पर सबस्ट्रिंग विधि के उपयोग पर जोर देता है। इसके अतिरिक्त, वक्ता चार्ट में प्रत्येक बार की संरचना को परिभाषित करने के लिए विजेट फ़ोल्डर के भीतर एक अलग चार्ट_बार.डार्ट फ़ाइल बनाने की अवधारणा का परिचय देता है। वक्ता चार्ट_बार स्टेटलेस विजेट के निर्माण का विवरण देता है, जिसमें लेबल, खर्च की राशि और कुल खर्च का प्रतिशत जैसी आवश्यक जानकारी निर्दिष्ट की जाती है। फिर वक्ता प्रदर्शित करता है कि तत्वों को ओवरले करने और आंशिक रूप से भरी हुई पृष्ठभूमि बनाने के लिए स्टैक विजेट का उपयोग करके बार कंटेनर को कैसे डिज़ाइन किया जाए। अंत में, वक्ता कंटेनर के लिए बॉर्डर, बैकग्राउंड कलर और बॉर्डर रेडियस सेट करने के बारे में जानकारी प्रदान करता है, जो फ़्लटर में एक आकर्षक बार चार्ट बनाने की चरण-दर-चरण प्रक्रिया को प्रदर्शित करता है।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador concentra-se na criação de um gráfico de barras dentro do ficheiro chart.dart para exibir valores de transação agrupados e resumidos. Ao gerar os filhos para a linha com base nos valores de transação agrupados, o orador destaca a necessidade de criar barras individuais que representam os dados de transação de cada dia da semana. O orador explica a lógica por detrás da conversão da abreviatura do dia da semana num único caractere para fins de exibição, enfatizando a utilização do método substring no dia da semana formatado. Além disso, o orador apresenta o conceito de criação de um ficheiro chart_bar.dart separado dentro da pasta widgets para definir a estrutura de cada barra no gráfico. O orador detalha a construção do widget chart_bar sem estado, especificando a informação necessária, como o rótulo, o valor gasto e a percentagem de gastos do total. O orador demonstra então como projetar o contentor da barra utilizando o widget de pilha para sobrepor elementos e criar um fundo parcialmente preenchido. Por fim, o orador fornece insights sobre como definir a borda, a cor do fundo e o raio da borda do contentor, mostrando o processo passo a passo de construção de um gráfico de barras visualmente apelativo no Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার দলবদ্ধ এবং সংক্ষিপ্ত লেনদেনের মানগুলি প্রদর্শন করতে chart.dart ফাইলের মধ্যে একটি বার চার্ট তৈরি করার উপর ফোকাস করে। গোষ্ঠীবদ্ধ লেনদেনের মানগুলির উপর ভিত্তি করে সারির জন্য বাচ্চাদের তৈরি করে, স্পিকার প্রতিটি সপ্তাহের দিনের লেনদেনের ডেটা উপস্থাপন করে পৃথক বার তৈরি করার প্রয়োজনীয়তা তুলে ধরেন। স্পিকার সাপ্তাহিক দিনের সংক্ষিপ্ত রূপকে প্রদর্শনের উদ্দেশ্যে একটি একক অক্ষরে রূপান্তর করার পিছনে যুক্তি ব্যাখ্যা করেন, ফর্ম্যাট করা সপ্তাহের দিনে সাবস্ট্রিং পদ্ধতির ব্যবহারের উপর জোর দেন। অতিরিক্তভাবে, স্পিকার চার্টে প্রতিটি বারের গঠন সংজ্ঞায়িত করার জন্য উইজেট ফোল্ডারের মধ্যে একটি পৃথক chart_bar.dart ফাইল তৈরি করার ধারণাটি প্রবর্তন করে। স্পিকার লেবেল, খরচের পরিমাণ এবং মোট খরচের শতাংশের মতো প্রয়োজনীয় তথ্য উল্লেখ করে চার্ট_বার স্টেটলেস উইজেটের নির্মাণের বিবরণ দেয়। স্পিকার তারপর প্রদর্শন করে কিভাবে স্ট্যাক উইজেট ব্যবহার করে উপাদানগুলিকে ওভারলে করতে এবং একটি আংশিকভাবে ভরা পটভূমি তৈরি করে বার কন্টেইনারটি ডিজাইন করতে হয়। অবশেষে, স্পিকার ধারকটির জন্য সীমানা, পটভূমির রঙ এবং সীমানা ব্যাসার্ধ সেট করার বিষয়ে অন্তর্দৃষ্টি প্রদান করে, ফ্লটারে একটি দৃশ্যমান আকর্ষণীয় বার চার্ট তৈরি করার ধাপে ধাপে প্রক্রিয়াটি প্রদর্শন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يركز المتحدث على إنشاء مخطط شريطي داخل ملف chart.dart لعرض قيم المعاملات المجمعة والملخصة. من خلال إنشاء العناصر الفرعية للصف بناءً على قيم المعاملات المجمعة، يسلط المتحدث الضوء على الحاجة إلى إنشاء أشرطة فردية تمثل بيانات معاملات كل يوم من أيام الأسبوع. يشرح المتحدث المنطق وراء تحويل اختصار يوم الأسبوع إلى حرف واحد لأغراض العرض، مع التأكيد على استخدام طريقة السلسلة الفرعية في يوم الأسبوع المنسق. بالإضافة إلى ذلك، يقدم المتحدث مفهوم إنشاء ملف chart_bar.dart منفصل داخل مجلد الأدوات لتحديد بنية كل شريط في المخطط. يوضح المتحدث بالتفصيل إنشاء أداة chart_bar عديمة الجنسية، مع تحديد المعلومات المطلوبة مثل الملصق ومبلغ الإنفاق ونسبة الإنفاق من الإجمالي. ثم يوضح المتحدث كيفية تصميم حاوية الشريط من خلال الاستفادة من أداة المكدس لتراكب العناصر وإنشاء خلفية مملوءة جزئيًا. أخيرًا، يقدم المتحدث رؤى حول ضبط الحدود ولون الخلفية ونصف قطر الحدود للحاوية، ويعرض العملية خطوة بخطوة لبناء مخطط شريطي جذاب بصريًا في Flutter.",
                                // Persian
                                "فارسی": "در این آموزش تصویری، گوینده بر ایجاد نمودار میله ای در فایل chart.dart تمرکز می کند تا مقادیر تراکنش های گروه بندی شده و خلاصه شده را نمایش دهد. با ایجاد فرزندان برای ردیف بر اساس مقادیر تراکنش گروه‌بندی‌شده، گوینده نیاز به ایجاد نوارهای مجزا برای نمایش داده‌های تراکنش هر روز هفته را برجسته می‌کند. سخنران منطق پشت تبدیل اختصار روز هفته به یک کاراکتر را برای اهداف نمایشی توضیح می دهد و بر استفاده از روش رشته فرعی در روزهای هفته فرمت شده تاکید می کند. علاوه بر این، سخنران مفهوم ایجاد یک فایل chart_bar.dart جداگانه را در پوشه ابزارک ها برای تعریف ساختار هر نوار در نمودار معرفی می کند. بلندگو جزئیات ساخت ویجت بدون حالت نمودار_نوار را مشخص می کند و اطلاعات مورد نیاز مانند برچسب، مبلغ هزینه و درصد هزینه کل را مشخص می کند. سپس بلندگو نحوه طراحی محفظه نوار را با استفاده از ویجت پشته برای همپوشانی عناصر و ایجاد یک پس‌زمینه نیمه پر نشان می‌دهد. در نهایت، بلندگو اطلاعاتی در مورد تنظیم حاشیه، رنگ پس‌زمینه و شعاع حاشیه برای ظرف ارائه می‌کند و روند گام به گام ساختن نمودار میله‌ای جذاب بصری را در Flutter نشان می‌دهد.",
                            },
                        },
                        // 91 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Populating the Chart with Values",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker continues working on the chart widget by integrating the chart bar widget to display transaction data. By importing the chart bar widget and passing in the necessary parameters like label and spending amount, the speaker explains the process of calculating the total spendings for the week using a getter function named Max spending. The speaker introduces and utilizes the fold method on lists in Dart to sum up the total transaction amounts for each day and derive the total spending for the week. Additionally, the speaker addresses errors related to dividing by zero when there are no transactions, implementing a ternary expression to handle the scenario and ensure the chart bars render correctly even when there are no transactions. The speaker emphasizes the importance of efficient utilization of space and highlights the importance of handling scenarios where there are no transactions in the application.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial arbeitet der Sprecher weiter am Diagramm-Widget, indem er das Diagrammbalken-Widget integriert, um Transaktionsdaten anzuzeigen. Durch Importieren des Diagrammbalken-Widgets und Übergeben der erforderlichen Parameter wie Beschriftung und Ausgabenbetrag erklärt der Sprecher den Prozess der Berechnung der Gesamtausgaben für die Woche mithilfe einer Getter-Funktion namens „Max. Ausgaben“. Der Sprecher stellt die Fold-Methode für Listen in Dart vor und verwendet sie, um die Gesamttransaktionsbeträge für jeden Tag zusammenzufassen und die Gesamtausgaben für die Woche abzuleiten. Darüber hinaus behandelt der Sprecher Fehler im Zusammenhang mit der Division durch Null, wenn keine Transaktionen vorhanden sind, und implementiert einen ternären Ausdruck, um das Szenario zu verarbeiten und sicherzustellen, dass die Diagrammbalken auch dann korrekt dargestellt werden, wenn keine Transaktionen vorhanden sind. Der Sprecher betont die Bedeutung einer effizienten Raumausnutzung und hebt die Bedeutung der Verarbeitung von Szenarien hervor, in denen in der Anwendung keine Transaktionen vorhanden sind.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者继续开发图表小部件，通过集成图表栏小部件来显示交易数据。通过导入图表栏小部件并传入标签和消费金额等必要参数，演讲者解释了使用名为 Max Compensation 的 getter 函数计算一周总消费的过程。演讲者介绍并使用 Dart 中列表上的 fold 方法来汇总每天的总交易金额并得出一周的总消费。此外，演讲者还解决了在没有交易时除以零的错误，实现了三元表达式来处理这种情况并确保图表栏即使在没有交易的情况下也能正确呈现。演讲者强调了高效利用空间的重要性，并强调了处理应用程序中没有交易的场景的重要性。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик продолжает работать над виджетом диаграммы, интегрируя виджет столбчатой ​​диаграммы для отображения данных о транзакциях. Импортируя виджет столбчатой ​​диаграммы и передавая необходимые параметры, такие как метка и сумма расходов, докладчик объясняет процесс расчета общих расходов за неделю с помощью функции-получателя с именем Max expenditure. Докладчик представляет и использует метод fold в списках в Dart для суммирования общих сумм транзакций за каждый день и получения общих расходов за неделю. Кроме того, докладчик рассматривает ошибки, связанные с делением на ноль при отсутствии транзакций, реализуя тернарное выражение для обработки сценария и обеспечения корректного отображения столбцов диаграммы даже при отсутствии транзакций. Докладчик подчеркивает важность эффективного использования пространства и подчеркивает важность обработки сценариев, когда в приложении нет транзакций.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant continue de travailler sur le widget graphique en intégrant le widget de barre de graphique pour afficher les données de transaction. En important le widget de barre de graphique et en transmettant les paramètres nécessaires comme l'étiquette et le montant des dépenses, l'intervenant explique le processus de calcul des dépenses totales de la semaine à l'aide d'une fonction getter nommée Max Spend. L'intervenant présente et utilise la méthode fold sur les listes dans Dart pour additionner les montants totaux des transactions pour chaque jour et en déduire les dépenses totales de la semaine. De plus, l'intervenant aborde les erreurs liées à la division par zéro lorsqu'il n'y a pas de transactions, en implémentant une expression ternaire pour gérer le scénario et garantir que les barres du graphique s'affichent correctement même lorsqu'il n'y a pas de transactions. L'intervenant souligne l'importance d'une utilisation efficace de l'espace et souligne l'importance de gérer les scénarios où il n'y a pas de transactions dans l'application.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、講演者はチャートウィジェットの作業を続行し、チャートバーウィジェットを統合して取引データを表示します。チャートバーウィジェットをインポートし、ラベルや支出額などの必要なパラメータを渡すことで、講演者は Max spend というゲッター関数を使用して週の合計支出を計算するプロセスについて説明します。講演者は、Dart のリストの fold メソッドを紹介して使用し、各日の合計取引額を合計して週の合計支出を導き出します。さらに、講演者は、取引がない場合にゼロで割ることに関連するエラーに対処し、シナリオを処理するための 3 項式を実装して、取引がない場合でもチャートバーが正しくレンダリングされるようにします。講演者は、スペースの効率的な利用の重要性を強調し、アプリケーションで取引がない場合のシナリオを処理することの重要性を強調します。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 차트 막대 위젯을 통합하여 거래 데이터를 표시함으로써 차트 위젯 작업을 계속합니다. 발표자는 차트 막대 위젯을 가져오고 레이블 및 지출 금액과 같은 필요한 매개변수를 전달하여 Max spending이라는 게터 함수를 사용하여 주당 총 지출을 계산하는 프로세스를 설명합니다. 발표자는 Dart의 목록에서 fold 메서드를 소개하고 활용하여 각 요일의 총 거래 금액을 합산하고 주당 총 지출을 도출합니다. 또한 발표자는 거래가 없을 때 0으로 나누는 것과 관련된 오류를 해결하고, 시나리오를 처리하고 거래가 없을 때에도 차트 막대가 올바르게 렌더링되도록 하는 3항 표현식을 구현합니다. 발표자는 공간을 효율적으로 활용하는 것의 중요성을 강조하고 애플리케이션에 거래가 없는 시나리오를 처리하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador continúa trabajando en el widget de gráfico mediante la integración del widget de barra de gráfico para mostrar datos de transacciones. Al importar el widget de barra de gráfico y pasar los parámetros necesarios como etiqueta y monto de gasto, el orador explica el proceso de cálculo de los gastos totales de la semana utilizando una función de obtención llamada Max Spending. El orador presenta y utiliza el método Fold en listas en Dart para sumar los montos totales de transacciones de cada día y derivar el gasto total de la semana. Además, el orador aborda los errores relacionados con la división por cero cuando no hay transacciones, implementando una expresión ternaria para manejar el escenario y garantizar que las barras del gráfico se representen correctamente incluso cuando no hay transacciones. El orador enfatiza la importancia de la utilización eficiente del espacio y destaca la importancia de manejar escenarios donde no hay transacciones en la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता चार्ट बार विजेट को एकीकृत करके लेन-देन डेटा प्रदर्शित करने के लिए चार्ट विजेट पर काम करना जारी रखता है। चार्ट बार विजेट को आयात करके और लेबल और खर्च राशि जैसे आवश्यक मापदंडों को पास करके, वक्ता अधिकतम खर्च नामक गेट्टर फ़ंक्शन का उपयोग करके सप्ताह के लिए कुल खर्चों की गणना करने की प्रक्रिया को समझाता है। वक्ता प्रत्येक दिन के लिए कुल लेन-देन राशियों को जोड़ने और सप्ताह के लिए कुल खर्च निकालने के लिए डार्ट में सूचियों पर फोल्ड विधि का परिचय और उपयोग करता है। इसके अतिरिक्त, वक्ता लेन-देन न होने पर शून्य से विभाजित करने से संबंधित त्रुटियों को संबोधित करता है, परिदृश्य को संभालने के लिए एक त्रिगुण अभिव्यक्ति को लागू करता है और यह सुनिश्चित करता है कि लेन-देन न होने पर भी चार्ट बार सही ढंग से प्रस्तुत हों। वक्ता स्थान के कुशल उपयोग के महत्व पर जोर देता है और उन परिदृश्यों को संभालने के महत्व पर प्रकाश डालता है जहाँ एप्लिकेशन में कोई लेन-देन नहीं है।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador continua a trabalhar no widget de gráfico integrando o widget de barra de gráfico para exibir os dados de transação. Ao importar o widget da barra do gráfico e passar os parâmetros necessários, como o rótulo e o valor dos gastos, o orador explica o processo de cálculo dos gastos totais da semana através de uma função getter chamada Gastos máximos. O orador apresenta e utiliza o método de dobragem nas listas do Dart para somar os valores totais das transações de cada dia e derivar os gastos totais da semana. Além disso, o orador aborda os erros relacionados com a divisão por zero quando não existem transações, implementando uma expressão ternária para lidar com o cenário e garantir que as barras do gráfico são renderizadas corretamente mesmo quando não existem transações. O orador realça a importância da utilização eficiente do espaço e realça a importância de lidar com cenários onde não existem transações na aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার লেনদেনের ডেটা প্রদর্শন করতে চার্ট বার উইজেটকে একীভূত করে চার্ট উইজেটে কাজ চালিয়ে যাচ্ছে। চার্ট বার উইজেট আমদানি করে এবং লেবেল এবং ব্যয়ের পরিমাণের মতো প্রয়োজনীয় পরামিতিগুলি পাস করে, স্পিকার সর্বাধিক ব্যয় নামে একটি গেটার ফাংশন ব্যবহার করে সপ্তাহের জন্য মোট ব্যয় গণনা করার প্রক্রিয়া ব্যাখ্যা করে। স্পিকার প্রতিটি দিনের জন্য মোট লেনদেনের পরিমাণ যোগ করার জন্য এবং সপ্তাহের জন্য মোট ব্যয় বের করতে ডার্টের তালিকায় ভাঁজ পদ্ধতি প্রবর্তন করে এবং ব্যবহার করে। অতিরিক্তভাবে, স্পিকার কোনো লেনদেন না থাকলে শূন্য দিয়ে ভাগ করার সাথে সম্পর্কিত ত্রুটির সমাধান করে, দৃশ্যকল্প পরিচালনা করার জন্য একটি ত্রিদেশীয় অভিব্যক্তি প্রয়োগ করে এবং কোনো লেনদেন না থাকলেও চার্ট বার সঠিকভাবে রেন্ডার হয় তা নিশ্চিত করে। স্পিকার স্থানের দক্ষ ব্যবহারের গুরুত্বের উপর জোর দেন এবং অ্যাপ্লিকেশনে কোন লেনদেন নেই এমন পরিস্থিতিতে পরিচালনার গুরুত্ব তুলে ধরেন।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يواصل المتحدث العمل على عنصر واجهة المستخدم للرسم البياني من خلال دمج عنصر واجهة المستخدم لشريط الرسم البياني لعرض بيانات المعاملات. من خلال استيراد عنصر واجهة المستخدم لشريط الرسم البياني وتمرير المعلمات الضرورية مثل الملصق ومبلغ الإنفاق، يشرح المتحدث عملية حساب إجمالي الإنفاق للأسبوع باستخدام دالة getter تسمى Max expenditure. يقدم المتحدث ويستخدم طريقة الطي في القوائم في Dart لتلخيص إجمالي مبالغ المعاملات لكل يوم واستنتاج إجمالي الإنفاق للأسبوع. بالإضافة إلى ذلك، يتناول المتحدث الأخطاء المتعلقة بالقسمة على الصفر عندما لا توجد معاملات، وتنفيذ تعبير ثلاثي للتعامل مع السيناريو وضمان عرض أشرطة الرسم البياني بشكل صحيح حتى عندما لا توجد معاملات. يؤكد المتحدث على أهمية الاستخدام الفعال للمساحة ويسلط الضوء على أهمية التعامل مع السيناريوهات حيث لا توجد معاملات في التطبيق.",
                                // Persian
                                "فارسی": "در این آموزش تصویری، سخنران با ادغام ویجت نوار نمودار برای نمایش داده های تراکنش، به کار بر روی ویجت نمودار ادامه می دهد. با وارد کردن ویجت نوار نمودار و پاس کردن پارامترهای لازم مانند برچسب و مقدار هزینه، گوینده فرآیند محاسبه کل هزینه‌های هفته را با استفاده از یک تابع گیرنده به نام حداکثر هزینه توضیح می‌دهد. گوینده برای جمع‌بندی کل مبالغ تراکنش برای هر روز و استخراج کل هزینه‌های هفته، روش fold را در فهرست‌های دارت معرفی و استفاده می‌کند. علاوه بر این، بلندگو خطاهای مربوط به تقسیم بر صفر را در زمانی که هیچ تراکنشی وجود ندارد برطرف می‌کند، یک عبارت سه تایی را برای مدیریت سناریو پیاده‌سازی می‌کند و اطمینان حاصل می‌کند که میله‌های نمودار به درستی نمایش داده می‌شوند، حتی زمانی که هیچ تراکنشی وجود ندارد. سخنران بر اهمیت استفاده کارآمد از فضا تأکید می کند و اهمیت رسیدگی به سناریوهایی را که در آن هیچ تراکنشی در برنامه وجود ندارد، برجسته می کند.",
                            },
                        },
                        // 92 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Finishing the Chart Bars",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the speaker focuses on optimizing space utilization by adjusting child elements in the chart widget, particularly the chart bar within a row. By implementing the mainAxisAlignment property with a spacing value like spaceAround, the speaker demonstrates achieving a more visually appealing layout. Additionally, the speaker explains the utilization of the Flexible widget to restrict the growth of child elements and ensure they maintain their size. Handling scenarios where text overflows due to limited space, the speaker introduces the FittedBox widget to scale and shrink text within the available space, preventing unwanted line breaks. To enhance the visual appeal further, the speaker adds padding around the bars by enclosing the row in a container with specific padding values. The speaker concludes by mentioning the simplicity of using the Padding widget for adding padding without the need for a container. Furthermore, the speaker hints at future enhancements in fine-tuning list items and exploring responsiveness and styling options for iOS and Android devices.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial konzentriert sich der Sprecher auf die Optimierung der Platznutzung durch Anpassen untergeordneter Elemente im Diagramm-Widget, insbesondere der Diagrammleiste innerhalb einer Zeile. Durch die Implementierung der Eigenschaft mainAxisAlignment mit einem Abstandswert wie spaceAround demonstriert der Sprecher, wie ein optisch ansprechenderes Layout erreicht werden kann. Darüber hinaus erklärt der Sprecher die Verwendung des Flexible-Widgets, um das Wachstum untergeordneter Elemente einzuschränken und sicherzustellen, dass sie ihre Größe beibehalten. In Szenarien, in denen Text aufgrund begrenzten Platzes überläuft, stellt der Sprecher das FittedBox-Widget vor, um Text innerhalb des verfügbaren Platzes zu skalieren und zu verkleinern und so unerwünschte Zeilenumbrüche zu vermeiden. Um die visuelle Attraktivität weiter zu verbessern, fügt der Sprecher eine Polsterung um die Balken hinzu, indem er die Zeile in einen Container mit bestimmten Polsterungswerten einschließt. Der Sprecher schließt mit der Erwähnung der Einfachheit der Verwendung des Padding-Widgets zum Hinzufügen von Polsterung ohne die Notwendigkeit eines Containers. Darüber hinaus weist der Sprecher auf zukünftige Verbesserungen bei der Feinabstimmung von Listenelementen hin und untersucht Reaktionsfähigkeit und Gestaltungsoptionen für iOS- und Android-Geräte.",
                                // Chinese
                                "中国人": "在本视频教程中，演讲者重点介绍了如何通过调整图表小部件中的子元素（尤其是行内的图表栏）来优化空间利用率。通过使用 spaceAround 之类的间距值实现 mainAxisAlignment 属性，演讲者演示了如何实现更具视觉吸引力的布局。此外，演讲者还解释了如何使用 Flexible 小部件来限制子元素的增长并确保它们保持其大小。为了处理由于空间有限而导致文本溢出的情况，演讲者引入​​了 FittedBox 小部件来在可用空间内缩放和缩小文本，从而防止出现不必要的换行。为了进一步增强视觉吸引力，演讲者通过将行封闭在具有特定填充值的容器中来在栏周围添加填充。演讲者最后提到了使用 Padding 小部件添加填充的简单性，而无需容器。此外，演讲者暗示未来将在微调列表项方面有所改进，并探索 iOS 和 Android 设备的响应能力和样式选项。",
                                // Russian
                                "Русский": "В этом видеоуроке докладчик фокусируется на оптимизации использования пространства путем настройки дочерних элементов в виджете диаграммы, в частности, панели диаграммы в строке. Реализуя свойство mainAxisAlignment со значением интервала, например spaceAround, докладчик демонстрирует достижение более визуально привлекательного макета. Кроме того, докладчик объясняет использование виджета Flexible для ограничения роста дочерних элементов и обеспечения сохранения их размера. Обрабатывая сценарии, в которых текст выходит за пределы из-за ограниченного пространства, докладчик представляет виджет FittedBox для масштабирования и сжатия текста в пределах доступного пространства, предотвращая нежелательные разрывы строк. Чтобы еще больше улучшить визуальную привлекательность, докладчик добавляет отступы вокруг полос, заключая строку в контейнер с определенными значениями отступов. В заключение докладчик упоминает простоту использования виджета Padding для добавления отступов без необходимости в контейнере. Кроме того, докладчик намекает на будущие улучшения в тонкой настройке элементов списка и изучении вариантов адаптивности и стилей для устройств iOS и Android.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'intervenant se concentre sur l'optimisation de l'utilisation de l'espace en ajustant les éléments enfants dans le widget graphique, en particulier la barre de graphique dans une ligne. En implémentant la propriété mainAxisAlignment avec une valeur d'espacement comme spaceAround, l'intervenant montre comment obtenir une mise en page plus attrayante visuellement. De plus, l'intervenant explique l'utilisation du widget Flexible pour limiter la croissance des éléments enfants et garantir qu'ils conservent leur taille. En gérant les scénarios où le texte déborde en raison d'un espace limité, l'intervenant présente le widget FittedBox pour mettre à l'échelle et réduire le texte dans l'espace disponible, évitant ainsi les sauts de ligne indésirables. Pour améliorer encore l'attrait visuel, l'intervenant ajoute un remplissage autour des barres en enfermant la ligne dans un conteneur avec des valeurs de remplissage spécifiques. L'intervenant conclut en mentionnant la simplicité d'utilisation du widget Padding pour ajouter un remplissage sans avoir besoin d'un conteneur. En outre, l'intervenant fait allusion à de futures améliorations dans le réglage fin des éléments de liste et à l'exploration des options de réactivité et de style pour les appareils iOS et Android.",
                                // Japanese
                                "日本語": "このビデオチュートリアルでは、講演者はチャートウィジェットの子要素、特に行内のチャートバーを調整することで、スペースの利用を最適化することに焦点を当てています。spaceAround のような間隔値を使用して mainAxisAlignment プロパティを実装することで、講演者は視覚的に魅力的なレイアウトを実現する方法を示します。さらに、講演者は、子要素の成長を制限し、サイズが維持されるようにするための Flexible ウィジェットの利用について説明します。スペースが限られているためにテキストがオーバーフローするシナリオに対処するために、講演者は、使用可能なスペース内でテキストを拡大縮小して不要な改行を防ぐ FittedBox ウィジェットを紹介します。視覚的な魅力をさらに高めるために、講演者は、特定のパディング値を持つコンテナーで行を囲むことで、バーの周りにパディングを追加します。講演者は、最後に、コンテナーを必要とせずにパディングを追加するための Padding ウィジェットの使用のシンプルさについて言及します。さらに、講演者は、リスト項目の微調整や、iOS および Android デバイスの応答性とスタイル設定オプションの検討における将来の機能強化について示唆しています。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 발표자는 차트 위젯의 자식 요소, 특히 행 내의 차트 막대를 조정하여 공간 활용을 최적화하는 데 중점을 둡니다. 발표자는 spaceAround와 같은 간격 값으로 mainAxisAlignment 속성을 구현하여 시각적으로 더 매력적인 레이아웃을 구현하는 방법을 보여줍니다. 또한 발표자는 자식 요소의 성장을 제한하고 크기를 유지하는 데 Flexible 위젯을 사용하는 방법을 설명합니다. 제한된 공간으로 인해 텍스트가 넘치는 시나리오를 처리하기 위해 발표자는 FittedBox 위젯을 소개하여 사용 가능한 공간 내에서 텍스트를 확장하고 축소하여 원치 않는 줄 바꿈을 방지합니다. 시각적 매력을 더욱 높이기 위해 발표자는 특정 패딩 값이 있는 컨테이너에 행을 둘러싸서 막대 주위에 패딩을 추가합니다. 발표자는 컨테이너가 필요 없이 패딩을 추가하는 데 Padding 위젯을 사용하는 것이 간단하다는 점을 언급하며 마무리합니다. 또한 발표자는 목록 항목을 미세 조정하고 iOS 및 Android 기기에 대한 응답성과 스타일 옵션을 탐색하는 데 있어 향후 개선 사항을 암시합니다.",
                                // Spanish
                                "Español": "En este videotutorial, el orador se centra en optimizar el uso del espacio mediante el ajuste de los elementos secundarios en el widget de gráfico, en particular la barra del gráfico dentro de una fila. Al implementar la propiedad mainAxisAlignment con un valor de espaciado como spaceAround, el orador demuestra cómo lograr un diseño visualmente más atractivo. Además, el orador explica el uso del widget Flexible para restringir el crecimiento de los elementos secundarios y garantizar que mantengan su tamaño. Para manejar escenarios en los que el texto se desborda debido al espacio limitado, el orador presenta el widget FittedBox para escalar y reducir el texto dentro del espacio disponible, lo que evita saltos de línea no deseados. Para mejorar aún más el atractivo visual, el orador agrega relleno alrededor de las barras al encerrar la fila en un contenedor con valores de relleno específicos. El orador concluye mencionando la simplicidad de usar el widget Padding para agregar relleno sin la necesidad de un contenedor. Además, el orador sugiere futuras mejoras en el ajuste fino de los elementos de la lista y la exploración de la capacidad de respuesta y las opciones de estilo para dispositivos iOS y Android.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, वक्ता चार्ट विजेट में चाइल्ड एलिमेंट्स, विशेष रूप से एक पंक्ति के भीतर चार्ट बार को समायोजित करके स्पेस उपयोग को अनुकूलित करने पर ध्यान केंद्रित करता है। स्पेसअराउंड जैसे स्पेसिंग मान के साथ mainAxisAlignment प्रॉपर्टी को लागू करके, वक्ता एक अधिक आकर्षक लेआउट प्राप्त करने का प्रदर्शन करता है। इसके अतिरिक्त, वक्ता चाइल्ड एलिमेंट्स की वृद्धि को प्रतिबंधित करने और यह सुनिश्चित करने के लिए कि वे अपना आकार बनाए रखें, फ्लेक्सिबल विजेट के उपयोग की व्याख्या करता है। ऐसे परिदृश्यों को संभालते हुए जहां सीमित स्थान के कारण टेक्स्ट ओवरफ्लो हो जाता है, वक्ता उपलब्ध स्थान के भीतर टेक्स्ट को छोटा और छोटा करने के लिए FittedBox विजेट पेश करता है, जिससे अवांछित लाइन ब्रेक को रोका जा सकता है। दृश्य अपील को और बढ़ाने के लिए, वक्ता पंक्ति को विशिष्ट पैडिंग मानों के साथ कंटेनर में संलग्न करके बार के चारों ओर पैडिंग जोड़ता है। वक्ता कंटेनर की आवश्यकता के बिना पैडिंग जोड़ने के लिए पैडिंग विजेट का उपयोग करने की सरलता का उल्लेख करके निष्कर्ष निकालता है। इसके अलावा, वक्ता भविष्य में सूची आइटम को ठीक करने और iOS और Android डिवाइस के लिए प्रतिक्रियाशीलता और स्टाइलिंग विकल्पों की खोज करने में भविष्य में होने वाले संवर्द्धन का संकेत देता है।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o orador foca-se na otimização da utilização do espaço, ajustando os elementos secundários no widget do gráfico, especialmente a barra do gráfico dentro de uma linha. Ao implementar a propriedade mainAxisAlignment com um valor de espaçamento como spaceAround, o orador demonstra a obtenção de um layout visualmente mais apelativo. Além disso, o orador explica a utilização do widget Flexível para restringir o crescimento dos elementos filhos e garantir que estes mantêm o seu tamanho. Lidando com cenários onde o texto transborda devido ao espaço limitado, o orador apresenta o widget FittedBox para escalar e reduzir o texto dentro do espaço disponível, evitando quebras de linha indesejadas. Para melhorar ainda mais o apelo visual, o altifalante adiciona preenchimento à volta das barras, colocando a linha num contentor com valores de preenchimento específicos. O orador conclui mencionando a simplicidade de utilizar o widget Padding para adicionar preenchimento sem a necessidade de um contentor. Além disso, o orador sugere melhorias futuras no ajuste fino dos itens da lista e na exploração de opções de capacidade de resposta e estilo para dispositivos iOS e Android.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, স্পিকার চার্ট উইজেটে, বিশেষ করে একটি সারির মধ্যে চার্ট বারে শিশু উপাদানগুলি সামঞ্জস্য করে স্থানের ব্যবহারকে অপ্টিমাইজ করার উপর ফোকাস করে। spaceAround এর মত ব্যবধানের মান সহ mainAxisAlignment প্রপার্টি বাস্তবায়ন করে, স্পিকার আরও দৃষ্টিনন্দন লেআউট অর্জন করে। উপরন্তু, স্পিকার শিশু উপাদানগুলির বৃদ্ধি সীমাবদ্ধ করতে এবং তাদের আকার বজায় রাখার বিষয়টি নিশ্চিত করতে নমনীয় উইজেটের ব্যবহার ব্যাখ্যা করে। সীমিত স্থানের কারণে টেক্সট ওভারফ্লো হয় এমন পরিস্থিতিতে, স্পিকার উপলব্ধ স্থানের মধ্যে পাঠ্যকে স্কেল এবং সঙ্কুচিত করার জন্য ফিটেডবক্স উইজেট প্রবর্তন করে, অবাঞ্ছিত লাইন বিরতি প্রতিরোধ করে। চাক্ষুষ আবেদন আরও উন্নত করতে, স্পিকার নির্দিষ্ট প্যাডিং মান সহ একটি পাত্রে সারিটি ঘেরাও করে বারগুলির চারপাশে প্যাডিং যুক্ত করে। স্পিকার একটি পাত্রের প্রয়োজন ছাড়াই প্যাডিং যোগ করার জন্য প্যাডিং উইজেট ব্যবহার করার সরলতা উল্লেখ করে শেষ করেন। তদুপরি, স্পিকারটি আইওএস এবং অ্যান্ড্রয়েড ডিভাইসগুলির জন্য সূক্ষ্ম-টিউনিং তালিকা আইটেমগুলিতে ভবিষ্যতের উন্নতি এবং প্রতিক্রিয়াশীলতা এবং স্টাইলিং বিকল্পগুলি অন্বেষণ করার ইঙ্গিত দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يركز المتحدث على تحسين استخدام المساحة من خلال ضبط العناصر الفرعية في أداة الرسم البياني، وخاصة شريط الرسم البياني داخل الصف. من خلال تنفيذ خاصية mainAxisAlignment بقيمة تباعد مثل spaceAround، يوضح المتحدث تحقيق تخطيط أكثر جاذبية بصريًا. بالإضافة إلى ذلك، يشرح المتحدث استخدام أداة Flexible لتقييد نمو العناصر الفرعية وضمان الحفاظ على حجمها. في التعامل مع السيناريوهات التي يفيض فيها النص بسبب المساحة المحدودة، يقدم المتحدث أداة FittedBox لتوسيع وتقليص النص داخل المساحة المتاحة، مما يمنع فواصل الأسطر غير المرغوب فيها. لتعزيز الجاذبية البصرية بشكل أكبر، يضيف المتحدث حشوًا حول الأشرطة من خلال إحاطة الصف بحاوية بقيم حشو محددة. ويختتم المتحدث بالإشارة إلى بساطة استخدام أداة Padding لإضافة الحشو دون الحاجة إلى حاوية. علاوة على ذلك، يلمح المتحدث إلى التحسينات المستقبلية في ضبط عناصر القائمة واستكشاف خيارات الاستجابة والتصميم لأجهزة iOS وAndroid.",
                                // Persian
                                "فارسی": "در این آموزش ویدیویی، سخنران بر روی بهینه سازی استفاده از فضا با تنظیم عناصر فرزند در ویجت نمودار، به ویژه نوار نمودار در یک ردیف تمرکز می کند. با پیاده سازی ویژگی mainAxisAlignment با مقدار فاصله مانند spaceAround، بلندگو دستیابی به یک طرح بصری جذاب تری را نشان می دهد. علاوه بر این، سخنران استفاده از ویجت Flexible را برای محدود کردن رشد عناصر کودک و اطمینان از حفظ اندازه آنها توضیح می دهد. با رسیدگی به سناریوهایی که متن به دلیل فضای محدود سرریز می‌شود، بلندگو ویجت FittedBox را برای مقیاس‌بندی و کوچک کردن متن در فضای موجود معرفی می‌کند و از شکسته شدن خط‌های ناخواسته جلوگیری می‌کند. برای افزایش جذابیت بصری بیشتر، بلندگو با محصور کردن ردیف در ظرفی با مقادیر ویژه، بالشتک را در اطراف میله ها اضافه می کند. سخنران در پایان به سادگی استفاده از ویجت Padding برای افزودن padding بدون نیاز به ظرف اشاره می کند. علاوه بر این، این بلندگو به پیشرفت‌های آینده در موارد لیست دقیق و بررسی گزینه‌های پاسخ‌گویی و استایل برای دستگاه‌های iOS و Android اشاره می‌کند.",
                            },
                        },
                        // 93 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Flexible & Expanded_ Deep Dive",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this detailed instructional guide, the speaker provides insights into optimizing the arrangement of elements within a row using Flutter widgets. By demonstrating a simple playground app setup with different colored containers and varying text lengths, the speaker explains the impact of flexible widgets, fit configurations, and flex values on the layout behavior. The tutorial delves into the functionality of the Flexible widget and the significance of the fit property with configurations like loose and tight. Moreover, the speaker elucidates the interaction of flex values in distributing available space among elements in rows and columns, emphasizing the dynamic adjustment of sizes based on flex and fit settings. The tutorial also touches on the utilization of the Expanded widget as a replacement for Flexible with Flexfit.tight, providing practical insights into fine-tuning layout flexibility in Flutter applications. The speaker encourages hands-on exploration through building demo apps to deepen understanding and proficiency in utilizing widgets for effective design and layout management.",
                                // German
                                "Deutsch": "In dieser ausführlichen Anleitung gibt der Referent Einblicke in die Optimierung der Anordnung von Elementen in einer Zeile mithilfe von Flutter-Widgets. Durch die Demonstration eines einfachen Playground-App-Setups mit verschiedenfarbigen Containern und unterschiedlichen Textlängen erklärt der Referent die Auswirkungen flexibler Widgets, Anpassungskonfigurationen und Flexwerte auf das Layoutverhalten. Das Tutorial befasst sich eingehend mit der Funktionalität des Flexible-Widgets und der Bedeutung der Anpassungseigenschaft bei Konfigurationen wie Loose und Tight. Darüber hinaus erläutert der Referent die Interaktion von Flexwerten bei der Verteilung des verfügbaren Platzes zwischen Elementen in Zeilen und Spalten und betont die dynamische Anpassung der Größen basierend auf Flex- und Fit-Einstellungen. Das Tutorial geht auch auf die Verwendung des Expanded-Widgets als Ersatz für Flexible mit Flexfit.tight ein und bietet praktische Einblicke in die Feinabstimmung der Layoutflexibilität in Flutter-Anwendungen. Der Referent ermutigt zur praktischen Erkundung durch die Erstellung von Demo-Apps, um das Verständnis und die Kompetenz bei der Verwendung von Widgets für effektives Design- und Layoutmanagement zu vertiefen.",
                                // Chinese
                                "中国人": "在本详细指导指南中，演讲者提供了使用 Flutter 小部件优化行内元素排列的见解。通过演示一个具有不同颜色容器和不同文本长度的简单游乐场应用设置，演讲者解释了灵活小部件、适合配置和弹性值对布局行为的影响。本教程深入探讨了灵活小部件的功能以及适合属性在宽松和紧密等配置下的重要性。此外，演讲者阐明了弹性值在行和列中元素之间分配可用空间的相互作用，强调了基于弹性和适合设置的动态调整大小。本教程还涉及使用 Expanded 小部件代替 Flexible 和 Flexfit.tight，为微调 Flutter 应用程序中的布局灵活性提供了实用见解。演讲者鼓励通过构建演示应用进行动手探索，以加深理解和熟练使用小部件进行有效的设计和布局管理。",
                                // Russian
                                "Русский": "В этом подробном руководстве докладчик дает представление об оптимизации расположения элементов в строке с помощью виджетов Flutter. Демонстрируя простую настройку приложения Playground с разноцветными контейнерами и разной длиной текста, докладчик объясняет влияние гибких виджетов, конфигураций подгонки и значений гибкости на поведение макета. В руководстве рассматриваются функциональные возможности виджета Flexible и значение свойства подгонки с такими конфигурациями, как свободная и плотная. Кроме того, докладчик разъясняет взаимодействие значений гибкости при распределении доступного пространства между элементами в строках и столбцах, подчеркивая динамическую корректировку размеров на основе настроек гибкости и подгонки. В руководстве также затрагивается использование виджета Expanded в качестве замены для Flexible с Flexfit.tight, предоставляя практические знания о тонкой настройке гибкости макета в приложениях Flutter. Докладчик поощряет практическое исследование путем создания демонстрационных приложений для углубления понимания и мастерства в использовании виджетов для эффективного управления дизайном и макетом.",
                                // French
                                "Français": "Dans ce guide d'instructions détaillé, l'intervenant fournit des informations sur l'optimisation de la disposition des éléments dans une ligne à l'aide de widgets Flutter. En démontrant une configuration d'application de terrain de jeu simple avec des conteneurs de différentes couleurs et des longueurs de texte variables, l'intervenant explique l'impact des widgets flexibles, des configurations d'ajustement et des valeurs flexibles sur le comportement de la mise en page. Le didacticiel se penche sur la fonctionnalité du widget Flexible et l'importance de la propriété fit avec des configurations telles que loose et tight. De plus, l'intervenant explique l'interaction des valeurs flex dans la répartition de l'espace disponible entre les éléments dans les lignes et les colonnes, en mettant l'accent sur l'ajustement dynamique des tailles en fonction des paramètres flex et fit. Le didacticiel aborde également l'utilisation du widget Expanded en remplacement de Flexible avec Flexfit.tight, fournissant des informations pratiques sur le réglage fin de la flexibilité de la mise en page dans les applications Flutter. L'intervenant encourage l'exploration pratique en créant des applications de démonstration pour approfondir la compréhension et la maîtrise de l'utilisation des widgets pour une conception et une gestion de la mise en page efficaces.",
                                // Japanese
                                "日本語": "この詳細な指導ガイドでは、講演者が Flutter ウィジェットを使用して行内の要素の配置を最適化する方法について説明しています。講演者は、さまざまな色のコンテナーとさまざまなテキスト長を備えたシンプルなプレイグラウンド アプリのセットアップを実演することで、フレキシブル ウィジェット、フィット構成、および flex 値がレイアウト動作に与える影響を説明します。このチュートリアルでは、Flexible ウィジェットの機能と、loose や tight などの構成での fit プロパティの重要性について詳しく説明します。さらに、講演者は、行と列の要素間で使用可能なスペースを分配する際の flex 値の相互作用を明らかにし、flex と fit の設定に基づくサイズの動的な調整を強調します。このチュートリアルでは、Flexfit.tight を使用して Flexible の代わりに Expanded ウィジェットを使用する方法についても触れ、Flutter アプリケーションでレイアウトの柔軟性を微調整するための実用的な情報を提供します。講演者は、効果的な設計とレイアウト管理のためにウィジェットを利用する理解と習熟を深めるために、デモ アプリの構築を通じて実践的な調査を奨励しています。",
                                // Korean
                                "한국인": "이 자세한 교육 가이드에서 발표자는 Flutter 위젯을 사용하여 행 내 요소의 배열을 최적화하는 방법에 대한 통찰력을 제공합니다. 발표자는 다양한 색상의 컨테이너와 다양한 텍스트 길이를 사용하여 간단한 놀이터 앱 설정을 보여줌으로써 유연한 위젯, 맞춤 구성 및 flex 값이 레이아웃 동작에 미치는 영향을 설명합니다. 이 튜토리얼은 유연한 위젯의 기능과 loose 및 tight와 같은 구성에서 fit 속성의 중요성을 깊이 있게 다룹니다. 또한 발표자는 행과 열의 요소 간에 사용 가능한 공간을 분배하는 flex 값의 상호 작용을 설명하며 flex 및 fit 설정에 따라 크기를 동적으로 조정하는 것을 강조합니다. 이 튜토리얼은 또한 Flexfit.tight를 사용하여 Flexible을 대체하는 Expanded 위젯을 활용하여 Flutter 애플리케이션에서 레이아웃 유연성을 미세 조정하는 방법에 대한 실질적인 통찰력을 제공합니다. 발표자는 데모 앱을 구축하여 실습을 통해 탐색하여 효과적인 디자인 및 레이아웃 관리를 위한 위젯 활용에 대한 이해와 능숙성을 심화합니다.",
                                // Spanish
                                "Español": "En esta guía instructiva detallada, el orador brinda información sobre cómo optimizar la disposición de los elementos dentro de una fila mediante widgets de Flutter. Al demostrar una configuración de aplicación de juegos simple con contenedores de diferentes colores y longitudes de texto variables, el orador explica el impacto de los widgets flexibles, las configuraciones de ajuste y los valores de flex en el comportamiento del diseño. El tutorial profundiza en la funcionalidad del widget Flexible y la importancia de la propiedad de ajuste con configuraciones como Loose y Tight. Además, el orador explica la interacción de los valores de flex en la distribución del espacio disponible entre los elementos en filas y columnas, enfatizando el ajuste dinámico de tamaños en función de las configuraciones de flex y fit. El tutorial también aborda el uso del widget Expanded como reemplazo de Flexible con Flexfit.tight, lo que brinda información práctica sobre cómo ajustar la flexibilidad del diseño en las aplicaciones de Flutter. El orador fomenta la exploración práctica mediante la creación de aplicaciones de demostración para profundizar la comprensión y la competencia en el uso de widgets para un diseño y una gestión del diseño efectivos.",
                                // Hindi
                                "हिंदी": "इस विस्तृत निर्देशात्मक मार्गदर्शिका में, वक्ता फ़्लटर विजेट का उपयोग करके पंक्ति के भीतर तत्वों की व्यवस्था को अनुकूलित करने के बारे में जानकारी प्रदान करता है। अलग-अलग रंग के कंटेनर और अलग-अलग टेक्स्ट लंबाई के साथ एक सरल प्लेग्राउंड ऐप सेटअप का प्रदर्शन करके, वक्ता लेआउट व्यवहार पर लचीले विजेट, फिट कॉन्फ़िगरेशन और फ्लेक्स वैल्यू के प्रभाव की व्याख्या करता है। ट्यूटोरियल फ्लेक्सिबल विजेट की कार्यक्षमता और ढीले और तंग जैसे कॉन्फ़िगरेशन के साथ फिट प्रॉपर्टी के महत्व पर गहराई से चर्चा करता है। इसके अलावा, वक्ता पंक्तियों और स्तंभों में तत्वों के बीच उपलब्ध स्थान को वितरित करने में फ्लेक्स वैल्यू की परस्पर क्रिया को स्पष्ट करता है, फ्लेक्स और फिट सेटिंग्स के आधार पर आकारों के गतिशील समायोजन पर जोर देता है। ट्यूटोरियल फ्लेक्सिबल के प्रतिस्थापन के रूप में फ्लेक्सफिट.टाइट के साथ विस्तारित विजेट के उपयोग पर भी चर्चा करता है, जो फ़्लटर अनुप्रयोगों में लेआउट लचीलेपन को ठीक करने में व्यावहारिक जानकारी प्रदान करता है। वक्ता प्रभावी डिज़ाइन और लेआउट प्रबंधन के लिए विजेट का उपयोग करने में समझ और दक्षता को गहरा करने के लिए डेमो ऐप बनाने के माध्यम से व्यावहारिक अन्वेषण को प्रोत्साहित करता है।",
                                // Portuguese
                                "Português": "Neste guia de instruções detalhado, o orador fornece insights sobre como otimizar a organização dos elementos numa linha utilizando widgets Flutter. Ao demonstrar uma configuração simples de aplicação de recreio com contentores de cores diferentes e comprimentos de texto variados, o orador explica o impacto dos widgets flexíveis, das definições de ajuste e dos valores flexíveis no comportamento do layout. O tutorial investiga a funcionalidade do widget Flexível e o significado da propriedade fit com definições como solto e apertado. Além disso, o orador elucida a interação dos valores flexíveis na distribuição do espaço disponível entre os elementos em linhas e colunas, enfatizando o ajuste dinâmico de tamanhos com base nas configurações flexíveis e de ajuste. O tutorial aborda também a utilização do widget Expandido como substituto do Flexível com Flexfit. tight, fornecendo informações práticas sobre o ajuste fino da flexibilidade de layout nas aplicações Flutter. O orador incentiva a exploração prática através da criação de aplicações de demonstração para aprofundar a compreensão e a proficiência na utilização de widgets para uma gestão eficaz do design e do layout.",
                                // Bengali
                                "বাংলা": "এই বিস্তারিত নির্দেশনামূলক গাইডে, স্পিকার ফ্লটার উইজেট ব্যবহার করে একটি সারির মধ্যে উপাদানগুলির বিন্যাসকে অপ্টিমাইজ করার জন্য অন্তর্দৃষ্টি প্রদান করে। বিভিন্ন রঙের পাত্রে এবং বিভিন্ন পাঠ্য দৈর্ঘ্য সহ একটি সাধারণ খেলার মাঠ অ্যাপ সেটআপ প্রদর্শন করে, স্পিকার বিন্যাস আচরণে নমনীয় উইজেট, ফিট কনফিগারেশন এবং ফ্লেক্স মানগুলির প্রভাব ব্যাখ্যা করে। টিউটোরিয়ালটি নমনীয় উইজেটের কার্যকারিতা এবং আলগা এবং আঁট মত কনফিগারেশন সহ ফিট বৈশিষ্ট্যের তাত্পর্যের মধ্যে পড়ে। তাছাড়া, স্পিকার ফ্লেক্স এবং ফিট সেটিংসের উপর ভিত্তি করে আকারের গতিশীল সামঞ্জস্যের উপর জোর দিয়ে সারি এবং কলামের উপাদানগুলির মধ্যে উপলব্ধ স্থান বিতরণে ফ্লেক্স মানগুলির মিথস্ক্রিয়া ব্যাখ্যা করে। টিউটোরিয়ালটি Flexfit.tight এর সাথে ফ্লেক্সিবলের প্রতিস্থাপন হিসাবে প্রসারিত উইজেটের ব্যবহারকেও স্পর্শ করে, যা ফ্লাটার অ্যাপ্লিকেশনগুলিতে সূক্ষ্ম-টিউনিং লেআউট নমনীয়তার বাস্তব অন্তর্দৃষ্টি প্রদান করে। স্পিকার কার্যকর ডিজাইন এবং লেআউট পরিচালনার জন্য উইজেট ব্যবহারে বোঝাপড়া এবং দক্ষতাকে আরও গভীর করতে ডেমো অ্যাপ তৈরির মাধ্যমে হ্যান্ডস-অন এক্সপ্লোরেশনকে উৎসাহিত করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الدليل الإرشادي المفصل، يقدم المتحدث رؤى حول تحسين ترتيب العناصر داخل صف باستخدام عناصر واجهة المستخدم الرسومية Flutter. من خلال عرض إعداد تطبيق ملعب بسيط مع حاويات ملونة مختلفة وأطوال نصية متفاوتة، يشرح المتحدث تأثير عناصر واجهة المستخدم الرسومية المرنة وتكوينات الملاءمة وقيم المرونة على سلوك التخطيط. يتعمق البرنامج التعليمي في وظائف عنصر واجهة المستخدم الرسومية المرنة وأهمية خاصية الملاءمة مع تكوينات مثل فضفاض ومحكم. علاوة على ذلك، يوضح المتحدث تفاعل قيم المرونة في توزيع المساحة المتاحة بين العناصر في الصفوف والأعمدة، مع التأكيد على التعديل الديناميكي للأحجام بناءً على إعدادات المرونة والملاءمة. يتطرق البرنامج التعليمي أيضًا إلى استخدام عنصر واجهة المستخدم الرسومية الموسع كبديل لعنصر واجهة المستخدم الرسومية المرنة مع Flexfit.tight، مما يوفر رؤى عملية حول ضبط مرونة التخطيط في تطبيقات Flutter. يشجع المتحدث الاستكشاف العملي من خلال بناء تطبيقات تجريبية لتعميق الفهم والكفاءة في استخدام عناصر واجهة المستخدم الرسومية لإدارة التصميم والتخطيط بشكل فعال.",
                                // Persian
                                "فارسی": "در این راهنمای آموزشی دقیق، سخنران بینش هایی را درباره بهینه سازی چیدمان عناصر در یک ردیف با استفاده از ویجت های Flutter ارائه می دهد. با نمایش یک راه‌اندازی ساده برنامه زمین بازی با ظروف رنگ‌های مختلف و طول متن‌های متفاوت، بلندگو تأثیر ویجت‌های انعطاف‌پذیر، پیکربندی‌های مناسب و مقادیر انعطاف‌پذیر را بر رفتار طرح‌بندی توضیح می‌دهد. این آموزش به عملکرد ویجت Flexible و اهمیت ویژگی fit با پیکربندی هایی مانند شل و تنگ می پردازد. علاوه بر این، بلندگو تعامل مقادیر انعطاف‌پذیر را در توزیع فضای موجود بین عناصر در ردیف‌ها و ستون‌ها روشن می‌کند و بر تنظیم دینامیکی اندازه‌ها بر اساس تنظیمات انعطاف‌پذیری و تناسب تأکید می‌کند. این آموزش همچنین به استفاده از ویجت Expanded به عنوان جایگزینی برای Flexible با Flexfit.tight می‌پردازد و بینش‌های عملی را در مورد تنظیم دقیق انعطاف‌پذیری چیدمان در برنامه‌های Flutter ارائه می‌دهد. این سخنران کاوش عملی را از طریق ساخت برنامه‌های نمایشی تشویق می‌کند تا درک و مهارت در استفاده از ویجت‌ها برای مدیریت طراحی و چیدمان مؤثر را افزایش دهد.",
                            },
                        },
                        // 94 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Adding a ListTile Widget",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker introduces an alternative to using custom list items in Flutter by utilizing the built-in ListTile widget. The video demonstrates how to set up leading, title, subtitle, and trailing elements within the ListTile, as well as how to style and format the elements. Additionally, the speaker shows how to wrap the elements in a Card widget to add spacing and elevation, resulting in a visually appealing list of transactions. The video ends by mentioning the importance of adjusting the app layout for different device sizes and operating systems.",
                                // German
                                "Deutsch": "In diesem Video stellt der Sprecher eine Alternative zur Verwendung benutzerdefinierter Listenelemente in Flutter vor, indem das integrierte ListTile-Widget verwendet wird. Das Video zeigt, wie Sie führende, Titel-, Untertitel- und nachfolgende Elemente innerhalb des ListTile einrichten und wie Sie die Elemente gestalten und formatieren. Darüber hinaus zeigt der Sprecher, wie Sie die Elemente in ein Karten-Widget einbinden, um Abstand und Höhe hinzuzufügen, wodurch eine optisch ansprechende Liste von Transaktionen entsteht. Das Video endet mit der Erwähnung, wie wichtig es ist, das App-Layout an unterschiedliche Gerätegrößen und Betriebssysteme anzupassen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者介绍了一种在 Flutter 中使用自定义列表项的替代方法，即利用内置的 ListTile 小部件。视频演示了如何在 ListTile 中设置前导、标题、副标题和尾随元素，以及如何设置元素的样式和格式。此外，演讲者还展示了如何将元素包装在 Card 小部件中以添加间距和高度，从而生成具有视觉吸引力的交易列表。视频最后提到了根据不同的设备尺寸和操作系统调整应用布局的重要性。",
                                // Russian
                                "Русский": "В этом видео докладчик представляет альтернативу использованию пользовательских элементов списка во Flutter с использованием встроенного виджета ListTile. Видео демонстрирует, как настроить начальные, заголовочные, подзаголовочные и конечные элементы в ListTile, а также как стилизовать и форматировать элементы. Кроме того, докладчик показывает, как обернуть элементы в виджет Card, чтобы добавить интервалы и высоту, что приведет к визуально привлекательному списку транзакций. Видео заканчивается упоминанием важности настройки макета приложения для разных размеров устройств и операционных систем.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant présente une alternative à l'utilisation d'éléments de liste personnalisés dans Flutter en utilisant le widget ListTile intégré. La vidéo montre comment configurer les éléments de début, de titre, de sous-titre et de fin dans ListTile, ainsi que comment styliser et formater les éléments. De plus, l'intervenant montre comment encapsuler les éléments dans un widget Card pour ajouter de l'espacement et de l'élévation, ce qui donne une liste de transactions visuellement attrayante. La vidéo se termine en mentionnant l'importance d'ajuster la mise en page de l'application pour différentes tailles d'appareils et systèmes d'exploitation.",
                                // Japanese
                                "日本語": "このビデオでは、スピーカーが、組み込みの ListTile ウィジェットを利用して、Flutter でカスタム リスト項目を使用する代替手段を紹介します。ビデオでは、ListTile 内で先頭、タイトル、サブタイトル、末尾の要素を設定する方法と、要素のスタイルと書式を設定する方法を説明します。さらに、スピーカーは、カード ウィジェットで要素をラップして間隔と高さを追加し、視覚的に魅力的な取引リストを作成する方法を示します。ビデオの最後に、さまざまなデバイス サイズとオペレーティング システムに合わせてアプリのレイアウトを調整することの重要性について説明します。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 내장된 ListTile 위젯을 활용하여 Flutter에서 사용자 지정 목록 항목을 사용하는 대안을 소개합니다. 이 영상은 ListTile 내에서 선행, 제목, 부제 및 후행 요소를 설정하는 방법과 요소의 스타일을 지정하고 서식을 지정하는 방법을 보여줍니다. 또한 발표자는 Card 위젯에 요소를 래핑하여 간격과 높이를 추가하여 시각적으로 매력적인 거래 목록을 만드는 방법을 보여줍니다. 이 영상은 다양한 기기 크기와 운영 체제에 맞게 앱 레이아웃을 조정하는 것의 중요성을 언급하면서 끝납니다.",
                                // Spanish
                                "Español": "En este video, el orador presenta una alternativa al uso de elementos de lista personalizados en Flutter mediante el uso del widget ListTile integrado. El video demuestra cómo configurar elementos iniciales, de título, de subtítulo y finales dentro de ListTile, así como también cómo aplicar estilo y formato a los elementos. Además, el orador muestra cómo envolver los elementos en un widget Card para agregar espaciado y elevación, lo que da como resultado una lista de transacciones visualmente atractiva. El video finaliza mencionando la importancia de ajustar el diseño de la aplicación para diferentes tamaños de dispositivos y sistemas operativos.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता अंतर्निहित ListTile विजेट का उपयोग करके फ़्लटर में कस्टम सूची आइटम का उपयोग करने के विकल्प का परिचय देता है। वीडियो दर्शाता है कि ListTile के भीतर अग्रणी, शीर्षक, उपशीर्षक और अनुगामी तत्वों को कैसे सेट किया जाए, साथ ही तत्वों को कैसे स्टाइल और फ़ॉर्मेट किया जाए। इसके अतिरिक्त, वक्ता दिखाता है कि कार्ड विजेट में तत्वों को कैसे लपेटा जाए ताकि स्पेसिंग और एलिवेशन जोड़ा जा सके, जिसके परिणामस्वरूप लेन-देन की एक आकर्षक सूची बन सके। वीडियो विभिन्न डिवाइस आकारों और ऑपरेटिंग सिस्टम के लिए ऐप लेआउट को समायोजित करने के महत्व का उल्लेख करके समाप्त होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador apresenta uma alternativa à utilização de itens de lista personalizados no Flutter, utilizando o widget ListTile integrado. O vídeo demonstra como configurar elementos iniciais, títulos, subtítulos e finais no ListTile, bem como estilizar e formatar os elementos. Além disso, o orador mostra como agrupar os elementos num widget de cartão para adicionar espaçamento e elevação, resultando numa lista de transações visualmente apelativa. O vídeo termina mencionando a importância de ajustar o layout da aplicação para diferentes tamanhos de dispositivos e sistemas operativos.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, বিল্ট-ইন লিস্টটাইল উইজেট ব্যবহার করে স্পিকার ফ্লটারে কাস্টম তালিকা আইটেমগুলি ব্যবহার করার একটি বিকল্প উপস্থাপন করেছে। লিস্টটাইলের মধ্যে লিডিং, শিরোনাম, সাবটাইটেল এবং ট্রেইলিং উপাদানগুলি কীভাবে সেট আপ করতে হয়, সেইসাথে উপাদানগুলিকে কীভাবে স্টাইল এবং ফর্ম্যাট করতে হয় তা ভিডিওটি প্রদর্শন করে৷ অতিরিক্তভাবে, স্পিকার দেখায় যে কীভাবে একটি কার্ড উইজেটে উপাদানগুলিকে ব্যবধান এবং উচ্চতা যুক্ত করতে হয়, যার ফলে লেনদেনের একটি দৃশ্যত আকর্ষণীয় তালিকা তৈরি হয়। বিভিন্ন ডিভাইসের আকার এবং অপারেটিং সিস্টেমের জন্য অ্যাপ লেআউট সামঞ্জস্য করার গুরুত্ব উল্লেখ করে ভিডিওটি শেষ হয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يقدم المتحدث بديلاً لاستخدام عناصر القائمة المخصصة في Flutter من خلال الاستفادة من عنصر واجهة المستخدم المضمن ListTile. يوضح الفيديو كيفية إعداد العناصر البادئة والعنوان والعنوان الفرعي واللاحقة داخل ListTile، بالإضافة إلى كيفية تصميم العناصر وتنسيقها. بالإضافة إلى ذلك، يوضح المتحدث كيفية لف العناصر في عنصر واجهة مستخدم Card لإضافة المسافات والارتفاع، مما يؤدي إلى قائمة جذابة بصريًا من المعاملات. وينتهي الفيديو بالإشارة إلى أهمية تعديل تخطيط التطبيق لأحجام الأجهزة وأنظمة التشغيل المختلفة.",
                                // Persian
                                "فارسی": "در این ویدئو، بلندگو با استفاده از ویجت ListTile داخلی، جایگزینی برای استفاده از آیتم های لیست سفارشی در Flutter معرفی می کند. این ویدیو نحوه تنظیم عناصر اصلی، عنوان، زیرنویس، و عناصر انتهایی را در ListTile و همچنین نحوه استایل و قالب بندی عناصر را نشان می دهد. علاوه بر این، بلندگو نشان می دهد که چگونه عناصر را در یک ویجت کارت قرار دهید تا فاصله و ارتفاع را اضافه کنید و در نتیجه فهرستی از تراکنش ها از نظر بصری جذاب ایجاد شود. این ویدئو با ذکر اهمیت تنظیم طرح برنامه برای اندازه های مختلف دستگاه و سیستم عامل به پایان می رسد.",
                            },
                        },
                        // 95 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Improving the Overall Chart",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video shows improvements made to a Flutter application's transaction chart, addressing issues with alignment of bars and text. The speaker demonstrates how to fix the alignment by adjusting the height of the text within a container, resulting in a more visually appealing and cohesive layout. Additionally, the video discusses how to change the order of days displayed on the chart by reversing the list of weekdays. These adjustments enhance the overall appearance and functionality of the transaction chart, providing a more polished and organized display for users.",
                                // German
                                "Deutsch": "Das Video zeigt Verbesserungen am Transaktionsdiagramm einer Flutter-Anwendung, die Probleme mit der Ausrichtung von Balken und Text beheben. Der Sprecher demonstriert, wie die Ausrichtung durch Anpassen der Texthöhe innerhalb eines Containers korrigiert werden kann, was zu einem optisch ansprechenderen und einheitlicheren Layout führt. Darüber hinaus wird im Video erläutert, wie die Reihenfolge der im Diagramm angezeigten Tage geändert werden kann, indem die Liste der Wochentage umgekehrt wird. Diese Anpassungen verbessern das allgemeine Erscheinungsbild und die Funktionalität des Transaktionsdiagramms und bieten Benutzern eine elegantere und übersichtlichere Anzeige.",
                                // Chinese
                                "中国人": "视频展示了对 Flutter 应用程序交易图表所做的改进，解决了条形图和文本对齐问题。演讲者演示了如何通过调整容器内文本的高度来修复对齐问题，从而实现更具视觉吸引力和凝聚力的布局。此外，视频还讨论了如何通过反转工作日列表来更改图表上显示的日期顺序。这些调整增强了交易图表的整体外观和功能，为用户提供了更精致、更有序的显示。",
                                // Russian
                                "Русский": "Видео демонстрирует улучшения, внесенные в диаграмму транзакций приложения Flutter, решая проблемы с выравниванием полос и текста. Докладчик демонстрирует, как исправить выравнивание, отрегулировав высоту текста в контейнере, что приведет к более визуально привлекательному и связному макету. Кроме того, в видео обсуждается, как изменить порядок дней, отображаемых на диаграмме, перевернув список дней недели. Эти корректировки улучшают общий вид и функциональность диаграммы транзакций, предоставляя пользователям более отточенное и организованное отображение.",
                                // French
                                "Français": "La vidéo montre les améliorations apportées au graphique des transactions d'une application Flutter, en abordant les problèmes d'alignement des barres et du texte. L'intervenant montre comment corriger l'alignement en ajustant la hauteur du texte dans un conteneur, ce qui permet d'obtenir une mise en page visuellement plus attrayante et plus cohérente. En outre, la vidéo explique comment modifier l'ordre des jours affichés sur le graphique en inversant la liste des jours de la semaine. Ces ajustements améliorent l'apparence générale et la fonctionnalité du graphique des transactions, offrant un affichage plus soigné et mieux organisé aux utilisateurs.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter アプリケーションのトランザクション チャートに加えられた改善点について紹介し、バーとテキストの配置に関する問題に対処しています。講演者は、コンテナー内のテキストの高さを調整して配置を修正し、より視覚的に魅力的でまとまりのあるレイアウトにする方法を実演しています。さらに、このビデオでは、曜日のリストを逆にしてチャートに表示される日付の順序を変更する方法についても説明しています。これらの調整により、トランザクション チャートの全体的な外観と機能が強化され、ユーザーにとってより洗練された整理された表示が提供されます。",
                                // Korean
                                "한국인": "이 비디오는 Flutter 애플리케이션의 거래 차트에 대한 개선 사항을 보여주며, 막대와 텍스트 정렬 문제를 해결합니다. 발표자는 컨테이너 내에서 텍스트 높이를 조정하여 정렬을 수정하는 방법을 보여주며, 그 결과 시각적으로 매력적이고 응집력 있는 레이아웃이 만들어집니다. 또한 이 비디오는 주중 목록을 반전하여 차트에 표시되는 요일 순서를 변경하는 방법을 설명합니다. 이러한 조정은 거래 차트의 전반적인 모양과 기능을 향상시켜 사용자에게 보다 세련되고 체계적인 디스플레이를 제공합니다.",
                                // Spanish
                                "Español": "El video muestra mejoras realizadas en el gráfico de transacciones de una aplicación Flutter, que solucionan problemas con la alineación de las barras y el texto. El orador demuestra cómo solucionar la alineación ajustando la altura del texto dentro de un contenedor, lo que da como resultado un diseño más atractivo y coherente a la vista. Además, el video analiza cómo cambiar el orden de los días que se muestran en el gráfico invirtiendo la lista de días de la semana. Estos ajustes mejoran la apariencia general y la funcionalidad del gráfico de transacciones, lo que proporciona una visualización más pulida y organizada para los usuarios.",
                                // Hindi
                                "हिंदी": "वीडियो में फ़्लटर एप्लिकेशन के ट्रांज़ैक्शन चार्ट में किए गए सुधार दिखाए गए हैं, जिसमें बार और टेक्स्ट के संरेखण से जुड़ी समस्याओं को संबोधित किया गया है। वक्ता यह दर्शाता है कि कंटेनर के भीतर टेक्स्ट की ऊंचाई को समायोजित करके संरेखण को कैसे ठीक किया जाए, जिसके परिणामस्वरूप अधिक आकर्षक और सुसंगत लेआउट प्राप्त होता है। इसके अतिरिक्त, वीडियो में चर्चा की गई है कि सप्ताह के दिनों की सूची को उलट कर चार्ट पर प्रदर्शित दिनों के क्रम को कैसे बदला जाए। ये समायोजन ट्रांज़ैक्शन चार्ट के समग्र स्वरूप और कार्यक्षमता को बढ़ाते हैं, जिससे उपयोगकर्ताओं के लिए अधिक पॉलिश और व्यवस्थित डिस्प्ले मिलता है।",
                                // Portuguese
                                "Português": "O vídeo mostra melhorias feitas no gráfico de transações de uma aplicação Flutter, abordando problemas de alinhamento de barras e texto. O orador demonstra como corrigir o alinhamento ajustando a altura do texto dentro de um contentor, resultando num layout visualmente mais apelativo e coeso. Além disso, o vídeo discute como alterar a ordem dos dias apresentados no gráfico invertendo a lista de dias da semana. Estes ajustes melhoram a aparência geral e a funcionalidade do gráfico de transações, proporcionando uma visualização mais refinada e organizada para os utilizadores.",
                                // Bengali
                                "বাংলা": "ভিডিওটি একটি ফ্লাটার অ্যাপ্লিকেশনের লেনদেন চার্টে করা উন্নতি দেখায়, বার এবং পাঠ্যের প্রান্তিককরণের সাথে সমস্যাগুলি সমাধান করে৷ স্পিকার প্রদর্শন করে যে কীভাবে একটি পাত্রের মধ্যে পাঠ্যের উচ্চতা সামঞ্জস্য করে সারিবদ্ধকরণটি ঠিক করা যায়, যার ফলে আরও দৃশ্যমানভাবে আকর্ষণীয় এবং সমন্বিত বিন্যাস হয়। উপরন্তু, ভিডিওটি আলোচনা করে কিভাবে সপ্তাহের দিনের তালিকা উল্টে চার্টে প্রদর্শিত দিনের ক্রম পরিবর্তন করতে হয়। এই সমন্বয়গুলি লেনদেন চার্টের সামগ্রিক উপস্থিতি এবং কার্যকারিতা বাড়ায়, ব্যবহারকারীদের জন্য আরও পালিশ এবং সংগঠিত প্রদর্শন প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "يُظهر الفيديو التحسينات التي تم إجراؤها على مخطط المعاملات في تطبيق Flutter، ومعالجة المشكلات المتعلقة بمحاذاة الأشرطة والنص. يوضح المتحدث كيفية إصلاح المحاذاة عن طريق ضبط ارتفاع النص داخل الحاوية، مما يؤدي إلى تصميم أكثر جاذبية بصريًا وتماسكًا. بالإضافة إلى ذلك، يناقش الفيديو كيفية تغيير ترتيب الأيام المعروضة على المخطط عن طريق عكس قائمة أيام الأسبوع. تعمل هذه التعديلات على تحسين المظهر العام ووظائف مخطط المعاملات، مما يوفر عرضًا أكثر أناقة وتنظيمًا للمستخدمين.",
                                // Persian
                                "فارسی": "این ویدیو بهبودهایی را نشان می دهد که در نمودار تراکنش یک برنامه Flutter انجام شده است و مشکلات مربوط به تراز کردن میله ها و متن را برطرف می کند. بلندگو نشان می دهد که چگونه می توان با تنظیم ارتفاع متن در یک ظرف، تراز را اصلاح کرد، که منجر به یک چیدمان بصری جذاب تر و منسجم می شود. علاوه بر این، این ویدئو نحوه تغییر ترتیب روزهای نمایش داده شده در نمودار را با معکوس کردن لیست روزهای هفته مورد بحث قرار می دهد. این تنظیمات ظاهر و عملکرد کلی نمودار تراکنش ها را بهبود می بخشد و نمایشگری منظم تر و منظم تر را برای کاربران فراهم می کند.",
                            },
                        },
                        // 96 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Widgets & Configuring Widgets - Summary _ Overview",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video provides a summary of the various widgets covered in previous lectures in a Flutter application, emphasizing the abundance of available widgets and the flexibility they offer for building layouts. The speaker discusses how different widgets can achieve similar effects and compares using Padding with Container as an example. They also mention the option to customize a CircleAvatar by manually creating a circle-shaped container. The video encourages viewers to explore and experiment with different widgets, utilize official documentation and widget catalog, and learn through hands-on experience to become proficient Flutter developers. The speaker emphasizes that discovering new widgets and values is a natural part of the learning process and can lead to improved development skills and efficiency.",
                                // German
                                "Deutsch": "Das Video bietet eine Zusammenfassung der verschiedenen Widgets, die in früheren Vorlesungen in einer Flutter-Anwendung behandelt wurden, und betont die Fülle der verfügbaren Widgets und die Flexibilität, die sie zum Erstellen von Layouts bieten. Der Sprecher erörtert, wie verschiedene Widgets ähnliche Effekte erzielen können, und vergleicht sie am Beispiel von Padding mit Container. Er erwähnt auch die Möglichkeit, einen CircleAvatar anzupassen, indem manuell ein kreisförmiger Container erstellt wird. Das Video ermutigt die Zuschauer, verschiedene Widgets zu erkunden und mit ihnen zu experimentieren, offizielle Dokumentation und Widget-Katalog zu verwenden und durch praktische Erfahrung zu lernen, um kompetente Flutter-Entwickler zu werden. Der Sprecher betont, dass das Entdecken neuer Widgets und Werte ein natürlicher Teil des Lernprozesses ist und zu verbesserten Entwicklungsfähigkeiten und -effizienz führen kann.",
                                // Chinese
                                "中国人": "视频总结了之前课程中介绍的 Flutter 应用程序中的各种小部件，强调了可用小部件的丰富性以及它们为构建布局提供的灵活性。演讲者讨论了不同的小部件如何实现类似的效果，并使用 Padding 和 Container 作为示例进行了比较。他们还提到了通过手动创建圆形容器来自定义 CircleAvatar 的选项。视频鼓励观众探索和尝试不同的小部件，利用官方文档和小部件目录，并通过实践经验学习成为熟练的 Flutter 开发人员。演讲者强调，发现新的小部件和价值是学习过程的自然组成部分，可以提高开发技能和效率。",
                                // Russian
                                "Русский": "Видео содержит сводку различных виджетов, рассмотренных в предыдущих лекциях в приложении Flutter, подчеркивая обилие доступных виджетов и гибкость, которую они предлагают для построения макетов. Докладчик обсуждает, как различные виджеты могут достигать схожих эффектов, и сравнивает использование Padding с Container в качестве примера. Они также упоминают возможность настройки CircleAvatar путем ручного создания контейнера в форме круга. Видео призывает зрителей исследовать и экспериментировать с различными виджетами, использовать официальную документацию и каталог виджетов, а также учиться на практическом опыте, чтобы стать опытными разработчиками Flutter. Докладчик подчеркивает, что открытие новых виджетов и значений является естественной частью процесса обучения и может привести к улучшению навыков разработки и эффективности.",
                                // French
                                "Français": "La vidéo fournit un résumé des différents widgets abordés dans les conférences précédentes dans une application Flutter, en soulignant l'abondance des widgets disponibles et la flexibilité qu'ils offrent pour la création de mises en page. L'intervenant explique comment différents widgets peuvent obtenir des effets similaires et compare l'utilisation de Padding avec Container comme exemple. Il mentionne également la possibilité de personnaliser un CircleAvatar en créant manuellement un conteneur en forme de cercle. La vidéo encourage les spectateurs à explorer et à expérimenter différents widgets, à utiliser la documentation officielle et le catalogue de widgets, et à apprendre par l'expérience pratique pour devenir des développeurs Flutter compétents. L'intervenant souligne que la découverte de nouveaux widgets et de nouvelles valeurs fait naturellement partie du processus d'apprentissage et peut conduire à des compétences et une efficacité de développement améliorées.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter アプリケーションの以前の講義で取り上げたさまざまなウィジェットの概要を示し、利用可能なウィジェットの豊富さとレイアウト構築の柔軟性を強調しています。講演者は、さまざまなウィジェットで同様の効果を実現する方法について説明し、例としてパディングとコンテナーを使用して比較します。また、手動で円形のコンテナーを作成して CircleAvatar をカスタマイズするオプションについても説明します。このビデオでは、視聴者がさまざまなウィジェットを調べて実験し、公式ドキュメントとウィジェット カタログを活用し、実践的な経験を通じて学習して熟練した Flutter 開発者になることを奨励しています。講演者は、新しいウィジェットと値を発見することは学習プロセスの自然な一部であり、開発スキルと効率の向上につながることを強調しています。",
                                // Korean
                                "한국인": "이 영상은 Flutter 애플리케이션에서 이전 강의에서 다룬 다양한 위젯을 요약하여 제공하며, 사용 가능한 위젯의 풍부함과 레이아웃을 구축하는 데 제공하는 유연성을 강조합니다. 발표자는 서로 다른 위젯이 어떻게 유사한 효과를 얻을 수 있는지 논의하고 Padding with Container를 예로 들어 비교합니다. 또한 원형 모양의 컨테이너를 수동으로 만들어 CircleAvatar를 사용자 지정하는 옵션도 언급합니다. 이 영상은 시청자가 다양한 위젯을 탐색하고 실험하고, 공식 문서와 위젯 카탈로그를 활용하고, 실무 경험을 통해 학습하여 능숙한 Flutter 개발자가 되도록 장려합니다. 발표자는 새로운 위젯과 값을 발견하는 것이 학습 과정의 자연스러운 부분이며, 개발 기술과 효율성을 향상시킬 수 있다고 강조합니다.",
                                // Spanish
                                "Español": "El video ofrece un resumen de los distintos widgets que se han tratado en las lecciones anteriores en una aplicación Flutter, y destaca la abundancia de widgets disponibles y la flexibilidad que ofrecen para crear diseños. El orador analiza cómo los distintos widgets pueden lograr efectos similares y compara el uso de Padding con Container como ejemplo. También menciona la opción de personalizar un CircleAvatar creando manualmente un contenedor con forma de círculo. El video anima a los espectadores a explorar y experimentar con diferentes widgets, utilizar la documentación oficial y el catálogo de widgets, y aprender a través de la experiencia práctica para convertirse en desarrolladores competentes de Flutter. El orador enfatiza que descubrir nuevos widgets y valores es una parte natural del proceso de aprendizaje y puede conducir a una mejora de las habilidades y la eficiencia del desarrollo.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर एप्लिकेशन में पिछले व्याख्यानों में शामिल किए गए विभिन्न विजेट्स का सारांश प्रदान करता है, जो उपलब्ध विजेट्स की प्रचुरता और लेआउट बनाने के लिए उनके द्वारा प्रदान की जाने वाली लचीलेपन पर जोर देता है। वक्ता चर्चा करता है कि विभिन्न विजेट कैसे समान प्रभाव प्राप्त कर सकते हैं और उदाहरण के रूप में कंटेनर के साथ पैडिंग का उपयोग करके तुलना करते हैं। वे मैन्युअल रूप से एक वृत्त के आकार का कंटेनर बनाकर CircleAvatar को अनुकूलित करने के विकल्प का भी उल्लेख करते हैं। वीडियो दर्शकों को विभिन्न विजेट्स का पता लगाने और उनके साथ प्रयोग करने, आधिकारिक दस्तावेज़ीकरण और विजेट कैटलॉग का उपयोग करने और कुशल फ़्लटर डेवलपर्स बनने के लिए व्यावहारिक अनुभव के माध्यम से सीखने के लिए प्रोत्साहित करता है। वक्ता इस बात पर जोर देता है कि नए विजेट्स और मूल्यों की खोज करना सीखने की प्रक्रिया का एक स्वाभाविक हिस्सा है और इससे विकास कौशल और दक्षता में सुधार हो सकता है।",
                                // Portuguese
                                "Português": "O vídeo fornece um resumo dos diversos widgets abordados em palestras anteriores numa aplicação Flutter, enfatizando a abundância de widgets disponíveis e a flexibilidade que oferecem para a construção de layouts. O orador discute como diferentes widgets podem obter efeitos semelhantes e compara a utilização de Padding com Container como exemplo. Também mencionam a opção de personalizar um CircleAvatar criando manualmente um contentor em forma de círculo. O vídeo incentiva os espectadores a explorar e experimentar diferentes widgets, a utilizar a documentação oficial e o catálogo de widgets e a aprender através da experiência prática para se tornarem proficientes programadores Flutter. O orador sublinha que descobrir novos widgets e valores é uma parte natural do processo de aprendizagem e pode levar a um melhor desenvolvimento de competências e eficiência.",
                                // Bengali
                                "বাংলা": "ভিডিওটি একটি ফ্লটার অ্যাপ্লিকেশনে পূর্ববর্তী লেকচারে কভার করা বিভিন্ন উইজেটগুলির একটি সারাংশ প্রদান করে, উপলব্ধ উইজেটের প্রাচুর্য এবং লেআউট তৈরির জন্য তারা যে নমনীয়তার প্রস্তাব দেয় তার উপর জোর দেয়। স্পিকার আলোচনা করে যে কীভাবে বিভিন্ন উইজেট একই রকম প্রভাব অর্জন করতে পারে এবং উদাহরণ হিসেবে প্যাডিং-এর সাথে কন্টেইনার ব্যবহার করে তুলনা করে। তারা ম্যানুয়ালি একটি বৃত্ত-আকৃতির ধারক তৈরি করে একটি CircleAvatar কাস্টমাইজ করার বিকল্পটিও উল্লেখ করে। ভিডিওটি দর্শকদের বিভিন্ন উইজেটগুলি অন্বেষণ করতে এবং পরীক্ষা করতে, অফিসিয়াল ডকুমেন্টেশন এবং উইজেট ক্যাটালগ ব্যবহার করতে এবং দক্ষ ফ্লাটার বিকাশকারী হওয়ার জন্য হ্যান্ডস-অন অভিজ্ঞতার মাধ্যমে শিখতে উত্সাহিত করে৷ স্পিকার জোর দেন যে নতুন উইজেট এবং মান আবিষ্কার করা শেখার প্রক্রিয়ার একটি স্বাভাবিক অংশ এবং এটি উন্নত বিকাশ দক্ষতা এবং দক্ষতার দিকে নিয়ে যেতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "يقدم الفيديو ملخصًا للأدوات المختلفة التي تم تناولها في المحاضرات السابقة في تطبيق Flutter، مع التركيز على وفرة الأدوات المتاحة والمرونة التي توفرها لبناء التخطيطات. يناقش المتحدث كيف يمكن للأدوات المختلفة تحقيق تأثيرات مماثلة ويقارن استخدام Padding مع Container كمثال. كما يذكرون خيار تخصيص CircleAvatar عن طريق إنشاء حاوية على شكل دائرة يدويًا. يشجع الفيديو المشاهدين على استكشاف وتجربة أدوات مختلفة، والاستفادة من الوثائق الرسمية وكتالوج الأدوات، والتعلم من خلال الخبرة العملية ليصبحوا مطورين مهرة في Flutter. يؤكد المتحدث أن اكتشاف أدوات وقيم جديدة هو جزء طبيعي من عملية التعلم ويمكن أن يؤدي إلى تحسين مهارات التطوير والكفاءة.",
                                // Persian
                                "فارسی": "این ویدئو خلاصه ای از ویجت های مختلف پوشش داده شده در سخنرانی های قبلی در یک برنامه فلاتر را ارائه می دهد و بر فراوانی ویجت های موجود و انعطاف پذیری آنها برای طرح بندی ساختمان ها تاکید می کند. سخنران درباره اینکه چگونه ویجت‌های مختلف می‌توانند جلوه‌های مشابهی به دست آورند بحث می‌کند و با استفاده از Padding with Container به عنوان مثال مقایسه می‌کند. آنها همچنین به گزینه ای برای سفارشی کردن CircleAvatar با ایجاد دستی یک ظرف دایره ای شکل اشاره می کنند. این ویدیو بینندگان را تشویق می‌کند تا ویجت‌های مختلف را کاوش و آزمایش کنند، از اسناد رسمی و کاتالوگ ویجت‌ها استفاده کنند و از طریق تجربه عملی یاد بگیرند تا به توسعه‌دهندگان حرفه‌ای Flutter تبدیل شوند. سخنران تاکید می کند که کشف ویجت ها و ارزش های جدید بخشی طبیعی از فرآیند یادگیری است و می تواند منجر به بهبود مهارت ها و کارایی توسعه شود.",
                            },
                        },
                        // 97 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Getting Started with Date Selection",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker addresses missing components in a Flutter application, specifically the lack of a date picker. They demonstrate how to add a new row below existing text fields containing a disabled text field displaying the chosen date and a FlatButton to open the date picker widget. The speaker adjusts the styling of the button and text field to enhance the appearance, including changing the button to a RaisedButton with a purple background and white text color. They showcase how to utilize the theme and set up a text style for the button within the main.dart file for consistent styling across the application. The video highlights the importance of utilizing the theme for color consistency and demonstrates how to override default button colors effectively.",
                                // German
                                "Deutsch": "In diesem Video spricht der Sprecher fehlende Komponenten in einer Flutter-Anwendung an, insbesondere das Fehlen eines Datumswählers. Er zeigt, wie man unter vorhandenen Textfeldern eine neue Zeile hinzufügt, die ein deaktiviertes Textfeld mit dem ausgewählten Datum und einen FlatButton zum Öffnen des Datumswähler-Widgets enthält. Der Sprecher passt das Design des Buttons und des Textfelds an, um das Erscheinungsbild zu verbessern, einschließlich der Änderung des Buttons in einen RaisedButton mit violettem Hintergrund und weißer Textfarbe. Er zeigt, wie man das Design nutzt und einen Textstil für den Button in der Datei main.dart einrichtet, um ein einheitliches Design in der gesamten Anwendung zu gewährleisten. Das Video hebt die Bedeutung der Nutzung des Designs für Farbkonsistenz hervor und zeigt, wie man die Standardfarben der Buttons effektiv überschreibt.",
                                // Chinese
                                "中国人": "在此视频中，演讲者介绍了 Flutter 应用程序中缺少的组件，特别是缺少日期选择器。他们演示了如何在现有文本字段下方添加一个新行，其中包含一个显示所选日期的已禁用文本字段和一个用于打开日期选择器小部件的 FlatButton。演讲者调整了按钮和文本字段的样式以增强外观，包括将按钮更改为具有紫色背景和白色文本颜色的 RaisedButton。他们展示了如何利用主题并在 main.dart 文件中为按钮设置文本样式，以实现整个应用程序的一致样式。视频强调了利用主题实现颜色一致性的重要性，并演示了如何有效地覆盖默认按钮颜色。",
                                // Russian
                                "Русский": "В этом видео докладчик рассматривает отсутствующие компоненты в приложении Flutter, в частности отсутствие выбора даты. Они показывают, как добавить новую строку под существующими текстовыми полями, содержащими отключенное текстовое поле, отображающее выбранную дату, и FlatButton для открытия виджета выбора даты. Докладчик корректирует стиль кнопки и текстового поля, чтобы улучшить внешний вид, включая изменение кнопки на RaisedButton с фиолетовым фоном и белым цветом текста. Они показывают, как использовать тему и настроить стиль текста для кнопки в файле main.dart для единообразного стиля во всем приложении. Видео подчеркивает важность использования темы для согласованности цветов и демонстрирует, как эффективно переопределять цвета кнопок по умолчанию.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant aborde les composants manquants dans une application Flutter, en particulier l'absence de sélecteur de date. Il montre comment ajouter une nouvelle ligne sous les champs de texte existants contenant un champ de texte désactivé affichant la date choisie et un FlatButton pour ouvrir le widget de sélection de date. L'intervenant ajuste le style du bouton et du champ de texte pour améliorer l'apparence, notamment en changeant le bouton en un RaisedButton avec un arrière-plan violet et une couleur de texte blanche. Il montre comment utiliser le thème et configurer un style de texte pour le bouton dans le fichier main.dart pour un style cohérent dans toute l'application. La vidéo souligne l'importance d'utiliser le thème pour la cohérence des couleurs et montre comment remplacer efficacement les couleurs des boutons par défaut.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が Flutter アプリケーションに欠けているコンポーネント、特に日付ピッカーの欠如について取り上げています。講演者は、既存のテキスト フィールドの下に、選択した日付を表示する無効なテキスト フィールドと、日付ピッカー ウィジェットを開く FlatButton を含む新しい行を追加する方法を示します。講演者は、ボタンを紫色の背景と白いテキスト カラーの RaisedButton に変更するなど、ボタンとテキスト フィールドのスタイルを調整して外観を向上させます。講演者は、テーマを利用して main.dart ファイル内でボタンのテキスト スタイルを設定し、アプリケーション全体で一貫したスタイルを設定する方法を紹介します。このビデオでは、色の一貫性を保つためにテーマを利用することの重要性を強調し、デフォルトのボタン カラーを効果的にオーバーライドする方法を示します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 애플리케이션에서 누락된 구성 요소, 특히 날짜 선택기의 부족에 대해 다룹니다. 발표자는 선택한 날짜를 표시하는 비활성화된 텍스트 필드와 날짜 선택기 위젯을 여는 FlatButton을 포함하는 기존 텍스트 필드 아래에 새 행을 추가하는 방법을 보여줍니다. 발표자는 버튼을 보라색 배경과 흰색 텍스트 색상을 가진 RaisedButton으로 변경하는 것을 포함하여 버튼과 텍스트 필드의 스타일을 조정하여 모양을 개선합니다. 발표자는 테마를 활용하고 애플리케이션 전체에서 일관된 스타일을 위해 main.dart 파일 내에서 버튼의 텍스트 스타일을 설정하는 방법을 보여줍니다. 이 비디오는 색상 일관성을 위해 테마를 활용하는 것의 중요성을 강조하고 기본 버튼 색상을 효과적으로 재정의하는 방법을 보여줍니다.",
                                // Spanish
                                "Español": "En este video, el orador aborda los componentes faltantes en una aplicación Flutter, específicamente la falta de un selector de fecha. Demuestra cómo agregar una nueva fila debajo de los campos de texto existentes que contienen un campo de texto deshabilitado que muestra la fecha elegida y un FlatButton para abrir el widget del selector de fecha. El orador ajusta el estilo del botón y del campo de texto para mejorar la apariencia, incluido el cambio del botón a un RaisedButton con un fondo violeta y un color de texto blanco. Muestra cómo utilizar el tema y configurar un estilo de texto para el botón dentro del archivo main.dart para lograr un estilo consistente en toda la aplicación. El video destaca la importancia de utilizar el tema para lograr la consistencia del color y demuestra cómo anular los colores predeterminados de los botones de manera efectiva.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर एप्लिकेशन में गुम घटकों, विशेष रूप से दिनांक चयनकर्ता की कमी को संबोधित करता है। वे प्रदर्शित करते हैं कि मौजूदा टेक्स्ट फ़ील्ड के नीचे एक नई पंक्ति कैसे जोड़ें जिसमें चुनी गई तिथि प्रदर्शित करने वाला अक्षम टेक्स्ट फ़ील्ड और दिनांक चयनकर्ता विजेट खोलने के लिए फ़्लैटबटन शामिल है। वक्ता उपस्थिति को बढ़ाने के लिए बटन और टेक्स्ट फ़ील्ड की स्टाइलिंग को समायोजित करता है, जिसमें बटन को बैंगनी पृष्ठभूमि और सफेद टेक्स्ट रंग के साथ RaisedButton में बदलना शामिल है। वे दिखाते हैं कि थीम का उपयोग कैसे करें और एप्लिकेशन में सुसंगत स्टाइलिंग के लिए main.dart फ़ाइल के भीतर बटन के लिए टेक्स्ट स्टाइल कैसे सेट करें। वीडियो रंग स्थिरता के लिए थीम का उपयोग करने के महत्व पर प्रकाश डालता है और प्रदर्शित करता है कि डिफ़ॉल्ट बटन रंगों को प्रभावी ढंग से कैसे ओवरराइड किया जाए।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador aborda os componentes em falta numa aplicação Flutter, especificamente a falta de um seletor de data. Demonstram como adicionar uma nova linha abaixo dos campos de texto existentes contendo um campo de texto desativado exibindo a data escolhida e um FlatButton para abrir o widget seletor de data. O altifalante ajusta o estilo do botão e do campo de texto para melhorar a aparência, incluindo a alteração do botão para um RaisedButton com fundo roxo e cor de texto branca. Mostram como utilizar o tema e configurar um estilo de texto para o botão no ficheiro main.dart para um estilo consistente em toda a aplicação. O vídeo destaca a importância de utilizar o tema para obter consistência de cor e demonstra como substituir as cores padrão dos botões de forma eficaz.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি ফ্লটার অ্যাপ্লিকেশনে অনুপস্থিত উপাদানগুলিকে সম্বোধন করে, বিশেষত একটি তারিখ পিকারের অভাব৷ তারা প্রদর্শন করে কিভাবে বিদ্যমান টেক্সট ফিল্ডের নিচে একটি নতুন সারি যুক্ত করতে হয় যাতে একটি অক্ষম করা টেক্সট ফিল্ড থাকে যা নির্বাচিত তারিখ প্রদর্শন করে এবং তারিখ পিকার উইজেট খুলতে একটি ফ্ল্যাটবাটন। স্পিকার একটি বেগুনি ব্যাকগ্রাউন্ড এবং সাদা টেক্সট রঙ সহ বোতামটিকে একটি RaisedButton এ পরিবর্তন সহ চেহারাটি উন্নত করতে বোতাম এবং পাঠ্য ক্ষেত্রের স্টাইলিং সামঞ্জস্য করে। তারা কীভাবে থিমটি ব্যবহার করতে হয় তা প্রদর্শন করে এবং পুরো অ্যাপ্লিকেশন জুড়ে সামঞ্জস্যপূর্ণ স্টাইলিংয়ের জন্য main.dart ফাইলের মধ্যে বোতামের জন্য একটি পাঠ্য শৈলী সেট আপ করে। ভিডিওটি রঙের সামঞ্জস্যের জন্য থিমটি ব্যবহারের গুরুত্ব তুলে ধরে এবং ডিফল্ট বোতামের রঙগুলিকে কার্যকরভাবে ওভাররাইড করার পদ্ধতি প্রদর্শন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث المكونات المفقودة في تطبيق Flutter، وتحديدًا عدم وجود محدد تاريخ. ويوضح كيفية إضافة صف جديد أسفل حقول النص الموجودة التي تحتوي على حقل نص معطل يعرض التاريخ المختار وزر FlatButton لفتح عنصر واجهة مستخدم محدد التاريخ. ويضبط المتحدث أسلوب الزر وحقل النص لتحسين المظهر، بما في ذلك تغيير الزر إلى زر RaisedButton بخلفية أرجوانية ولون نص أبيض. ويوضح كيفية استخدام السمة وإعداد أسلوب نص للزر داخل ملف main.dart لتحقيق أسلوب متسق عبر التطبيق. ويسلط الفيديو الضوء على أهمية استخدام السمة لتحقيق اتساق الألوان ويوضح كيفية تجاوز ألوان الأزرار الافتراضية بشكل فعال.",
                                // Persian
                                "فارسی": "در این ویدئو، بلندگو به اجزای از دست رفته در یک برنامه فلاتر، به ویژه عدم وجود تاریخ انتخاب می‌پردازد. آنها نشان می دهند که چگونه می توان یک ردیف جدید به زیر فیلدهای متنی موجود اضافه کرد که حاوی یک فیلد متنی غیرفعال است که تاریخ انتخابی را نشان می دهد و یک FlatButton برای باز کردن ویجت انتخابگر تاریخ. بلندگو برای بهبود ظاهر، استایل دکمه و فیلد متن را تنظیم می‌کند، از جمله تغییر دکمه به دکمه برجسته با پس‌زمینه بنفش و رنگ متن سفید. آنها نحوه استفاده از تم را نشان می دهند و یک سبک متن را برای دکمه در فایل main.dart برای یک استایل ثابت در سراسر برنامه تنظیم می کنند. این ویدئو اهمیت استفاده از تم برای ثبات رنگ را برجسته می‌کند و نشان می‌دهد که چگونه می‌توان رنگ‌های دکمه پیش‌فرض را به طور موثر نادیده گرفت.",
                            },
                        },
                        // 98 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Showing a DatePicker",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker demonstrates how to implement a date picker in a Flutter application by creating a method that presents the date picker widget. They modify the existing state class to include the _submitData method to maintain consistency with private properties and methods. The speaker explains how to use the showDatePicker function provided by Flutter to display the date picker overlay, configure initial date selection, and restrict date ranges. They show how to handle the future returned by the showDatePicker method, allowing the app to react to the user's date selection. The video details how to store the selected date in a variable and format it using the intl package for date formatting. The speaker also adjusts the UI layout to display the selected date and ensure it is updated via the set state method to reflect changes in the stateful widget. The video concludes with the implementation of the date picker functionality in the Flutter app, providing users with the ability to select and display dates within the application.",
                                // German
                                "Deutsch": "In diesem Video demonstriert der Sprecher, wie man einen Datumswähler in einer Flutter-Anwendung implementiert, indem er eine Methode erstellt, die das Datumswähler-Widget präsentiert. Er ändert die vorhandene Statusklasse, um die Methode _submitData einzuschließen, um die Konsistenz mit privaten Eigenschaften und Methoden zu wahren. Der Sprecher erklärt, wie man die von Flutter bereitgestellte Funktion showDatePicker verwendet, um das Datumswähler-Overlay anzuzeigen, die anfängliche Datumsauswahl zu konfigurieren und Datumsbereiche einzuschränken. Er zeigt, wie man mit der von der Methode showDatePicker zurückgegebenen Zukunft umgeht, sodass die App auf die Datumsauswahl des Benutzers reagieren kann. Das Video beschreibt detailliert, wie man das ausgewählte Datum in einer Variablen speichert und es mit dem intl-Paket für die Datumsformatierung formatiert. Der Sprecher passt auch das UI-Layout an, um das ausgewählte Datum anzuzeigen und sicherzustellen, dass es über die Methode set state aktualisiert wird, um Änderungen im statusbehafteten Widget widerzuspiegeln. Das Video endet mit der Implementierung der Datumswähler-Funktionalität in der Flutter-App, die Benutzern die Möglichkeit bietet, Daten innerhalb der Anwendung auszuwählen und anzuzeigen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者演示了如何在 Flutter 应用程序中实现日期选择器，方法是创建一个显示日期选择器小部件的方法。他们修改了现有的状态类以包含 _submitData 方法，以保持与私有属性和方法的一致性。演讲者解释了如何使用 Flutter 提供的 showDatePicker 函数显示日期选择器覆盖、配置初始日期选择和限制日期范围。他们展示了如何处理 showDatePicker 方法返回的未来，让应用程序能够对用户的日期选择做出反应。视频详细介绍了如何将选定的日期存储在变量中，并使用 intl 包对其进行格式化以进行日期格式化。演讲者还调整了 UI 布局以显示选定的日期，并确保通过设置状态方法对其进行更新以反映有状态小部件中的变化。视频最后介绍了 Flutter 应用程序中日期选择器功能的实现，使用户能够在应用程序内选择和显示日期。",
                                // Russian
                                "Русский": "В этом видео докладчик демонстрирует, как реализовать выбор даты в приложении Flutter, создав метод, который представляет виджет выбора даты. Они изменяют существующий класс состояния, чтобы включить метод _submitData для поддержания согласованности с частными свойствами и методами. Докладчик объясняет, как использовать функцию showDatePicker, предоставляемую Flutter, для отображения наложения выбора даты, настройки начального выбора даты и ограничения диапазонов дат. Они показывают, как обрабатывать будущее, возвращаемое методом showDatePicker, позволяя приложению реагировать на выбор даты пользователем. Видео подробно описывает, как сохранить выбранную дату в переменной и отформатировать ее с помощью пакета intl для форматирования даты. Докладчик также настраивает макет пользовательского интерфейса для отображения выбранной даты и обеспечивает ее обновление с помощью метода set state для отражения изменений в виджете с отслеживанием состояния. Видео завершается реализацией функциональности выбора даты в приложении Flutter, предоставляя пользователям возможность выбирать и отображать даты в приложении.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant montre comment implémenter un sélecteur de date dans une application Flutter en créant une méthode qui présente le widget de sélecteur de date. Il modifie la classe d'état existante pour inclure la méthode _submitData afin de maintenir la cohérence avec les propriétés et méthodes privées. L'intervenant explique comment utiliser la fonction showDatePicker fournie par Flutter pour afficher la superposition du sélecteur de date, configurer la sélection de date initiale et restreindre les plages de dates. Il montre comment gérer le futur renvoyé par la méthode showDatePicker, permettant à l'application de réagir à la sélection de date de l'utilisateur. La vidéo détaille comment stocker la date sélectionnée dans une variable et la formater à l'aide du package intl pour le formatage de la date. L'intervenant ajuste également la disposition de l'interface utilisateur pour afficher la date sélectionnée et s'assurer qu'elle est mise à jour via la méthode set state pour refléter les modifications dans le widget avec état. La vidéo se termine par l'implémentation de la fonctionnalité de sélecteur de date dans l'application Flutter, offrant aux utilisateurs la possibilité de sélectionner et d'afficher des dates dans l'application.",
                                // Japanese
                                "日本語": "このビデオでは、講演者は、日付ピッカー ウィジェットを表示するメソッドを作成して、Flutter アプリケーションに日付ピッカーを実装する方法を実演します。既存の状態クラスを変更して _submitData メソッドを追加し、プライベート プロパティとメソッドとの一貫性を維持します。講演者は、Flutter が提供する showDatePicker 関数を使用して日付ピッカー オーバーレイを表示し、初期日付選択を構成し、日付範囲を制限する方法について説明します。また、showDatePicker メソッドによって返される future を処理して、アプリがユーザーの日付選択に反応できるようにする方法を示します。ビデオでは、選択した日付を変数に格納し、日付の書式設定に intl パッケージを使用して書式設定する方法について詳しく説明します。講演者はまた、UI レイアウトを調整して選択した日付を表示し、set state メソッドを介して更新されてステートフル ウィジェットの変更が反映されるようにします。ビデオの最後には、Flutter アプリに日付ピッカー機能を実装して、ユーザーがアプリケーション内で日付を選択して表示できるようにします。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 날짜 선택기 위젯을 표시하는 메서드를 만들어 Flutter 애플리케이션에서 날짜 선택기를 구현하는 방법을 보여줍니다. 발표자는 기존 상태 클래스를 수정하여 _submitData 메서드를 포함시켜 개인 속성 및 메서드와의 일관성을 유지합니다. 발표자는 Flutter에서 제공하는 showDatePicker 함수를 사용하여 날짜 선택기 오버레이를 표시하고, 초기 날짜 선택을 구성하고, 날짜 범위를 제한하는 방법을 설명합니다. 발표자는 showDatePicker 메서드에서 반환된 미래를 처리하여 앱이 사용자의 날짜 선택에 반응할 수 있도록 하는 방법을 보여줍니다. 이 비디오에서는 선택한 날짜를 변수에 저장하고 날짜 서식을 위한 intl 패키지를 사용하여 서식을 지정하는 방법을 자세히 설명합니다. 발표자는 또한 UI 레이아웃을 조정하여 선택한 날짜를 표시하고 상태 위젯의 변경 사항을 반영하도록 set state 메서드를 통해 업데이트되도록 합니다. 이 비디오는 Flutter 앱에서 날짜 선택기 기능을 구현하여 사용자가 애플리케이션 내에서 날짜를 선택하고 표시할 수 있도록 하는 것으로 마무리됩니다.",
                                // Spanish
                                "Español": "En este video, el orador demuestra cómo implementar un selector de fecha en una aplicación Flutter mediante la creación de un método que presenta el widget de selector de fecha. Modifica la clase de estado existente para incluir el método _submitData para mantener la coherencia con las propiedades y los métodos privados. El orador explica cómo usar la función showDatePicker proporcionada por Flutter para mostrar la superposición del selector de fecha, configurar la selección de fecha inicial y restringir los rangos de fechas. Muestra cómo manejar el futuro devuelto por el método showDatePicker, lo que permite que la aplicación reaccione a la selección de fecha del usuario. El video detalla cómo almacenar la fecha seleccionada en una variable y formatearla utilizando el paquete intl para el formato de fecha. El orador también ajusta el diseño de la interfaz de usuario para mostrar la fecha seleccionada y asegurarse de que se actualice a través del método set state para reflejar los cambios en el widget con estado. El video concluye con la implementación de la funcionalidad del selector de fecha en la aplicación Flutter, lo que brinda a los usuarios la capacidad de seleccionar y mostrar fechas dentro de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता एक फ़्लटर एप्लिकेशन में दिनांक पिकर को लागू करने का तरीका प्रदर्शित करता है, इसके लिए एक विधि बनाता है जो दिनांक पिकर विजेट प्रस्तुत करता है। वे निजी गुणों और विधियों के साथ संगति बनाए रखने के लिए _submitData विधि को शामिल करने के लिए मौजूदा स्टेट क्लास को संशोधित करते हैं। वक्ता बताते हैं कि दिनांक पिकर ओवरले को प्रदर्शित करने, प्रारंभिक तिथि चयन को कॉन्फ़िगर करने और तिथि सीमाओं को प्रतिबंधित करने के लिए फ़्लटर द्वारा प्रदान किए गए showDatePicker फ़ंक्शन का उपयोग कैसे करें। वे दिखाते हैं कि showDatePicker विधि द्वारा लौटाए गए भविष्य को कैसे संभालना है, जिससे ऐप उपयोगकर्ता के तिथि चयन पर प्रतिक्रिया कर सके। वीडियो में विस्तार से बताया गया है कि चयनित तिथि को एक चर में कैसे संग्रहीत किया जाए और तिथि स्वरूपण के लिए intl पैकेज का उपयोग करके इसे कैसे स्वरूपित किया जाए। वक्ता चयनित तिथि को प्रदर्शित करने के लिए UI लेआउट को भी समायोजित करता है और यह सुनिश्चित करता है कि स्टेटफुल विजेट में परिवर्तनों को प्रतिबिंबित करने के लिए इसे सेट स्टेट विधि के माध्यम से अपडेट किया जाए। वीडियो फ़्लटर ऐप में दिनांक पिकर कार्यक्षमता के कार्यान्वयन के साथ समाप्त होता है, जो उपयोगकर्ताओं को एप्लिकेशन के भीतर तिथियों को चुनने और प्रदर्शित करने की क्षमता प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador demonstra como implementar um seletor de data numa aplicação Flutter criando um método que apresenta o widget seletor de data. Modificam a classe de estado existente para incluir o método _submitData para manter a consistência com as propriedades e métodos privados. O orador explica como utilizar a função showDatePicker fornecida pelo Flutter para exibir a sobreposição do seletor de data, configurar a seleção de data inicial e restringir os intervalos de datas. Mostram como lidar com o futuro devolvido pelo método showDatePicker, permitindo que a aplicação reaja à seleção de data do utilizador. O vídeo detalha como armazenar a data selecionada numa variável e formatá-la utilizando o pacote intl para a formatação da data. O orador também ajusta o layout da IU para exibir a data selecionada e garantir que é atualizada através do método set state para refletir as alterações no widget com estado. O vídeo termina com a implementação da funcionalidade de seletor de data na aplicação Flutter, proporcionando aos utilizadores a capacidade de selecionar e exibir datas dentro da aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার প্রদর্শন করে যে কীভাবে তারিখ পিকার উইজেট উপস্থাপন করে এমন একটি পদ্ধতি তৈরি করে একটি ফ্লাটার অ্যাপ্লিকেশনে একটি তারিখ পিকার প্রয়োগ করতে হয়। ব্যক্তিগত বৈশিষ্ট্য এবং পদ্ধতির সাথে সামঞ্জস্য বজায় রাখতে তারা _submitData পদ্ধতি অন্তর্ভুক্ত করার জন্য বিদ্যমান রাষ্ট্রীয় শ্রেণীকে সংশোধন করে। স্পিকার ব্যাখ্যা করে যে কীভাবে তারিখ পিকার ওভারলে প্রদর্শন করতে, প্রাথমিক তারিখ নির্বাচন কনফিগার করতে এবং তারিখের ব্যাপ্তি সীমাবদ্ধ করতে ফ্লটার দ্বারা প্রদত্ত showDatePicker ফাংশনটি ব্যবহার করতে হয়। তারা শোডেটপিকার পদ্ধতির দ্বারা ফিরে আসা ভবিষ্যতকে কীভাবে পরিচালনা করতে হয় তা দেখায়, অ্যাপটিকে ব্যবহারকারীর তারিখ নির্বাচনের প্রতিক্রিয়া জানানোর অনুমতি দেয়। ভিডিওতে বিশদ বিবরণ দেওয়া হয়েছে যে কীভাবে নির্বাচিত তারিখটিকে একটি পরিবর্তনশীলে সংরক্ষণ করতে হয় এবং তারিখ বিন্যাসের জন্য intl প্যাকেজ ব্যবহার করে ফর্ম্যাট করতে হয়। নির্বাচিত তারিখ প্রদর্শন করতে স্পিকার UI লেআউট সামঞ্জস্য করে এবং নিশ্চিত করে যে এটি রাষ্ট্রীয় উইজেটে পরিবর্তনগুলি প্রতিফলিত করতে সেট স্টেট পদ্ধতির মাধ্যমে আপডেট করা হয়েছে। ভিডিওটি Flutter অ্যাপে তারিখ পিকার কার্যকারিতা বাস্তবায়নের মাধ্যমে শেষ হয়েছে, ব্যবহারকারীদের অ্যাপ্লিকেশনের মধ্যে তারিখ নির্বাচন এবং প্রদর্শন করার ক্ষমতা প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المتحدث كيفية تنفيذ محدد التاريخ في تطبيق Flutter من خلال إنشاء طريقة تعرض عنصر واجهة المستخدم لمحدد التاريخ. كما يقومون بتعديل فئة الحالة الحالية لتشمل طريقة _submitData للحفاظ على الاتساق مع الخصائص والطرق الخاصة. ويشرح المتحدث كيفية استخدام وظيفة showDatePicker التي توفرها Flutter لعرض تراكب محدد التاريخ، وتكوين تحديد التاريخ الأولي، وتقييد نطاقات التاريخ. كما يوضح كيفية التعامل مع المستقبل الذي يتم إرجاعه بواسطة طريقة showDatePicker، مما يسمح للتطبيق بالتفاعل مع تحديد تاريخ المستخدم. ويوضح الفيديو بالتفصيل كيفية تخزين التاريخ المحدد في متغير وتنسيقه باستخدام حزمة intl لتنسيق التاريخ. كما يضبط المتحدث تخطيط واجهة المستخدم لعرض التاريخ المحدد والتأكد من تحديثه عبر طريقة تعيين الحالة ليعكس التغييرات في عنصر واجهة المستخدم المرتبط بالحالة. ويختتم الفيديو بتنفيذ وظيفة محدد التاريخ في تطبيق Flutter، مما يوفر للمستخدمين القدرة على تحديد وعرض التواريخ داخل التطبيق.",
                                // Persian
                                "فارسی": "در این ویدئو، بلندگو نحوه پیاده‌سازی انتخابگر تاریخ را در برنامه فلاتر با ایجاد روشی که ویجت انتخابگر تاریخ را ارائه می‌دهد، نشان می‌دهد. آنها کلاس state موجود را تغییر می دهند تا متد _submitData را برای حفظ سازگاری با ویژگی ها و متدهای خصوصی در بر بگیرد. بلندگو نحوه استفاده از تابع showDatePicker ارائه شده توسط Flutter را برای نمایش همپوشانی انتخابگر تاریخ، پیکربندی انتخاب تاریخ اولیه و محدود کردن محدوده تاریخ توضیح می‌دهد. آنها نشان می دهند که چگونه می توان با روش showDatePicker آینده بازگشتی را مدیریت کرد و به برنامه اجازه می دهد تا به انتخاب تاریخ کاربر واکنش نشان دهد. ویدئو نحوه ذخیره تاریخ انتخاب شده در یک متغیر و قالب بندی آن با استفاده از بسته بین المللی برای قالب بندی تاریخ را توضیح می دهد. بلندگو همچنین چیدمان UI را برای نمایش تاریخ انتخاب شده تنظیم می کند و اطمینان حاصل می کند که از طریق روش set state به روز می شود تا تغییرات در ویجت حالت دار را منعکس کند. این ویدیو با اجرای عملکرد انتخابگر تاریخ در برنامه Flutter به پایان می رسد و به کاربران امکان انتخاب و نمایش تاریخ ها را در برنامه می دهد.",
                            },
                        },
                        // 99 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Adding Transactions with a Date",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video demonstrates how to utilize the selected date in a Flutter application by adding conditions to ensure the date is not null before submitting a transaction. The speaker modifies the submit data method to include a check for the presence of a selected date along with title and amount validation. They explain how to pass the selected date as a third argument to the add transaction function in the main.dart file, enhancing the capability to include the chosen date in transaction records. The video showcases the implementation of selecting and utilizing a date in transactions, indicating successful integration and display of transaction details based on the chosen date. Additionally, the speaker acknowledges the need to address the issue of closing the keyboard to access the date picker, noting that this will be resolved in a future video.",
                                // German
                                "Deutsch": "Dieses Video zeigt, wie das ausgewählte Datum in einer Flutter-Anwendung verwendet wird, indem Bedingungen hinzugefügt werden, um sicherzustellen, dass das Datum nicht null ist, bevor eine Transaktion übermittelt wird. Der Sprecher ändert die Methode zum Senden von Daten, um eine Prüfung auf das Vorhandensein eines ausgewählten Datums sowie eine Validierung von Titel und Betrag einzuschließen. Er erklärt, wie das ausgewählte Datum als drittes Argument an die Funktion „Transaktion hinzufügen“ in der Datei main.dart übergeben wird, wodurch die Möglichkeit verbessert wird, das ausgewählte Datum in Transaktionsdatensätze aufzunehmen. Das Video zeigt die Implementierung der Auswahl und Verwendung eines Datums in Transaktionen und zeigt eine erfolgreiche Integration und Anzeige von Transaktionsdetails basierend auf dem ausgewählten Datum. Darüber hinaus erkennt der Sprecher die Notwendigkeit an, das Problem des Schließens der Tastatur zum Zugriff auf die Datumsauswahl zu lösen, und weist darauf hin, dass dies in einem zukünftigen Video behoben wird.",
                                // Chinese
                                "中国人": "该视频演示了如何在 Flutter 应用程序中使用所选日期，方法是添加条件以确保在提交交易之前日期不为空。演讲者修改了提交数据方法，以检查所选日期是否存在以及标题和金额验证。他们解释了如何将选定的日期作为第三个参数传递给 main.dart 文件中的添加交易函数，从而增强了将选定日期包含在交易记录中的能力。该视频展示了在交易中选择和使用日期的实现，表明已成功集成并显示基于所选日期的交易详细信息。此外，演讲者承认需要解决关闭键盘以访问日期选择器的问题，并指出这将在未来的视频中得到解决。",
                                // Russian
                                "Русский": "В этом видео показано, как использовать выбранную дату в приложении Flutter, добавляя условия, чтобы убедиться, что дата не равна нулю перед отправкой транзакции. Докладчик изменяет метод отправки данных, чтобы включить проверку наличия выбранной даты вместе с проверкой заголовка и суммы. Они объясняют, как передать выбранную дату в качестве третьего аргумента функции добавления транзакции в файле main.dart, расширяя возможности включения выбранной даты в записи транзакций. Видео демонстрирует реализацию выбора и использования даты в транзакциях, что указывает на успешную интеграцию и отображение сведений о транзакции на основе выбранной даты. Кроме того, докладчик признает необходимость решения проблемы закрытия клавиатуры для доступа к средству выбора даты, отмечая, что это будет решено в будущем видео.",
                                // French
                                "Français": "Cette vidéo montre comment utiliser la date sélectionnée dans une application Flutter en ajoutant des conditions pour garantir que la date n'est pas nulle avant de soumettre une transaction. L'intervenant modifie la méthode de soumission des données pour inclure une vérification de la présence d'une date sélectionnée ainsi qu'une validation du titre et du montant. Il explique comment transmettre la date sélectionnée comme troisième argument à la fonction d'ajout de transaction dans le fichier main.dart, améliorant ainsi la capacité d'inclure la date choisie dans les enregistrements de transaction. La vidéo présente la mise en œuvre de la sélection et de l'utilisation d'une date dans les transactions, indiquant l'intégration et l'affichage réussis des détails de la transaction en fonction de la date choisie. De plus, l'intervenant reconnaît la nécessité de résoudre le problème de la fermeture du clavier pour accéder au sélecteur de date, en notant que cela sera résolu dans une future vidéo.",
                                // Japanese
                                "日本語": "このビデオでは、トランザクションを送信する前に日付が null でないことを確認する条件を追加することで、Flutter アプリケーションで選択した日付を利用する方法を説明します。講演者は、データ送信メソッドを変更して、タイトルと金額の検証とともに、選択した日付の存在のチェックを含めます。また、選択した日付を main.dart ファイルの add transaction 関数の 3 番目の引数として渡す方法を説明し、選択した日付をトランザクション レコードに含める機能を強化します。このビデオでは、トランザクションで日付を選択して利用する実装を紹介し、選択した日付に基づいてトランザクションの詳細が正常に統合および表示されることを示しています。さらに、講演者は、キーボードを閉じて日付ピッカーにアクセスする問題に対処する必要があることを認めており、これは今後のビデオで解決されると述べています。",
                                // Korean
                                "한국인": "이 비디오는 거래를 제출하기 전에 날짜가 null이 아닌지 확인하는 조건을 추가하여 Flutter 애플리케이션에서 선택한 날짜를 활용하는 방법을 보여줍니다. 발표자는 제목 및 금액 검증과 함께 선택한 날짜의 존재 여부를 확인하는 submit data 메서드를 수정합니다. 그들은 main.dart 파일에서 add transaction 함수에 세 번째 인수로 선택한 날짜를 전달하는 방법을 설명하여 선택한 날짜를 거래 기록에 포함하는 기능을 향상시킵니다. 이 비디오는 거래에서 날짜를 선택하고 활용하는 구현을 보여주며, 선택한 날짜를 기반으로 성공적인 통합 및 거래 세부 정보 표시를 나타냅니다. 또한 발표자는 날짜 선택기에 액세스하기 위해 키보드를 닫는 문제를 해결해야 할 필요성을 인정하며 이는 향후 비디오에서 해결될 것이라고 언급합니다.",
                                // Spanish
                                "Español": "Este video demuestra cómo utilizar la fecha seleccionada en una aplicación Flutter agregando condiciones para garantizar que la fecha no sea nula antes de enviar una transacción. El orador modifica el método de envío de datos para incluir una verificación de la presencia de una fecha seleccionada junto con la validación del título y el monto. Explica cómo pasar la fecha seleccionada como un tercer argumento a la función de agregar transacción en el archivo main.dart, lo que mejora la capacidad de incluir la fecha elegida en los registros de transacciones. El video muestra la implementación de la selección y el uso de una fecha en las transacciones, lo que indica una integración exitosa y la visualización de los detalles de la transacción en función de la fecha elegida. Además, el orador reconoce la necesidad de abordar el problema de cerrar el teclado para acceder al selector de fecha y señala que esto se resolverá en un video futuro.",
                                // Hindi
                                "हिंदी": "यह वीडियो दर्शाता है कि किसी लेनदेन को सबमिट करने से पहले तिथि को शून्य न होने की स्थिति में शर्तें जोड़कर फ़्लटर एप्लिकेशन में चयनित तिथि का उपयोग कैसे किया जाए। वक्ता शीर्षक और राशि सत्यापन के साथ चयनित तिथि की उपस्थिति की जांच को शामिल करने के लिए सबमिट डेटा विधि को संशोधित करता है। वे बताते हैं कि चयनित तिथि को main.dart फ़ाइल में add transaction फ़ंक्शन में तीसरे तर्क के रूप में कैसे पास किया जाए, जिससे लेनदेन रिकॉर्ड में चुनी गई तिथि को शामिल करने की क्षमता बढ़ जाती है। वीडियो लेनदेन में तिथि का चयन और उपयोग करने के कार्यान्वयन को प्रदर्शित करता है, जो चयनित तिथि के आधार पर लेनदेन विवरण के सफल एकीकरण और प्रदर्शन को दर्शाता है। इसके अतिरिक्त, वक्ता तिथि चयनकर्ता तक पहुँचने के लिए कीबोर्ड को बंद करने की समस्या को संबोधित करने की आवश्यकता को स्वीकार करता है, यह देखते हुए कि इसे भविष्य के वीडियो में हल किया जाएगा।",
                                // Portuguese
                                "Português": "Este vídeo demonstra como utilizar a data selecionada numa aplicação Flutter adicionando condições para garantir que a data não é nula antes de enviar uma transação. O orador modifica o método de envio de dados para incluir uma verificação da presença de uma data selecionada juntamente com a validação do título e do valor. Explicam como passar a data selecionada como terceiro argumento para a função add transaction no ficheiro main.dart, melhorando a capacidade de incluir a data escolhida nos registos de transações. O vídeo mostra a implementação da seleção e utilização de uma data nas transações, indicando a integração bem-sucedida e a apresentação dos detalhes da transação com base na data escolhida. Além disso, o orador reconhece a necessidade de abordar a questão do fecho do teclado para aceder ao seletor de data, tendo em conta que isso será resolvido num vídeo futuro.",
                                // Bengali
                                "বাংলা": "একটি লেনদেন জমা দেওয়ার আগে তারিখটি শূন্য না হয় তা নিশ্চিত করার জন্য শর্ত যোগ করে কীভাবে একটি ফ্লটার অ্যাপ্লিকেশনে নির্বাচিত তারিখটি ব্যবহার করতে হয় তা এই ভিডিওটি প্রদর্শন করে৷ স্পিকার শিরোনাম এবং পরিমাণ বৈধতা সহ একটি নির্বাচিত তারিখের উপস্থিতির জন্য একটি চেক অন্তর্ভুক্ত করতে জমা ডেটা পদ্ধতিটি সংশোধন করে। তারা ব্যাখ্যা করে যে কিভাবে নির্বাচিত তারিখটি main.dart ফাইলে লেনদেন ফাংশন যোগ করার তৃতীয় যুক্তি হিসাবে পাস করতে হয়, লেনদেনের রেকর্ডে নির্বাচিত তারিখ অন্তর্ভুক্ত করার ক্ষমতা বৃদ্ধি করে। ভিডিওটি লেনদেনে একটি তারিখ নির্বাচন এবং ব্যবহার করার বাস্তবায়ন প্রদর্শন করে, নির্বাচিত তারিখের উপর ভিত্তি করে সফল একীকরণ এবং লেনদেনের বিবরণ প্রদর্শনের ইঙ্গিত দেয়। উপরন্তু, স্পিকার তারিখ পিকার অ্যাক্সেস করার জন্য কীবোর্ড বন্ধ করার সমস্যাটি সমাধান করার প্রয়োজনীয়তা স্বীকার করে, উল্লেখ করে যে এটি ভবিষ্যতের ভিডিওতে সমাধান করা হবে।",
                                // Arabic
                                "عَرَبِيّ": "يوضح هذا الفيديو كيفية الاستفادة من التاريخ المحدد في تطبيق Flutter عن طريق إضافة شروط لضمان عدم كون التاريخ فارغًا قبل إرسال معاملة. يعدل المتحدث طريقة إرسال البيانات لتشمل فحصًا لوجود تاريخ محدد إلى جانب التحقق من صحة العنوان والمبلغ. يشرح كيفية تمرير التاريخ المحدد كحجة ثالثة إلى وظيفة إضافة المعاملة في ملف main.dart، مما يعزز القدرة على تضمين التاريخ المختار في سجلات المعاملات. يعرض الفيديو تنفيذ تحديد واستخدام تاريخ في المعاملات، مما يشير إلى التكامل الناجح وعرض تفاصيل المعاملة بناءً على التاريخ المختار. بالإضافة إلى ذلك، يقر المتحدث بالحاجة إلى معالجة مشكلة إغلاق لوحة المفاتيح للوصول إلى محدد التاريخ، مشيرًا إلى أنه سيتم حل هذه المشكلة في مقطع فيديو مستقبلي.",
                                // Persian
                                "فارسی": "این ویدیو نحوه استفاده از تاریخ انتخابی را در برنامه فلاتر با افزودن شرایطی نشان می‌دهد تا اطمینان حاصل شود که تاریخ قبل از ارسال تراکنش باطل نیست. گوینده روش ارسال داده را تغییر می دهد تا شامل بررسی وجود تاریخ انتخابی همراه با اعتبارسنجی عنوان و مبلغ باشد. آنها توضیح می دهند که چگونه می توان تاریخ انتخاب شده را به عنوان آرگومان سوم به تابع تراکنش افزودن در فایل main.dart ارسال کرد و قابلیت گنجاندن تاریخ انتخابی در سوابق تراکنش را افزایش داد. این ویدئو اجرای انتخاب و استفاده از تاریخ در تراکنش ها را نشان می دهد که نشان دهنده ادغام موفقیت آمیز و نمایش جزئیات تراکنش بر اساس تاریخ انتخاب شده است. علاوه بر این، گوینده نیاز به رسیدگی به مشکل بستن صفحه کلید برای دسترسی به انتخابگر تاریخ را تأیید می کند و خاطرنشان می کند که این مشکل در ویدیوی آینده حل خواهد شد.",
                            },
                        },
                        // 100 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Deleting Transactions & Using IconButtons",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker enhances the Flutter application by implementing a feature that allows users to delete transactions. They modify the ListTile in the transaction_list.dart file to include a trailing icon button with a delete icon that triggers the deletion of the corresponding transaction when pressed. The speaker explains how the delete transaction method is added to the main.dart file and utilizes the unique transaction ID as an identifier for deletion. They demonstrate how to use the removeWhere method to remove a transaction with a specific ID from the list of transactions. The video concludes with the integration of the delete transaction functionality in the application, enabling users to delete transactions by tapping the delete icon and observing the updated chart reflecting the changes in transactions.",
                                // German
                                "Deutsch": "In diesem Video erweitert der Sprecher die Flutter-Anwendung, indem er eine Funktion implementiert, mit der Benutzer Transaktionen löschen können. Er ändert die ListTile in der Datei transaction_list.dart, um eine nachgestellte Symbolschaltfläche mit einem Löschsymbol einzufügen, das beim Drücken das Löschen der entsprechenden Transaktion auslöst. Der Sprecher erklärt, wie die Methode zum Löschen von Transaktionen zur Datei main.dart hinzugefügt wird und verwendet die eindeutige Transaktions-ID als Kennung für das Löschen. Er demonstriert, wie die Methode removeWhere verwendet wird, um eine Transaktion mit einer bestimmten ID aus der Liste der Transaktionen zu entfernen. Das Video endet mit der Integration der Funktion zum Löschen von Transaktionen in die Anwendung, die es Benutzern ermöglicht, Transaktionen zu löschen, indem sie auf das Löschsymbol tippen und das aktualisierte Diagramm beobachten, das die Änderungen bei den Transaktionen widerspiegelt.",
                                // Chinese
                                "中国人": "在本视频中，演讲者通过实现允许用户删除交易的功能来增强 Flutter 应用程序。他们修改了 transaction_list.dart 文件中的 ListTile，以包含一个带有删除图标的尾随图标按钮，按下该按钮会触发相应交易的删除。演讲者解释了如何将删除交易方法添加到 main.dart 文件中，并使用唯一的交易 ID 作为删除标识符。他们演示了如何使用 removeWhere 方法从交易列表中删除具有特定 ID 的交易。视频最后介绍了应用程序中删除交易功能的集成，使用户能够通过点击删除图标并观察反映交易变化的更新图表来删除交易。",
                                // Russian
                                "Русский": "В этом видео докладчик улучшает приложение Flutter, внедряя функцию, которая позволяет пользователям удалять транзакции. Они изменяют ListTile в файле transaction_list.dart, чтобы включить завершающую кнопку со значком удаления, которая запускает удаление соответствующей транзакции при нажатии. Докладчик объясняет, как метод удаления транзакции добавляется в файл main.dart и использует уникальный идентификатор транзакции в качестве идентификатора для удаления. Они демонстрируют, как использовать метод removeWhere для удаления транзакции с определенным идентификатором из списка транзакций. Видео завершается интеграцией функциональности удаления транзакции в приложение, позволяя пользователям удалять транзакции, нажимая значок удаления и наблюдая обновленную диаграмму, отражающую изменения в транзакциях.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant améliore l'application Flutter en implémentant une fonctionnalité qui permet aux utilisateurs de supprimer des transactions. Il modifie le ListTile dans le fichier transaction_list.dart pour inclure un bouton d'icône de fin avec une icône de suppression qui déclenche la suppression de la transaction correspondante lorsqu'il est enfoncé. L'intervenant explique comment la méthode de suppression de transaction est ajoutée au fichier main.dart et utilise l'ID de transaction unique comme identifiant pour la suppression. Il montre comment utiliser la méthode removeWhere pour supprimer une transaction avec un ID spécifique de la liste des transactions. La vidéo se termine par l'intégration de la fonctionnalité de suppression de transaction dans l'application, permettant aux utilisateurs de supprimer des transactions en appuyant sur l'icône de suppression et en observant le graphique mis à jour reflétant les modifications des transactions.",
                                // Japanese
                                "日本語": "このビデオでは、講演者はユーザーがトランザクションを削除できる機能を実装することで、Flutter アプリケーションを強化します。transaction_list.dart ファイルの ListTile を変更して、削除アイコン付きの末尾アイコン ボタンを追加します。このボタンが押されると、対応するトランザクションが削除されます。講演者は、トランザクション削除メソッドを main.dart ファイルに追加し、一意のトランザクション ID を削除の識別子として使用する方法について説明します。また、removeWhere メソッドを使用して、特定の ID を持つトランザクションをトランザクション リストから削除する方法を示します。ビデオの最後には、アプリケーションにトランザクション削除機能を統合し、ユーザーが削除アイコンをタップしてトランザクションの変更を反映した更新されたチャートを確認することでトランザクションを削除できるようにします。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 사용자가 거래를 삭제할 수 있는 기능을 구현하여 Flutter 애플리케이션을 개선합니다. 발표자는 transaction_list.dart 파일에서 ListTile을 수정하여 삭제 아이콘이 있는 후행 아이콘 버튼을 포함하도록 합니다. 이 아이콘은 누르면 해당 거래가 삭제됩니다. 발표자는 delete transaction 메서드가 main.dart 파일에 추가되고 고유한 거래 ID를 삭제 식별자로 사용하는 방법을 설명합니다. 발표자는 removeWhere 메서드를 사용하여 특정 ID가 있는 거래를 거래 목록에서 제거하는 방법을 보여줍니다. 이 비디오는 애플리케이션에 delete transaction 기능을 통합하여 사용자가 삭제 아이콘을 탭하고 거래의 변경 사항을 반영하는 업데이트된 차트를 관찰하여 거래를 삭제할 수 있도록 하는 것으로 마무리됩니다.",
                                // Spanish
                                "Español": "En este video, el orador mejora la aplicación Flutter al implementar una función que permite a los usuarios eliminar transacciones. Modifica el ListTile en el archivo transaction_list.dart para incluir un botón de icono final con un icono de eliminación que activa la eliminación de la transacción correspondiente cuando se presiona. El orador explica cómo se agrega el método de eliminación de transacciones al archivo main.dart y utiliza el ID de transacción único como identificador para la eliminación. Demuestra cómo usar el método removeWhere para eliminar una transacción con un ID específico de la lista de transacciones. El video concluye con la integración de la funcionalidad de eliminación de transacciones en la aplicación, lo que permite a los usuarios eliminar transacciones tocando el icono de eliminación y observando el gráfico actualizado que refleja los cambios en las transacciones.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर एप्लिकेशन को एक ऐसी सुविधा लागू करके बेहतर बनाता है जो उपयोगकर्ताओं को लेनदेन हटाने की अनुमति देती है। वे transaction_list.dart फ़ाइल में ListTile को संशोधित करते हैं ताकि एक डिलीट आइकन के साथ एक अनुगामी आइकन बटन शामिल किया जा सके जो दबाए जाने पर संबंधित लेनदेन को हटाने को ट्रिगर करता है। वक्ता बताते हैं कि कैसे डिलीट ट्रांजेक्शन विधि को main.dart फ़ाइल में जोड़ा जाता है और डिलीट करने के लिए पहचानकर्ता के रूप में अद्वितीय ट्रांजेक्शन आईडी का उपयोग किया जाता है। वे प्रदर्शित करते हैं कि ट्रांजेक्शन की सूची से किसी विशिष्ट आईडी वाले ट्रांजेक्शन को हटाने के लिए removeWhere विधि का उपयोग कैसे किया जाता है। वीडियो एप्लिकेशन में डिलीट ट्रांजेक्शन कार्यक्षमता के एकीकरण के साथ समाप्त होता है, जिससे उपयोगकर्ता डिलीट आइकन पर टैप करके और ट्रांजेक्शन में परिवर्तनों को दर्शाने वाले अपडेट किए गए चार्ट को देखकर ट्रांजेक्शन को हटा सकते हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador melhora a aplicação Flutter implementando uma funcionalidade que permite aos utilizadores excluir transações. Modificam o ListTile no ficheiro transaction_list.dart para incluir um botão de ícone final com um ícone de eliminação que desencadeia a eliminação da transação correspondente quando pressionado. O orador explica como o método de eliminação de transações é adicionado ao ficheiro main.dart e utiliza o ID de transação único como identificador para eliminação. Demonstram como utilizar o método removeWhere para remover uma transação com um ID específico da lista de transações. O vídeo termina com a integração da funcionalidade de eliminação de transações na aplicação, permitindo aos utilizadores eliminar transações tocando no ícone de eliminação e observando o gráfico atualizado que reflete as alterações nas transações.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি বৈশিষ্ট্য প্রয়োগ করে ফ্লাটার অ্যাপ্লিকেশনটিকে উন্নত করে যা ব্যবহারকারীদের লেনদেন মুছে ফেলতে দেয়। তারা transaction_list.dart ফাইলে ListTile পরিবর্তন করে একটি ডিলিট আইকন সহ একটি ট্রেলিং আইকন বোতাম অন্তর্ভুক্ত করে যা চাপলে সংশ্লিষ্ট লেনদেন মুছে ফেলার ট্রিগার করে। স্পিকার ব্যাখ্যা করে কিভাবে লেনদেন মুছে ফেলার পদ্ধতি main.dart ফাইলে যোগ করা হয় এবং মুছে ফেলার জন্য একটি শনাক্তকারী হিসাবে অনন্য লেনদেন আইডি ব্যবহার করে। তারা লেনদেনের তালিকা থেকে একটি নির্দিষ্ট আইডি সহ একটি লেনদেন সরাতে removeWhere পদ্ধতিটি কীভাবে ব্যবহার করতে হয় তা প্রদর্শন করে৷ ভিডিওটি অ্যাপ্লিকেশনটিতে মুছে ফেলার লেনদেনের কার্যকারিতা একীকরণের সাথে শেষ হয়েছে, ব্যবহারকারীদের ডিলিট আইকনে আলতো চাপ দিয়ে লেনদেনগুলি মুছে ফেলতে সক্ষম করে এবং লেনদেনের পরিবর্তনগুলি প্রতিফলিত করে আপডেট করা চার্ট পর্যবেক্ষণ করে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يقوم المتحدث بتحسين تطبيق Flutter من خلال تنفيذ ميزة تسمح للمستخدمين بحذف المعاملات. يقومون بتعديل ListTile في ملف transaction_list.dart لتضمين زر أيقونة لاحق مع أيقونة حذف تؤدي إلى حذف المعاملة المقابلة عند الضغط عليها. يشرح المتحدث كيفية إضافة طريقة حذف المعاملة إلى ملف main.dart واستخدام معرف المعاملة الفريد كمعرف للحذف. كما يوضح كيفية استخدام طريقة removeWhere لإزالة معاملة بمعرف معين من قائمة المعاملات. ويختتم الفيديو بدمج وظيفة حذف المعاملة في التطبيق، مما يتيح للمستخدمين حذف المعاملات من خلال النقر على أيقونة الحذف ومراقبة الرسم البياني المحدث الذي يعكس التغييرات في المعاملات.",
                                // Persian
                                "فارسی": "در این ویدئو، اسپیکر با اجرای قابلیتی که به کاربران اجازه می دهد تراکنش ها را حذف کنند، اپلیکیشن فلاتر را تقویت می کند. آنها ListTile را در فایلtransaction_list.dart تغییر می دهند تا یک دکمه آیکون دنباله دار همراه با یک نماد حذف باشد که با فشار دادن، تراکنش مربوطه را حذف می کند. گوینده توضیح می دهد که چگونه روش تراکنش حذف به فایل main.dart اضافه می شود و از شناسه تراکنش منحصر به فرد به عنوان شناسه برای حذف استفاده می کند. آنها نحوه استفاده از روش removeWhere را برای حذف تراکنش با یک شناسه خاص از لیست تراکنش ها نشان می دهند. این ویدئو با ادغام قابلیت تراکنش حذف در برنامه به پایان می رسد و کاربران را قادر می سازد تا تراکنش ها را با ضربه زدن روی نماد حذف و مشاهده نمودار به روز شده منعکس کننده تغییرات در تراکنش ها حذف کنند.",
                            },
                        },
                        // 101 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Final Polishing!",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker discusses the issue of the transaction list being cut off at the top and bottom in the application. They explain how using the expanded widget creates problems with the ListView having an infinite height, leading to the need for a fixed height to prevent cutoff. The speaker mentions that in the next section, they will address this issue by dynamically calculating the height based on the viewport. Despite the current limitations, they conclude that the app is looking better with the adjusted height. They mention upcoming lessons on making the app more flexible for different device sizes and platforms.",
                                // German
                                "Deutsch": "In diesem Video erörtert der Sprecher das Problem, dass die Transaktionsliste in der Anwendung oben und unten abgeschnitten wird. Er erklärt, wie die Verwendung des erweiterten Widgets Probleme mit der ListView mit unendlicher Höhe verursacht, was dazu führt, dass eine feste Höhe erforderlich ist, um ein Abschneiden zu verhindern. Der Sprecher erwähnt, dass er dieses Problem im nächsten Abschnitt beheben wird, indem er die Höhe basierend auf dem Ansichtsfenster dynamisch berechnet. Trotz der aktuellen Einschränkungen kommt er zu dem Schluss, dass die App mit der angepassten Höhe besser aussieht. Er erwähnt kommende Lektionen, in denen es darum geht, die App flexibler für verschiedene Gerätegrößen und Plattformen zu gestalten.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了交易列表在应用程序中顶部和底部被截断的问题。他们解释了使用扩展小部件如何导致 ListView 具有无限高度的问题，从而需要固定高度以防止截断。演讲者提到，在下一节中，他们将通过基于视口动态计算高度来解决这个问题。尽管目前存在限制，但他们得出结论，调整高度后应用程序看起来更好。他们提到了即将开设的课程，内容是如何让应用程序更灵活地适应不同的设备尺寸和平台。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает проблему обрезания списка транзакций сверху и снизу в приложении. Они объясняют, как использование расширенного виджета создает проблемы с ListView, имеющим бесконечную высоту, что приводит к необходимости фиксированной высоты для предотвращения обрезания. Докладчик упоминает, что в следующем разделе они решат эту проблему, динамически вычисляя высоту на основе области просмотра. Несмотря на текущие ограничения, они приходят к выводу, что приложение выглядит лучше с измененной высотой. Они упоминают предстоящие уроки о том, как сделать приложение более гибким для разных размеров устройств и платформ.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant discute du problème de la liste des transactions coupée en haut et en bas de l'application. Il explique comment l'utilisation du widget étendu crée des problèmes avec la ListView ayant une hauteur infinie, ce qui conduit à la nécessité d'une hauteur fixe pour éviter la coupure. L'intervenant mentionne que dans la section suivante, il abordera ce problème en calculant dynamiquement la hauteur en fonction de la fenêtre d'affichage. Malgré les limitations actuelles, il conclut que l'application est plus belle avec la hauteur ajustée. Il mentionne les leçons à venir pour rendre l'application plus flexible pour différentes tailles d'appareils et plates-formes.",
                                // Japanese
                                "日本語": "このビデオでは、講演者は、アプリケーションでトランザクション リストが上部と下部で途切れる問題について説明しています。拡張ウィジェットを使用すると、ListView の高さが無限になるという問題が発生し、途切れを防ぐために固定の高さが必要になることを説明します。講演者は、次のセクションで、ビューポートに基づいて高さを動的に計算することでこの問題に対処すると述べています。現在の制限にもかかわらず、高さを調整することでアプリの見栄えが良くなると結論付けています。講演者は、さまざまなデバイス サイズやプラットフォームに対してアプリをより柔軟にするための今後のレッスンについて言及しています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 애플리케이션의 상단과 하단에서 거래 목록이 잘리는 문제에 대해 논의합니다. 그들은 확장된 위젯을 사용하면 ListView가 무한한 높이를 갖는 문제가 발생하여 잘림을 방지하기 위해 고정된 높이가 필요하다는 것을 설명합니다. 발표자는 다음 섹션에서 뷰포트를 기반으로 높이를 동적으로 계산하여 이 문제를 해결할 것이라고 언급합니다. 현재의 제한에도 불구하고, 그들은 조정된 높이로 앱이 더 좋아 보인다고 결론지었습니다. 그들은 다양한 기기 크기와 플랫폼에 맞게 앱을 더 유연하게 만드는 방법에 대한 다가올 레슨을 언급합니다.",
                                // Spanish
                                "Español": "En este video, el orador analiza el problema de la lista de transacciones que se corta en la parte superior e inferior de la aplicación. Explica cómo el uso del widget expandido crea problemas con la altura infinita de ListView, lo que genera la necesidad de una altura fija para evitar el corte. El orador menciona que en la siguiente sección abordará este problema calculando dinámicamente la altura en función de la ventana gráfica. A pesar de las limitaciones actuales, concluye que la aplicación se ve mejor con la altura ajustada. Menciona próximas lecciones sobre cómo hacer que la aplicación sea más flexible para diferentes tamaños y plataformas de dispositivos.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता एप्लीकेशन में ऊपर और नीचे ट्रांजेक्शन सूची के कट जाने की समस्या पर चर्चा करता है। वे बताते हैं कि कैसे विस्तारित विजेट का उपयोग करने से ListView की अनंत ऊंचाई के साथ समस्याएँ पैदा होती हैं, जिससे कटऑफ को रोकने के लिए एक निश्चित ऊंचाई की आवश्यकता होती है। वक्ता ने उल्लेख किया कि अगले भाग में, वे व्यूपोर्ट के आधार पर ऊंचाई की गतिशील रूप से गणना करके इस समस्या का समाधान करेंगे। वर्तमान सीमाओं के बावजूद, वे निष्कर्ष निकालते हैं कि समायोजित ऊंचाई के साथ ऐप बेहतर दिख रहा है। वे विभिन्न डिवाइस आकारों और प्लेटफ़ॉर्म के लिए ऐप को अधिक लचीला बनाने पर आगामी पाठों का उल्लेख करते हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador discute a questão da lista de transações ser cortada na parte superior e inferior da aplicação. Explicam como a utilização do widget expandido cria problemas com o ListView a ter uma altura infinita, levando à necessidade de uma altura fixa para evitar o corte. O orador refere que na próxima secção irão abordar este problema calculando dinamicamente a altura com base na janela de visualização. Apesar das limitações atuais, concluem que a app fica melhor com a altura ajustada. Mencionam lições futuras sobre como tornar a aplicação mais flexível para diferentes tamanhos e plataformas de dispositivos.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার লেনদেনের তালিকাটি অ্যাপ্লিকেশনের উপরের এবং নীচে কাটা হওয়ার বিষয়টি নিয়ে আলোচনা করেছেন। তারা ব্যাখ্যা করে যে কীভাবে প্রসারিত উইজেট ব্যবহার করা লিস্টভিউ-এর অসীম উচ্চতা নিয়ে সমস্যা তৈরি করে, যার ফলে কাটঅফ প্রতিরোধ করার জন্য একটি নির্দিষ্ট উচ্চতার প্রয়োজন হয়। স্পিকার উল্লেখ করেছেন যে পরবর্তী বিভাগে, তারা ভিউপোর্টের উপর ভিত্তি করে গতিশীলভাবে উচ্চতা গণনা করে এই সমস্যাটি সমাধান করবে। বর্তমান সীমাবদ্ধতা সত্ত্বেও, তারা উপসংহারে পৌঁছেছে যে অ্যাপটি সামঞ্জস্যপূর্ণ উচ্চতার সাথে আরও ভাল দেখাচ্ছে। তারা বিভিন্ন ডিভাইসের আকার এবং প্ল্যাটফর্মের জন্য অ্যাপটিকে আরও নমনীয় করার বিষয়ে আসন্ন পাঠের কথা উল্লেখ করেছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث مشكلة قطع قائمة المعاملات في الأعلى والأسفل في التطبيق. ويشرح كيف يؤدي استخدام الأداة الموسعة إلى حدوث مشكلات مع ارتفاع ListView اللانهائي، مما يؤدي إلى الحاجة إلى ارتفاع ثابت لمنع القطع. ويذكر المتحدث أنه في القسم التالي، سيتناول هذه المشكلة من خلال حساب الارتفاع ديناميكيًا بناءً على منفذ العرض. وعلى الرغم من القيود الحالية، يستنتج أن التطبيق يبدو أفضل مع الارتفاع المعدل. ويذكر الدروس القادمة حول جعل التطبيق أكثر مرونة لأحجام الأجهزة والمنصات المختلفة.",
                                // Persian
                                "فارسی": "در این ویدئو، سخنران در مورد قطع شدن لیست تراکنش ها در بالا و پایین برنامه صحبت می کند. آنها توضیح می دهند که چگونه استفاده از ویجت توسعه یافته مشکلاتی را با داشتن ارتفاع بی نهایت ListView ایجاد می کند که منجر به نیاز به ارتفاع ثابت برای جلوگیری از قطع می شود. سخنران اشاره می کند که در قسمت بعدی با محاسبه دینامیک ارتفاع بر اساس ویوپورت به این موضوع می پردازند. علیرغم محدودیت های فعلی، آنها به این نتیجه رسیدند که این برنامه با ارتفاع تنظیم شده بهتر به نظر می رسد. آنها به درس‌های آتی در مورد انعطاف‌پذیری بیشتر برنامه برای اندازه‌ها و پلتفرم‌های مختلف دستگاه اشاره می‌کنند.",
                            },
                        },
                        // 102 [Video Number]
                        {
                            "SectionName": "Widgets, Styling, Adding Logic - Building a Real App [PERSONAL EXPENSES APP]",
                            "VideoName": "Wrap Up",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this module, the speaker discusses the various custom widgets and built-in widgets available in Flutter, such as text field widgets, containers, buttons, ListTile, and ListView. They emphasize the importance of using the official documentation and IDE support to understand and configure widgets effectively. The module covers styling and configuring widgets, theming in MaterialApp, and adding business logic to the app using stateful widgets. The concept of lifting state up is highlighted to manage data and trigger changes within the app. Additionally, the video demonstrates adjusting the user interface based on logic, like showing a bottom modal sheet for a better user experience when adding new transactions.",
                                // German
                                "Deutsch": "In diesem Modul bespricht der Sprecher die verschiedenen benutzerdefinierten und integrierten Widgets, die in Flutter verfügbar sind, wie Textfeld-Widgets, Container, Schaltflächen, ListTile und ListView. Er betont, wie wichtig es ist, die offizielle Dokumentation und IDE-Unterstützung zu verwenden, um Widgets zu verstehen und effektiv zu konfigurieren. Das Modul behandelt das Stylen und Konfigurieren von Widgets, das Theming in MaterialApp und das Hinzufügen von Geschäftslogik zur App mithilfe von Stateful Widgets. Das Konzept des Anhebens des Status wird hervorgehoben, um Daten zu verwalten und Änderungen innerhalb der App auszulösen. Darüber hinaus zeigt das Video, wie die Benutzeroberfläche basierend auf Logik angepasst werden kann, z. B. durch Anzeigen eines unteren Modalblatts für eine bessere Benutzererfahrung beim Hinzufügen neuer Transaktionen.",
                                // Chinese
                                "中国人": "在本模块中，演讲者讨论了 Flutter 中可用的各种自定义小部件和内置小部件，例如文本字段小部件、容器、按钮、ListTile 和 ListView。他们强调了使用官方文档和 IDE 支持来理解和有效配置小部件的重要性。该模块涵盖了小部件的样式和配置、MaterialApp 中的主题以及使用有状态小部件向应用添加业务逻辑。重点介绍了提升状态的概念，以管理数据并触发应用内的更改。此外，视频还演示了根据逻辑调整用户界面，例如在添加新交易时显示底部模式表以获得更好的用户体验。",
                                // Russian
                                "Русский": "В этом модуле докладчик обсуждает различные пользовательские виджеты и встроенные виджеты, доступные во Flutter, такие как виджеты текстовых полей, контейнеры, кнопки, ListTile и ListView. Они подчеркивают важность использования официальной документации и поддержки IDE для эффективного понимания и настройки виджетов. Модуль охватывает стилизацию и настройку виджетов, тематизацию в MaterialApp и добавление бизнес-логики в приложение с помощью виджетов с отслеживанием состояния. Концепция подъема состояния подчеркивается для управления данными и запуска изменений в приложении. Кроме того, в видео демонстрируется настройка пользовательского интерфейса на основе логики, например, отображение нижней модальной таблицы для лучшего пользовательского опыта при добавлении новых транзакций.",
                                // French
                                "Français": "Dans ce module, l'intervenant présente les différents widgets personnalisés et intégrés disponibles dans Flutter, tels que les widgets de champ de texte, les conteneurs, les boutons, ListTile et ListView. Il souligne l'importance d'utiliser la documentation officielle et le support IDE pour comprendre et configurer efficacement les widgets. Le module couvre le style et la configuration des widgets, la thématisation dans MaterialApp et l'ajout de logique métier à l'application à l'aide de widgets avec état. Le concept de remontée d'état est mis en évidence pour gérer les données et déclencher des modifications au sein de l'application. De plus, la vidéo montre comment ajuster l'interface utilisateur en fonction de la logique, comme l'affichage d'une feuille modale inférieure pour une meilleure expérience utilisateur lors de l'ajout de nouvelles transactions.",
                                // Japanese
                                "日本語": "このモジュールでは、テキスト フィールド ウィジェット、コンテナー、ボタン、ListTile、ListView など、Flutter で使用できるさまざまなカスタム ウィジェットと組み込みウィジェットについて説明します。ウィジェットを効果的に理解して構成するには、公式ドキュメントと IDE サポートを使用することの重要性を強調しています。このモジュールでは、ウィジェットのスタイル設定と構成、MaterialApp でのテーマ設定、ステートフル ウィジェットを使用したアプリへのビジネス ロジックの追加について説明します。アプリ内でデータを管理し、変更をトリガーするために、状態を上に持ち上げるという概念が強調されています。さらに、このビデオでは、新しいトランザクションを追加するときにユーザー エクスペリエンスを向上させるために下部のモーダル シートを表示するなど、ロジックに基づいてユーザー インターフェイスを調整する方法を示します。",
                                // Korean
                                "한국인": "이 모듈에서 발표자는 텍스트 필드 위젯, 컨테이너, 버튼, ListTile, ListView와 같은 Flutter에서 사용할 수 있는 다양한 사용자 지정 위젯과 기본 제공 위젯에 대해 설명합니다. 그들은 위젯을 효과적으로 이해하고 구성하기 위해 공식 문서와 IDE 지원을 사용하는 것의 중요성을 강조합니다. 이 모듈은 위젯 스타일링 및 구성, MaterialApp에서 테마 지정, 상태 저장 위젯을 사용하여 앱에 비즈니스 로직 추가를 다룹니다. 앱 내에서 데이터를 관리하고 변경을 트리거하기 위해 상태를 들어올리는 개념이 강조됩니다. 또한 이 비디오는 새 트랜잭션을 추가할 때 더 나은 사용자 경험을 위해 하단 모달 시트를 보여주는 것과 같이 로직에 따라 사용자 인터페이스를 조정하는 방법을 보여줍니다.",
                                // Spanish
                                "Español": "En este módulo, el orador analiza los distintos widgets personalizados y los widgets integrados disponibles en Flutter, como los widgets de campo de texto, los contenedores, los botones, ListTile y ListView. Destaca la importancia de utilizar la documentación oficial y el soporte de IDE para comprender y configurar los widgets de manera eficaz. El módulo cubre el estilo y la configuración de widgets, la creación de temas en MaterialApp y la incorporación de lógica empresarial a la aplicación mediante widgets con estado. Se destaca el concepto de elevación del estado para administrar datos y activar cambios dentro de la aplicación. Además, el video demuestra cómo ajustar la interfaz de usuario en función de la lógica, como mostrar una hoja modal inferior para una mejor experiencia de usuario al agregar nuevas transacciones.",
                                // Hindi
                                "हिंदी": "इस मॉड्यूल में, वक्ता फ़्लटर में उपलब्ध विभिन्न कस्टम विजेट और बिल्ट-इन विजेट जैसे टेक्स्ट फ़ील्ड विजेट, कंटेनर, बटन, लिस्टटाइल और लिस्टव्यू पर चर्चा करता है। वे विजेट को प्रभावी ढंग से समझने और कॉन्फ़िगर करने के लिए आधिकारिक दस्तावेज़ और IDE समर्थन का उपयोग करने के महत्व पर ज़ोर देते हैं। मॉड्यूल विजेट को स्टाइल करना और कॉन्फ़िगर करना, मटीरियलऐप में थीमिंग और स्टेटफुल विजेट का उपयोग करके ऐप में व्यावसायिक तर्क जोड़ना शामिल करता है। डेटा को प्रबंधित करने और ऐप के भीतर परिवर्तनों को ट्रिगर करने के लिए स्टेट को ऊपर उठाने की अवधारणा पर प्रकाश डाला गया है। इसके अतिरिक्त, वीडियो तर्क के आधार पर उपयोगकर्ता इंटरफ़ेस को समायोजित करने का प्रदर्शन करता है, जैसे नए लेनदेन जोड़ते समय बेहतर उपयोगकर्ता अनुभव के लिए नीचे एक मोडल शीट दिखाना।",
                                // Portuguese
                                "Português": "Neste módulo, o orador discute os vários widgets personalizados e widgets integrados disponíveis no Flutter, tais como widgets de campo de texto, contentores, botões, ListTile e ListView. Realçam a importância de utilizar a documentação oficial e o suporte do IDE para compreender e configurar widgets de forma eficaz. O módulo cobre o estilo e a configuração de widgets, temas na MaterialApp e adição de lógica de negócio à aplicação utilizando widgets com estado. O conceito de elevação do estado é destacado para gerir dados e desencadear alterações dentro da aplicação. Além disso, o vídeo demonstra o ajuste da interface do utilizador com base na lógica, como mostrar uma folha de cálculo modal inferior para uma melhor experiência do utilizador ao adicionar novas transações.",
                                // Bengali
                                "বাংলা": "এই মডিউলে, স্পিকার ফ্লটারে উপলব্ধ বিভিন্ন কাস্টম উইজেট এবং অন্তর্নির্মিত উইজেট নিয়ে আলোচনা করে, যেমন টেক্সট ফিল্ড উইজেট, কন্টেইনার, বোতাম, লিস্টটাইল এবং লিস্টভিউ। তারা কার্যকরভাবে উইজেটগুলি বুঝতে এবং কনফিগার করতে অফিসিয়াল ডকুমেন্টেশন এবং IDE সমর্থন ব্যবহার করার গুরুত্বের উপর জোর দেয়। মডিউলটি স্টাইলিং এবং কনফিগারিং উইজেট, মেটেরিয়ালঅ্যাপে থিমিং, এবং স্টেটফুল উইজেট ব্যবহার করে অ্যাপে ব্যবসায়িক যুক্তি যোগ করে। ডেটা পরিচালনা করতে এবং অ্যাপের মধ্যে পরিবর্তনগুলিকে ট্রিগার করতে স্টেট আপ তোলার ধারণাটি হাইলাইট করা হয়েছে। অতিরিক্তভাবে, ভিডিওটি যুক্তির উপর ভিত্তি করে ব্যবহারকারীর ইন্টারফেস সামঞ্জস্য করে দেখায়, যেমন নতুন লেনদেন যোগ করার সময় একটি ভাল ব্যবহারকারীর অভিজ্ঞতার জন্য নীচের মডেল শীট দেখানো।",
                                // Arabic
                                "عَرَبِيّ": "في هذه الوحدة، يناقش المتحدث الأدوات المخصصة المختلفة والأدوات المضمنة المتوفرة في Flutter، مثل أدوات حقول النص والحاويات والأزرار وListTile وListView. ويؤكدون على أهمية استخدام الوثائق الرسمية ودعم IDE لفهم الأدوات وتكوينها بشكل فعال. وتغطي الوحدة تصميم الأدوات وتكوينها، والموضوعات في MaterialApp، وإضافة منطق العمل إلى التطبيق باستخدام الأدوات ذات الحالة. ويتم تسليط الضوء على مفهوم رفع الحالة لإدارة البيانات وتحفيز التغييرات داخل التطبيق. بالإضافة إلى ذلك، يوضح الفيديو ضبط واجهة المستخدم بناءً على المنطق، مثل عرض ورقة نموذجية سفلية للحصول على تجربة مستخدم أفضل عند إضافة معاملات جديدة.",
                                // Persian
                                "فارسی": "در این ماژول، سخنران در مورد ویجت‌های سفارشی مختلف و ویجت‌های داخلی موجود در Flutter مانند ویجت‌های فیلد متنی، کانتینرها، دکمه‌ها، ListTile و ListView بحث می‌کند. آنها بر اهمیت استفاده از اسناد رسمی و پشتیبانی IDE برای درک و پیکربندی مؤثر ویجت ها تأکید می کنند. این ماژول شامل استایل‌سازی و پیکربندی ویجت‌ها، قالب‌بندی در MaterialApp، و افزودن منطق تجاری به برنامه با استفاده از ویجت‌های حالت است. مفهوم بالا بردن وضعیت برای مدیریت داده ها و ایجاد تغییرات در برنامه برجسته شده است. علاوه بر این، این ویدئو تنظیم رابط کاربری بر اساس منطق را نشان می‌دهد، مانند نمایش یک صفحه مدال پایین برای تجربه کاربری بهتر هنگام افزودن تراکنش‌های جدید.",
                            },
                        },
                    ]
                },
                // Section 5 : Responsive & Adaptive User Interfaces and Apps
                {
                    "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                    "Videos": [
                        // 103 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Module Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the importance of creating responsive and adaptive user interfaces and app designs with Flutter is discussed. The video explains how to make layouts that work on different devices and operating systems, as well as how to create platform-specific layouts for Android and iOS. The core tools provided by Flutter for creating responsive layouts are demonstrated, with a focus on turning an existing app into a responsive design that looks and feels different on various device sizes. The video also explores building different UIs for Android and iOS devices to cater to their specific design needs.",
                                // German
                                "Deutsch": "In diesem Video wird die Bedeutung der Erstellung responsiver und adaptiver Benutzeroberflächen und App-Designs mit Flutter erläutert. Das Video erklärt, wie Layouts erstellt werden, die auf verschiedenen Geräten und Betriebssystemen funktionieren, sowie wie plattformspezifische Layouts für Android und iOS erstellt werden. Die von Flutter bereitgestellten Kerntools zum Erstellen responsiver Layouts werden demonstriert, wobei der Schwerpunkt auf der Umwandlung einer vorhandenen App in ein responsives Design liegt, das auf verschiedenen Gerätegrößen unterschiedlich aussieht und sich unterschiedlich anfühlt. Das Video untersucht auch die Erstellung verschiedener Benutzeroberflächen für Android- und iOS-Geräte, um deren spezifischen Designanforderungen gerecht zu werden.",
                                // Chinese
                                "中国人": "本视频讨论了使用 Flutter 创建响应式和自适应用户界面和应用设计的重要性。视频介绍了如何制作适用于不同设备和操作系统的布局，以及如何为 Android 和 iOS 创建特定于平台的布局。视频演示了 Flutter 提供的用于创建响应式布局的核心工具，重点是将现有应用转变为响应式设计，使其在不同尺寸的设备上看起来和感觉都不同。视频还探讨了为 Android 和 iOS 设备构建不同的 UI 以满足其特定的设计需求。",
                                // Russian
                                "Русский": "В этом видео обсуждается важность создания отзывчивых и адаптивных пользовательских интерфейсов и дизайнов приложений с помощью Flutter. В видео объясняется, как создавать макеты, которые работают на разных устройствах и операционных системах, а также как создавать платформенно-зависимые макеты для Android и iOS. Демонстрируются основные инструменты, предоставляемые Flutter для создания отзывчивых макетов, с акцентом на превращение существующего приложения в отзывчивый дизайн, который выглядит и ощущается по-разному на устройствах разных размеров. В видео также рассматривается создание различных пользовательских интерфейсов для устройств Android и iOS для удовлетворения их особых потребностей в дизайне.",
                                // French
                                "Français": "Dans cette vidéo, nous abordons l'importance de créer des interfaces utilisateur et des conceptions d'applications réactives et adaptatives avec Flutter. La vidéo explique comment créer des mises en page qui fonctionnent sur différents appareils et systèmes d'exploitation, ainsi que comment créer des mises en page spécifiques à la plate-forme pour Android et iOS. Les principaux outils fournis par Flutter pour créer des mises en page réactives sont présentés, en mettant l'accent sur la transformation d'une application existante en une conception réactive qui présente une apparence et une convivialité différentes sur différentes tailles d'appareils. La vidéo explore également la création de différentes interfaces utilisateur pour les appareils Android et iOS afin de répondre à leurs besoins de conception spécifiques.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter を使用してレスポンシブで適応性の高いユーザー インターフェースとアプリ デザインを作成することの重要性について説明します。ビデオでは、さまざまなデバイスやオペレーティング システムで機能するレイアウトの作成方法と、Android および iOS 用のプラットフォーム固有のレイアウトの作成方法について説明します。レスポンシブ レイアウトを作成するために Flutter が提供するコア ツールのデモでは、既存のアプリをさまざまなデバイス サイズで外観や操作感が異なるレスポンシブ デザインに変換することに重点を置いています。ビデオでは、Android および iOS デバイス用のさまざまな UI を構築して、それぞれの特定のデザイン ニーズに対応する方法についても説明します。",
                                // Korean
                                "한국인": "이 영상에서는 Flutter로 반응형 및 적응형 사용자 인터페이스와 앱 디자인을 만드는 것의 중요성에 대해 설명합니다. 이 영상에서는 다양한 기기와 운영 체제에서 작동하는 레이아웃을 만드는 방법과 Android 및 iOS용 플랫폼별 레이아웃을 만드는 방법을 설명합니다. Flutter에서 제공하는 반응형 레이아웃을 만드는 핵심 도구를 시연하며, 기존 앱을 다양한 기기 크기에서 다르게 보이고 느껴지는 반응형 디자인으로 전환하는 데 중점을 둡니다. 또한 이 영상에서는 Android 및 iOS 기기에 맞는 다양한 UI를 구축하여 해당 기기의 특정 디자인 요구 사항을 충족하는 방법도 살펴봅니다.",
                                // Spanish
                                "Español": "En este video, se analiza la importancia de crear interfaces de usuario y diseños de aplicaciones adaptables y responsivos con Flutter. El video explica cómo crear diseños que funcionen en diferentes dispositivos y sistemas operativos, así como también cómo crear diseños específicos para plataformas Android e iOS. Se muestran las herramientas principales que ofrece Flutter para crear diseños responsivos, con el foco puesto en convertir una aplicación existente en un diseño responsivo que se vea y se sienta diferente en distintos tamaños de dispositivos. El video también explora la creación de diferentes IU para dispositivos Android e iOS para satisfacer sus necesidades de diseño específicas.",
                                // Hindi
                                "हिंदी": "इस वीडियो में फ़्लटर के साथ रिस्पॉन्सिव और अनुकूली उपयोगकर्ता इंटरफ़ेस और ऐप डिज़ाइन बनाने के महत्व पर चर्चा की गई है। वीडियो बताता है कि विभिन्न डिवाइस और ऑपरेटिंग सिस्टम पर काम करने वाले लेआउट कैसे बनाएं, साथ ही एंड्रॉइड और iOS के लिए प्लेटफ़ॉर्म-विशिष्ट लेआउट कैसे बनाएं। फ़्लटर द्वारा रिस्पॉन्सिव लेआउट बनाने के लिए दिए गए मुख्य टूल का प्रदर्शन किया गया है, जिसमें मौजूदा ऐप को ऐसे रिस्पॉन्सिव डिज़ाइन में बदलने पर ध्यान केंद्रित किया गया है जो विभिन्न डिवाइस साइज़ पर अलग दिखता और महसूस होता है। वीडियो एंड्रॉइड और iOS डिवाइस के लिए उनकी विशिष्ट डिज़ाइन आवश्यकताओं को पूरा करने के लिए अलग-अलग UI बनाने की भी खोज करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, é discutida a importância de criar interfaces de utilizador e designs de aplicações responsivos e adaptáveis ​​com Flutter. O vídeo explica como fazer layouts que funcionem em diferentes dispositivos e sistemas operativos, bem como como criar layouts específicos de plataforma para Android e iOS. São demonstradas as principais ferramentas fornecidas pelo Flutter para a criação de layouts responsivos, com foco na transformação de uma aplicação existente num design responsivo que tem um aspeto diferente em vários tamanhos de dispositivos. O vídeo também explora a construção de diferentes UIs para dispositivos Android e iOS para satisfazer as suas necessidades específicas de design.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, Flutter সহ প্রতিক্রিয়াশীল এবং অভিযোজিত ব্যবহারকারী ইন্টারফেস এবং অ্যাপ ডিজাইন তৈরি করার গুরুত্ব নিয়ে আলোচনা করা হয়েছে। ভিডিওটি ব্যাখ্যা করে যে কীভাবে বিভিন্ন ডিভাইস এবং অপারেটিং সিস্টেমে কাজ করে এমন লেআউট তৈরি করতে হয়, সেইসাথে কীভাবে অ্যান্ড্রয়েড এবং আইওএসের জন্য প্ল্যাটফর্ম-নির্দিষ্ট লেআউট তৈরি করতে হয়। প্রতিক্রিয়াশীল লেআউট তৈরির জন্য Flutter দ্বারা প্রদত্ত মূল সরঞ্জামগুলি প্রদর্শন করা হয়, একটি বিদ্যমান অ্যাপকে একটি প্রতিক্রিয়াশীল ডিজাইনে পরিণত করার উপর ফোকাস সহ যা বিভিন্ন ডিভাইসের আকারে আলাদা দেখায় এবং অনুভব করে। ভিডিওটি অ্যান্ড্রয়েড এবং আইওএস ডিভাইসগুলির জন্য তাদের নির্দিষ্ট ডিজাইনের চাহিদা মেটাতে বিভিন্ন UI তৈরিরও অন্বেষণ করে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، تتم مناقشة أهمية إنشاء واجهات مستخدم وتصميمات تطبيقات متجاوبة وقابلة للتكيف باستخدام Flutter. يشرح الفيديو كيفية إنشاء تخطيطات تعمل على أجهزة وأنظمة تشغيل مختلفة، بالإضافة إلى كيفية إنشاء تخطيطات خاصة بالمنصة لنظامي التشغيل Android وiOS. يتم توضيح الأدوات الأساسية التي يوفرها Flutter لإنشاء تخطيطات متجاوبة، مع التركيز على تحويل التطبيق الحالي إلى تصميم متجاوب يبدو مختلفًا على أحجام الأجهزة المختلفة. يستكشف الفيديو أيضًا إنشاء واجهات مستخدم مختلفة لأجهزة Android وiOS لتلبية احتياجات التصميم الخاصة بها.",
                                // Persian
                                "فارسی": "در این ویدیو به اهمیت ایجاد رابط های کاربری واکنش گرا و تطبیقی ​​و طراحی اپلیکیشن با فلاتر پرداخته شده است. این ویدئو نحوه ساخت طرح‌بندی‌هایی را که روی دستگاه‌ها و سیستم‌عامل‌های مختلف کار می‌کنند و همچنین نحوه ایجاد طرح‌بندی‌های مخصوص پلتفرم برای اندروید و iOS را توضیح می‌دهد. ابزارهای اصلی ارائه شده توسط Flutter برای ایجاد طرح‌بندی‌های واکنش‌گرا، با تمرکز بر تبدیل یک برنامه موجود به یک طراحی واکنش‌گرا که در اندازه‌های مختلف دستگاه متفاوت به نظر می‌رسد، نشان داده شده‌اند. این ویدئو همچنین به بررسی ساخت رابط‌های کاربری مختلف برای دستگاه‌های اندروید و iOS می‌پردازد تا نیازهای طراحی خاص آن‌ها را برآورده کند.",
                            },
                        },
                        // 104 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "What does _Responsive_ and _Adaptive_ Mean",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video explains the concepts of responsive and adaptive design in user interfaces for different devices and operating systems with Flutter. The importance of creating layouts that work well on various screen sizes, orientations, and platforms such as Android and iOS is discussed. The video emphasizes the need to maintain a single code base in order to avoid managing multiple projects, and demonstrates how to use Flutter tools to build responsive and adaptive apps within a single project. Examples are provided on how to adjust the app's appearance and behavior based on the platform and device size, while ensuring a cohesive widget tree structure in the Flutter app. The goal is to have a consistent user experience across different platforms while maximizing code reusability.",
                                // German
                                "Deutsch": "In diesem Video werden die Konzepte des responsiven und adaptiven Designs in Benutzeroberflächen für verschiedene Geräte und Betriebssysteme mit Flutter erläutert. Es wird die Bedeutung der Erstellung von Layouts erläutert, die auf verschiedenen Bildschirmgrößen, Ausrichtungen und Plattformen wie Android und iOS gut funktionieren. Das Video betont die Notwendigkeit, eine einzige Codebasis beizubehalten, um die Verwaltung mehrerer Projekte zu vermeiden, und zeigt, wie Sie mit Flutter-Tools responsive und adaptive Apps innerhalb eines einzigen Projekts erstellen können. Es werden Beispiele bereitgestellt, wie Sie das Erscheinungsbild und Verhalten der App basierend auf der Plattform und Gerätegröße anpassen und gleichzeitig eine zusammenhängende Widget-Baumstruktur in der Flutter-App sicherstellen können. Das Ziel besteht darin, ein konsistentes Benutzererlebnis über verschiedene Plattformen hinweg zu bieten und gleichzeitig die Wiederverwendbarkeit des Codes zu maximieren.",
                                // Chinese
                                "中国人": "本视频介绍了使用 Flutter 为不同设备和操作系统设计用户界面的响应式和自适应设计概念。视频讨论了创建适用于各种屏幕尺寸、方向和 Android 和 iOS 等平台的布局的重要性。视频强调了维护单一代码库以避免管理多个项目的必要性，并演示了如何使用 Flutter 工具在单个项目中构建响应式和自适应应用程序。视频提供了有关如何根据平台和设备尺寸调整应用程序外观和行为的示例，同时确保 Flutter 应用程序中的小部件树结构具有凝聚力。目标是在不同平台上获得一致的用户体验，同时最大限度地提高代码的可重用性。",
                                // Russian
                                "Русский": "В этом видео объясняются концепции отзывчивого и адаптивного дизайна в пользовательских интерфейсах для различных устройств и операционных систем с Flutter. Обсуждается важность создания макетов, которые хорошо работают на экранах разных размеров, ориентаций и платформах, таких как Android и iOS. В видео подчеркивается необходимость поддержания единой кодовой базы, чтобы избежать управления несколькими проектами, и демонстрируется, как использовать инструменты Flutter для создания отзывчивых и адаптивных приложений в рамках одного проекта. Приводятся примеры того, как настроить внешний вид и поведение приложения в зависимости от платформы и размера устройства, обеспечивая при этом целостную структуру дерева виджетов в приложении Flutter. Цель состоит в том, чтобы обеспечить единообразный пользовательский опыт на разных платформах, максимизируя при этом возможность повторного использования кода.",
                                // French
                                "Français": "Cette vidéo explique les concepts de conception réactive et adaptative dans les interfaces utilisateur pour différents appareils et systèmes d'exploitation avec Flutter. L'importance de créer des mises en page qui fonctionnent bien sur différentes tailles d'écran, orientations et plates-formes telles qu'Android et iOS est abordée. La vidéo souligne la nécessité de conserver une base de code unique afin d'éviter de gérer plusieurs projets et montre comment utiliser les outils Flutter pour créer des applications réactives et adaptatives au sein d'un seul projet. Des exemples sont fournis sur la façon d'ajuster l'apparence et le comportement de l'application en fonction de la plate-forme et de la taille de l'appareil, tout en garantissant une structure d'arborescence de widgets cohérente dans l'application Flutter. L'objectif est d'avoir une expérience utilisateur cohérente sur différentes plates-formes tout en maximisant la réutilisabilité du code.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter を使用したさまざまなデバイスやオペレーティング システムのユーザー インターフェースにおけるレスポンシブ デザインとアダプティブ デザインの概念について説明します。Android や iOS などのさまざまな画面サイズ、向き、プラットフォームで適切に機能するレイアウトを作成することの重要性について説明します。このビデオでは、複数のプロジェクトを管理することを避けるために単一のコード ベースを維持する必要性を強調し、Flutter ツールを使用して単一のプロジェクト内でレスポンシブでアダプティブなアプリを構築する方法を示します。プラットフォームとデバイスのサイズに基づいてアプリの外観と動作を調整しながら、Flutter アプリで一貫性のあるウィジェット ツリー構造を確保する方法の例を示します。目標は、コードの再利用性を最大限に高めながら、さまざまなプラットフォームで一貫したユーザー エクスペリエンスを実現することです。",
                                // Korean
                                "한국인": "이 비디오에서는 Flutter를 사용하여 다양한 기기와 운영 체제의 사용자 인터페이스에서 반응형 및 적응형 디자인의 개념을 설명합니다. Android 및 iOS와 같은 다양한 화면 크기, 방향 및 플랫폼에서 잘 작동하는 레이아웃을 만드는 것의 중요성에 대해 설명합니다. 이 비디오는 여러 프로젝트를 관리하지 않기 위해 단일 코드 기반을 유지해야 할 필요성을 강조하고 Flutter 도구를 사용하여 단일 프로젝트 내에서 반응형 및 적응형 앱을 빌드하는 방법을 보여줍니다. Flutter 앱에서 응집력 있는 위젯 트리 구조를 보장하면서 플랫폼 및 기기 크기에 따라 앱의 모양과 동작을 조정하는 방법에 대한 예가 제공됩니다. 목표는 코드 재사용성을 극대화하는 동시에 다양한 플랫폼에서 일관된 사용자 경험을 제공하는 것입니다.",
                                // Spanish
                                "Español": "이 비디오에서는 Flutter를 사용하여 다양한 기기와 운영 체제의 사용자 인터페이스에서 반응형 및 적응형 디자인의 개념을 설명합니다. Android 및 iOS와 같은 다양한 화면 크기, 방향 및 플랫폼에서 잘 작동하는 레이아웃을 만드는 것의 중요성에 대해 설명합니다. 이 비디오는 여러 프로젝트를 관리하지 않기 위해 단일 코드 기반을 유지해야 할 필요성을 강조하고 Flutter 도구를 사용하여 단일 프로젝트 내에서 반응형 및 적응형 앱을 빌드하는 방법을 보여줍니다. Flutter 앱에서 응집력 있는 위젯 트리 구조를 보장하면서 플랫폼 및 기기 크기에 따라 앱의 모양과 동작을 조정하는 방법에 대한 예가 제공됩니다. 목표는 코드 재사용성을 극대화하는 동시에 다양한 플랫폼에서 일관된 사용자 경험을 제공하는 것입니다.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर के साथ विभिन्न डिवाइस और ऑपरेटिंग सिस्टम के लिए उपयोगकर्ता इंटरफ़ेस में उत्तरदायी और अनुकूली डिज़ाइन की अवधारणाओं को समझाता है। विभिन्न स्क्रीन आकारों, ओरिएंटेशन और एंड्रॉइड और आईओएस जैसे प्लेटफ़ॉर्म पर अच्छी तरह से काम करने वाले लेआउट बनाने के महत्व पर चर्चा की गई है। वीडियो कई प्रोजेक्ट्स को मैनेज करने से बचने के लिए सिंगल कोड बेस बनाए रखने की आवश्यकता पर जोर देता है, और प्रदर्शित करता है कि एक ही प्रोजेक्ट के भीतर उत्तरदायी और अनुकूली ऐप बनाने के लिए फ़्लटर टूल का उपयोग कैसे करें। प्लेटफ़ॉर्म और डिवाइस के आकार के आधार पर ऐप की उपस्थिति और व्यवहार को समायोजित करने के तरीके पर उदाहरण दिए गए हैं, जबकि फ़्लटर ऐप में एक सुसंगत विजेट ट्री संरचना सुनिश्चित की गई है। लक्ष्य कोड पुन: प्रयोज्यता को अधिकतम करते हुए विभिन्न प्लेटफ़ॉर्म पर एक समान उपयोगकर्ता अनुभव प्राप्त करना है।",
                                // Portuguese
                                "Português": "यह वीडियो फ़्लटर के साथ विभिन्न डिवाइस और ऑपरेटिंग सिस्टम के लिए उपयोगकर्ता इंटरफ़ेस में उत्तरदायी और अनुकूली डिज़ाइन की अवधारणाओं को समझाता है। विभिन्न स्क्रीन आकारों, ओरिएंटेशन और एंड्रॉइड और आईओएस जैसे प्लेटफ़ॉर्म पर अच्छी तरह से काम करने वाले लेआउट बनाने के महत्व पर चर्चा की गई है। वीडियो कई प्रोजेक्ट्स को मैनेज करने से बचने के लिए सिंगल कोड बेस बनाए रखने की आवश्यकता पर जोर देता है, और प्रदर्शित करता है कि एक ही प्रोजेक्ट के भीतर उत्तरदायी और अनुकूली ऐप बनाने के लिए फ़्लटर टूल का उपयोग कैसे करें। प्लेटफ़ॉर्म और डिवाइस के आकार के आधार पर ऐप की उपस्थिति और व्यवहार को समायोजित करने के तरीके पर उदाहरण दिए गए हैं, जबकि फ़्लटर ऐप में एक सुसंगत विजेट ट्री संरचना सुनिश्चित की गई है। लक्ष्य कोड पुन: प्रयोज्यता को अधिकतम करते हुए विभिन्न प्लेटफ़ॉर्म पर एक समान उपयोगकर्ता अनुभव प्राप्त करना है।",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি ফ্লটার সহ বিভিন্ন ডিভাইস এবং অপারেটিং সিস্টেমের ব্যবহারকারী ইন্টারফেসে প্রতিক্রিয়াশীল এবং অভিযোজিত ডিজাইনের ধারণাগুলি ব্যাখ্যা করে। বিভিন্ন স্ক্রীন সাইজ, ওরিয়েন্টেশন এবং অ্যান্ড্রয়েড এবং আইওএসের মতো প্ল্যাটফর্মে ভালোভাবে কাজ করে এমন লেআউট তৈরির গুরুত্ব নিয়ে আলোচনা করা হয়েছে। ভিডিওটি একাধিক প্রকল্প পরিচালনা এড়াতে একটি একক কোড বেস বজায় রাখার প্রয়োজনীয়তার উপর জোর দেয় এবং একটি একক প্রকল্পের মধ্যে প্রতিক্রিয়াশীল এবং অভিযোজিত অ্যাপ্লিকেশনগুলি তৈরি করতে ফ্লটার টুলগুলি কীভাবে ব্যবহার করতে হয় তা প্রদর্শন করে৷ Flutter অ্যাপে একটি সমন্বিত উইজেট ট্রি কাঠামো নিশ্চিত করার সময় প্ল্যাটফর্ম এবং ডিভাইসের আকারের উপর ভিত্তি করে অ্যাপের চেহারা এবং আচরণ কীভাবে সামঞ্জস্য করা যায় তার উদাহরণ দেওয়া হয়েছে। লক্ষ্য হল কোড পুনর্ব্যবহারযোগ্যতা সর্বাধিক করার সময় বিভিন্ন প্ল্যাটফর্ম জুড়ে একটি ধারাবাহিক ব্যবহারকারীর অভিজ্ঞতা থাকা।",
                                // Arabic
                                "عَرَبِيّ": "يوضح هذا الفيديو مفاهيم التصميم المستجيب والتكيفي في واجهات المستخدم للأجهزة وأنظمة التشغيل المختلفة باستخدام Flutter. تتم مناقشة أهمية إنشاء تخطيطات تعمل بشكل جيد على أحجام شاشات وتوجهات ومنصات مختلفة مثل Android وiOS. يؤكد الفيديو على الحاجة إلى الحفاظ على قاعدة كود واحدة لتجنب إدارة مشاريع متعددة، ويوضح كيفية استخدام أدوات Flutter لبناء تطبيقات مستجيبة وتكيفية داخل مشروع واحد. يتم توفير أمثلة حول كيفية ضبط مظهر التطبيق وسلوكه بناءً على المنصة وحجم الجهاز، مع ضمان بنية شجرة عناصر واجهة مستخدم متماسكة في تطبيق Flutter. الهدف هو الحصول على تجربة مستخدم متسقة عبر منصات مختلفة مع تعظيم إمكانية إعادة استخدام الكود.",
                                // Persian
                                "فارسی": "در این ویدیو مفاهیم طراحی واکنشگرا و تطبیقی ​​در رابط های کاربری دستگاه ها و سیستم عامل های مختلف با فلاتر توضیح داده شده است. اهمیت ایجاد طرح‌بندی‌هایی که در اندازه‌ها، جهت‌گیری‌ها و پلتفرم‌های مختلف صفحه نمایش به خوبی کار می‌کنند مانند Android و iOS مورد بحث قرار گرفته است. این ویدئو بر نیاز به حفظ یک پایه کد واحد برای جلوگیری از مدیریت پروژه های متعدد تاکید می کند و نحوه استفاده از ابزارهای Flutter را برای ساخت اپلیکیشن های پاسخگو و سازگار در یک پروژه نشان می دهد. مثال هایی در مورد نحوه تنظیم ظاهر و رفتار برنامه بر اساس پلت فرم و اندازه دستگاه ارائه شده است، در حالی که از ساختار درختی ویجت منسجم در برنامه Flutter اطمینان حاصل می شود. هدف، داشتن یک تجربه کاربری ثابت در پلتفرم‌های مختلف و در عین حال به حداکثر رساندن قابلیت استفاده مجدد کد است.",
                            },
                        },
                        // 105 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Examples_ Where we could improve the App!",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the concept of responsiveness in user interface design is explored through an example application. The video highlights issues that arise when the app is rotated to landscape mode, including difficulty scrolling certain elements and container heights exceeding the screen boundaries. The presenter discusses solutions such as dynamically calculating container heights based on device size and adjusting layout elements to fit within the available space without the need for scrolling. The importance of optimizing layouts for different screen orientations and device sizes is emphasized, with plans to implement these adjustments in future lectures for improved responsiveness.",
                                // German
                                "Deutsch": "In diesem Video wird das Konzept der Reaktionsfähigkeit im Benutzeroberflächendesign anhand einer Beispielanwendung untersucht. Das Video zeigt Probleme auf, die auftreten, wenn die App in den Querformatmodus gedreht wird, darunter Schwierigkeiten beim Scrollen bestimmter Elemente und Containerhöhen, die die Bildschirmgrenzen überschreiten. Der Moderator erörtert Lösungen wie die dynamische Berechnung der Containerhöhen basierend auf der Gerätegröße und die Anpassung von Layoutelementen, damit sie in den verfügbaren Platz passen, ohne dass gescrollt werden muss. Die Bedeutung der Optimierung von Layouts für unterschiedliche Bildschirmausrichtungen und Gerätegrößen wird hervorgehoben. Es ist geplant, diese Anpassungen in zukünftigen Vorträgen zur Verbesserung der Reaktionsfähigkeit umzusetzen.",
                                // Chinese
                                "中国人": "在本视频中，通过示例应用程序探索了用户界面设计中的响应性概念。视频重点介绍了应用程序旋转到横向模式时出现的问题，包括难以滚动某些元素以及容器高度超出屏幕边界。演示者讨论了一些解决方案，例如根据设备尺寸动态计算容器高度以及调整布局元素以适应可用空间而无需滚动。强调了针对不同屏幕方向和设备尺寸优化布局的重要性，并计划在未来的讲座中实施这些调整以提高响应性。",
                                // Russian
                                "Русский": "В этом видео концепция отзывчивости в дизайне пользовательского интерфейса рассматривается на примере приложения. Видео освещает проблемы, возникающие при повороте приложения в ландшафтный режим, включая трудности с прокруткой определенных элементов и превышение высоты контейнера границ экрана. Докладчик обсуждает такие решения, как динамический расчет высоты контейнера на основе размера устройства и корректировка элементов макета для размещения в доступном пространстве без необходимости прокрутки. Подчеркивается важность оптимизации макетов для различных ориентаций экрана и размеров устройств, и планируется реализовать эти корректировки в будущих лекциях для улучшения отзывчивости.",
                                // French
                                "Français": "Dans cette vidéo, le concept de réactivité dans la conception d'interface utilisateur est exploré à travers un exemple d'application. La vidéo met en évidence les problèmes qui surviennent lorsque l'application est tournée en mode paysage, notamment la difficulté de faire défiler certains éléments et les hauteurs de conteneur dépassant les limites de l'écran. Le présentateur discute de solutions telles que le calcul dynamique des hauteurs de conteneur en fonction de la taille de l'appareil et l'ajustement des éléments de mise en page pour s'adapter à l'espace disponible sans avoir besoin de faire défiler l'écran. L'importance d'optimiser les mises en page pour différentes orientations d'écran et tailles d'appareils est soulignée, avec des plans pour mettre en œuvre ces ajustements dans les prochaines conférences pour une meilleure réactivité.",
                                // Japanese
                                "日本語": "このビデオでは、サンプル アプリケーションを通じて、ユーザー インターフェイス デザインにおける応答性の概念について説明します。ビデオでは、特定の要素のスクロールが困難になったり、コンテナーの高さが画面の境界を超えたりするなど、アプリを横向きにしたときに発生する問題について説明します。プレゼンターは、デバイスのサイズに基づいてコンテナーの高さを動的に計算したり、スクロールせずに使用可能なスペースに収まるようにレイアウト要素を調整したりするなどのソリューションについて説明します。さまざまな画面の向きやデバイスのサイズに合わせてレイアウトを最適化することの重要性が強調されており、今後の講義では応答性を向上させるためにこれらの調整を実装する予定です。",
                                // Korean
                                "한국인": "이 영상에서는 사용자 인터페이스 디자인에서 반응성이라는 개념을 예제 애플리케이션을 통해 살펴봅니다. 이 영상에서는 앱을 가로 모드로 회전할 때 발생하는 문제, 즉 특정 요소를 스크롤하는 데 어려움이 있고 컨테이너 높이가 화면 경계를 초과하는 문제를 강조합니다. 발표자는 장치 크기에 따라 컨테이너 높이를 동적으로 계산하고 스크롤할 필요 없이 사용 가능한 공간에 맞게 레이아웃 요소를 조정하는 것과 같은 솔루션을 논의합니다. 다양한 화면 방향과 장치 크기에 맞게 레이아웃을 최적화하는 것의 중요성을 강조하며, 향후 강의에서 이러한 조정을 구현하여 반응성을 개선할 계획입니다.",
                                // Spanish
                                "Español": "En este video, se explora el concepto de capacidad de respuesta en el diseño de la interfaz de usuario a través de una aplicación de ejemplo. El video destaca los problemas que surgen cuando la aplicación se gira al modo horizontal, incluida la dificultad para desplazarse por ciertos elementos y las alturas de los contenedores que exceden los límites de la pantalla. El presentador analiza soluciones como el cálculo dinámico de las alturas de los contenedores en función del tamaño del dispositivo y el ajuste de los elementos del diseño para que se ajusten al espacio disponible sin necesidad de desplazarse. Se enfatiza la importancia de optimizar los diseños para diferentes orientaciones de pantalla y tamaños de dispositivos, y se planea implementar estos ajustes en futuras conferencias para mejorar la capacidad de respuesta.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, उपयोगकर्ता इंटरफ़ेस डिज़ाइन में प्रतिक्रियाशीलता की अवधारणा को एक उदाहरण एप्लिकेशन के माध्यम से खोजा गया है। वीडियो उन समस्याओं पर प्रकाश डालता है जो ऐप को लैंडस्केप मोड में घुमाए जाने पर उत्पन्न होती हैं, जिसमें कुछ तत्वों को स्क्रॉल करने में कठिनाई और स्क्रीन की सीमाओं से अधिक कंटेनर की ऊँचाई शामिल है। प्रस्तुतकर्ता डिवाइस के आकार के आधार पर कंटेनर की ऊँचाई की गतिशील रूप से गणना करने और स्क्रॉलिंग की आवश्यकता के बिना उपलब्ध स्थान के भीतर फिट होने के लिए लेआउट तत्वों को समायोजित करने जैसे समाधानों पर चर्चा करता है। विभिन्न स्क्रीन ओरिएंटेशन और डिवाइस आकारों के लिए लेआउट को अनुकूलित करने के महत्व पर जोर दिया गया है, साथ ही बेहतर प्रतिक्रियाशीलता के लिए भविष्य के व्याख्यानों में इन समायोजनों को लागू करने की योजना है।",
                                // Portuguese
                                "Português": "Neste vídeo, o conceito de capacidade de resposta no design da interface do utilizador é explorado através de um exemplo de aplicação. O vídeo destaca problemas que surgem quando a aplicação é rodada para o modo paisagem, incluindo a dificuldade de deslocação de certos elementos e alturas de contentores que excedem os limites do ecrã. O apresentador discute soluções como calcular dinamicamente as alturas dos contentores com base no tamanho do dispositivo e ajustar os elementos do layout para caber no espaço disponível sem a necessidade de fazer scroll. É enfatizada a importância de otimizar os layouts para diferentes orientações do ecrã e tamanhos de dispositivos, com planos para implementar estes ajustes em palestras futuras para melhorar a capacidade de resposta.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, ব্যবহারকারী ইন্টারফেস ডিজাইনে প্রতিক্রিয়াশীলতার ধারণাটি একটি উদাহরণ অ্যাপ্লিকেশনের মাধ্যমে অন্বেষণ করা হয়েছে। অ্যাপটিকে ল্যান্ডস্কেপ মোডে ঘোরানো হলে যে সমস্যাগুলি দেখা দেয় ভিডিওটি হাইলাইট করে, যার মধ্যে কিছু উপাদান স্ক্রোল করতে অসুবিধা এবং কন্টেইনারের উচ্চতা স্ক্রীনের সীমানা অতিক্রম করা সহ। উপস্থাপক ডিভাইসের আকারের উপর ভিত্তি করে গতিশীলভাবে কন্টেইনারের উচ্চতা গণনা করা এবং স্ক্রল করার প্রয়োজন ছাড়াই উপলব্ধ স্থানের মধ্যে ফিট করার জন্য লেআউট উপাদানগুলিকে সামঞ্জস্য করার মতো সমাধানগুলি নিয়ে আলোচনা করে৷ বিভিন্ন স্ক্রীন ওরিয়েন্টেশন এবং ডিভাইসের আকারের জন্য লেআউট অপ্টিমাইজ করার গুরুত্বের উপর জোর দেওয়া হয়েছে, উন্নত প্রতিক্রিয়াশীলতার জন্য ভবিষ্যতের বক্তৃতায় এই সমন্বয়গুলি বাস্তবায়নের পরিকল্পনার সাথে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتم استكشاف مفهوم الاستجابة في تصميم واجهة المستخدم من خلال تطبيق مثال. يسلط الفيديو الضوء على المشكلات التي تنشأ عند تدوير التطبيق إلى الوضع الأفقي، بما في ذلك صعوبة تمرير عناصر معينة وارتفاعات الحاويات التي تتجاوز حدود الشاشة. يناقش مقدم العرض حلولاً مثل حساب ارتفاعات الحاويات ديناميكيًا بناءً على حجم الجهاز وضبط عناصر التخطيط لتناسب المساحة المتاحة دون الحاجة إلى التمرير. يتم التأكيد على أهمية تحسين التخطيطات لاتجاهات الشاشة المختلفة وأحجام الأجهزة، مع وجود خطط لتنفيذ هذه التعديلات في المحاضرات المستقبلية لتحسين الاستجابة.",
                                // Persian
                                "فارسی": "در این ویدئو مفهوم واکنش گرایی در طراحی رابط کاربری از طریق یک اپلیکیشن نمونه بررسی شده است. این ویدیو مشکلاتی را که هنگام چرخش برنامه به حالت افقی ایجاد می‌شود، برجسته می‌کند، از جمله مشکل در پیمایش عناصر خاص و ارتفاع کانتینر بیش از مرزهای صفحه. ارائه دهنده راه حل هایی مانند محاسبه پویا ارتفاع کانتینر بر اساس اندازه دستگاه و تنظیم عناصر چیدمان برای قرار گرفتن در فضای موجود بدون نیاز به پیمایش را مورد بحث قرار می دهد. اهمیت بهینه‌سازی طرح‌بندی‌ها برای جهت‌گیری‌های مختلف صفحه‌نمایش و اندازه‌های دستگاه، با برنامه‌ریزی برای پیاده‌سازی این تنظیمات در سخنرانی‌های آینده برای پاسخ‌دهی بهتر مورد تأکید قرار می‌گیرد.",
                            },
                        },
                        // 106 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Calculating Sizes Dynamically",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter demonstrates how to calculate the height of container widgets dynamically in a Flutter application using the MediaQuery class. By accessing device dimensions through MediaQuery.of(context), the video explains how to adjust container heights based on the available screen space, taking into account factors such as the app bar and status bar heights. The presenter illustrates the process of dynamically assigning heights to different widgets based on a percentage of the available screen space, ensuring that the app's layout adjusts appropriately to different device sizes. The video emphasizes the importance of considering various screen elements when calculating widget heights to create a responsive user interface design.",
                                // German
                                "Deutsch": "In diesem Video zeigt der Moderator, wie die Höhe von Container-Widgets in einer Flutter-Anwendung mithilfe der MediaQuery-Klasse dynamisch berechnet wird. Durch Zugriff auf die Geräteabmessungen über MediaQuery.of(context) erklärt das Video, wie Containerhöhen basierend auf dem verfügbaren Bildschirmplatz angepasst werden können, wobei Faktoren wie die Höhe der App-Leiste und der Statusleiste berücksichtigt werden. Der Moderator veranschaulicht den Prozess der dynamischen Zuweisung von Höhen zu verschiedenen Widgets basierend auf einem Prozentsatz des verfügbaren Bildschirmplatzes, um sicherzustellen, dass sich das Layout der App entsprechend an verschiedene Gerätegrößen anpasst. Das Video betont, wie wichtig es ist, bei der Berechnung der Widget-Höhen verschiedene Bildschirmelemente zu berücksichtigen, um ein ansprechendes Benutzeroberflächendesign zu erstellen.",
                                // Chinese
                                "中国人": "在此视频中，演示者演示了如何使用 MediaQuery 类在 Flutter 应用中动态计算容器小部件的高度。通过 MediaQuery.of(context) 访问设备尺寸，视频解释了如何根据可用屏幕空间调整容器高度，同时考虑到应用栏和状态栏高度等因素。演示者说明了根据可用屏幕空间的百分比动态为不同小部件分配高度的过程，以确保应用的布局能够根据不同的设备尺寸进行适当调整。视频强调了在计算小部件高度以创建响应式用户界面设计时考虑各种屏幕元素的重要性。",
                                // Russian
                                "Русский": "В этом видео ведущий демонстрирует, как динамически рассчитывать высоту виджетов-контейнеров в приложении Flutter с помощью класса MediaQuery. Получая доступ к размерам устройства через MediaQuery.of(context), видео объясняет, как регулировать высоту контейнеров на основе доступного пространства экрана, принимая во внимание такие факторы, как высота панели приложения и строки состояния. Ведущий иллюстрирует процесс динамического назначения высоты различным виджетам на основе процента доступного пространства экрана, гарантируя, что макет приложения будет соответствующим образом подстраиваться под различные размеры устройств. Видео подчеркивает важность учета различных элементов экрана при расчете высоты виджетов для создания адаптивного дизайна пользовательского интерфейса.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur montre comment calculer dynamiquement la hauteur des widgets de conteneur dans une application Flutter à l'aide de la classe MediaQuery. En accédant aux dimensions de l'appareil via MediaQuery.of(context), la vidéo explique comment ajuster les hauteurs des conteneurs en fonction de l'espace disponible sur l'écran, en tenant compte de facteurs tels que la hauteur de la barre d'application et de la barre d'état. Le présentateur illustre le processus d'attribution dynamique de hauteurs à différents widgets en fonction d'un pourcentage de l'espace disponible sur l'écran, garantissant ainsi que la mise en page de l'application s'adapte de manière appropriée aux différentes tailles d'appareils. La vidéo souligne l'importance de prendre en compte divers éléments de l'écran lors du calcul des hauteurs des widgets pour créer une conception d'interface utilisateur réactive.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが MediaQuery クラスを使用して Flutter アプリケーションでコンテナ ウィジェットの高さを動的に計算する方法を説明します。MediaQuery.of(context) を介してデバイスのサイズにアクセスすることで、アプリ バーやステータス バーの高さなどの要素を考慮しながら、使用可能な画面スペースに基づいてコンテナの高さを調整する方法について説明します。プレゼンターは、使用可能な画面スペースの割合に基づいてさまざまなウィジェットに高さを動的に割り当てるプロセスを示し、アプリのレイアウトがさまざまなデバイス サイズに適切に調整されるようにします。このビデオでは、ウィジェットの高さを計算してレスポンシブなユーザー インターフェイス デザインを作成する際に、さまざまな画面要素を考慮することの重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 MediaQuery 클래스를 사용하여 Flutter 애플리케이션에서 컨테이너 위젯의 높이를 동적으로 계산하는 방법을 보여줍니다. MediaQuery.of(context)를 통해 장치 차원에 액세스하여 앱 바 및 상태 표시줄 높이와 같은 요소를 고려하여 사용 가능한 화면 공간에 따라 컨테이너 높이를 조정하는 방법을 설명합니다. 발표자는 사용 가능한 화면 공간의 백분율에 따라 다양한 위젯에 높이를 동적으로 할당하는 프로세스를 보여 주며, 앱의 레이아웃이 다양한 장치 크기에 맞게 적절하게 조정되도록 합니다. 이 비디오는 반응형 사용자 인터페이스 디자인을 만들기 위해 위젯 높이를 계산할 때 다양한 화면 요소를 고려하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el presentador demuestra cómo calcular la altura de los widgets de contenedor de forma dinámica en una aplicación Flutter utilizando la clase MediaQuery. Al acceder a las dimensiones del dispositivo a través de MediaQuery.of(context), el video explica cómo ajustar las alturas de los contenedores en función del espacio de pantalla disponible, teniendo en cuenta factores como las alturas de la barra de la aplicación y de la barra de estado. El presentador ilustra el proceso de asignación dinámica de alturas a diferentes widgets en función de un porcentaje del espacio de pantalla disponible, lo que garantiza que el diseño de la aplicación se ajuste adecuadamente a diferentes tamaños de dispositivos. El video enfatiza la importancia de considerar varios elementos de la pantalla al calcular las alturas de los widgets para crear un diseño de interfaz de usuario responsivo.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता यह दर्शाता है कि MediaQuery क्लास का उपयोग करके फ़्लटर एप्लिकेशन में कंटेनर विजेट की ऊंचाई को गतिशील रूप से कैसे परिकलित किया जाए। MediaQuery.of(context) के माध्यम से डिवाइस आयामों तक पहुँचकर, वीडियो बताता है कि ऐप बार और स्टेटस बार की ऊँचाई जैसे कारकों को ध्यान में रखते हुए, उपलब्ध स्क्रीन स्पेस के आधार पर कंटेनर की ऊँचाई को कैसे समायोजित किया जाए। प्रस्तुतकर्ता उपलब्ध स्क्रीन स्पेस के प्रतिशत के आधार पर विभिन्न विजेट को ऊँचाई को गतिशील रूप से निर्दिष्ट करने की प्रक्रिया को दर्शाता है, यह सुनिश्चित करते हुए कि ऐप का लेआउट विभिन्न डिवाइस आकारों के लिए उचित रूप से समायोजित होता है। वीडियो एक उत्तरदायी उपयोगकर्ता इंटरफ़ेस डिज़ाइन बनाने के लिए विजेट की ऊँचाई की गणना करते समय विभिन्न स्क्रीन तत्वों पर विचार करने के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador demonstra como calcular a altura de widgets contentores dinamicamente numa aplicação Flutter utilizando a classe MediaQuery. Ao aceder às dimensões do dispositivo através de MediaQuery.of(context), o vídeo explica como ajustar as alturas dos contentores com base no espaço disponível no ecrã, tendo em conta fatores como a barra de aplicações e a altura da barra de estado. O apresentador ilustra o processo de atribuição dinâmica de alturas a diferentes widgets com base numa percentagem do espaço disponível no ecrã, garantindo que o layout da aplicação se ajusta adequadamente aos diferentes tamanhos de dispositivos. O vídeo enfatiza a importância de considerar vários elementos do ecrã ao calcular a altura dos widgets para criar um design de interface de utilizador responsivo.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক মিডিয়াকুয়েরি ক্লাস ব্যবহার করে একটি ফ্লাটার অ্যাপ্লিকেশনে গতিশীলভাবে কন্টেইনার উইজেটগুলির উচ্চতা কীভাবে গণনা করতে হয় তা প্রদর্শন করে। MediaQuery.of(context) এর মাধ্যমে ডিভাইসের মাত্রা অ্যাক্সেস করে, ভিডিওটি ব্যাখ্যা করে যে কীভাবে উপলব্ধ স্ক্রীনের স্থানের উপর ভিত্তি করে কন্টেইনারের উচ্চতা সামঞ্জস্য করা যায়, যেমন অ্যাপ বার এবং স্ট্যাটাস বারের উচ্চতার মতো বিষয়গুলি বিবেচনা করে। উপস্থাপক উপলব্ধ স্ক্রীন স্পেসের শতাংশের উপর ভিত্তি করে বিভিন্ন উইজেটগুলিতে গতিশীলভাবে উচ্চতা নির্ধারণের প্রক্রিয়াটি চিত্রিত করে, অ্যাপের বিন্যাসটি বিভিন্ন ডিভাইসের আকারের সাথে যথাযথভাবে সামঞ্জস্য করা নিশ্চিত করে৷ ভিডিওটি একটি প্রতিক্রিয়াশীল ইউজার ইন্টারফেস ডিজাইন তৈরি করতে উইজেটের উচ্চতা গণনা করার সময় বিভিন্ন স্ক্রীন উপাদান বিবেচনা করার গুরুত্বের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح مقدم العرض كيفية حساب ارتفاع عناصر واجهة المستخدم الرسومية للحاويات بشكل ديناميكي في تطبيق Flutter باستخدام فئة MediaQuery. من خلال الوصول إلى أبعاد الجهاز من خلال MediaQuery.of(context)، يشرح الفيديو كيفية ضبط ارتفاعات الحاوية بناءً على مساحة الشاشة المتاحة، مع مراعاة عوامل مثل ارتفاعات شريط التطبيق وشريط الحالة. يوضح مقدم العرض عملية تعيين الارتفاعات بشكل ديناميكي لعناصر واجهة المستخدم الرسومية المختلفة بناءً على نسبة من مساحة الشاشة المتاحة، مما يضمن تعديل تخطيط التطبيق بشكل مناسب لأحجام الأجهزة المختلفة. يؤكد الفيديو على أهمية مراعاة عناصر الشاشة المختلفة عند حساب ارتفاعات عناصر واجهة المستخدم الرسومية لإنشاء تصميم واجهة مستخدم متجاوب.",
                                // Persian
                                "فارسی": "در این ویدئو، ارائه دهنده نحوه محاسبه ارتفاع ویجت های کانتینر را به صورت پویا در یک برنامه Flutter با استفاده از کلاس MediaQuery نشان می دهد. با دسترسی به ابعاد دستگاه از طریق MediaQuery.of(context)، ویدئو نحوه تنظیم ارتفاع کانتینر بر اساس فضای صفحه نمایش موجود را با در نظر گرفتن عواملی مانند نوار برنامه و ارتفاع نوار وضعیت توضیح می‌دهد. ارائه‌دهنده فرآیند تخصیص پویا ارتفاع به ویجت‌های مختلف را بر اساس درصدی از فضای صفحه نمایش در دسترس نشان می‌دهد و اطمینان حاصل می‌کند که طرح‌بندی برنامه به‌طور مناسب با اندازه‌های مختلف دستگاه تنظیم می‌شود. این ویدئو بر اهمیت در نظر گرفتن عناصر مختلف صفحه هنگام محاسبه ارتفاع ویجت برای ایجاد یک طراحی رابط کاربری پاسخگو تاکید می کند.",
                            },
                        },
                        // 107 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Using the LayoutBuilder Widget",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter discusses adjusting the height of container widgets dynamically in a Flutter application to better utilize available screen space. The video demonstrates different ways to adjust the height of elements, such as the chart and transaction list, based on percentage allocations. The LayoutBuilder widget is introduced to dynamically calculate heights based on constraints and screen sizes, ensuring that widget elements are properly sized. The video emphasizes the importance of using relative heights for elements to create a responsive layout design that adapts to different device sizes and screen orientations. The presenter showcases the process of dynamically calculating and adjusting widget heights to optimize the app's layout for varying screen dimensions and orientations.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Moderator, wie die Höhe von Container-Widgets in einer Flutter-Anwendung dynamisch angepasst werden kann, um den verfügbaren Bildschirmplatz besser zu nutzen. Das Video zeigt verschiedene Möglichkeiten, die Höhe von Elementen wie Diagrammen und Transaktionslisten basierend auf prozentualen Zuweisungen anzupassen. Das LayoutBuilder-Widget wird vorgestellt, um Höhen basierend auf Einschränkungen und Bildschirmgrößen dynamisch zu berechnen und so sicherzustellen, dass Widget-Elemente die richtige Größe haben. Das Video betont, wie wichtig es ist, relative Höhen für Elemente zu verwenden, um ein ansprechendes Layout-Design zu erstellen, das sich an unterschiedliche Gerätegrößen und Bildschirmausrichtungen anpasst. Der Moderator demonstriert den Prozess der dynamischen Berechnung und Anpassung von Widget-Höhen, um das Layout der App für unterschiedliche Bildschirmabmessungen und -ausrichtungen zu optimieren.",
                                // Chinese
                                "中国人": "在此视频中，演示者讨论了如何在 Flutter 应用程序中动态调整容器小部件的高度，以更好地利用可用的屏幕空间。视频演示了根据百分比分配调整元素（例如图表和交易列表）高度的不同方法。引入了 LayoutBuilder 小部件以根据约束和屏幕尺寸动态计算高度，确保小部件元素的大小合适。视频强调了使用元素的相对高度来创建适应不同设备尺寸和屏幕方向的响应式布局设计的重要性。演示者展示了动态计算和调整小部件高度的过程，以优化应用程序的布局以适应不同的屏幕尺寸和方向。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает динамическую регулировку высоты виджетов-контейнеров в приложении Flutter для лучшего использования доступного пространства экрана. Видео демонстрирует различные способы регулировки высоты элементов, таких как диаграмма и список транзакций, на основе процентного распределения. Представлен виджет LayoutBuilder для динамического расчета высоты на основе ограничений и размеров экрана, гарантируя, что элементы виджета будут иметь правильный размер. Видео подчеркивает важность использования относительных высот для элементов для создания адаптивного дизайна макета, который адаптируется к различным размерам устройств и ориентациям экрана. Докладчик демонстрирует процесс динамического расчета и регулировки высоты виджетов для оптимизации макета приложения для различных размеров и ориентаций экрана.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur explique comment ajuster dynamiquement la hauteur des widgets de conteneur dans une application Flutter afin de mieux utiliser l'espace disponible sur l'écran. La vidéo montre différentes manières d'ajuster la hauteur des éléments, tels que le graphique et la liste des transactions, en fonction des allocations de pourcentage. Le widget LayoutBuilder est présenté pour calculer dynamiquement les hauteurs en fonction des contraintes et des tailles d'écran, garantissant ainsi que les éléments du widget sont correctement dimensionnés. La vidéo souligne l'importance d'utiliser des hauteurs relatives pour les éléments afin de créer une conception de mise en page réactive qui s'adapte à différentes tailles d'appareils et orientations d'écran. Le présentateur présente le processus de calcul et d'ajustement dynamiques des hauteurs des widgets pour optimiser la mise en page de l'application en fonction des différentes dimensions et orientations de l'écran.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが Flutter アプリケーションでコンテナ ウィジェットの高さを動的に調整して、利用可能な画面スペースをより有効に活用する方法について説明します。ビデオでは、パーセンテージ割り当てに基づいて、チャートやトランザクション リストなどの要素の高さを調整するさまざまな方法を紹介します。LayoutBuilder ウィジェットは、制約と画面サイズに基づいて高さを動的に計算し、ウィジェット要素が適切なサイズになるようにするために導入されています。ビデオでは、さまざまなデバイス サイズと画面の向きに適応するレスポンシブなレイアウト デザインを作成するために、要素に相対的な高さを使用することの重要性を強調しています。プレゼンターは、ウィジェットの高さを動的に計算して調整し、さまざまな画面のサイズと向きに合わせてアプリのレイアウトを最適化するプロセスを紹介します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 사용 가능한 화면 공간을 더 잘 활용하기 위해 Flutter 애플리케이션에서 컨테이너 위젯의 높이를 동적으로 조정하는 방법을 설명합니다. 이 비디오는 차트 및 거래 목록과 같은 요소의 높이를 백분율 할당에 따라 조정하는 다양한 방법을 보여줍니다. LayoutBuilder 위젯은 제약 조건과 화면 크기에 따라 높이를 동적으로 계산하여 위젯 요소의 크기가 적절하게 조정되도록 하는 데 사용됩니다. 이 비디오는 다양한 장치 크기와 화면 방향에 적응하는 반응형 레이아웃 디자인을 만들기 위해 요소의 상대 높이를 사용하는 것의 중요성을 강조합니다. 발표자는 다양한 화면 크기와 방향에 맞게 앱의 레이아웃을 최적화하기 위해 위젯 높이를 동적으로 계산하고 조정하는 프로세스를 보여줍니다.",
                                // Spanish
                                "Español": "En este video, el presentador analiza cómo ajustar la altura de los widgets de contenedor de forma dinámica en una aplicación Flutter para utilizar mejor el espacio disponible en la pantalla. El video muestra diferentes formas de ajustar la altura de los elementos, como el gráfico y la lista de transacciones, en función de las asignaciones porcentuales. Se presenta el widget LayoutBuilder para calcular dinámicamente las alturas en función de las restricciones y los tamaños de pantalla, lo que garantiza que los elementos del widget tengan el tamaño adecuado. El video enfatiza la importancia de usar alturas relativas para los elementos a fin de crear un diseño de diseño responsivo que se adapte a diferentes tamaños de dispositivos y orientaciones de pantalla. El presentador muestra el proceso de cálculo y ajuste dinámico de las alturas de los widgets para optimizar el diseño de la aplicación para distintas dimensiones y orientaciones de pantalla.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर एप्लिकेशन में कंटेनर विजेट की ऊंचाई को गतिशील रूप से समायोजित करने पर चर्चा करता है ताकि उपलब्ध स्क्रीन स्पेस का बेहतर उपयोग किया जा सके। वीडियो प्रतिशत आवंटन के आधार पर चार्ट और लेनदेन सूची जैसे तत्वों की ऊंचाई को समायोजित करने के विभिन्न तरीकों को प्रदर्शित करता है। लेआउटबिल्डर विजेट को बाधाओं और स्क्रीन आकारों के आधार पर ऊंचाइयों की गतिशील रूप से गणना करने के लिए पेश किया गया है, यह सुनिश्चित करते हुए कि विजेट तत्व उचित आकार के हैं। वीडियो तत्वों के लिए सापेक्ष ऊंचाइयों का उपयोग करने के महत्व पर जोर देता है ताकि एक उत्तरदायी लेआउट डिज़ाइन बनाया जा सके जो विभिन्न डिवाइस आकारों और स्क्रीन ओरिएंटेशन के अनुकूल हो। प्रस्तुतकर्ता अलग-अलग स्क्रीन आयामों और ओरिएंटेशन के लिए ऐप के लेआउट को अनुकूलित करने के लिए विजेट की ऊंचाइयों की गतिशील रूप से गणना और समायोजन करने की प्रक्रिया को प्रदर्शित करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador discute o ajuste dinâmico da altura dos widgets de contentores numa aplicação Flutter para utilizar melhor o espaço disponível no ecrã. O vídeo demonstra diferentes formas de ajustar a altura dos elementos, como o gráfico e a lista de transações, com base em alocações percentuais. O widget LayoutBuilder é introduzido para calcular as alturas dinamicamente com base em restrições e tamanhos de ecrã, garantindo que os elementos do widget são dimensionados corretamente. O vídeo enfatiza a importância de utilizar alturas relativas para os elementos para criar um design de layout responsivo que se adapte a diferentes tamanhos de dispositivos e orientações de ecrã. O apresentador mostra o processo de cálculo e ajuste dinâmico das alturas dos widgets para otimizar o layout da aplicação para diversas dimensões e orientações do ecrã.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক উপলব্ধ স্ক্রীন স্থানকে আরও ভালভাবে ব্যবহার করার জন্য একটি ফ্লটার অ্যাপ্লিকেশনে গতিশীলভাবে কন্টেইনার উইজেটগুলির উচ্চতা সামঞ্জস্য করার বিষয়ে আলোচনা করেছেন। ভিডিওটি উপাদানগুলির উচ্চতা সামঞ্জস্য করার বিভিন্ন উপায় প্রদর্শন করে, যেমন চার্ট এবং লেনদেনের তালিকা, শতাংশ বরাদ্দের উপর ভিত্তি করে। LayoutBuilder উইজেটটি সীমাবদ্ধতা এবং পর্দার আকারের উপর ভিত্তি করে গতিশীলভাবে উচ্চতা গণনা করার জন্য প্রবর্তন করা হয়েছে, নিশ্চিত করে যে উইজেট উপাদানগুলি সঠিকভাবে মাপ করা হয়েছে। ভিডিওটি একটি প্রতিক্রিয়াশীল লেআউট ডিজাইন তৈরি করতে উপাদানগুলির জন্য আপেক্ষিক উচ্চতা ব্যবহার করার গুরুত্বের উপর জোর দেয় যা বিভিন্ন ডিভাইসের আকার এবং স্ক্রীন অভিযোজনের সাথে খাপ খায়। উপস্থাপক বিভিন্ন স্ক্রীনের মাত্রা এবং অভিযোজনের জন্য অ্যাপের লেআউটকে অপ্টিমাইজ করতে উইজেট উচ্চতা গতিশীলভাবে গণনা এবং সামঞ্জস্য করার প্রক্রিয়াটি প্রদর্শন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش مقدم العرض تعديل ارتفاع عناصر واجهة المستخدم الرسومية للحاويات بشكل ديناميكي في تطبيق Flutter للاستفادة بشكل أفضل من مساحة الشاشة المتاحة. يوضح الفيديو طرقًا مختلفة لتعديل ارتفاع العناصر، مثل الرسم البياني وقائمة المعاملات، استنادًا إلى تخصيصات النسبة المئوية. يتم تقديم عنصر واجهة المستخدم الرسومية LayoutBuilder لحساب الارتفاعات بشكل ديناميكي استنادًا إلى القيود وأحجام الشاشة، مما يضمن تحديد حجم عناصر واجهة المستخدم الرسومية بشكل صحيح. يؤكد الفيديو على أهمية استخدام الارتفاعات النسبية للعناصر لإنشاء تصميم تخطيط متجاوب يتكيف مع أحجام الأجهزة المختلفة واتجاهات الشاشة. يعرض مقدم العرض عملية حساب ارتفاعات واجهة المستخدم الرسومية وتعديلها بشكل ديناميكي لتحسين تخطيط التطبيق لأبعاد الشاشة واتجاهاتها المختلفة.",
                                // Persian
                                "فارسی": "در این ویدیو، مجری در مورد تنظیم ارتفاع ویجت های کانتینر به صورت پویا در یک برنامه Flutter برای استفاده بهتر از فضای صفحه نمایش بحث می کند. این ویدیو روش‌های مختلفی را برای تنظیم ارتفاع عناصر، مانند نمودار و فهرست تراکنش‌ها، بر اساس درصد تخصیص نشان می‌دهد. ویجت LayoutBuilder برای محاسبه پویا ارتفاعات بر اساس محدودیت‌ها و اندازه صفحه‌نمایش معرفی شده است و اطمینان حاصل می‌کند که عناصر ویجت به درستی اندازه می‌شوند. این ویدئو بر اهمیت استفاده از ارتفاع نسبی برای عناصر برای ایجاد یک طرح چیدمان پاسخگو که با اندازه های مختلف دستگاه و جهت گیری های صفحه سازگار است، تاکید می کند. ارائه‌دهنده فرآیند محاسبه پویا و تنظیم ارتفاع ویجت را برای بهینه‌سازی طرح‌بندی برنامه برای ابعاد و جهت‌های مختلف صفحه نمایش می‌دهد.",
                            },
                        },
                        // 108 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Controlling the Device Orientation",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter addresses the issue of screen orientation in a Flutter app by demonstrating how to adjust the app's settings to prevent landscape mode on smaller devices. By utilizing the SystemChrome package and ensureInitialized method, the video explains how to set preferred orientations in the app to allow only portrait mode. The presenter emphasizes the importance of implementing a proper landscape mode rather than resorting to blocking landscape mode as a quick fix. The video provides a step-by-step guide on how to adjust app settings to ensure a seamless user experience in both portrait and landscape modes, highlighting the necessity of adapting the app's layout to different screen orientations for optimal functionality.",
                                // German
                                "Deutsch": "In diesem Video geht der Moderator auf das Problem der Bildschirmausrichtung in einer Flutter-App ein, indem er demonstriert, wie die App-Einstellungen angepasst werden können, um den Querformatmodus auf kleineren Geräten zu verhindern. Unter Verwendung des SystemChrome-Pakets und der Methode EnsureInitialized erklärt das Video, wie bevorzugte Ausrichtungen in der App festgelegt werden, um nur den Hochformatmodus zuzulassen. Der Moderator betont, wie wichtig es ist, einen richtigen Querformatmodus zu implementieren, anstatt als schnelle Lösung auf das Blockieren des Querformatmodus zurückzugreifen. Das Video bietet eine Schritt-für-Schritt-Anleitung zum Anpassen der App-Einstellungen, um ein nahtloses Benutzererlebnis sowohl im Hoch- als auch im Querformatmodus zu gewährleisten, und betont die Notwendigkeit, das Layout der App für eine optimale Funktionalität an unterschiedliche Bildschirmausrichtungen anzupassen.",
                                // Chinese
                                "中国人": "在此视频中，演示者通过演示如何调整应用的设置以防止在较小的设备上使用横向模式来解决 Flutter 应用中的屏幕方向问题。通过使用 SystemChrome 包和 EnsureInitialized 方法，视频解释了如何在应用中设置首选方向以仅允许纵向模式。演示者强调了实施适当的横向模式的重要性，而不是诉诸阻止横向模式作为快速解决方案。该视频提供了有关如何调整应用设置的分步指南，以确保在纵向和横向模式下都能获得无缝的用户体验，并强调了根据不同的屏幕方向调整应用布局以实现最佳功能的必要性。",
                                // Russian
                                "Русский": "В этом видео докладчик рассматривает проблему ориентации экрана в приложении Flutter, демонстрируя, как настроить параметры приложения, чтобы предотвратить альбомный режим на небольших устройствах. Используя пакет SystemChrome и метод ensureInitialized, в видео объясняется, как установить предпочтительные ориентации в приложении, чтобы разрешить только портретный режим. Докладчик подчеркивает важность реализации правильного альбомного режима, а не прибегания к блокировке альбомного режима в качестве быстрого решения. Видео предоставляет пошаговое руководство по настройке параметров приложения, чтобы обеспечить бесперебойный пользовательский опыт как в портретном, так и в альбомном режимах, подчеркивая необходимость адаптации макета приложения к различным ориентациям экрана для оптимальной функциональности.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur aborde le problème de l'orientation de l'écran dans une application Flutter en montrant comment ajuster les paramètres de l'application pour empêcher le mode paysage sur les appareils plus petits. En utilisant le package SystemChrome et la méthode ensureInitialized, la vidéo explique comment définir les orientations préférées dans l'application pour autoriser uniquement le mode portrait. Le présentateur souligne l'importance de mettre en œuvre un mode paysage approprié plutôt que de recourir au blocage du mode paysage comme solution rapide. La vidéo fournit un guide étape par étape sur la façon d'ajuster les paramètres de l'application pour garantir une expérience utilisateur transparente en modes portrait et paysage, soulignant la nécessité d'adapter la mise en page de l'application à différentes orientations d'écran pour une fonctionnalité optimale.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが Flutter アプリの画面の向きの問題に対処し、小型デバイスで横向きモードにならないようにアプリの設定を調整する方法を説明します。このビデオでは、SystemChrome パッケージと EnsureInitialized メソッドを利用して、アプリの優先方向を設定して縦向きモードのみを許可する方法について説明します。プレゼンターは、手っ取り早い解決策として横向きモードをブロックするのではなく、適切な横向きモードを実装することの重要性を強調しています。このビデオでは、縦向きモードと横向きモードの両方でシームレスなユーザー エクスペリエンスを確保するためにアプリの設定を調整する方法について手順を追って説明し、最適な機能のためにアプリのレイアウトをさまざまな画面の向きに適応させる必要性を強調しています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 작은 기기에서 가로 모드가 작동하지 않도록 앱 설정을 조정하는 방법을 보여줌으로써 Flutter 앱의 화면 방향 문제를 해결합니다. SystemChrome 패키지와 ensureInitialized 메서드를 활용하여 앱에서 선호하는 방향을 설정하여 세로 모드만 허용하는 방법을 설명합니다. 발표자는 빠른 해결책으로 가로 모드를 차단하는 대신 적절한 가로 모드를 구현하는 것의 중요성을 강조합니다. 이 영상은 세로 모드와 가로 모드 모두에서 원활한 사용자 경험을 보장하기 위해 앱 설정을 조정하는 방법에 대한 단계별 가이드를 제공하며, 최적의 기능을 위해 앱의 레이아웃을 다양한 화면 방향에 맞게 조정해야 하는 필요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el presentador aborda el problema de la orientación de la pantalla en una aplicación Flutter y demuestra cómo ajustar la configuración de la aplicación para evitar el modo horizontal en dispositivos más pequeños. Al utilizar el paquete SystemChrome y el método ensureInitialized, el video explica cómo establecer las orientaciones preferidas en la aplicación para permitir solo el modo vertical. El presentador enfatiza la importancia de implementar un modo horizontal adecuado en lugar de recurrir a bloquear el modo horizontal como una solución rápida. El video proporciona una guía paso a paso sobre cómo ajustar la configuración de la aplicación para garantizar una experiencia de usuario perfecta tanto en modo vertical como horizontal, y destaca la necesidad de adaptar el diseño de la aplicación a diferentes orientaciones de pantalla para una funcionalidad óptima.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर ऐप में स्क्रीन ओरिएंटेशन की समस्या को संबोधित करता है, जिसमें छोटे डिवाइस पर लैंडस्केप मोड को रोकने के लिए ऐप की सेटिंग को समायोजित करने का तरीका दिखाया गया है। SystemChrome पैकेज और EnsureInitialized विधि का उपयोग करके, वीडियो बताता है कि केवल पोर्ट्रेट मोड की अनुमति देने के लिए ऐप में पसंदीदा ओरिएंटेशन कैसे सेट करें। प्रस्तुतकर्ता एक त्वरित समाधान के रूप में लैंडस्केप मोड को ब्लॉक करने का सहारा लेने के बजाय एक उचित लैंडस्केप मोड को लागू करने के महत्व पर जोर देता है। वीडियो पोर्ट्रेट और लैंडस्केप दोनों मोड में एक सहज उपयोगकर्ता अनुभव सुनिश्चित करने के लिए ऐप सेटिंग्स को समायोजित करने के तरीके पर एक चरण-दर-चरण मार्गदर्शिका प्रदान करता है, जो इष्टतम कार्यक्षमता के लिए ऐप के लेआउट को विभिन्न स्क्रीन ओरिएंटेशन के अनुकूल बनाने की आवश्यकता पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador aborda a questão da orientação do ecrã numa aplicação Flutter, demonstrando como ajustar as definições da aplicação para evitar o modo paisagem em dispositivos mais pequenos. Ao utilizar o pacote SystemChrome e o método garantirInitialized, o vídeo explica como definir orientações preferenciais na aplicação para permitir apenas o modo retrato. O apresentador sublinha a importância de implementar um modo paisagem adequado, em vez de recorrer ao bloqueio do modo paisagem como solução rápida. O vídeo fornece um guia passo a passo sobre como ajustar as definições da aplicação para garantir uma experiência de utilizador perfeita nos modos retrato e paisagem, destacando a necessidade de adaptar o layout da aplicação a diferentes orientações do ecrã para obter uma funcionalidade ideal.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক ছোট ডিভাইসে ল্যান্ডস্কেপ মোড প্রতিরোধ করার জন্য অ্যাপের সেটিংস কীভাবে সামঞ্জস্য করতে হয় তা প্রদর্শন করে একটি ফ্লাটার অ্যাপে স্ক্রিন ওরিয়েন্টেশনের সমস্যার সমাধান করে। SystemChrome প্যাকেজ ব্যবহার করে এবং ইনিশিয়ালাইজড পদ্ধতি নিশ্চিত করার মাধ্যমে, ভিডিওটি ব্যাখ্যা করে যে কীভাবে অ্যাপে শুধুমাত্র পোর্ট্রেট মোডের জন্য পছন্দের অভিযোজন সেট করতে হয়। উপস্থাপক দ্রুত সমাধান হিসাবে ল্যান্ডস্কেপ মোড ব্লক করার অবলম্বন না করে একটি সঠিক ল্যান্ডস্কেপ মোড বাস্তবায়নের গুরুত্বের উপর জোর দেন। ভিডিওটি পোর্ট্রেট এবং ল্যান্ডস্কেপ উভয় মোডে একটি নিরবিচ্ছিন্ন ব্যবহারকারীর অভিজ্ঞতা নিশ্চিত করার জন্য কীভাবে অ্যাপ সেটিংস সামঞ্জস্য করতে হয় তার একটি ধাপে ধাপে নির্দেশিকা প্রদান করে, সর্বোত্তম কার্যকারিতার জন্য অ্যাপের লেআউটকে বিভিন্ন স্ক্রীন ওরিয়েন্টেশনে মানিয়ে নেওয়ার প্রয়োজনীয়তা তুলে ধরে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتناول مقدم العرض مشكلة اتجاه الشاشة في تطبيق Flutter من خلال توضيح كيفية ضبط إعدادات التطبيق لمنع وضع العرض الأفقي على الأجهزة الصغيرة. من خلال الاستفادة من حزمة SystemChrome وطريقة EnsureInitialized، يشرح الفيديو كيفية تعيين الاتجاهات المفضلة في التطبيق للسماح بوضع العرض الرأسي فقط. ويؤكد مقدم العرض على أهمية تنفيذ وضع العرض الأفقي المناسب بدلاً من اللجوء إلى حظر وضع العرض الأفقي كحل سريع. يوفر الفيديو دليلًا خطوة بخطوة حول كيفية ضبط إعدادات التطبيق لضمان تجربة مستخدم سلسة في كل من وضعي العرض الرأسي والأفقي، مع تسليط الضوء على ضرورة تكييف تخطيط التطبيق مع اتجاهات الشاشة المختلفة لتحقيق الأداء الأمثل.",
                                // Persian
                                "فارسی": "در این ویدیو، ارائه کننده با نشان دادن نحوه تنظیم تنظیمات برنامه برای جلوگیری از حالت افقی در دستگاه های کوچکتر، به مسئله جهت گیری صفحه در یک برنامه Flutter می پردازد. با استفاده از بسته SystemChrome و روش sureInitialized، این ویدئو نحوه تنظیم جهت‌های ترجیحی در برنامه را توضیح می‌دهد تا فقط حالت عمودی مجاز باشد. مجری بر اهمیت اجرای یک حالت افقی مناسب به جای توسل به حالت منظره مسدود به عنوان یک راه حل سریع تاکید می کند. این ویدئو راهنمای گام به گام نحوه تنظیم تنظیمات برنامه برای اطمینان از تجربه کاربری یکپارچه در هر دو حالت عمودی و افقی را ارائه می‌کند، که بر لزوم تطبیق طرح‌بندی برنامه با جهت‌گیری‌های مختلف صفحه برای عملکرد بهینه تاکید می‌کند.",
                            },
                        },
                        // 109 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Rendering Alternative Landscape Content - 1",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter addresses the challenge of accommodating landscape mode in a Flutter app by proposing a solution involving a switch toggle which allows users to switch between a Chart View and ListView. The video demonstrates how to implement a switch element in Flutter and configure its properties such as value and onPressed function to toggle visibility between the chart and list elements. By utilizing a stateful widget and ternary expression, the presenter explains how to update the UI based on the user's switch selection, showing either the chart or list based on the switch position. The video highlights the importance of adapting the app's layout to different screen dimensions and orientations for improved user experience in landscape mode.",
                                // German
                                "Deutsch": "In diesem Video befasst sich der Moderator mit der Herausforderung, den Querformatmodus in einer Flutter-App zu integrieren, indem er eine Lösung mit einem Schalter vorschlägt, mit dem Benutzer zwischen einer Diagrammansicht und einer Listenansicht wechseln können. Das Video zeigt, wie man ein Schalterelement in Flutter implementiert und seine Eigenschaften wie Wert und die Funktion „onPressed“ konfiguriert, um die Sichtbarkeit zwischen den Diagramm- und Listenelementen umzuschalten. Durch die Verwendung eines zustandsbehafteten Widgets und eines ternären Ausdrucks erklärt der Moderator, wie man die Benutzeroberfläche basierend auf der Schalterauswahl des Benutzers aktualisiert und je nach Schalterposition entweder das Diagramm oder die Liste anzeigt. Das Video unterstreicht, wie wichtig es ist, das Layout der App an unterschiedliche Bildschirmabmessungen und -ausrichtungen anzupassen, um das Benutzererlebnis im Querformat zu verbessern.",
                                // Chinese
                                "中国人": "在此视频中，演示者通过提出一种涉及开关切换的解决方案来解决在 Flutter 应用中适应横向模式的挑战，该解决方案允许用户在图表视图和列表视图之间切换。该视频演示了如何在 Flutter 中实现开关元素并配置其属性（例如值和 onPressed 函数）以在图表和列表元素之间切换可见性。通过使用有状态的小部件和三元表达式，演示者解释了如何根据用户的开关选择更新 UI，根据开关位置显示图表或列表。该视频强调了根据不同的屏幕尺寸和方向调整应用布局的重要性，以改善横向模式下的用户体验。",
                                // Russian
                                "Русский": "В этом видео докладчик рассматривает проблему размещения ландшафтного режима в приложении Flutter, предлагая решение с использованием переключателя, который позволяет пользователям переключаться между Chart View и ListView. Видео демонстрирует, как реализовать элемент switch во Flutter и настроить его свойства, такие как value и onPressed, для переключения видимости между элементами диаграммы и списка. Используя виджет с отслеживанием состояния и тернарное выражение, докладчик объясняет, как обновить пользовательский интерфейс на основе выбора переключателя пользователем, отображая либо диаграмму, либо список на основе положения переключателя. Видео подчеркивает важность адаптации макета приложения к различным размерам и ориентациям экрана для улучшения пользовательского опыта в ландшафтном режиме.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur aborde le défi de l'adaptation du mode paysage dans une application Flutter en proposant une solution impliquant un commutateur qui permet aux utilisateurs de basculer entre une vue graphique et une vue de liste. La vidéo montre comment implémenter un élément de commutation dans Flutter et configurer ses propriétés telles que la valeur et la fonction onPressed pour basculer la visibilité entre les éléments de graphique et de liste. En utilisant un widget avec état et une expression ternaire, le présentateur explique comment mettre à jour l'interface utilisateur en fonction de la sélection du commutateur de l'utilisateur, en affichant soit le graphique, soit la liste en fonction de la position du commutateur. La vidéo souligne l'importance d'adapter la mise en page de l'application à différentes dimensions et orientations d'écran pour une meilleure expérience utilisateur en mode paysage.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが Flutter アプリでランドスケープ モードに対応するという課題に対処し、ユーザーが Chart View と ListView を切り替えることができるスイッチ トグルに関するソリューションを提案しています。このビデオでは、Flutter でスイッチ要素を実装し、そのプロパティ (値や onPressed 関数など) を構成して、チャート要素とリスト要素の表示を切り替える方法を説明します。プレゼンターは、ステートフル ウィジェットと 3 項式を利用して、ユーザーのスイッチ選択に基づいて UI を更新し、スイッチの位置に基づいてチャートまたはリストを表示する方法について説明します。このビデオでは、ランドスケープ モードでのユーザー エクスペリエンスを向上させるために、アプリのレイアウトをさまざまな画面サイズと向きに適応させることの重要性を強調しています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 앱에서 가로 모드를 수용하는 과제를 다루며, 사용자가 차트 뷰와 리스트 뷰 사이를 전환할 수 있는 스위치 토글을 포함하는 솔루션을 제안합니다. 이 영상은 Flutter에서 스위치 요소를 구현하고 값과 onPressed 함수와 같은 속성을 구성하여 차트와 목록 요소 사이의 가시성을 토글하는 방법을 보여줍니다. 발표자는 상태 저장 위젯과 3항 표현식을 활용하여 사용자의 스위치 선택에 따라 UI를 업데이트하고 스위치 위치에 따라 차트나 목록을 표시하는 방법을 설명합니다. 이 영상은 가로 모드에서 사용자 경험을 개선하기 위해 앱의 레이아웃을 다양한 화면 크기와 방향에 맞게 조정하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el presentador aborda el desafío de adaptar el modo horizontal en una aplicación Flutter al proponer una solución que implica un interruptor que permite a los usuarios cambiar entre una vista de gráfico y una vista de lista. El video demuestra cómo implementar un elemento de interruptor en Flutter y configurar sus propiedades, como el valor y la función onPressed, para alternar la visibilidad entre los elementos de gráfico y lista. Al utilizar un widget con estado y una expresión ternaria, el presentador explica cómo actualizar la interfaz de usuario en función de la selección del interruptor del usuario, mostrando el gráfico o la lista en función de la posición del interruptor. El video destaca la importancia de adaptar el diseño de la aplicación a diferentes dimensiones y orientaciones de pantalla para mejorar la experiencia del usuario en modo horizontal.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर ऐप में लैंडस्केप मोड को समायोजित करने की चुनौती को संबोधित करता है, जिसमें स्विच टॉगल से जुड़े समाधान का प्रस्ताव है जो उपयोगकर्ताओं को चार्ट व्यू और लिस्ट व्यू के बीच स्विच करने की अनुमति देता है। वीडियो दर्शाता है कि फ़्लटर में स्विच एलिमेंट को कैसे लागू किया जाए और चार्ट और सूची तत्वों के बीच दृश्यता को टॉगल करने के लिए इसके गुणों जैसे कि वैल्यू और ऑनप्रेस्ड फ़ंक्शन को कैसे कॉन्फ़िगर किया जाए। स्टेटफुल विजेट और टर्नरी एक्सप्रेशन का उपयोग करके, प्रस्तुतकर्ता बताता है कि उपयोगकर्ता के स्विच चयन के आधार पर UI को कैसे अपडेट किया जाए, स्विच स्थिति के आधार पर चार्ट या सूची को दिखाया जाए। वीडियो लैंडस्केप मोड में बेहतर उपयोगकर्ता अनुभव के लिए ऐप के लेआउट को अलग-अलग स्क्रीन आयामों और ओरिएंटेशन के अनुकूल बनाने के महत्व पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador aborda o desafio de acomodar o modo paisagem numa aplicação Flutter, propondo uma solução que envolve uma comutação de chave que permite aos utilizadores alternar entre Chart View e ListView. O vídeo demonstra como implementar um elemento switch no Flutter e configurar as suas propriedades, como o valor e a função onPressed, para alternar a visibilidade entre os elementos do gráfico e da lista. Utilizando um widget com estado e uma expressão ternária, o apresentador explica como atualizar a UI com base na seleção do switch do utilizador, mostrando o gráfico ou a lista com base na posição do switch. O vídeo destaca a importância de adaptar o layout da aplicação às diferentes dimensões e orientações do ecrã para melhorar a experiência do utilizador no modo paisagem.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক একটি স্যুইচ টগল যুক্ত একটি সমাধান প্রস্তাব করে একটি ফ্লাটার অ্যাপে ল্যান্ডস্কেপ মোড সামঞ্জস্য করার চ্যালেঞ্জ মোকাবেলা করেছেন যা ব্যবহারকারীদের একটি চার্ট ভিউ এবং লিস্টভিউ এর মধ্যে স্যুইচ করতে দেয়৷ ভিডিওটি দেখায় যে কীভাবে ফ্লটারে একটি সুইচ উপাদান প্রয়োগ করা যায় এবং চার্ট এবং তালিকা উপাদানগুলির মধ্যে দৃশ্যমানতা টগল করতে মান এবং অনপ্রেসড ফাংশনের মতো বৈশিষ্ট্যগুলি কনফিগার করা যায়। একটি স্টেটফুল উইজেট এবং তির্যক অভিব্যক্তি ব্যবহার করে, উপস্থাপক ব্যাখ্যা করে কিভাবে ব্যবহারকারীর সুইচ নির্বাচনের উপর ভিত্তি করে UI আপডেট করতে হয়, হয় সুইচ অবস্থানের উপর ভিত্তি করে চার্ট বা তালিকা দেখায়। ভিডিওটি ল্যান্ডস্কেপ মোডে উন্নত ব্যবহারকারীর অভিজ্ঞতার জন্য অ্যাপের লেআউটকে বিভিন্ন স্ক্রীনের মাত্রা এবং অভিযোজনে অভিযোজিত করার গুরুত্ব তুলে ধরে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتناول مقدم العرض التحدي المتمثل في استيعاب الوضع الأفقي في تطبيق Flutter من خلال اقتراح حل يتضمن تبديل التبديل الذي يسمح للمستخدمين بالتبديل بين Chart View وListView. يوضح الفيديو كيفية تنفيذ عنصر تبديل في Flutter وتكوين خصائصه مثل القيمة ووظيفة onPressed للتبديل بين الرؤية بين عناصر الرسم البياني والقائمة. من خلال استخدام عنصر واجهة مستخدم وتعبير ثلاثي، يشرح مقدم العرض كيفية تحديث واجهة المستخدم بناءً على اختيار المستخدم للتبديل، مع عرض الرسم البياني أو القائمة بناءً على موضع التبديل. يسلط الفيديو الضوء على أهمية تكييف تخطيط التطبيق مع أبعاد الشاشة المختلفة واتجاهاتها لتحسين تجربة المستخدم في الوضع الأفقي.",
                                // Persian
                                "فارسی": "در این ویدئو، ارائه‌دهنده چالش تطبیق حالت افقی در یک برنامه Flutter را با پیشنهاد راه‌حلی شامل تغییر سوئیچ که به کاربران اجازه می‌دهد بین نمودار نمودار و نمای فهرست جابجا شوند، پاسخ می‌دهد. این ویدئو نحوه پیاده‌سازی یک عنصر سوئیچ در Flutter و پیکربندی ویژگی‌های آن مانند مقدار و تابع onPressed را برای تغییر قابلیت مشاهده بین عناصر نمودار و لیست نشان می‌دهد. با استفاده از یک ویجت حالت و عبارت سه تایی، ارائه دهنده نحوه به روز رسانی رابط کاربری را بر اساس انتخاب سوئیچ کاربر توضیح می دهد و نمودار یا لیست را بر اساس موقعیت سوئیچ نشان می دهد. این ویدئو اهمیت تطبیق طرح برنامه را با ابعاد و جهت های مختلف صفحه نمایش برای بهبود تجربه کاربر در حالت افقی برجسته می کند.",
                            },
                        },
                        // 110 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Finishing Landscape Mode",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker explains how to adjust the height of different elements on a screen in Flutter. They discuss setting the chart height to 1 and adjusting the image container height to be a percentage of the surrounding container using LayoutBuilder. The speaker also addresses the issue of switching between landscape and portrait modes and making adjustments accordingly.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Sprecher, wie man die Höhe verschiedener Elemente auf einem Bildschirm in Flutter anpasst. Er bespricht, wie man die Diagrammhöhe auf 1 setzt und die Höhe des Bildcontainers mithilfe von LayoutBuilder auf einen Prozentsatz des umgebenden Containers anpasst. Der Sprecher geht auch auf das Umschalten zwischen Quer- und Hochformat ein und nimmt entsprechende Anpassungen vor.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讲解了如何在 Flutter 中调整屏幕上不同元素的高度。他们讨论了将图表高度设置为 1，并使用 LayoutBuilder 将图片容器高度调整为周围容器的百分比。演讲者还讨论了在横向和纵向模式之间切换并进行相应调整的问题。",
                                // Russian
                                "Русский": "В этом видео докладчик объясняет, как настроить высоту различных элементов на экране во Flutter. Они обсуждают установку высоты диаграммы на 1 и настройку высоты контейнера изображения в процентном соотношении к окружающему контейнеру с помощью LayoutBuilder. Докладчик также рассматривает проблему переключения между ландшафтным и портретным режимами и внесения соответствующих корректировок.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique comment ajuster la hauteur de différents éléments sur un écran dans Flutter. Il explique comment définir la hauteur du graphique sur 1 et ajuster la hauteur du conteneur d'images pour qu'elle corresponde à un pourcentage du conteneur environnant à l'aide de LayoutBuilder. L'intervenant aborde également la question du basculement entre les modes paysage et portrait et des ajustements à apporter en conséquence.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が Flutter で画面上のさまざまな要素の高さを調整する方法について説明します。チャートの高さを 1 に設定し、LayoutBuilder を使用して画像コンテナの高さを周囲のコンテナのパーセンテージに調整する方法について説明します。講演者は、横向きモードと縦向きモードを切り替えてそれに応じて調整する問題についても説明します。",
                                // Korean
                                "한국인": "이 영상에서, 발표자는 Flutter에서 화면의 다양한 요소의 높이를 조정하는 방법을 설명합니다. 그들은 LayoutBuilder를 사용하여 차트 높이를 1로 설정하고 이미지 컨테이너 높이를 주변 컨테이너의 백분율로 조정하는 방법을 논의합니다. 발표자는 또한 가로 모드와 세로 모드를 전환하고 그에 따라 조정하는 문제도 다룹니다.",
                                // Spanish
                                "Español": "En este video, el orador explica cómo ajustar la altura de diferentes elementos en una pantalla en Flutter. Habla sobre cómo establecer la altura del gráfico en 1 y ajustar la altura del contenedor de imágenes para que sea un porcentaje del contenedor circundante usando LayoutBuilder. El orador también aborda el problema de cambiar entre los modos horizontal y vertical y realizar los ajustes correspondientes.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता बताते हैं कि फ़्लटर में स्क्रीन पर विभिन्न तत्वों की ऊँचाई को कैसे समायोजित किया जाए। वे चार्ट की ऊँचाई को 1 पर सेट करने और लेआउटबिल्डर का उपयोग करके छवि कंटेनर की ऊँचाई को आसपास के कंटेनर के प्रतिशत के रूप में समायोजित करने पर चर्चा करते हैं। वक्ता लैंडस्केप और पोर्ट्रेट मोड के बीच स्विच करने और उसके अनुसार समायोजन करने के मुद्दे को भी संबोधित करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador explica como ajustar a altura de diferentes elementos num ecrã no Flutter. Discutem a definição da altura do gráfico como 1 e o ajuste da altura do contentor de imagens para ser uma percentagem do contentor circundante utilizando o LayoutBuilder. O orador aborda ainda a questão de alternar entre os modos paisagem e retrato e fazer os ajustes necessários.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার ব্যাখ্যা করেছেন কিভাবে ফ্লটারে একটি স্ক্রিনে বিভিন্ন উপাদানের উচ্চতা সামঞ্জস্য করা যায়। তারা লেআউটবিল্ডার ব্যবহার করে চার্টের উচ্চতা 1 এ সেট করা এবং চিত্র কন্টেইনারের উচ্চতাকে আশেপাশের কন্টেইনারের শতাংশ হিসাবে সামঞ্জস্য করার বিষয়ে আলোচনা করে। স্পিকার ল্যান্ডস্কেপ এবং পোর্ট্রেট মোডগুলির মধ্যে স্যুইচ করার এবং সেই অনুযায়ী সামঞ্জস্য করার সমস্যাটিও সম্বোধন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المتحدث كيفية ضبط ارتفاع العناصر المختلفة على الشاشة في Flutter. ويناقشون ضبط ارتفاع الرسم البياني إلى 1 وضبط ارتفاع حاوية الصورة ليكون نسبة مئوية من الحاوية المحيطة باستخدام LayoutBuilder. ويتناول المتحدث أيضًا مشكلة التبديل بين الوضعين الأفقي والرأسي وإجراء التعديلات وفقًا لذلك.",
                                // Persian
                                "فارسی": "در این ویدئو اسپیکر نحوه تنظیم ارتفاع عناصر مختلف روی صفحه نمایش را در فلاتر توضیح می دهد. آنها در مورد تنظیم ارتفاع نمودار روی 1 و تنظیم ارتفاع ظرف تصویر به عنوان درصدی از ظرف اطراف با استفاده از LayoutBuilder بحث می کنند. این بلندگو همچنین به موضوع جابجایی بین حالت افقی و عمودی و انجام تنظیمات بر این اساس می پردازد.",
                            },
                        },
                        // 111 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Showing Different Content Based on Device Orientation",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker demonstrates how to adjust the layout of elements on a screen in Flutter based on the device orientation. By using media query and the orientation property, they determine whether the device is in landscape or portrait mode. The speaker then explains how to conditionally render different widgets based on the orientation, such as showing a switch only in landscape mode and adjusting the height of elements accordingly. By utilizing if statements and variables to store widget configurations, the speaker provides a comprehensive guide on dynamically rendering content based on the device orientation in a Flutter app.",
                                // German
                                "Deutsch": "In diesem Tutorial zeigt der Sprecher, wie man das Layout von Elementen auf einem Bildschirm in Flutter basierend auf der Geräteausrichtung anpasst. Durch die Verwendung von Medienabfragen und der Ausrichtungseigenschaft bestimmen sie, ob sich das Gerät im Quer- oder Hochformat befindet. Der Sprecher erklärt dann, wie man verschiedene Widgets basierend auf der Ausrichtung bedingt rendert, z. B. einen Schalter nur im Querformat anzeigt und die Höhe der Elemente entsprechend anpasst. Durch die Verwendung von if-Anweisungen und Variablen zum Speichern von Widget-Konfigurationen bietet der Sprecher eine umfassende Anleitung zum dynamischen Rendern von Inhalten basierend auf der Geräteausrichtung in einer Flutter-App.",
                                // Chinese
                                "中国人": "在本教程中，演讲者演示了如何根据设备方向调整 Flutter 中屏幕上元素的布局。通过使用媒体查询和 orientation 属性，它们可以确定设备处于横向还是纵向模式。然后，演讲者解释了如何根据方向有条件地渲染不同的小部件，例如仅在横向模式下显示开关并相应地调整元素的高度。通过使用 if 语句和变量来存储小部件配置，演讲者提供了有关在 Flutter 应用中根据设备方向动态渲染内容的全面指南。",
                                // Russian
                                "Русский": "В этом уроке докладчик демонстрирует, как настроить макет элементов на экране во Flutter на основе ориентации устройства. Используя медиа-запрос и свойство orientation, они определяют, находится ли устройство в альбомном или портретном режиме. Затем докладчик объясняет, как условно отображать различные виджеты на основе ориентации, например, отображать переключатель только в альбомном режиме и соответствующим образом регулировать высоту элементов. Используя операторы if и переменные для хранения конфигураций виджетов, докладчик предоставляет исчерпывающее руководство по динамической визуализации контента на основе ориентации устройства в приложении Flutter.",
                                // French
                                "Français": "Dans ce didacticiel, l'intervenant montre comment ajuster la disposition des éléments sur un écran dans Flutter en fonction de l'orientation de l'appareil. En utilisant la requête multimédia et la propriété d'orientation, ils déterminent si l'appareil est en mode paysage ou portrait. L'intervenant explique ensuite comment restituer de manière conditionnelle différents widgets en fonction de l'orientation, par exemple en affichant un commutateur uniquement en mode paysage et en ajustant la hauteur des éléments en conséquence. En utilisant des instructions if et des variables pour stocker les configurations de widgets, l'intervenant fournit un guide complet sur le rendu dynamique du contenu en fonction de l'orientation de l'appareil dans une application Flutter.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講演者がデバイスの向きに基づいて Flutter の画面上の要素のレイアウトを調整する方法を説明します。メディア クエリと orientation プロパティを使用して、デバイスが横向きか縦向きかを判断します。次に、スイッチを横向きモードでのみ表示し、それに応じて要素の高さを調整するなど、向きに基づいてさまざまなウィジェットを条件付きでレンダリングする方法を説明します。ウィジェットの設定を保存するために if ステートメントと変数を利用することで、講演者は Flutter アプリでデバイスの向きに基づいてコンテンツを動的にレンダリングするための包括的なガイドを提供します。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 Flutter에서 기기 방향에 따라 화면의 요소 레이아웃을 조정하는 방법을 보여줍니다. 미디어 쿼리와 orientation 속성을 사용하여 기기가 가로 모드인지 세로 모드인지 확인합니다. 그런 다음 발표자는 가로 모드에서만 스위치를 표시하고 그에 따라 요소의 높이를 조정하는 등 방향에 따라 다른 위젯을 조건부로 렌더링하는 방법을 설명합니다. 발표자는 if 문과 변수를 사용하여 위젯 구성을 저장함으로써 Flutter 앱에서 기기 방향에 따라 콘텐츠를 동적으로 렌더링하는 방법에 대한 포괄적인 가이드를 제공합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador demuestra cómo ajustar el diseño de los elementos en una pantalla en Flutter según la orientación del dispositivo. Mediante el uso de una consulta de medios y la propiedad de orientación, se determina si el dispositivo está en modo horizontal o vertical. Luego, el orador explica cómo representar condicionalmente diferentes widgets según la orientación, como mostrar un interruptor solo en modo horizontal y ajustar la altura de los elementos en consecuencia. Al utilizar declaraciones if y variables para almacenar configuraciones de widgets, el orador proporciona una guía completa sobre cómo representar dinámicamente contenido según la orientación del dispositivo en una aplicación Flutter.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता यह दर्शाता है कि डिवाइस ओरिएंटेशन के आधार पर फ़्लटर में स्क्रीन पर तत्वों के लेआउट को कैसे समायोजित किया जाए। मीडिया क्वेरी और ओरिएंटेशन प्रॉपर्टी का उपयोग करके, वे यह निर्धारित करते हैं कि डिवाइस लैंडस्केप या पोर्ट्रेट मोड में है या नहीं। फिर वक्ता बताता है कि ओरिएंटेशन के आधार पर अलग-अलग विजेट को सशर्त रूप से कैसे प्रस्तुत किया जाए, जैसे कि केवल लैंडस्केप मोड में स्विच दिखाना और तत्वों की ऊंचाई को तदनुसार समायोजित करना। विजेट कॉन्फ़िगरेशन को संग्रहीत करने के लिए if स्टेटमेंट और वैरिएबल का उपयोग करके, वक्ता फ़्लटर ऐप में डिवाइस ओरिएंटेशन के आधार पर सामग्री को गतिशील रूप से प्रस्तुत करने पर एक व्यापक गाइड प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador demonstra como ajustar o layout dos elementos num ecrã no Flutter com base na orientação do dispositivo. Utilizando a consulta de média e a propriedade de orientação, determinam se o dispositivo está no modo paisagem ou retrato. O orador explica então como renderizar condicionalmente diferentes widgets com base na orientação, como mostrar uma opção apenas no modo paisagem e ajustar a altura dos elementos em conformidade. Ao utilizar instruções if e variáveis ​​para armazenar definições de widgets, o orador fornece um guia abrangente sobre a renderização dinâmica de conteúdos com base na orientação do dispositivo numa aplicação Flutter.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার প্রদর্শন করে যে কীভাবে ডিভাইসের অভিযোজনের উপর ভিত্তি করে ফ্লটারে একটি স্ক্রিনে উপাদানগুলির বিন্যাস সামঞ্জস্য করা যায়। মিডিয়া ক্যোয়ারী এবং ওরিয়েন্টেশন প্রপার্টি ব্যবহার করে, তারা ডিভাইসটি ল্যান্ডস্কেপ বা প্রতিকৃতি মোডে আছে কিনা তা নির্ধারণ করে। স্পিকার তারপর ব্যাখ্যা করে কিভাবে শর্তসাপেক্ষে বিভিন্ন উইজেট রেন্ডার করতে হয় ওরিয়েন্টেশনের উপর ভিত্তি করে, যেমন শুধুমাত্র ল্যান্ডস্কেপ মোডে একটি সুইচ দেখানো এবং সেই অনুযায়ী উপাদানের উচ্চতা সামঞ্জস্য করা। উইজেট কনফিগারেশন সঞ্চয় করার জন্য বিবৃতি এবং ভেরিয়েবল ব্যবহার করে, স্পিকার একটি ফ্লাটার অ্যাপে ডিভাইসের অভিযোজনের উপর ভিত্তি করে গতিশীলভাবে রেন্ডারিং বিষয়বস্তু সম্পর্কে একটি বিস্তৃত নির্দেশিকা প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يوضح المتحدث كيفية ضبط تخطيط العناصر على الشاشة في Flutter بناءً على اتجاه الجهاز. باستخدام استعلام الوسائط وخاصية الاتجاه، يحددون ما إذا كان الجهاز في وضع أفقي أو عمودي. ثم يشرح المتحدث كيفية عرض عناصر واجهة مستخدم مختلفة بشكل مشروط بناءً على الاتجاه، مثل عرض مفتاح في وضع أفقي فقط وضبط ارتفاع العناصر وفقًا لذلك. من خلال استخدام عبارات الشرط والمتغيرات لتخزين تكوينات عناصر واجهة المستخدم، يقدم المتحدث دليلاً شاملاً حول عرض المحتوى ديناميكيًا بناءً على اتجاه الجهاز في تطبيق Flutter.",
                                // Persian
                                "فارسی": "در این آموزش، بلندگو نحوه تنظیم چیدمان عناصر روی صفحه در فلاتر را بر اساس جهت گیری دستگاه نشان می دهد. آنها با استفاده از پرس و جو رسانه و ویژگی جهت گیری، تعیین می کنند که آیا دستگاه در حالت افقی یا عمودی است. سپس سخنران نحوه ارائه شرطی ویجت های مختلف را بر اساس جهت گیری توضیح می دهد، مانند نمایش یک سوئیچ فقط در حالت افقی و تنظیم ارتفاع عناصر بر این اساس. با استفاده از عبارات if و متغیرها برای ذخیره تنظیمات ویجت، بلندگو راهنمای جامعی در مورد ارائه پویا محتوا بر اساس جهت گیری دستگاه در یک برنامه Flutter ارائه می دهد.",
                            },
                        },
                        // 112 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Respecting the Softkeyboard Insets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker addresses the issue of the soft keyboard covering input fields in a Flutter app, making it difficult to type on smaller screens or in landscape mode. By utilizing Flutter's tools, the speaker shows how to adjust the padding of containers to move them up when the keyboard appears, ensuring that users can still interact with the input fields. They explain how to use EdgeInsets constructors and media query to dynamically adjust padding based on the space occupied by the keyboard. Additionally, the speaker demonstrates how to wrap containers in SingleChildScrollView to allow for scrolling when content overlaps, providing a practical solution to the problem. They mention that more advanced solutions can involve customizing modal bottom sheets to improve user interaction further.",
                                // German
                                "Deutsch": "In diesem Tutorial geht der Sprecher auf das Problem ein, dass die Softtastatur Eingabefelder in einer Flutter-App abdeckt, was das Tippen auf kleineren Bildschirmen oder im Querformat erschwert. Unter Verwendung der Flutter-Tools zeigt der Sprecher, wie die Polsterung von Containern angepasst werden kann, um sie nach oben zu verschieben, wenn die Tastatur angezeigt wird, und so sicherzustellen, dass Benutzer weiterhin mit den Eingabefeldern interagieren können. Er erklärt, wie EdgeInsets-Konstruktoren und Medienabfragen verwendet werden, um die Polsterung dynamisch basierend auf dem von der Tastatur belegten Platz anzupassen. Darüber hinaus zeigt der Sprecher, wie Container in SingleChildScrollView umschlossen werden, um Scrollen bei überlappenden Inhalten zu ermöglichen, und bietet damit eine praktische Lösung für das Problem. Er erwähnt, dass fortgeschrittenere Lösungen das Anpassen modaler unterer Blätter umfassen können, um die Benutzerinteraktion weiter zu verbessern.",
                                // Chinese
                                "中国人": "在本教程中，演讲者解决了 Flutter 应用中软键盘覆盖输入字段的问题，导致在较小的屏幕或横向模式下难以输入内容。通过利用 Flutter 的工具，演讲者展示了如何调整容器的填充，以便在键盘出现时将其向上移动，从而确保用户仍能与输入字段交互。他们解释了如何使用 EdgeInsets 构造函数和媒体查询根据键盘占用的空间动态调整填充。此外，演讲者还演示了如何在 SingleChildScrollView 中包装容器，以便在内容重叠时滚动，从而为该问题提供了实用的解决方案。他们提到，更高级的解决方案可以包括自定义模态底部表单，以进一步改善用户交互。",
                                // Russian
                                "Русский": "В этом уроке докладчик рассматривает проблему экранной клавиатуры, закрывающей поля ввода в приложении Flutter, что затрудняет ввод текста на небольших экранах или в ландшафтном режиме. Используя инструменты Flutter, докладчик показывает, как настроить отступы контейнеров, чтобы поднять их при появлении клавиатуры, гарантируя, что пользователи по-прежнему смогут взаимодействовать с полями ввода. Они объясняют, как использовать конструкторы EdgeInsets и медиазапросы для динамической настройки отступов в зависимости от пространства, занимаемого клавиатурой. Кроме того, докладчик демонстрирует, как обернуть контейнеры в SingleChildScrollView, чтобы обеспечить прокрутку при перекрытии контента, что дает практическое решение проблемы. Они упоминают, что более продвинутые решения могут включать настройку модальных нижних листов для дальнейшего улучшения взаимодействия с пользователем.",
                                // French
                                "Français": "Dans ce tutoriel, l'intervenant aborde le problème du clavier logiciel qui recouvre les champs de saisie dans une application Flutter, ce qui rend difficile la saisie sur des écrans plus petits ou en mode paysage. En utilisant les outils de Flutter, l'intervenant montre comment ajuster le remplissage des conteneurs pour les déplacer vers le haut lorsque le clavier apparaît, garantissant ainsi que les utilisateurs peuvent toujours interagir avec les champs de saisie. Il explique comment utiliser les constructeurs EdgeInsets et la requête multimédia pour ajuster dynamiquement le remplissage en fonction de l'espace occupé par le clavier. De plus, l'intervenant montre comment encapsuler des conteneurs dans SingleChildScrollView pour permettre le défilement lorsque le contenu se chevauche, offrant ainsi une solution pratique au problème. Il mentionne que des solutions plus avancées peuvent impliquer la personnalisation des feuilles inférieures modales pour améliorer encore l'interaction avec l'utilisateur.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講演者は、Flutter アプリでソフト キーボードが入力フィールドを覆い、小さい画面や横向きモードで入力しにくくなるという問題に対処します。講演者は、Flutter のツールを利用して、キーボードが表示されたときにコンテナーのパディングを調整して上に移動させ、ユーザーが入力フィールドを操作できるようにする方法を示します。講演者は、EdgeInsets コンストラクターとメディア クエリを使用して、キーボードが占めるスペースに基づいてパディングを動的に調整する方法を説明します。さらに、講演者は、SingleChildScrollView でコンテナーをラップして、コンテンツが重なったときにスクロールできるようにする方法を示し、問題の実用的な解決策を示します。講演者は、より高度な解決策として、モーダル ボトム シートをカスタマイズしてユーザー操作をさらに改善できると述べています。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 Flutter 앱에서 소프트 키보드가 입력 필드를 덮어 작은 화면이나 가로 모드에서 입력하기 어려운 문제를 다룹니다. 발표자는 Flutter의 도구를 활용하여 키보드가 나타날 때 컨테이너의 패딩을 조정하여 위로 이동하고 사용자가 입력 필드와 계속 상호 작용할 수 있도록 하는 방법을 보여줍니다. 발표자는 EdgeInsets 생성자와 미디어 쿼리를 사용하여 키보드가 차지하는 공간에 따라 패딩을 동적으로 조정하는 방법을 설명합니다. 또한 발표자는 SingleChildScrollView에서 컨테이너를 래핑하여 콘텐츠가 겹칠 때 스크롤할 수 있도록 하는 방법을 보여주어 문제에 대한 실용적인 솔루션을 제공합니다. 발표자는 보다 고급 솔루션에는 모달 바텀 시트를 사용자 지정하여 사용자 상호 작용을 더욱 개선하는 것이 포함될 수 있다고 언급합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador aborda el problema del teclado virtual que cubre los campos de entrada en una aplicación Flutter, lo que dificulta escribir en pantallas más pequeñas o en modo horizontal. Al utilizar las herramientas de Flutter, el orador muestra cómo ajustar el relleno de los contenedores para moverlos hacia arriba cuando aparece el teclado, lo que garantiza que los usuarios aún puedan interactuar con los campos de entrada. Explica cómo usar los constructores EdgeInsets y la consulta de medios para ajustar dinámicamente el relleno en función del espacio que ocupa el teclado. Además, el orador demuestra cómo envolver los contenedores en SingleChildScrollView para permitir el desplazamiento cuando el contenido se superpone, lo que proporciona una solución práctica al problema. Menciona que las soluciones más avanzadas pueden implicar la personalización de las hojas inferiores modales para mejorar aún más la interacción del usuario.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता फ़्लटर ऐप में इनपुट फ़ील्ड को कवर करने वाले सॉफ्ट कीबोर्ड की समस्या को संबोधित करता है, जिससे छोटी स्क्रीन या लैंडस्केप मोड में टाइप करना मुश्किल हो जाता है। फ़्लटर के टूल का उपयोग करके, वक्ता दिखाता है कि कीबोर्ड दिखाई देने पर कंटेनरों की पैडिंग को कैसे समायोजित किया जाए ताकि उन्हें ऊपर ले जाया जा सके, यह सुनिश्चित करते हुए कि उपयोगकर्ता अभी भी इनपुट फ़ील्ड के साथ इंटरैक्ट कर सकते हैं। वे बताते हैं कि कीबोर्ड द्वारा कब्जा किए गए स्थान के आधार पर पैडिंग को गतिशील रूप से समायोजित करने के लिए EdgeInsets कंस्ट्रक्टर और मीडिया क्वेरी का उपयोग कैसे करें। इसके अतिरिक्त, वक्ता यह प्रदर्शित करता है कि सामग्री ओवरलैप होने पर स्क्रॉल करने की अनुमति देने के लिए SingleChildScrollView में कंटेनरों को कैसे लपेटा जाए, जो समस्या का व्यावहारिक समाधान प्रदान करता है। वे उल्लेख करते हैं कि अधिक उन्नत समाधानों में उपयोगकर्ता इंटरैक्शन को और बेहतर बनाने के लिए मॉडल बॉटम शीट को कस्टमाइज़ करना शामिल हो सकता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador aborda o problema do teclado virtual que cobre os campos de entrada numa aplicação Flutter, dificultando a escrita em ecrãs mais pequenos ou no modo paisagem. Ao utilizar as ferramentas Flutter, o orador mostra como ajustar o preenchimento dos contentores para os mover para cima quando o teclado aparece, garantindo que os utilizadores ainda podem interagir com os campos de entrada. Explicam como utilizar construtores EdgeInsets e media queries para ajustar dinamicamente o preenchimento com base no espaço ocupado pelo teclado. Além disso, o orador demonstra como agrupar contentores no SingleChildScrollView para permitir a rolagem quando o conteúdo se sobrepõe, fornecendo uma solução prática para o problema. Referem que soluções mais avançadas podem envolver a personalização de folhas inferiores modais para melhorar ainda mais a interação do utilizador.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার একটি ফ্লটার অ্যাপে ইনপুট ক্ষেত্রগুলিকে কভার করে নরম কীবোর্ডের সমস্যাটির সমাধান করে, যা ছোট পর্দায় বা ল্যান্ডস্কেপ মোডে টাইপ করা কঠিন করে তোলে। Flutter-এর টুলস ব্যবহার করে, স্পিকার দেখায় কিভাবে কীবোর্ড প্রদর্শিত হলে কনটেইনারগুলির প্যাডিং সামঞ্জস্য করতে হয়, যাতে ব্যবহারকারীরা এখনও ইনপুট ক্ষেত্রগুলির সাথে যোগাযোগ করতে পারে। তারা ব্যাখ্যা করে কিভাবে EdgeInsets কনস্ট্রাক্টর এবং মিডিয়া ক্যোয়ারী ব্যবহার করে কীবোর্ড দ্বারা দখলকৃত স্থানের উপর ভিত্তি করে গতিশীলভাবে প্যাডিং সামঞ্জস্য করা যায়। অতিরিক্তভাবে, স্পিকার দেখায় কিভাবে SingleChildScrollView-এ কন্টেইনারগুলিকে মোড়ানো যায় যাতে বিষয়বস্তু ওভারল্যাপ হয়ে গেলে স্ক্রল করার অনুমতি দেয়, সমস্যার একটি বাস্তব সমাধান প্রদান করে। তারা উল্লেখ করেছে যে আরও উন্নত সমাধানগুলি ব্যবহারকারীর মিথস্ক্রিয়াকে আরও উন্নত করতে মডেলের নীচের শীটগুলি কাস্টমাইজ করতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يتناول المتحدث مشكلة لوحة المفاتيح الناعمة التي تغطي حقول الإدخال في تطبيق Flutter، مما يجعل من الصعب الكتابة على الشاشات الصغيرة أو في وضع أفقي. من خلال الاستفادة من أدوات Flutter، يوضح المتحدث كيفية ضبط حشو الحاويات لتحريكها لأعلى عند ظهور لوحة المفاتيح، مما يضمن استمرار المستخدمين في التفاعل مع حقول الإدخال. كما يشرح كيفية استخدام منشئي EdgeInsets واستعلام الوسائط لضبط الحشو ديناميكيًا بناءً على المساحة التي تشغلها لوحة المفاتيح. بالإضافة إلى ذلك، يوضح المتحدث كيفية تغليف الحاويات في SingleChildScrollView للسماح بالتمرير عند تداخل المحتوى، مما يوفر حلاً عمليًا للمشكلة. ويذكر أن الحلول الأكثر تقدمًا يمكن أن تتضمن تخصيص أوراق أسفل النموذج لتحسين تفاعل المستخدم بشكل أكبر.",
                                // Persian
                                "فارسی": "در این آموزش، بلندگو به این موضوع می پردازد که صفحه کلید نرم فیلدهای ورودی را در یک برنامه Flutter پوشش می دهد و تایپ در صفحه های کوچکتر یا در حالت افقی را دشوار می کند. با استفاده از ابزارهای Flutter، بلندگو نشان می‌دهد که چگونه می‌توان بالشتک‌های کانتینرها را تنظیم کرد تا وقتی صفحه‌کلید ظاهر می‌شود، آن‌ها را به سمت بالا ببرند و اطمینان حاصل شود که کاربران همچنان می‌توانند با فیلدهای ورودی تعامل داشته باشند. آنها نحوه استفاده از سازنده های EdgeInsets و پرس و جو رسانه ای را برای تنظیم پویا padding بر اساس فضای اشغال شده توسط صفحه کلید توضیح می دهند. علاوه بر این، بلندگو نشان می‌دهد که چگونه ظرف‌ها را در SingleChildScrollView بپیچید تا امکان اسکرول در هنگام همپوشانی محتوا فراهم شود و راه‌حلی عملی برای مشکل ارائه شود. آن‌ها اشاره می‌کنند که راه‌حل‌های پیشرفته‌تر می‌توانند شامل سفارشی‌سازی صفحات پایین مدال برای بهبود بیشتر تعامل کاربر باشد.",
                            },
                        },
                        // 113 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Using the Device Size in Conditions",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the speaker demonstrates how to dynamically adjust the content displayed on a Flutter app based on the available screen width. They show how to add additional information to an IconButton based on screen size, such as showing a text label next to the icon when there is enough space. By using MediaQuery to access the screen width and conditionally rendering different widgets using FlatButton constructors, the speaker showcases how to create a more responsive and flexible user interface. They highlight the importance of considering screen size rather than orientation and provide a practical example of how to show or hide content based on the device's width, allowing for the development of truly adaptable apps.",
                                // German
                                "Deutsch": "In diesem Tutorial demonstriert der Sprecher, wie der in einer Flutter-App angezeigte Inhalt dynamisch an die verfügbare Bildschirmbreite angepasst werden kann. Er zeigt, wie einem IconButton basierend auf der Bildschirmgröße zusätzliche Informationen hinzugefügt werden können, z. B. die Anzeige einer Textbeschriftung neben dem Symbol, wenn genügend Platz vorhanden ist. Durch die Verwendung von MediaQuery zum Zugriff auf die Bildschirmbreite und die bedingte Darstellung verschiedener Widgets mithilfe von FlatButton-Konstruktoren zeigt der Sprecher, wie eine reaktionsschnellere und flexiblere Benutzeroberfläche erstellt werden kann. Er betont, wie wichtig es ist, die Bildschirmgröße statt der Ausrichtung zu berücksichtigen, und liefert ein praktisches Beispiel dafür, wie Inhalte basierend auf der Breite des Geräts angezeigt oder ausgeblendet werden können, was die Entwicklung wirklich anpassbarer Apps ermöglicht.",
                                // Chinese
                                "中国人": "在本教程中，演讲者演示了如何根据可用的屏幕宽度动态调整 Flutter 应用上显示的内容。他们展示了如何根据屏幕尺寸向 IconButton 添加其他信息，例如当有足够空间时在图标旁边显示文本标签。通过使用 MediaQuery 访问屏幕宽度并使用 FlatButton 构造函数有条件地渲染不同的小部件，演讲者展示了如何创建响应更快、更灵活的用户界面。他们强调了考虑屏幕尺寸而不是方向的重要性，并提供了一个实际示例，说明如何根据设备的宽度显示或隐藏内容，从而开发出真正适应性强的应用。",
                                // Russian
                                "Русский": "В этом уроке докладчик демонстрирует, как динамически настраивать содержимое, отображаемое в приложении Flutter, на основе доступной ширины экрана. Они показывают, как добавлять дополнительную информацию к IconButton на основе размера экрана, например, показывать текстовую метку рядом со значком, когда есть достаточно места. Используя MediaQuery для доступа к ширине экрана и условно отображая различные виджеты с помощью конструкторов FlatButton, докладчик демонстрирует, как создать более отзывчивый и гибкий пользовательский интерфейс. Они подчеркивают важность учета размера экрана, а не ориентации, и приводят практический пример того, как показывать или скрывать содержимое на основе ширины устройства, что позволяет разрабатывать действительно адаптируемые приложения.",
                                // French
                                "Français": "Dans ce didacticiel, l'intervenant montre comment ajuster de manière dynamique le contenu affiché sur une application Flutter en fonction de la largeur d'écran disponible. Il montre comment ajouter des informations supplémentaires à un IconButton en fonction de la taille de l'écran, par exemple en affichant une étiquette de texte à côté de l'icône lorsqu'il y a suffisamment d'espace. En utilisant MediaQuery pour accéder à la largeur de l'écran et en effectuant le rendu conditionnel de différents widgets à l'aide de constructeurs FlatButton, l'intervenant montre comment créer une interface utilisateur plus réactive et plus flexible. Il souligne l'importance de prendre en compte la taille de l'écran plutôt que l'orientation et fournit un exemple pratique de la manière d'afficher ou de masquer du contenu en fonction de la largeur de l'appareil, permettant ainsi le développement d'applications véritablement adaptables.",
                                // Japanese
                                "日本語": "このチュートリアルでは、利用可能な画面の幅に基づいて、Flutter アプリに表示されるコンテンツを動的に調整する方法を講師が実演します。十分なスペースがある場合にアイコンの横にテキスト ラベルを表示するなど、画面サイズに基づいて IconButton に追加情報を追加する方法を示します。MediaQuery を使用して画面の幅にアクセスし、FlatButton コンストラクターを使用してさまざまなウィジェットを条件付きでレンダリングすることで、講師はより応答性が高く柔軟なユーザー インターフェースを作成する方法を紹介します。画面の向きではなくサイズを考慮することの重要性を強調し、デバイスの幅に基づいてコンテンツを表示または非表示にする方法の実用的な例を示して、真に適応性の高いアプリの開発を可能にします。",
                                // Korean
                                "한국인": "이 튜토리얼에서 발표자는 사용 가능한 화면 너비에 따라 Flutter 앱에 표시되는 콘텐츠를 동적으로 조정하는 방법을 보여줍니다. 충분한 공간이 있을 때 아이콘 옆에 텍스트 레이블을 표시하는 것과 같이 화면 크기에 따라 IconButton에 추가 정보를 추가하는 방법을 보여줍니다. 발표자는 MediaQuery를 사용하여 화면 너비에 액세스하고 FlatButton 생성자를 사용하여 다양한 위젯을 조건부로 렌더링하여 더욱 반응성 있고 유연한 사용자 인터페이스를 만드는 방법을 보여줍니다. 방향보다는 화면 크기를 고려하는 것의 중요성을 강조하고 장치의 너비에 따라 콘텐츠를 표시하거나 숨기는 방법에 대한 실제적인 예를 제공하여 진정으로 적응 가능한 앱을 개발할 수 있도록 합니다.",
                                // Spanish
                                "Español": "En este tutorial, el orador demuestra cómo ajustar dinámicamente el contenido que se muestra en una aplicación Flutter en función del ancho de pantalla disponible. Muestra cómo agregar información adicional a un IconButton en función del tamaño de la pantalla, como mostrar una etiqueta de texto junto al ícono cuando hay suficiente espacio. Al usar MediaQuery para acceder al ancho de la pantalla y representar condicionalmente diferentes widgets mediante constructores FlatButton, el orador muestra cómo crear una interfaz de usuario más flexible y con mayor capacidad de respuesta. Destaca la importancia de considerar el tamaño de la pantalla en lugar de la orientación y brinda un ejemplo práctico de cómo mostrar u ocultar contenido en función del ancho del dispositivo, lo que permite el desarrollo de aplicaciones verdaderamente adaptables.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, वक्ता यह प्रदर्शित करता है कि उपलब्ध स्क्रीन चौड़ाई के आधार पर फ़्लटर ऐप पर प्रदर्शित सामग्री को गतिशील रूप से कैसे समायोजित किया जाए। वे दिखाते हैं कि स्क्रीन आकार के आधार पर आइकनबटन में अतिरिक्त जानकारी कैसे जोड़ें, जैसे कि पर्याप्त स्थान होने पर आइकन के बगल में एक टेक्स्ट लेबल दिखाना। स्क्रीन की चौड़ाई तक पहुँचने के लिए MediaQuery का उपयोग करके और FlatButton कंस्ट्रक्टर का उपयोग करके विभिन्न विजेट को सशर्त रूप से प्रस्तुत करके, वक्ता यह दिखाता है कि अधिक उत्तरदायी और लचीला उपयोगकर्ता इंटरफ़ेस कैसे बनाया जाए। वे अभिविन्यास के बजाय स्क्रीन आकार पर विचार करने के महत्व को उजागर करते हैं और डिवाइस की चौड़ाई के आधार पर सामग्री को दिखाने या छिपाने का एक व्यावहारिक उदाहरण प्रदान करते हैं, जिससे वास्तव में अनुकूलनीय ऐप्स के विकास की अनुमति मिलती है।",
                                // Portuguese
                                "Português": "Neste tutorial, o orador demonstra como ajustar dinamicamente o conteúdo apresentado numa aplicação Flutter com base na largura de ecrã disponível. Mostram como adicionar informações adicionais a um IconButton com base no tamanho do ecrã, como mostrar um rótulo de texto junto ao ícone quando há espaço suficiente. Ao utilizar o MediaQuery para aceder à largura do ecrã e renderizar condicionalmente diferentes widgets utilizando construtores FlatButton, o orador mostra como criar uma interface de utilizador mais ágil e flexível. Realçam a importância de considerar o tamanho do ecrã em vez da orientação e fornecem um exemplo prático de como mostrar ou ocultar conteúdo com base na largura do dispositivo, permitindo o desenvolvimento de aplicações verdadeiramente adaptáveis.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, স্পিকার প্রদর্শন করে যে কীভাবে উপলব্ধ স্ক্রিনের প্রস্থের উপর ভিত্তি করে একটি ফ্লাটার অ্যাপে প্রদর্শিত বিষয়বস্তুকে গতিশীলভাবে সামঞ্জস্য করা যায়। তারা দেখায় কিভাবে স্ক্রীনের আকারের উপর ভিত্তি করে একটি আইকন বোতামে অতিরিক্ত তথ্য যোগ করতে হয়, যেমন পর্যাপ্ত জায়গা থাকলে আইকনের পাশে একটি টেক্সট লেবেল দেখানো। স্ক্রীনের প্রস্থ অ্যাক্সেস করতে MediaQuery ব্যবহার করে এবং FlatButton কনস্ট্রাক্টর ব্যবহার করে শর্তসাপেক্ষে বিভিন্ন উইজেট রেন্ডার করার মাধ্যমে, স্পিকার কীভাবে আরও প্রতিক্রিয়াশীল এবং নমনীয় ব্যবহারকারী ইন্টারফেস তৈরি করতে হয় তা প্রদর্শন করে। তারা অরিয়েন্টেশনের পরিবর্তে স্ক্রীনের আকার বিবেচনা করার গুরুত্ব তুলে ধরে এবং ডিভাইসের প্রস্থের উপর ভিত্তি করে কীভাবে বিষয়বস্তু দেখাতে বা লুকানো যায় তার একটি বাস্তব উদাহরণ প্রদান করে, যা সত্যিকারের অভিযোজনযোগ্য অ্যাপগুলির বিকাশের অনুমতি দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يوضح المتحدث كيفية ضبط المحتوى المعروض على تطبيق Flutter بشكل ديناميكي بناءً على عرض الشاشة المتاح. كما يوضح كيفية إضافة معلومات إضافية إلى IconButton بناءً على حجم الشاشة، مثل عرض تسمية نصية بجوار الرمز عندما تكون هناك مساحة كافية. من خلال استخدام MediaQuery للوصول إلى عرض الشاشة والرسم المشروط لعناصر واجهة المستخدم المختلفة باستخدام منشئي FlatButton، يوضح المتحدث كيفية إنشاء واجهة مستخدم أكثر استجابة ومرونة. كما يسلط الضوء على أهمية مراعاة حجم الشاشة بدلاً من الاتجاه ويوفر مثالاً عمليًا لكيفية إظهار أو إخفاء المحتوى بناءً على عرض الجهاز، مما يسمح بتطوير تطبيقات قابلة للتكيف حقًا.",
                                // Persian
                                "فارسی": "در این آموزش، بلندگو نحوه تنظیم پویا محتوای نمایش داده شده در برنامه Flutter را بر اساس عرض صفحه نمایش در دسترس نشان می دهد. آنها نشان می دهند که چگونه می توان اطلاعات اضافی را بر اساس اندازه صفحه به یک IconButton اضافه کرد، مانند نشان دادن برچسب متنی در کنار نماد زمانی که فضای کافی وجود دارد. با استفاده از MediaQuery برای دسترسی به عرض صفحه و رندر کردن شرطی ویجت های مختلف با استفاده از سازنده FlatButton، بلندگو نحوه ایجاد یک رابط کاربری پاسخگوتر و انعطاف پذیرتر را نشان می دهد. آنها اهمیت در نظر گرفتن اندازه صفحه نمایش را به جای جهت گیری برجسته می کنند و یک مثال عملی از نحوه نمایش یا پنهان کردن محتوا بر اساس عرض دستگاه ارائه می دهند که امکان توسعه برنامه های واقعاً سازگار را فراهم می کند.",
                            },
                        },
                        // 114 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Managing the MediaQuery Object",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker provides a final note on efficiency when using MediaQuery multiple times within the same widget tree in a Flutter app. They recommend storing the MediaQuery object in a variable at the beginning of the build method and then reusing that variable throughout the widget tree to avoid unnecessary performance costs and re-render cycles. By utilizing one instance of the MediaQuery object, developers can improve efficiency and maintain consistency in data retrieval throughout the app, ensuring that the app maintains functionality while optimizing performance.",
                                // German
                                "Deutsch": "In diesem Video gibt der Sprecher einen letzten Hinweis zur Effizienz bei der mehrmaligen Verwendung von MediaQuery innerhalb desselben Widget-Baums in einer Flutter-App. Er empfiehlt, das MediaQuery-Objekt am Anfang der Build-Methode in einer Variablen zu speichern und diese Variable dann im gesamten Widget-Baum wiederzuverwenden, um unnötige Leistungskosten und erneute Renderzyklen zu vermeiden. Durch die Verwendung einer Instanz des MediaQuery-Objekts können Entwickler die Effizienz verbessern und die Konsistenz beim Datenabruf in der gesamten App aufrechterhalten, wodurch sichergestellt wird, dass die App ihre Funktionalität beibehält und gleichzeitig die Leistung optimiert.",
                                // Chinese
                                "中国人": "在本视频中，演讲者最后介绍了在 Flutter 应用中的同一个 widget 树中多次使用 MediaQuery 时的效率。他们建议在构建方法开始时将 MediaQuery 对象存储在一个变量中，然后在整个 widget 树中重复使用该变量，以避免不必要的性能成本和重新渲染周期。通过利用 MediaQuery 对象的一个​​实例，开发人员可以提高效率并在整个应用中保持数据检索的一致性，从而确保应用在优化性能的同时保持功能性。",
                                // Russian
                                "Русский": "В этом видео докладчик делает заключительное замечание об эффективности при многократном использовании MediaQuery в одном и том же дереве виджетов в приложении Flutter. Они рекомендуют сохранять объект MediaQuery в переменной в начале метода сборки, а затем повторно использовать эту переменную во всем дереве виджетов, чтобы избежать ненужных затрат производительности и циклов повторной визуализации. Используя один экземпляр объекта MediaQuery, разработчики могут повысить эффективность и поддерживать согласованность в извлечении данных во всем приложении, гарантируя, что приложение сохранит функциональность при оптимизации производительности.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant fournit une note finale sur l'efficacité lors de l'utilisation de MediaQuery plusieurs fois dans la même arborescence de widgets dans une application Flutter. Il recommande de stocker l'objet MediaQuery dans une variable au début de la méthode de construction, puis de réutiliser cette variable dans l'ensemble de l'arborescence des widgets pour éviter des coûts de performances inutiles et des cycles de rendu. En utilisant une instance de l'objet MediaQuery, les développeurs peuvent améliorer l'efficacité et maintenir la cohérence dans la récupération des données dans toute l'application, garantissant ainsi que l'application conserve ses fonctionnalités tout en optimisant les performances.",
                                // Japanese
                                "日本語": "このビデオでは、スピーカーが、Flutter アプリの同じウィジェット ツリー内で MediaQuery を複数回使用する場合の効率性について最終的な注意点を説明しています。不要なパフォーマンス コストと再レンダリング サイクルを回避するために、ビルド メソッドの先頭で MediaQuery オブジェクトを変数に保存し、その変数をウィジェット ツリー全体で再利用することを推奨しています。MediaQuery オブジェクトの 1 つのインスタンスを利用することで、開発者は効率性を向上させ、アプリ全体でデータ取得の一貫性を維持できるため、アプリが機能を維持しながらパフォーマンスを最適化できます。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 앱에서 동일한 위젯 트리 내에서 MediaQuery를 여러 번 사용할 때의 효율성에 대한 마지막 참고 사항을 제공합니다. 발표자는 빌드 메서드의 시작 부분에 있는 변수에 MediaQuery 객체를 저장한 다음 위젯 트리 전체에서 해당 변수를 재사용하여 불필요한 성능 비용과 재렌더링 주기를 방지할 것을 권장합니다. 개발자는 MediaQuery 객체의 한 인스턴스를 활용하여 효율성을 개선하고 앱 전체에서 데이터 검색의 일관성을 유지하여 앱이 기능을 유지하면서 성능을 최적화할 수 있습니다.",
                                // Spanish
                                "Español": "En este video, el orador brinda una nota final sobre la eficiencia al usar MediaQuery varias veces dentro del mismo árbol de widgets en una aplicación Flutter. Recomienda almacenar el objeto MediaQuery en una variable al comienzo del método de compilación y luego reutilizar esa variable en todo el árbol de widgets para evitar costos de rendimiento innecesarios y ciclos de renderización repetidos. Al utilizar una instancia del objeto MediaQuery, los desarrolladores pueden mejorar la eficiencia y mantener la coherencia en la recuperación de datos en toda la aplicación, lo que garantiza que la aplicación mantenga la funcionalidad y optimice el rendimiento.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर ऐप में एक ही विजेट ट्री में कई बार MediaQuery का उपयोग करते समय दक्षता पर एक अंतिम नोट प्रदान करता है। वे बिल्ड विधि की शुरुआत में एक चर में MediaQuery ऑब्जेक्ट को संग्रहीत करने और फिर अनावश्यक प्रदर्शन लागत और री-रेंडर चक्रों से बचने के लिए विजेट ट्री में उस चर का पुन: उपयोग करने की सलाह देते हैं। MediaQuery ऑब्जेक्ट के एक इंस्टेंस का उपयोग करके, डेवलपर्स दक्षता में सुधार कर सकते हैं और पूरे ऐप में डेटा पुनर्प्राप्ति में स्थिरता बनाए रख सकते हैं, यह सुनिश्चित करते हुए कि ऐप प्रदर्शन को अनुकूलित करते हुए कार्यक्षमता बनाए रखता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador fornece uma nota final sobre a eficiência ao utilizar o MediaQuery várias vezes na mesma árvore de widgets numa aplicação Flutter. Recomendam armazenar o objeto MediaQuery numa variável no início do método de construção e, em seguida, reutilizar essa variável em toda a árvore de widgets para evitar custos desnecessários de desempenho e ciclos de nova renderização. Ao utilizar uma instância do objeto MediaQuery, os programadores podem melhorar a eficiência e manter a consistência na recuperação de dados em toda a aplicação, garantindo que a aplicação mantém a funcionalidade enquanto otimiza o desempenho.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি Flutter অ্যাপে একই উইজেট ট্রির মধ্যে MediaQuery একাধিকবার ব্যবহার করার সময় দক্ষতার উপর একটি চূড়ান্ত নোট প্রদান করে। তারা বিল্ড পদ্ধতির শুরুতে একটি ভেরিয়েবলে MediaQuery অবজেক্ট সংরক্ষণ করার এবং তারপর অপ্রয়োজনীয় পারফরম্যান্স খরচ এড়াতে এবং পুনরায় রেন্ডার চক্র এড়াতে উইজেট ট্রি জুড়ে সেই ভেরিয়েবলটিকে পুনরায় ব্যবহার করার পরামর্শ দেয়। MediaQuery অবজেক্টের একটি উদাহরণ ব্যবহার করে, ডেভেলপাররা কার্যকারিতা উন্নত করতে পারে এবং সমগ্র অ্যাপ জুড়ে ডেটা পুনরুদ্ধারে ধারাবাহিকতা বজায় রাখতে পারে, এটি নিশ্চিত করে যে অ্যাপটি কার্যকারিতা অপ্টিমাইজ করার সময় কার্যকারিতা বজায় রাখে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يقدم المتحدث ملاحظة أخيرة حول الكفاءة عند استخدام MediaQuery عدة مرات داخل شجرة الأدوات نفسها في تطبيق Flutter. ويوصي بتخزين كائن MediaQuery في متغير في بداية طريقة البناء ثم إعادة استخدام هذا المتغير في شجرة الأدوات لتجنب تكاليف الأداء غير الضرورية ودورات إعادة العرض. من خلال الاستفادة من مثيل واحد لكائن MediaQuery، يمكن للمطورين تحسين الكفاءة والحفاظ على الاتساق في استرداد البيانات في جميع أنحاء التطبيق، مما يضمن أن التطبيق يحافظ على الوظائف مع تحسين الأداء.",
                                // Persian
                                "فارسی": "در این ویدیو، بلندگو هنگام استفاده چند بار از MediaQuery در یک درخت ویجت در یک برنامه Flutter، یادداشت نهایی را در مورد کارایی ارائه می دهد. آنها توصیه می کنند شی MediaQuery را در یک متغیر در ابتدای روش ساخت ذخیره کنید و سپس از آن متغیر در سراسر درخت ویجت استفاده مجدد کنید تا از هزینه های عملکرد غیر ضروری و چرخه های رندر مجدد جلوگیری شود. با استفاده از یک نمونه از شی MediaQuery، توسعه‌دهندگان می‌توانند کارایی را بهبود بخشند و در بازیابی داده‌ها در سراسر برنامه سازگاری داشته باشند، و اطمینان حاصل کنند که برنامه در عین بهینه‌سازی عملکرد، عملکرد را حفظ می‌کند.",
                            },
                        },
                        // 115 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Checking the Device Platform",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker addresses the importance of creating adaptive user interfaces for iOS devices in a Flutter app, focusing on customizing the appearance to align with iOS design patterns. They emphasize the need to adjust certain UI elements, such as the switch and floating action button, for iOS-specific styling to enhance user experience. By showcasing examples of how to utilize adaptive constructors for widgets like the switch to automatically adjust based on platform, and how to conditionally render components based on the platform (iOS in this case), the speaker demonstrates techniques for creating platform-specific UI adaptations. Additionally, they explain how to determine the platform the app is running on using platform-specific features in Dart, allowing for the seamless customization of widgets based on the operating system, culminating in an optimized and intuitive user interface design tailored for iOS devices.",
                                // German
                                "Deutsch": "In diesem Video geht der Sprecher auf die Bedeutung der Erstellung adaptiver Benutzeroberflächen für iOS-Geräte in einer Flutter-App ein und konzentriert sich dabei auf die Anpassung des Erscheinungsbilds an iOS-Designmuster. Er betont die Notwendigkeit, bestimmte UI-Elemente wie den Schalter und die schwebende Aktionsschaltfläche an das iOS-spezifische Styling anzupassen, um das Benutzererlebnis zu verbessern. Anhand von Beispielen zur Verwendung adaptiver Konstruktoren für Widgets wie den Schalter zur automatischen Anpassung an die Plattform und zur bedingten Darstellung von Komponenten basierend auf der Plattform (in diesem Fall iOS) demonstriert der Sprecher Techniken zum Erstellen plattformspezifischer UI-Anpassungen. Darüber hinaus erklärt er, wie die Plattform ermittelt werden kann, auf der die App ausgeführt wird, indem plattformspezifische Funktionen in Dart verwendet werden, wodurch eine nahtlose Anpassung von Widgets basierend auf dem Betriebssystem ermöglicht wird, was in einem optimierten und intuitiven Benutzeroberflächendesign gipfelt, das auf iOS-Geräte zugeschnitten ist.",
                                // Chinese
                                "中国人": "在本视频中，演讲者介绍了在 Flutter 应用中为 iOS 设备创建自适应用户界面的重要性，重点介绍了自定义外观以符合 iOS 设计模式。他们强调需要调整某些 UI 元素（例如开关和浮动操作按钮），以获得特定于 iOS 的样式，以增强用户体验。通过展示如何利用开关等小部件的自适应构造函数根据平台自动调整以及如何根据平台（在本例中为 iOS）有条件地渲染组件的示例，演讲者演示了创建特定于平台的 UI 适配的技术。此外，他们还解释了如何使用 Dart 中特定于平台的功能来确定应用所运行的平台，从而允许根据操作系统无缝自定义小部件，最终设计出针对 iOS 设备优化且直观的用户界面。",
                                // Russian
                                "Русский": "В этом видео докладчик рассматривает важность создания адаптивных пользовательских интерфейсов для устройств iOS в приложении Flutter, уделяя особое внимание настройке внешнего вида в соответствии с шаблонами дизайна iOS. Они подчеркивают необходимость настройки определенных элементов пользовательского интерфейса, таких как переключатель и плавающая кнопка действия, для специфичного для iOS стиля, чтобы улучшить пользовательский опыт. Демонстрируя примеры того, как использовать адаптивные конструкторы для виджетов, таких как переключатель, для автоматической настройки на основе платформы, и как условно отображать компоненты на основе платформы (в данном случае iOS), докладчик демонстрирует методы создания адаптаций пользовательского интерфейса для конкретной платформы. Кроме того, они объясняют, как определить платформу, на которой работает приложение, с помощью специфичных для платформы функций в Dart, что позволяет бесшовно настраивать виджеты на основе операционной системы, что приводит к оптимизированному и интуитивно понятному дизайну пользовательского интерфейса, адаптированному для устройств iOS.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant aborde l'importance de créer des interfaces utilisateur adaptatives pour les appareils iOS dans une application Flutter, en se concentrant sur la personnalisation de l'apparence pour l'aligner sur les modèles de conception iOS. Il souligne la nécessité d'ajuster certains éléments de l'interface utilisateur, tels que le commutateur et le bouton d'action flottant, pour un style spécifique à iOS afin d'améliorer l'expérience utilisateur. En présentant des exemples d'utilisation de constructeurs adaptatifs pour des widgets tels que le commutateur pour s'ajuster automatiquement en fonction de la plateforme, et comment restituer conditionnellement des composants en fonction de la plateforme (iOS dans ce cas), l'intervenant démontre des techniques pour créer des adaptations d'interface utilisateur spécifiques à la plateforme. De plus, il explique comment déterminer la plateforme sur laquelle l'application s'exécute à l'aide de fonctionnalités spécifiques à la plateforme dans Dart, permettant une personnalisation transparente des widgets en fonction du système d'exploitation, aboutissant à une conception d'interface utilisateur optimisée et intuitive adaptée aux appareils iOS.",
                                // Japanese
                                "日本語": "このビデオでは、スピーカーが Flutter アプリで iOS デバイス用のアダプティブ ユーザー インターフェースを作成することの重要性について説明し、iOS のデザイン パターンに合わせて外観をカスタマイズすることに焦点を当てています。ユーザー エクスペリエンスを向上させるには、スイッチやフローティング アクション ボタンなどの特定の UI 要素を iOS 固有のスタイルに調整する必要があることを強調しています。スイッチなどのウィジェットのアダプティブ コンストラクターを使用してプラットフォームに基づいて自動的に調整する方法や、プラットフォーム (この場合は iOS) に基づいてコンポーネントを条件付きでレンダリングする方法の例を紹介することで、スピーカーはプラットフォーム固有の UI 適応を作成するための手法を実演します。さらに、アプリが実行されているプラ​​ットフォームを Dart のプラットフォーム固有の機能を使用して判別する方法についても説明します。これにより、オペレーティング システムに基づいてウィジェットをシームレスにカスタマイズして、iOS デバイスに合わせて最適化された直感的なユーザー インターフェース デザインを実現できます。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 앱에서 iOS 기기에 대한 적응형 사용자 인터페이스를 만드는 것의 중요성에 대해 설명하며, iOS 디자인 패턴에 맞게 모양을 사용자 지정하는 데 중점을 둡니다. 그들은 스위치 및 플로팅 작업 버튼과 같은 특정 UI 요소를 조정하여 사용자 경험을 향상시키기 위해 iOS 특정 스타일로 조정해야 할 필요성을 강조합니다. 발표자는 플랫폼에 따라 자동으로 조정되는 스위치와 같은 위젯에 대한 적응형 생성자를 활용하는 방법과 플랫폼(이 경우 iOS)에 따라 구성 요소를 조건부로 렌더링하는 방법의 예를 보여줌으로써 플랫폼별 UI 적응을 만드는 기술을 보여줍니다. 또한 그들은 Dart의 플랫폼별 기능을 사용하여 앱이 실행되는 플랫폼을 확인하는 방법을 설명하여 운영 체제에 따라 위젯을 원활하게 사용자 지정할 수 있으며, iOS 기기에 맞게 최적화된 직관적인 사용자 인터페이스 디자인을 완성합니다.",
                                // Spanish
                                "Español": "En este video, el orador aborda la importancia de crear interfaces de usuario adaptables para dispositivos iOS en una aplicación Flutter, centrándose en personalizar la apariencia para alinearla con los patrones de diseño de iOS. Hace hincapié en la necesidad de ajustar ciertos elementos de la interfaz de usuario, como el interruptor y el botón de acción flotante, para un estilo específico de iOS con el fin de mejorar la experiencia del usuario. Al mostrar ejemplos de cómo utilizar constructores adaptables para widgets como el interruptor para que se ajusten automáticamente en función de la plataforma y cómo renderizar componentes de manera condicional en función de la plataforma (iOS en este caso), el orador demuestra técnicas para crear adaptaciones de interfaz de usuario específicas para cada plataforma. Además, explica cómo determinar la plataforma en la que se ejecuta la aplicación mediante funciones específicas de la plataforma en Dart, lo que permite una personalización perfecta de los widgets en función del sistema operativo, lo que culmina en un diseño de interfaz de usuario optimizado e intuitivo adaptado a los dispositivos iOS.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर ऐप में iOS डिवाइस के लिए अनुकूली उपयोगकर्ता इंटरफ़ेस बनाने के महत्व को संबोधित करता है, जो iOS डिज़ाइन पैटर्न के साथ संरेखित करने के लिए उपस्थिति को अनुकूलित करने पर ध्यान केंद्रित करता है। वे उपयोगकर्ता अनुभव को बढ़ाने के लिए iOS-विशिष्ट स्टाइलिंग के लिए स्विच और फ़्लोटिंग एक्शन बटन जैसे कुछ UI तत्वों को समायोजित करने की आवश्यकता पर जोर देते हैं। प्लेटफ़ॉर्म के आधार पर स्वचालित रूप से समायोजित करने के लिए स्विच जैसे विजेट के लिए अनुकूली कंस्ट्रक्टर का उपयोग करने के तरीके और प्लेटफ़ॉर्म (इस मामले में iOS) के आधार पर घटकों को सशर्त रूप से प्रस्तुत करने के तरीके के उदाहरणों को प्रदर्शित करके, वक्ता प्लेटफ़ॉर्म-विशिष्ट UI अनुकूलन बनाने की तकनीकों का प्रदर्शन करता है। इसके अतिरिक्त, वे बताते हैं कि डार्ट में प्लेटफ़ॉर्म-विशिष्ट सुविधाओं का उपयोग करके ऐप किस प्लेटफ़ॉर्म पर चल रहा है, यह निर्धारित करने का तरीका, ऑपरेटिंग सिस्टम के आधार पर विजेट के सहज अनुकूलन की अनुमति देता है, जो iOS डिवाइस के लिए अनुकूलित एक अनुकूलित और सहज उपयोगकर्ता इंटरफ़ेस डिज़ाइन में परिणत होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador aborda a importância de criar interfaces de utilizador adaptáveis ​​para dispositivos iOS numa aplicação Flutter, com foco na personalização da aparência para se alinhar com os padrões de design do iOS. Enfatizam a necessidade de ajustar certos elementos da interface do utilizador, como o interruptor e o botão de ação flutuante, para um estilo específico do iOS para melhorar a experiência do utilizador. Ao apresentar exemplos de como utilizar construtores adaptativos para widgets, como o switch para o ajuste automático com base na plataforma, e como renderizar condicionalmente componentes com base na plataforma (iOS, neste caso), o orador demonstra técnicas para criar adaptações de UI específicas da plataforma . Além disso, explicam como determinar a plataforma em que a aplicação está a ser executada utilizando funcionalidades específicas da plataforma no Dart, permitindo a personalização perfeita dos widgets com base no sistema operativo, culminando num design de interface de utilizador otimizado e intuitivo, feito sob medida para dispositivos iOS.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি Flutter অ্যাপে iOS ডিভাইসগুলির জন্য অভিযোজিত ব্যবহারকারী ইন্টারফেস তৈরি করার গুরুত্বকে সম্বোধন করেছেন, iOS ডিজাইনের প্যাটার্নগুলির সাথে সারিবদ্ধ করার জন্য চেহারাটি কাস্টমাইজ করার উপর ফোকাস করে৷ তারা ব্যবহারকারীর অভিজ্ঞতা বাড়াতে iOS-নির্দিষ্ট স্টাইলিং-এর জন্য সুইচ এবং ফ্লোটিং অ্যাকশন বোতামের মতো নির্দিষ্ট UI উপাদানগুলিকে সামঞ্জস্য করার প্রয়োজনীয়তার উপর জোর দেয়। প্ল্যাটফর্মের উপর ভিত্তি করে স্বয়ংক্রিয়ভাবে সামঞ্জস্য করার জন্য স্যুইচের মতো উইজেটগুলির জন্য অভিযোজিত কনস্ট্রাক্টরগুলিকে কীভাবে ব্যবহার করা যায় এবং প্ল্যাটফর্মের উপর ভিত্তি করে কীভাবে শর্তসাপেক্ষে উপাদানগুলি রেন্ডার করতে হয় (এই ক্ষেত্রে আইওএস), স্পিকার প্ল্যাটফর্ম-নির্দিষ্ট UI অভিযোজন তৈরি করার কৌশলগুলি প্রদর্শন করে। উপরন্তু, তারা ব্যাখ্যা করে যে কীভাবে অ্যাপটি ডার্ট-এ প্ল্যাটফর্ম-নির্দিষ্ট বৈশিষ্ট্যগুলি ব্যবহার করে যে প্ল্যাটফর্মে চলছে তা নির্ধারণ করতে হয়, অপারেটিং সিস্টেমের উপর ভিত্তি করে উইজেটগুলির নিরবিচ্ছিন্ন কাস্টমাইজেশনের অনুমতি দেয়, যা iOS ডিভাইসের জন্য তৈরি একটি অপ্টিমাইজড এবং স্বজ্ঞাত ইউজার ইন্টারফেস ডিজাইনে পরিণত হয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتطرق المتحدث إلى أهمية إنشاء واجهات مستخدم قابلة للتكيف لأجهزة iOS في تطبيق Flutter، مع التركيز على تخصيص المظهر ليتماشى مع أنماط تصميم iOS. ويؤكدون على الحاجة إلى ضبط عناصر واجهة مستخدم معينة، مثل المفتاح وزر الإجراء العائم، من أجل التصميم الخاص بنظام iOS لتعزيز تجربة المستخدم. ومن خلال عرض أمثلة حول كيفية استخدام المنشئين التكيفيين للأدوات مثل المفتاح للتعديل تلقائيًا بناءً على النظام الأساسي، وكيفية عرض المكونات بشكل مشروط بناءً على النظام الأساسي (iOS في هذه الحالة)، يوضح المتحدث تقنيات إنشاء تكيفات واجهة مستخدم خاصة بالنظام الأساسي. بالإضافة إلى ذلك، يشرحون كيفية تحديد النظام الأساسي الذي يعمل عليه التطبيق باستخدام ميزات خاصة بالنظام الأساسي في Dart، مما يسمح بالتخصيص السلس للأدوات بناءً على نظام التشغيل، مما يؤدي إلى تصميم واجهة مستخدم محسّنة وبديهية مصممة خصيصًا لأجهزة iOS.",
                                // Persian
                                "فارسی": "در این ویدیو، بلندگو به اهمیت ایجاد رابط‌های کاربری تطبیقی ​​برای دستگاه‌های iOS در یک برنامه Flutter می‌پردازد و بر سفارشی‌سازی ظاهر برای همسویی با الگوهای طراحی iOS تمرکز دارد. آنها بر نیاز به تنظیم برخی از عناصر رابط کاربری، مانند دکمه سوئیچ و اکشن شناور، برای استایل مخصوص iOS برای بهبود تجربه کاربر تأکید می کنند. با نشان دادن نمونه‌هایی از نحوه استفاده از سازنده‌های تطبیقی ​​برای ویجت‌هایی مانند سوئیچ برای تنظیم خودکار بر اساس پلتفرم، و نحوه نمایش مشروط اجزا بر اساس پلتفرم (در این مورد iOS)، بلندگو تکنیک‌هایی را برای ایجاد سازگاری‌های رابط کاربری خاص پلتفرم نشان می‌دهد. علاوه بر این، آنها توضیح می‌دهند که چگونه می‌توان با استفاده از ویژگی‌های پلتفرم خاص در Dart، پلتفرمی را که برنامه روی آن اجرا می‌شود، تعیین کرد، که امکان سفارشی‌سازی یکپارچه ویجت‌ها را بر اساس سیستم‌عامل فراهم می‌آورد، که منجر به طراحی رابط کاربری بهینه و بصری متناسب با دستگاه‌های iOS می‌شود.",
                            },
                        },
                        // 116 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Using Cupertino (iOS) Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker discusses the process of creating adaptive user interfaces for iOS devices in a Flutter app by customizing the appearance to align with iOS design patterns. They demonstrate how to use Cupertino widgets in conjunction with Platform checks to render Cupertino-styled elements for iOS and Material Design for Android, such as using CupertinoPageScaffold and CupertinoNavigationBar. The speaker explains the importance of importing flutter/cupertino.dart to access Cupertino widgets and addresses challenges, such as errors related to iOS-specific icons and preferred size definitions. Additionally, they show how to resolve issues with CupertinoNavigationBar layout, specifically adjusting MainAxisSize to properly display iOS-specific elements like the plus icon and text. The video showcases the transition from a Material Design to a Cupertino-style UI for iOS, highlighting the importance of accurately styling and rendering elements for platform-specific user experiences.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Sprecher den Prozess der Erstellung adaptiver Benutzeroberflächen für iOS-Geräte in einer Flutter-App, indem das Erscheinungsbild an iOS-Designmuster angepasst wird. Er zeigt, wie Cupertino-Widgets in Verbindung mit Plattformprüfungen verwendet werden, um Cupertino-artige Elemente für iOS und Material Design für Android darzustellen, z. B. mithilfe von CupertinoPageScaffold und CupertinoNavigationBar. Der Sprecher erklärt, wie wichtig es ist, flutter/cupertino.dart zu importieren, um auf Cupertino-Widgets zuzugreifen, und geht auf Herausforderungen ein, z. B. Fehler im Zusammenhang mit iOS-spezifischen Symbolen und bevorzugten Größendefinitionen. Darüber hinaus zeigt er, wie Probleme mit dem CupertinoNavigationBar-Layout gelöst werden können, insbesondere durch Anpassen von MainAxisSize, um iOS-spezifische Elemente wie das Plus-Symbol und Text richtig anzuzeigen. Das Video zeigt den Übergang von einem Material Design zu einer Cupertino-artigen Benutzeroberfläche für iOS und unterstreicht die Bedeutung einer genauen Gestaltung und Darstellung von Elementen für plattformspezifische Benutzererlebnisse.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了在 Flutter 应用中通过自定义外观以符合 iOS 设计模式来为 iOS 设备创建自适应用户界面的过程。他们演示了如何结合使用 Cupertino 小部件和平台检查来为 iOS 和 Android 渲染 Cupertino 风格的元素，例如使用 CupertinoPageScaffold 和 CupertinoNavigationBar。演讲者解释了导入 flutter/cupertino.dart 以访问 Cupertino 小部件的重要性，并解决了一些挑战，例如与 iOS 特定图标和首选大小定义相关的错误。此外，他们还展示了如何解决 CupertinoNavigationBar 布局问题，特别是调整 MainAxisSize 以正确显示 iOS 特定元素，如加号图标和文本。该视频展示了从 Material Design 到 iOS Cupertino 风格 UI 的过渡，强调了准确设计和渲染元素对于特定于平台的用户体验的重要性。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает процесс создания адаптивных пользовательских интерфейсов для устройств iOS в приложении Flutter путем настройки внешнего вида в соответствии с шаблонами дизайна iOS. Они демонстрируют, как использовать виджеты Cupertino в сочетании с проверками платформы для рендеринга элементов в стиле Cupertino для iOS и Material Design для Android, например, с помощью CupertinoPageScaffold и CupertinoNavigationBar. Докладчик объясняет важность импорта flutter/cupertino.dart для доступа к виджетам Cupertino и решает проблемы, такие как ошибки, связанные со значками, специфичными для iOS, и определениями предпочтительных размеров. Кроме того, они показывают, как решать проблемы с макетом CupertinoNavigationBar, в частности, настраивая MainAxisSize для правильного отображения элементов, специфичных для iOS, таких как значок «плюс» и текст. Видео демонстрирует переход от Material Design к пользовательскому интерфейсу в стиле Cupertino для iOS, подчеркивая важность точного оформления и рендеринга элементов для пользовательского опыта, специфичного для платформы.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique le processus de création d'interfaces utilisateur adaptatives pour les appareils iOS dans une application Flutter en personnalisant l'apparence pour l'aligner sur les modèles de conception iOS. Il montre comment utiliser les widgets Cupertino en conjonction avec les vérifications de plate-forme pour restituer des éléments de style Cupertino pour iOS et Material Design pour Android, comme l'utilisation de CupertinoPageScaffold et CupertinoNavigationBar. L'intervenant explique l'importance d'importer flutter/cupertino.dart pour accéder aux widgets Cupertino et aborde les défis, tels que les erreurs liées aux icônes spécifiques à iOS et aux définitions de taille préférées. De plus, il montre comment résoudre les problèmes liés à la mise en page de CupertinoNavigationBar, en ajustant spécifiquement MainAxisSize pour afficher correctement les éléments spécifiques à iOS comme l'icône plus et le texte. La vidéo présente la transition d'un Material Design à une interface utilisateur de style Cupertino pour iOS, soulignant l'importance de styliser et de restituer avec précision les éléments pour des expériences utilisateur spécifiques à la plate-forme.",
                                // Japanese
                                "日本語": "この動画では、iOS のデザイン パターンに合わせて外観をカスタマイズすることで、Flutter アプリで iOS デバイス用のアダプティブ ユーザー インターフェースを作成するプロセスについて説明します。Cupertino ウィジェットをプラットフォーム チェックと組み合わせて使用​​し、CupertinoPageScaffold や CupertinoNavigationBar などを使用して、iOS 用の Cupertino スタイルの要素と Android 用のマテリアル デザインをレンダリングする方法を示します。また、Cupertino ウィジェットにアクセスするために flutter/cupertino.dart をインポートすることの重要性を説明し、iOS 固有のアイコンや推奨サイズの定義に関連するエラーなどの課題に対処します。さらに、CupertinoNavigationBar レイアウトの問題を解決する方法、具体的には MainAxisSize を調整してプラス アイコンやテキストなどの iOS 固有の要素を適切に表示する方法を示します。この動画では、マテリアル デザインから iOS の Cupertino スタイルの UI への移行を紹介し、プラットフォーム固有のユーザー エクスペリエンスのために要素を正確にスタイル設定してレンダリングすることの重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 앱에서 iOS 디자인 패턴에 맞게 모양을 사용자 정의하여 iOS 기기에 대한 적응형 사용자 인터페이스를 만드는 프로세스에 대해 설명합니다. 발표자는 CupertinoPageScaffold 및 CupertinoNavigationBar와 같이 iOS 및 Android용 Material Design의 Cupertino 스타일 요소를 렌더링하기 위해 Platform checks와 함께 Cupertino 위젯을 사용하는 방법을 보여줍니다. 발표자는 Cupertino 위젯에 액세스하기 위해 flutter/cupertino.dart를 가져오는 것의 중요성을 설명하고 iOS 관련 아이콘 및 선호하는 크기 정의와 관련된 오류와 같은 과제를 해결합니다. 또한 CupertinoNavigationBar 레이아웃의 문제를 해결하는 방법, 특히 MainAxisSize를 조정하여 더하기 아이콘 및 텍스트와 같은 iOS 관련 요소를 올바르게 표시하는 방법을 보여줍니다. 이 비디오는 Material Design에서 iOS용 Cupertino 스타일 UI로의 전환을 보여주며 플랫폼별 사용자 경험을 위해 요소를 정확하게 스타일링하고 렌더링하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el orador analiza el proceso de creación de interfaces de usuario adaptables para dispositivos iOS en una aplicación Flutter personalizando la apariencia para que se alinee con los patrones de diseño de iOS. Demuestra cómo usar los widgets de Cupertino junto con las comprobaciones de la plataforma para representar elementos con estilo de Cupertino para iOS y Material Design para Android, como el uso de CupertinoPageScaffold y CupertinoNavigationBar. El orador explica la importancia de importar flutter/cupertino.dart para acceder a los widgets de Cupertino y aborda desafíos, como errores relacionados con íconos específicos de iOS y definiciones de tamaño preferido. Además, muestra cómo resolver problemas con el diseño de CupertinoNavigationBar, específicamente ajustando MainAxisSize para mostrar correctamente elementos específicos de iOS como el ícono más y el texto. El video muestra la transición de un Material Design a una interfaz de usuario de estilo Cupertino para iOS, destacando la importancia de diseñar y representar elementos con precisión para experiencias de usuario específicas de la plataforma.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता iOS डिज़ाइन पैटर्न के साथ संरेखित करने के लिए उपस्थिति को अनुकूलित करके फ़्लटर ऐप में iOS डिवाइस के लिए अनुकूली उपयोगकर्ता इंटरफ़ेस बनाने की प्रक्रिया पर चर्चा करता है। वे प्रदर्शित करते हैं कि iOS के लिए क्यूपर्टिनो-शैली वाले तत्वों और Android के लिए मटीरियल डिज़ाइन को रेंडर करने के लिए प्लेटफ़ॉर्म चेक के साथ क्यूपर्टिनो विजेट का उपयोग कैसे करें, जैसे कि क्यूपर्टिनोपेजस्कैफ़ोल्ड और क्यूपर्टिनोनेविगेशनबार का उपयोग करना। वक्ता क्यूपर्टिनो विजेट तक पहुँचने के लिए फ़्लटर/क्यूपर्टिनो.डार्ट को आयात करने के महत्व को समझाता है और चुनौतियों को संबोधित करता है, जैसे कि iOS-विशिष्ट आइकन और पसंदीदा आकार परिभाषाओं से संबंधित त्रुटियाँ। इसके अतिरिक्त, वे दिखाते हैं कि क्यूपर्टिनोनेविगेशनबार लेआउट के साथ समस्याओं को कैसे हल किया जाए, विशेष रूप से प्लस आइकन और टेक्स्ट जैसे iOS-विशिष्ट तत्वों को ठीक से प्रदर्शित करने के लिए MainAxisSize को समायोजित करना। वीडियो iOS के लिए मटीरियल डिज़ाइन से क्यूपर्टिनो-शैली UI में परिवर्तन को प्रदर्शित करता है, जो प्लेटफ़ॉर्म-विशिष्ट उपयोगकर्ता अनुभवों के लिए तत्वों को सटीक रूप से स्टाइल करने और रेंडर करने के महत्व पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador discute o processo de criação de interfaces de utilizador adaptáveis ​​para dispositivos iOS numa aplicação Flutter, personalizando o aspeto para o alinhar com os padrões de design do iOS. Demonstram como utilizar widgets Cupertino em conjunto com verificações de plataforma para renderizar elementos ao estilo Cupertino para iOS e Material Design para Android, como utilizar CupertinoPageScaffold e CupertinoNavigationBar. O orador explica a importância de importar o flutter/cupertino.dart para aceder aos widgets de Cupertino e aborda desafios, como erros relacionados com ícones específicos do iOS e definições de tamanho preferido. Além disso, mostram como resolver problemas com o layout CupertinoNavigationBar, ajustando especificamente o MainAxisSize para exibir corretamente elementos específicos do iOS, como o ícone de adição e o texto. O vídeo mostra a transição de um Material Design para uma UI estilo Cupertino para iOS, destacando a importância de estilizar e renderizar elementos com precisão para experiências de utilizador específicas da plataforma.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি ফ্লাটার অ্যাপে iOS ডিভাইসের জন্য অভিযোজিত ইউজার ইন্টারফেস তৈরি করার প্রক্রিয়া নিয়ে আলোচনা করেছেন যা iOS ডিজাইনের প্যাটার্নের সাথে সারিবদ্ধ করার জন্য চেহারা কাস্টমাইজ করে। তারা প্রদর্শন করে কিভাবে প্ল্যাটফর্ম চেকের সাথে একযোগে Cupertino উইজেটগুলি ব্যবহার করতে হয় iOS এর জন্য Cupertino-স্টাইলযুক্ত উপাদান এবং Android এর জন্য উপাদান ডিজাইন, যেমন CupertinoPageScaffold এবং CupertinoNavigationBar ব্যবহার করে। স্পিকার Cupertino উইজেট অ্যাক্সেস করতে flutter/cupertino.dart আমদানির গুরুত্ব ব্যাখ্যা করে এবং চ্যালেঞ্জগুলি মোকাবেলা করে, যেমন iOS-নির্দিষ্ট আইকন এবং পছন্দের আকারের সংজ্ঞা সম্পর্কিত ত্রুটিগুলি। উপরন্তু, তারা কিউপারটিনো নেভিগেশনবার লেআউটের সমস্যাগুলি কীভাবে সমাধান করতে হয় তা দেখায়, বিশেষভাবে প্লাস আইকন এবং পাঠ্যের মতো iOS-নির্দিষ্ট উপাদানগুলিকে সঠিকভাবে প্রদর্শন করতে MainAxisSize সামঞ্জস্য করে। ভিডিওটি আইওএস-এর জন্য একটি ম্যাটেরিয়াল ডিজাইন থেকে কাপার্টিনো-স্টাইল UI-তে রূপান্তর দেখায়, প্ল্যাটফর্ম-নির্দিষ্ট ব্যবহারকারীর অভিজ্ঞতার জন্য নির্ভুলভাবে স্টাইলিং এবং রেন্ডারিং উপাদানের গুরুত্ব তুলে ধরে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث عملية إنشاء واجهات مستخدم قابلة للتكيف لأجهزة iOS في تطبيق Flutter من خلال تخصيص المظهر ليتماشى مع أنماط تصميم iOS. كما يوضح كيفية استخدام عناصر واجهة مستخدم Cupertino جنبًا إلى جنب مع عمليات التحقق من النظام الأساسي لعرض عناصر على غرار Cupertino لنظام iOS وتصميم المواد لنظام Android، مثل استخدام CupertinoPageScaffold وCupertinoNavigationBar. ويشرح المتحدث أهمية استيراد flutter/cupertino.dart للوصول إلى عناصر واجهة مستخدم Cupertino ويتناول التحديات، مثل الأخطاء المتعلقة بالأيقونات الخاصة بنظام iOS وتعريفات الحجم المفضلة. بالإضافة إلى ذلك، يوضح كيفية حل المشكلات المتعلقة بتخطيط CupertinoNavigationBar، وتحديدًا ضبط MainAxisSize لعرض العناصر الخاصة بنظام iOS بشكل صحيح مثل أيقونة علامة الجمع والنص. ويعرض الفيديو الانتقال من تصميم المواد إلى واجهة مستخدم على غرار Cupertino لنظام iOS، مع تسليط الضوء على أهمية التصميم الدقيق وعرض العناصر لتجارب المستخدم الخاصة بالمنصة.",
                                // Persian
                                "فارسی": "در این ویدیو، سخنران فرآیند ایجاد رابط های کاربری تطبیقی ​​برای دستگاه های iOS را در یک برنامه Flutter با سفارشی کردن ظاهر به منظور هماهنگی با الگوهای طراحی iOS مورد بحث قرار می دهد. آنها نحوه استفاده از ویجت‌های کوپرتینویی را همراه با بررسی‌های پلتفرم برای ارائه عناصر به سبک کوپرتینویی برای iOS و طراحی مواد برای اندروید، مانند استفاده از CupertinoPageScaffold و CupertinoNavigationBar نشان می‌دهند. سخنران اهمیت وارد کردن flutter/cupertino.dart برای دسترسی به ویجت‌های کوپرتینویی را توضیح می‌دهد و چالش‌هایی مانند خطاهای مربوط به نمادهای مخصوص iOS و تعاریف اندازه ترجیحی را برطرف می‌کند. علاوه بر این، آنها نشان می‌دهند که چگونه می‌توان مشکلات طرح‌بندی CupertinoNavigationBar را حل کرد، به‌ویژه تنظیم MainAxisSize برای نمایش صحیح عناصر خاص iOS مانند نماد پلاس و متن. این ویدئو انتقال از طراحی متریال به یک رابط کاربری به سبک کوپرتینویی برای iOS را نشان می‌دهد و اهمیت استایل‌سازی و رندر دقیق عناصر را برای تجربه‌های کاربری خاص پلتفرم برجسته می‌کند.",
                            },
                        },
                        // 117 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Using the SafeArea",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker discusses the issue of strange positioning of widgets in a Flutter app, particularly related to the navigation bar height not being accounted for due to available screen space being reserved by system icons like the top notch and app drawer task manager icon on iOS, causing the navigation bar to be pushed down on the screen. To address this issue, the speaker demonstrates the use of the SafeArea widget in the page body to ensure that widgets are correctly positioned within the screen boundaries and respect the reserved areas without being obscured by system icons. By wrapping the body with the SafeArea widget, the app layout is adjusted to accommodate the reserved spaces effectively. The video highlights the importance of considering system spaces in app design to ensure proper widget positioning and user experience.",
                                // German
                                "Deutsch": "In diesem Video bespricht der Sprecher das Problem der seltsamen Positionierung von Widgets in einer Flutter-App, insbesondere im Zusammenhang mit der Höhe der Navigationsleiste, die nicht berücksichtigt wird, da der verfügbare Bildschirmplatz durch Systemsymbole wie das oberste Symbol und das Task-Manager-Symbol der App-Schublade unter iOS reserviert ist, wodurch die Navigationsleiste auf dem Bildschirm nach unten geschoben wird. Um dieses Problem zu beheben, demonstriert der Sprecher die Verwendung des SafeArea-Widgets im Seitentext, um sicherzustellen, dass Widgets richtig innerhalb der Bildschirmgrenzen positioniert sind und die reservierten Bereiche einhalten, ohne von Systemsymbolen verdeckt zu werden. Indem der Text mit dem SafeArea-Widget umschlossen wird, wird das App-Layout angepasst, um die reservierten Bereiche effektiv unterzubringen. Das Video unterstreicht, wie wichtig es ist, Systembereiche beim App-Design zu berücksichtigen, um eine ordnungsgemäße Widget-Positionierung und Benutzererfahrung sicherzustellen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了 Flutter 应用中小部件定位奇怪的问题，特别是由于可用屏幕空间被系统图标（如 iOS 上的顶部凹槽和应用抽屉任务管理器图标）保留，导致导航栏高度未被考虑在内，从而导致导航栏在屏幕上被向下推。为了解决这个问题，演讲者演示了如何在页面主体中使用 SafeArea 小部件，以确保小部件在屏幕边界内正确定位并尊重保留区域，而不会被系统图标遮挡。通过使用 SafeArea 小部件包裹主体，可以调整应用布局以有效适应保留空间。该视频强调了在应用设计中考虑系统空间以确保正确的小部件定位和用户体验的重要性。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает проблему странного расположения виджетов в приложении Flutter, в частности, связанную с тем, что высота панели навигации не учитывается из-за того, что доступное пространство экрана зарезервировано системными значками, такими как верхняя выемка и значок диспетчера задач в панели приложений на iOS, из-за чего панель навигации смещается вниз по экрану. Чтобы решить эту проблему, докладчик демонстрирует использование виджета SafeArea в теле страницы, чтобы гарантировать, что виджеты правильно расположены в пределах границ экрана и соответствуют зарезервированным областям, не будучи закрытыми системными значками. Благодаря обертыванию тела виджетом SafeArea макет приложения корректируется для эффективного размещения зарезервированных пространств. Видео подчеркивает важность учета системных пространств в дизайне приложения для обеспечения правильного расположения виджетов и пользовательского опыта.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant discute du problème du positionnement étrange des widgets dans une application Flutter, notamment en ce qui concerne la hauteur de la barre de navigation qui n'est pas prise en compte en raison de l'espace disponible sur l'écran réservé par les icônes système telles que l'icône du gestionnaire de tâches du tiroir d'applications et de l'encoche supérieure sur iOS, ce qui entraîne le déplacement de la barre de navigation vers le bas de l'écran. Pour résoudre ce problème, l'intervenant démontre l'utilisation du widget SafeArea dans le corps de la page pour garantir que les widgets sont correctement positionnés dans les limites de l'écran et respectent les zones réservées sans être masqués par les icônes système. En enveloppant le corps avec le widget SafeArea, la mise en page de l'application est ajustée pour s'adapter efficacement aux espaces réservés. La vidéo souligne l'importance de prendre en compte les espaces système dans la conception de l'application pour garantir un positionnement correct des widgets et une expérience utilisateur optimale.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter アプリでウィジェットが奇妙に配置される問題について説明しています。特に、iOS の最上部のノッチやアプリ ドロワーのタスク マネージャー アイコンなどのシステム アイコンによって画面の空き領域が確保され、ナビゲーション バーの高さが考慮されず、ナビゲーション バーが画面上で押し下げられるという問題に関連しています。この問題に対処するために、講演者はページ本体で SafeArea ウィジェットを使用して、ウィジェットが画面の境界内に正しく配置され、システム アイコンに隠れることなく予約領域が尊重されるようにする方法を示します。本体を SafeArea ウィジェットでラップすることで、予約領域を効果的に収容するようにアプリのレイアウトが調整されます。このビデオでは、適切なウィジェットの配置とユーザー エクスペリエンスを確保するために、アプリ設計でシステム領域を考慮することの重要性を強調しています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 앱에서 위젯이 이상하게 배치되는 문제에 대해 논의합니다. 특히 iOS의 상단 노치 및 앱 서랍 작업 관리자 아이콘과 같은 시스템 아이콘이 사용 가능한 화면 공간을 예약하여 탐색 모음 높이를 고려하지 않아 탐색 모음이 화면에서 아래로 밀려나는 문제에 대해 논의합니다. 이 문제를 해결하기 위해 발표자는 페이지 본문에서 SafeArea 위젯을 사용하여 위젯이 화면 경계 내에 올바르게 배치되고 시스템 아이콘에 가려지지 않고 예약된 영역을 존중하는지 확인하는 방법을 보여줍니다. SafeArea 위젯으로 본문을 래핑하면 앱 레이아웃이 예약된 공간을 효과적으로 수용하도록 조정됩니다. 이 영상은 적절한 위젯 배치와 사용자 경험을 보장하기 위해 앱 디자인에서 시스템 공간을 고려하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el orador analiza el problema de la ubicación extraña de los widgets en una aplicación Flutter, en particular en relación con la altura de la barra de navegación que no se tiene en cuenta debido a que el espacio disponible en la pantalla está reservado por íconos del sistema, como el ícono del administrador de tareas del cajón de aplicaciones y la muesca superior en iOS, lo que hace que la barra de navegación se desplace hacia abajo en la pantalla. Para abordar este problema, el orador demuestra el uso del widget SafeArea en el cuerpo de la página para garantizar que los widgets estén ubicados correctamente dentro de los límites de la pantalla y respeten las áreas reservadas sin quedar ocultos por los íconos del sistema. Al envolver el cuerpo con el widget SafeArea, el diseño de la aplicación se ajusta para acomodar los espacios reservados de manera efectiva. El video destaca la importancia de considerar los espacios del sistema en el diseño de la aplicación para garantizar la ubicación adecuada de los widgets y la experiencia del usuario.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर ऐप में विजेट्स की अजीब स्थिति के मुद्दे पर चर्चा करता है, विशेष रूप से नेविगेशन बार की ऊंचाई से संबंधित, जो उपलब्ध स्क्रीन स्पेस के कारण iOS पर टॉप नॉच और ऐप ड्रॉअर टास्क मैनेजर आइकन जैसे सिस्टम आइकन द्वारा आरक्षित होने के कारण जिम्मेदार नहीं है, जिससे नेविगेशन बार स्क्रीन पर नीचे धकेल दिया जाता है। इस मुद्दे को संबोधित करने के लिए, वक्ता पेज बॉडी में SafeArea विजेट के उपयोग को प्रदर्शित करता है ताकि यह सुनिश्चित किया जा सके कि विजेट स्क्रीन सीमाओं के भीतर सही ढंग से स्थित हैं और सिस्टम आइकन द्वारा अस्पष्ट किए बिना आरक्षित क्षेत्रों का सम्मान करते हैं। SafeArea विजेट के साथ बॉडी को लपेटने से, आरक्षित स्थानों को प्रभावी ढंग से समायोजित करने के लिए ऐप लेआउट को समायोजित किया जाता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador discute a questão do posicionamento estranho de widgets numa aplicação Flutter, principalmente relacionado com o facto de a altura da barra de navegação não ser contabilizada devido ao espaço disponível no ecrã ser reservado por ícones do sistema, como o topo e o ícone do gestor de tarefas da gaveta da aplicação no iOS, fazendo com que a barra de navegação seja empurrada para baixo no ecrã. Para resolver este problema, o orador demonstra a utilização do widget SafeArea no corpo da página para garantir que os widgets estão corretamente posicionados dentro dos limites do ecrã e respeitam as áreas reservadas sem serem obscurecidos pelos ícones do sistema. Ao envolver o corpo com o widget SafeArea, o layout da aplicação é ajustado para acomodar os espaços reservados de forma eficaz. O vídeo destaca a importância de considerar os espaços do sistema no design da aplicação para garantir o posicionamento adequado do widget e a experiência do utilizador.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি ফ্লাটার অ্যাপে উইজেটগুলির অদ্ভুত অবস্থানের সমস্যা নিয়ে আলোচনা করেছেন, বিশেষ করে নেভিগেশন বারের উচ্চতার সাথে সম্পর্কিত যা উপরের খাঁজ এবং অ্যাপ ড্রয়ার টাস্ক ম্যানেজার আইকনের মতো সিস্টেম আইকনগুলির দ্বারা সংরক্ষিত স্ক্রীনের স্থানের জন্য উপলব্ধ নয়। iOS-এ, যার ফলে নেভিগেশন বার স্ক্রিনে নিচের দিকে ঠেলে দেওয়া হয়। এই সমস্যাটির সমাধান করার জন্য, স্পিকার পৃষ্ঠার অংশে SafeArea উইজেটের ব্যবহার প্রদর্শন করে যাতে উইজেটগুলি সঠিকভাবে পর্দার সীমানার মধ্যে অবস্থান করে এবং সিস্টেম আইকনগুলির দ্বারা অস্পষ্ট না হয়ে সংরক্ষিত এলাকাগুলিকে সম্মান করে। SafeArea উইজেট দিয়ে শরীর মোড়ানোর মাধ্যমে, সংরক্ষিত স্থানগুলি কার্যকরভাবে মিটমাট করার জন্য অ্যাপের বিন্যাস সামঞ্জস্য করা হয়। ভিডিওটি সঠিক উইজেট অবস্থান এবং ব্যবহারকারীর অভিজ্ঞতা নিশ্চিত করতে অ্যাপ ডিজাইনে সিস্টেম স্পেস বিবেচনা করার গুরুত্ব তুলে ধরে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث مشكلة وضع الأدوات بشكل غريب في تطبيق Flutter، وخاصة فيما يتعلق بعدم احتساب ارتفاع شريط التنقل بسبب حجز مساحة الشاشة المتاحة بواسطة أيقونات النظام مثل أيقونة مدير المهام في الجزء العلوي ودرج التطبيقات على نظام التشغيل iOS، مما يتسبب في دفع شريط التنقل لأسفل على الشاشة. لمعالجة هذه المشكلة، يوضح المتحدث استخدام أداة SafeArea في نص الصفحة لضمان وضع الأدوات بشكل صحيح داخل حدود الشاشة واحترام المناطق المحجوزة دون حجبها بواسطة أيقونات النظام. من خلال تغليف النص باستخدام أداة SafeArea، يتم تعديل تخطيط التطبيق لاستيعاب المساحات المحجوزة بشكل فعال. يسلط الفيديو الضوء على أهمية مراعاة مساحات النظام في تصميم التطبيق لضمان وضع الأدوات بشكل صحيح وتجربة المستخدم.",
                                // Persian
                                "فارسی": "در این ویدیو، گوینده موضوع موقعیت‌یابی عجیب ویجت‌ها را در یک برنامه فلاتر، به ویژه مربوط به عدم در نظر گرفتن ارتفاع نوار ناوبری به دلیل رزرو فضای موجود روی صفحه توسط نمادهای سیستم مانند بریدگی بالای صفحه و نماد مدیر وظیفه کشوی برنامه، مورد بحث قرار می‌دهد. در iOS، که باعث می شود نوار ناوبری روی صفحه نمایش داده شود. برای رفع این مشکل، بلندگو استفاده از ویجت SafeArea را در بدنه صفحه نشان می‌دهد تا اطمینان حاصل شود که ویجت‌ها به درستی در محدوده‌های صفحه قرار گرفته‌اند و به مناطق رزرو شده احترام می‌گذارند بدون اینکه توسط نمادهای سیستم مبهم شوند. با پیچاندن بدنه با ویجت SafeArea، طرح‌بندی برنامه به گونه‌ای تنظیم می‌شود که فضاهای رزرو شده را به طور موثری در خود جای دهد. این ویدئو اهمیت در نظر گرفتن فضاهای سیستم را در طراحی اپلیکیشن برای اطمینان از موقعیت یابی مناسب ویجت و تجربه کاربر برجسته می کند.",
                            },
                        },
                        // 118 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "More Cupertino Styles",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker addresses an issue related to text styling in a CupertinoPageScaffold in a Flutter app, pointing out that the CupertinoPageScaffold does not automatically assign a theme to texts. To resolve this, the speaker suggests switching the general app widget from a MaterialApp to a CupertinoApp widget, which would not only solve the text styling problem but also ensure that other aspects, such as route transitions, work correctly. Making this change at the top of the main.dart file would provide a consistent and cohesive design across the app, aligning with the Cupertino design style and enhancing the overall functionality of the app.",
                                // German
                                "Deutsch": "In diesem Video spricht der Sprecher ein Problem im Zusammenhang mit der Textformatierung in einem CupertinoPageScaffold in einer Flutter-App an und weist darauf hin, dass das CupertinoPageScaffold Texten nicht automatisch ein Design zuweist. Um dies zu beheben, schlägt der Sprecher vor, das allgemeine App-Widget von einem MaterialApp-Widget auf ein CupertinoApp-Widget umzustellen, was nicht nur das Textformatierungsproblem lösen, sondern auch sicherstellen würde, dass andere Aspekte wie Routenübergänge korrekt funktionieren. Diese Änderung oben in der Datei main.dart würde ein konsistentes und einheitliches Design in der gesamten App bieten, das dem Cupertino-Designstil entspricht und die Gesamtfunktionalität der App verbessert.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了 Flutter 应用中 CupertinoPageScaffold 中文本样式的问题，并指出 CupertinoPageScaffold 不会自动为文本分配主题。为了解决这个问题，演讲者建议将通用应用小部件从 MaterialApp 切换到 CupertinoApp 小部件，这不仅可以解决文本样式问题，还可以确保其他方面（例如路由转换）正常工作。在 main.dart 文件顶部进行此更改将为整个应用提供一致且有凝聚力的设计，与 Cupertino 设计风格保持一致并增强应用的整体功能。",
                                // Russian
                                "Русский": "В этом видео докладчик рассматривает проблему, связанную со стилем текста в CupertinoPageScaffold в приложении Flutter, указывая на то, что CupertinoPageScaffold автоматически не назначает тему текстам. Чтобы решить эту проблему, докладчик предлагает переключить общий виджет приложения с MaterialApp на виджет CupertinoApp, что не только решит проблему со стилем текста, но и обеспечит правильную работу других аспектов, таких как переходы маршрутов. Внесение этого изменения в верхнюю часть файла main.dart обеспечит последовательный и связный дизайн во всем приложении, соответствующий стилю дизайна Cupertino и улучшающий общую функциональность приложения.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant aborde un problème lié au style de texte dans un CupertinoPageScaffold dans une application Flutter, en soulignant que le CupertinoPageScaffold n'attribue pas automatiquement un thème aux textes. Pour résoudre ce problème, l'intervenant suggère de remplacer le widget général de l'application par un widget MaterialApp par un widget CupertinoApp, ce qui résoudrait non seulement le problème de style de texte, mais garantirait également que d'autres aspects, tels que les transitions d'itinéraire, fonctionnent correctement. Apporter cette modification en haut du fichier main.dart fournirait une conception cohérente et cohérente dans toute l'application, en s'alignant sur le style de conception de Cupertino et en améliorant la fonctionnalité globale de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が Flutter アプリの CupertinoPageScaffold のテキスト スタイルに関する問題を取り上げ、CupertinoPageScaffold がテキストにテーマを自動的に割り当てないことを指摘しています。この問題を解決するために、講演者は一般的なアプリ ウィジェットを MaterialApp から CupertinoApp ウィジェットに切り替えることを提案しています。これにより、テキスト スタイルの問題が解決されるだけでなく、ルート遷移などの他の側面も正しく機能するようになります。この変更を main.dart ファイルの先頭で行うと、アプリ全体で一貫性のあるまとまりのあるデザインになり、Cupertino のデザイン スタイルと一致し、アプリの全体的な機能が向上します。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 앱의 CupertinoPageScaffold에서 텍스트 스타일링과 관련된 문제를 다루며, CupertinoPageScaffold가 텍스트에 테마를 자동으로 지정하지 않는다는 점을 지적합니다. 발표자는 이를 해결하기 위해 일반 앱 위젯을 MaterialApp에서 CupertinoApp 위젯으로 전환할 것을 제안합니다. 이렇게 하면 텍스트 스타일링 문제가 해결될 뿐만 아니라 경로 전환과 같은 다른 측면도 올바르게 작동합니다. main.dart 파일 맨 위에서 이 변경을 수행하면 앱 전체에서 일관되고 응집력 있는 디자인이 제공되어 Cupertino 디자인 스타일과 일치하고 앱의 전반적인 기능이 향상됩니다.",
                                // Spanish
                                "Español": "En este video, el orador aborda un problema relacionado con el estilo de texto en un CupertinoPageScaffold en una aplicación Flutter y señala que el CupertinoPageScaffold no asigna automáticamente un tema a los textos. Para resolver esto, el orador sugiere cambiar el widget general de la aplicación de un MaterialApp a un widget CupertinoApp, lo que no solo resolvería el problema de estilo de texto, sino que también garantizaría que otros aspectos, como las transiciones de ruta, funcionen correctamente. Realizar este cambio en la parte superior del archivo main.dart proporcionaría un diseño coherente y consistente en toda la aplicación, que se alinearía con el estilo de diseño de Cupertino y mejoraría la funcionalidad general de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर ऐप में क्यूपर्टिनोपेजस्कैफ़ोल्ड में टेक्स्ट स्टाइलिंग से संबंधित एक समस्या को संबोधित करता है, यह बताते हुए कि क्यूपर्टिनोपेजस्कैफ़ोल्ड स्वचालित रूप से टेक्स्ट को थीम असाइन नहीं करता है। इसे हल करने के लिए, वक्ता सामान्य ऐप विजेट को मटेरियलऐप से क्यूपर्टिनोऐप विजेट में बदलने का सुझाव देता है, जो न केवल टेक्स्ट स्टाइलिंग समस्या को हल करेगा बल्कि यह भी सुनिश्चित करेगा कि रूट ट्रांज़िशन जैसे अन्य पहलू सही तरीके से काम करें। main.dart फ़ाइल के शीर्ष पर यह परिवर्तन करने से पूरे ऐप में एक सुसंगत और सुसंगत डिज़ाइन मिलेगा, जो क्यूपर्टिनो डिज़ाइन शैली के साथ संरेखित होगा और ऐप की समग्र कार्यक्षमता को बढ़ाएगा।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador aborda um assunto relacionado com o estilo de texto num CupertinoPageScaffold numa aplicação Flutter, salientando que o CupertinoPageScaffold não atribui automaticamente um tema aos textos. Para resolver isto, o orador sugere a mudança do widget geral da aplicação de MaterialApp para um widget CupertinoApp, o que não só resolveria o problema do estilo de texto, como também garantiria que outros aspetos, como as transições de rota, funcionassem corretamente. Fazer esta alteração na parte superior do ficheiro main.dart proporcionaria um design consistente e coeso em toda a aplicação, alinhando-se com o estilo de design de Cupertino e melhorando a funcionalidade geral da aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি ফ্লাটার অ্যাপে CupertinoPageScaffold-এ টেক্সট স্টাইলিং সম্পর্কিত একটি সমস্যার সমাধান করেছেন, উল্লেখ করেছেন যে CupertinoPageScaffold স্বয়ংক্রিয়ভাবে পাঠ্যগুলিতে একটি থিম বরাদ্দ করে না। এটি সমাধান করার জন্য, স্পিকার একটি MaterialApp থেকে একটি CupertinoApp উইজেটে সাধারণ অ্যাপ উইজেটে স্যুইচ করার পরামর্শ দেন, যা শুধুমাত্র টেক্সট স্টাইলিং সমস্যার সমাধান করবে না বরং অন্যান্য দিকগুলি যেমন রুট ট্রানজিশন সঠিকভাবে কাজ করবে তাও নিশ্চিত করবে। main.dart ফাইলের শীর্ষে এই পরিবর্তনটি করা হলে তা অ্যাপ জুড়ে একটি সামঞ্জস্যপূর্ণ এবং সমন্বিত নকশা প্রদান করবে, কিউপারটিনো ডিজাইন শৈলীর সাথে সারিবদ্ধ হবে এবং অ্যাপটির সামগ্রিক কার্যকারিতা উন্নত করবে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتناول المتحدث مشكلة تتعلق بتنسيق النص في CupertinoPageScaffold في تطبيق Flutter، مشيرًا إلى أن CupertinoPageScaffold لا يعين تلقائيًا سمة للنصوص. لحل هذه المشكلة، يقترح المتحدث تبديل عنصر واجهة المستخدم العامة للتطبيق من MaterialApp إلى عنصر واجهة مستخدم CupertinoApp، وهو ما لن يحل مشكلة تنسيق النص فحسب، بل يضمن أيضًا عمل جوانب أخرى، مثل انتقالات المسار، بشكل صحيح. سيؤدي إجراء هذا التغيير في الجزء العلوي من ملف main.dart إلى توفير تصميم متسق ومتماسك عبر التطبيق، بما يتماشى مع أسلوب تصميم Cupertino ويعزز الوظائف العامة للتطبيق.",
                                // Persian
                                "فارسی": "در این ویدیو، گوینده به موضوعی مربوط به استایل کردن متن در یک CupertinoPageScaffold در یک برنامه Flutter می پردازد و به این نکته اشاره می کند که CupertinoPageScaffold به طور خودکار موضوعی را به متون اختصاص نمی دهد. برای حل این مشکل، گوینده پیشنهاد می‌کند که ویجت برنامه عمومی را از MaterialApp به ویجت CupertinoApp تغییر دهید، که نه تنها مشکل استایل متن را حل می‌کند، بلکه اطمینان می‌دهد که سایر جنبه‌ها، مانند انتقال مسیر، به درستی کار می‌کنند. ایجاد این تغییر در بالای فایل main.dart، طراحی منسجم و منسجمی را در سراسر برنامه ارائه می‌کند، که با سبک طراحی کوپرتینویی هماهنگ شده و عملکرد کلی برنامه را بهبود می‌بخشد.",
                            },
                        },
                        // 119 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Using Cupertino Buttons",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video demonstrates how to replace text fields with Cupertino text fields in the new_transaction.dart file, showing how to set placeholder text and customize various attributes like auto-correction and cursor color. It also explains how to use the CupertinoButton instead of FlatButton for iOS styling, including importing the necessary packages and setting button properties like color and onPressed listener. The video highlights the visual differences between Cupertino and material design buttons, showcasing the unique effects of tapping on a CupertinoButton.",
                                // German
                                "Deutsch": "Das Video zeigt, wie man Textfelder durch Cupertino-Textfelder in der Datei new_transaction.dart ersetzt, wie man Platzhaltertext einstellt und verschiedene Attribute wie Autokorrektur und Cursorfarbe anpasst. Es erklärt auch, wie man den CupertinoButton anstelle des FlatButton für das iOS-Styling verwendet, einschließlich des Importierens der erforderlichen Pakete und des Einstellens von Schaltflächeneigenschaften wie Farbe und onPressed-Listener. Das Video hebt die visuellen Unterschiede zwischen Cupertino- und Material Design-Schaltflächen hervor und zeigt die einzigartigen Effekte, die das Tippen auf einen CupertinoButton hat.",
                                // Chinese
                                "中国人": "该视频演示了如何在 new_transaction.dart 文件中将文本字段替换为 Cupertino 文本字段，并展示了如何设置占位符文本以及自定义各种属性，例如自动更正和光标颜色。它还解释了如何使用 CupertinoButton 而不是 FlatButton 进行 iOS 样式设置，包括导入必要的软件包以及设置按钮属性，例如颜色和 onPressed 监听器。该视频重点介绍了 Cupertino 和 Material Design 按钮之间的视觉差异，展示了点击 CupertinoButton 的独特效果。",
                                // Russian
                                "Русский": "Видео демонстрирует, как заменить текстовые поля на текстовые поля Cupertino в файле new_transaction.dart, показывая, как задать текст-заполнитель и настроить различные атрибуты, такие как автокоррекция и цвет курсора. В нем также объясняется, как использовать CupertinoButton вместо FlatButton для стилизации iOS, включая импорт необходимых пакетов и настройку свойств кнопки, таких как цвет и прослушиватель onPressed. Видео подчеркивает визуальные различия между кнопками Cupertino и Material Design, демонстрируя уникальные эффекты нажатия на CupertinoButton.",
                                // French
                                "Français": "La vidéo montre comment remplacer les champs de texte par des champs de texte Cupertino dans le fichier new_transaction.dart, en montrant comment définir un texte d'espace réservé et personnaliser divers attributs tels que la correction automatique et la couleur du curseur. Elle explique également comment utiliser le CupertinoButton au lieu de FlatButton pour le style iOS, notamment en important les packages nécessaires et en définissant les propriétés des boutons comme la couleur et l'écouteur onPressed. La vidéo met en évidence les différences visuelles entre les boutons Cupertino et Material Design, en présentant les effets uniques d'un appui sur un CupertinoButton.",
                                // Japanese
                                "日本語": "このビデオでは、new_transaction.dart ファイルでテキスト フィールドを Cupertino テキスト フィールドに置き換える方法を示し、プレースホルダー テキストの設定方法や、自動修正やカーソルの色などのさまざまな属性をカスタマイズする方法を示します。また、iOS スタイル設定に FlatButton の代わりに CupertinoButton を使用する方法についても説明し、必要なパッケージのインポートや、色や onPressed リスナーなどのボタン プロパティの設定も行います。このビデオでは、Cupertino ボタンとマテリアル デザインのボタンの視覚的な違いを強調し、CupertinoButton をタップしたときのユニークな効果を紹介します。",
                                // Korean
                                "한국인": "이 비디오는 new_transaction.dart 파일에서 텍스트 필드를 Cupertino 텍스트 필드로 바꾸는 방법을 보여주며, 플레이스홀더 텍스트를 설정하고 자동 수정 및 커서 색상과 같은 다양한 속성을 사용자 지정하는 방법을 보여줍니다. 또한 필요한 패키지를 가져오고 color 및 onPressed 리스너와 같은 버튼 속성을 설정하는 것을 포함하여 iOS 스타일링을 위해 FlatButton 대신 CupertinoButton을 사용하는 방법도 설명합니다. 이 비디오는 Cupertino와 Material Design 버튼 간의 시각적 차이점을 강조하며, CupertinoButton을 탭하는 고유한 효과를 보여줍니다.",
                                // Spanish
                                "Español": "El video muestra cómo reemplazar campos de texto con campos de texto de Cupertino en el archivo new_transaction.dart, mostrando cómo configurar texto de marcador de posición y personalizar varios atributos como la corrección automática y el color del cursor. También explica cómo usar CupertinoButton en lugar de FlatButton para el estilo de iOS, incluida la importación de los paquetes necesarios y la configuración de propiedades de botón como el color y el detector onPressed. El video destaca las diferencias visuales entre los botones de Cupertino y los de diseño de materiales, mostrando los efectos únicos de tocar un CupertinoButton.",
                                // Hindi
                                "हिंदी": "वीडियो में दिखाया गया है कि new_transaction.dart फ़ाइल में टेक्स्ट फ़ील्ड को क्यूपर्टिनो टेक्स्ट फ़ील्ड से कैसे बदला जाए, प्लेसहोल्डर टेक्स्ट कैसे सेट करें और ऑटो-करेक्शन और कर्सर रंग जैसी विभिन्न विशेषताओं को कैसे कस्टमाइज़ करें। यह यह भी बताता है कि iOS स्टाइलिंग के लिए फ़्लैटबटन के बजाय क्यूपर्टिनोबटन का उपयोग कैसे करें, जिसमें आवश्यक पैकेज आयात करना और रंग और ऑनप्रेस्ड श्रोता जैसे बटन गुण सेट करना शामिल है। वीडियो क्यूपर्टिनो और मटीरियल डिज़ाइन बटन के बीच दृश्य अंतर को उजागर करता है, क्यूपर्टिनोबटन पर टैप करने के अनूठे प्रभावों को प्रदर्शित करता है।",
                                // Portuguese
                                "Português": "O vídeo demonstra como substituir campos de texto por campos de texto de Cupertino no ficheiro new_transaction.dart, mostrando como definir texto de espaço reservado e personalizar vários atributos, como a correção automática e a cor do cursor. Explica também como utilizar o CupertinoButton em vez do FlatButton para o estilo iOS, incluindo a importação dos pacotes necessários e a configuração das propriedades dos botões, como a cor e o listener onPressed. O vídeo destaca as diferenças visuais entre os botões de Cupertino e de material design, mostrando os efeitos únicos de tocar num CupertinoButton.",
                                // Bengali
                                "বাংলা": "ভিডিওটি দেখায় যে কিভাবে new_transaction.dart ফাইলে টেক্সট ফিল্ডকে Cupertino টেক্সট ফিল্ডের সাথে প্রতিস্থাপন করা যায়, তা দেখানো হয়েছে কিভাবে প্লেসহোল্ডার টেক্সট সেট করা যায় এবং স্বয়ংক্রিয়-সংশোধন এবং কার্সারের রঙের মতো বিভিন্ন বৈশিষ্ট্য কাস্টমাইজ করা যায়। প্রয়োজনীয় প্যাকেজ আমদানি করা এবং রঙ এবং অনপ্রেসড লিসেনারের মতো বোতাম বৈশিষ্ট্যগুলি সেট করা সহ iOS স্টাইলিং-এর জন্য ফ্ল্যাটবাটনের পরিবর্তে কিউপারটিনোবাটন কীভাবে ব্যবহার করবেন তাও এটি ব্যাখ্যা করে। ভিডিওটি Cupertino এবং উপাদান ডিজাইন বোতামের মধ্যে চাক্ষুষ পার্থক্য হাইলাইট করে, একটি CupertinoButton-এ ট্যাপ করার অনন্য প্রভাবগুলি প্রদর্শন করে৷",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو كيفية استبدال حقول النص بحقول نصية في Cupertino في ملف new_transaction.dart، مع توضيح كيفية تعيين نص بديل وتخصيص سمات مختلفة مثل التصحيح التلقائي ولون المؤشر. كما يوضح كيفية استخدام CupertinoButton بدلاً من FlatButton لأسلوب iOS، بما في ذلك استيراد الحزم الضرورية وتعيين خصائص الزر مثل اللون ومستمع onPressed. يسلط الفيديو الضوء على الاختلافات المرئية بين أزرار Cupertino وأزرار التصميم المادي، مع عرض التأثيرات الفريدة للنقر على زر Cupertino.",
                                // Persian
                                "فارسی": "این ویدئو نحوه جایگزینی فیلدهای متنی با فیلدهای متنی کوپرتینویی را در فایل new_transaction.dart نشان می‌دهد و نحوه تنظیم متن مکان‌نما و سفارشی کردن ویژگی‌های مختلف مانند تصحیح خودکار و رنگ مکان‌نما را نشان می‌دهد. همچنین نحوه استفاده از CupertinoButton به جای FlatButton برای استایل iOS، از جمله وارد کردن بسته‌های لازم و تنظیم ویژگی‌های دکمه مانند color و onPressed listener را توضیح می‌دهد. این ویدئو تفاوت‌های بصری بین دکمه‌های کوپرتینویی و طراحی متریال را برجسته می‌کند و جلوه‌های منحصر به فرد ضربه زدن روی دکمه‌های کوپرتینویی را نشان می‌دهد.",
                            },
                        },
                        // 120 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Creating Custom Adaptive Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video concludes by highlighting the importance of splitting the widget tree into smaller, manageable pieces for better organization in a Flutter application. It suggests creating adaptive widgets, like an AdaptiveFlatButton, that automatically adjust based on the platform being used, reducing the need for duplicated code. The video walks through creating this adaptive button widget and explains how it can be easily implemented throughout the widget tree to render the appropriate button based on the platform.",
                                // German
                                "Deutsch": "Abschließend wird im Video betont, wie wichtig es ist, den Widget-Baum in kleinere, handlichere Teile aufzuteilen, um eine bessere Organisation in einer Flutter-Anwendung zu gewährleisten. Es wird vorgeschlagen, adaptive Widgets wie einen AdaptiveFlatButton zu erstellen, die sich automatisch an die verwendete Plattform anpassen, wodurch die Notwendigkeit doppelten Codes reduziert wird. Das Video führt durch die Erstellung dieses adaptiven Schaltflächen-Widgets und erklärt, wie es problemlos im gesamten Widget-Baum implementiert werden kann, um die entsprechende Schaltfläche basierend auf der Plattform darzustellen.",
                                // Chinese
                                "中国人": "视频最后强调了将控件树拆分成更小、更易于管理的部分的重要性，以便在 Flutter 应用程序中更好地组织。它建议创建自适应控件，例如 AdaptiveFlatButton，可根据所使用的平台自动调整，从而减少重复代码的需要。视频介绍了如何创建此自适应按钮控件，并解释了如何在整个控件树中轻松实现它，以根据平台呈现适当的按钮。",
                                // Russian
                                "Русский": "Видео завершается подчеркиванием важности разделения дерева виджетов на более мелкие, управляемые части для лучшей организации в приложении Flutter. В нем предлагается создавать адаптивные виджеты, такие как AdaptiveFlatButton, которые автоматически подстраиваются под используемую платформу, что снижает необходимость в дублировании кода. Видео демонстрирует создание этого адаптивного виджета кнопки и объясняет, как его можно легко реализовать по всему дереву виджетов для визуализации соответствующей кнопки на основе платформы.",
                                // French
                                "Français": "La vidéo conclut en soulignant l'importance de diviser l'arborescence des widgets en éléments plus petits et plus faciles à gérer pour une meilleure organisation dans une application Flutter. Elle suggère de créer des widgets adaptatifs, comme un AdaptiveFlatButton, qui s'ajustent automatiquement en fonction de la plateforme utilisée, réduisant ainsi le besoin de dupliquer du code. La vidéo décrit la création de ce widget de bouton adaptatif et explique comment il peut être facilement implémenté dans l'arborescence des widgets pour restituer le bouton approprié en fonction de la plateforme.",
                                // Japanese
                                "日本語": "このビデオの最後では、Flutter アプリケーションを整理するためにウィジェット ツリーを小さく管理しやすい部分に分割することの重要性を強調しています。使用されているプラ​​ットフォームに基づいて自動的に調整される AdaptiveFlatButton などのアダプティブ ウィジェットを作成し、重複するコードの必要性を減らすことを提案しています。このビデオでは、このアダプティブ ボタン ウィジェットの作成手順を説明し、ウィジェット ツリー全体に簡単に実装して、プラットフォームに基づいて適切なボタンをレンダリングする方法を説明します。",
                                // Korean
                                "한국인": "이 영상은 Flutter 애플리케이션에서 더 나은 구성을 위해 위젯 트리를 더 작고 관리하기 쉬운 조각으로 분할하는 것의 중요성을 강조하면서 끝납니다. AdaptiveFlatButton과 같이 사용 중인 플랫폼에 따라 자동으로 조정되는 적응형 위젯을 생성하여 중복된 코드의 필요성을 줄이는 것을 제안합니다. 이 영상은 이 적응형 버튼 위젯을 만드는 방법을 안내하고 플랫폼에 따라 적절한 버튼을 렌더링하기 위해 위젯 트리 전체에 쉽게 구현할 수 있는 방법을 설명합니다.",
                                // Spanish
                                "Español": "El video concluye destacando la importancia de dividir el árbol de widgets en partes más pequeñas y manejables para una mejor organización en una aplicación Flutter. Sugiere crear widgets adaptables, como un AdaptiveFlatButton, que se ajustan automáticamente según la plataforma que se esté utilizando, lo que reduce la necesidad de código duplicado. El video muestra cómo crear este widget de botón adaptable y explica cómo se puede implementar fácilmente en todo el árbol de widgets para representar el botón apropiado según la plataforma.",
                                // Hindi
                                "हिंदी": "वीडियो फ़्लटर एप्लिकेशन में बेहतर संगठन के लिए विजेट ट्री को छोटे, प्रबंधनीय टुकड़ों में विभाजित करने के महत्व पर प्रकाश डालते हुए समाप्त होता है। यह एक अनुकूली विजेट बनाने का सुझाव देता है, जैसे कि AdaptiveFlatButton, जो उपयोग किए जा रहे प्लेटफ़ॉर्म के आधार पर स्वचालित रूप से समायोजित होता है, जिससे डुप्लिकेट कोड की आवश्यकता कम हो जाती है। वीडियो इस अनुकूली बटन विजेट को बनाने के बारे में बताता है और बताता है कि प्लेटफ़ॉर्म के आधार पर उपयुक्त बटन को प्रस्तुत करने के लिए इसे विजेट ट्री में आसानी से कैसे लागू किया जा सकता है।",
                                // Portuguese
                                "Português": "O vídeo conclui destacando a importância de dividir a árvore de widgets em partes mais pequenas e geríveis para uma melhor organização numa aplicação Flutter. Sugere a criação de widgets adaptativos, como um AdaptiveFlatButton, que se ajustam automaticamente com base na plataforma utilizada, reduzindo a necessidade de código duplicado. O vídeo explica como criar este widget de botão adaptável e explica como pode ser facilmente implementado em toda a árvore de widgets para renderizar o botão apropriado com base na plataforma.",
                                // Bengali
                                "বাংলা": "একটি ফ্লটার অ্যাপ্লিকেশনে আরও ভাল সংগঠনের জন্য উইজেট ট্রিকে ছোট, পরিচালনাযোগ্য টুকরোগুলিতে বিভক্ত করার গুরুত্ব তুলে ধরে ভিডিওটি শেষ হয়েছে। এটি একটি অ্যাডাপ্টিভ ফ্ল্যাটবাটনের মতো অভিযোজিত উইজেট তৈরি করার পরামর্শ দেয়, যা ব্যবহার করা প্ল্যাটফর্মের উপর ভিত্তি করে স্বয়ংক্রিয়ভাবে সামঞ্জস্য করে, ডুপ্লিকেট কোডের প্রয়োজনীয়তা হ্রাস করে। ভিডিওটি এই অভিযোজিত বোতাম উইজেট তৈরির মধ্য দিয়ে চলে এবং ব্যাখ্যা করে যে কীভাবে এটি প্ল্যাটফর্মের উপর ভিত্তি করে উপযুক্ত বোতাম রেন্ডার করতে উইজেট ট্রি জুড়ে সহজেই প্রয়োগ করা যেতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "يختتم الفيديو بتسليط الضوء على أهمية تقسيم شجرة الأدوات إلى أجزاء أصغر وأكثر قابلية للإدارة لتحسين التنظيم في تطبيق Flutter. ويقترح إنشاء أدوات قابلة للتكيف، مثل AdaptiveFlatButton، والتي تتكيف تلقائيًا بناءً على المنصة المستخدمة، مما يقلل الحاجة إلى تكرار التعليمات البرمجية. يشرح الفيديو عملية إنشاء أداة الأزرار القابلة للتكيف هذه ويشرح كيف يمكن تنفيذها بسهولة في شجرة الأدوات لعرض الزر المناسب بناءً على المنصة.",
                                // Persian
                                "فارسی": "این ویدئو با برجسته کردن اهمیت تقسیم درخت ویجت به قطعات کوچکتر و قابل مدیریت برای سازماندهی بهتر در یک برنامه فلاتر به پایان می رسد. پیشنهاد می‌کند ویجت‌های تطبیقی ​​مانند AdaptiveFlatButton ایجاد کنید که به طور خودکار بر اساس پلتفرم مورد استفاده تنظیم می‌شوند و نیاز به کدهای تکراری را کاهش می‌دهند. این ویدئو در ساخت این ویجت دکمه تطبیقی ​​می گذرد و توضیح می دهد که چگونه می توان آن را به راحتی در سراسر درخت ویجت پیاده سازی کرد تا دکمه مناسب را بر اساس پلت فرم ارائه دهد.",
                            },
                        },
                        // 121 [Video Number]
                        {
                            "SectionName": "Responsive & Adaptive User Interfaces and Apps",
                            "VideoName": "Wrap Up",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video module concludes by emphasizing the importance of utilizing various techniques like media queries and platform adaptive features in Flutter to build responsive user interfaces that look good on different screen sizes and orientations. It highlights the need to configure widgets differently for Cupertino and material design elements, suggesting the use of adaptive and responsive widgets to streamline code and improve maintainability. The video stresses the benefits of splitting the app into widgets to enhance organization and ease of navigation within larger codebases, ultimately emphasizing the tools provided by Flutter for adjusting applications to different screen sizes and operating systems.",
                                // German
                                "Deutsch": "Das Videomodul betont abschließend, wie wichtig es ist, verschiedene Techniken wie Medienabfragen und plattformadaptive Funktionen in Flutter zu verwenden, um reaktionsfähige Benutzeroberflächen zu erstellen, die auf verschiedenen Bildschirmgrößen und -ausrichtungen gut aussehen. Es hebt die Notwendigkeit hervor, Widgets für Cupertino- und Materialdesignelemente unterschiedlich zu konfigurieren, und schlägt die Verwendung adaptiver und reaktionsfähiger Widgets vor, um den Code zu rationalisieren und die Wartbarkeit zu verbessern. Das Video betont die Vorteile der Aufteilung der App in Widgets, um die Organisation und die Navigation innerhalb größerer Codebasen zu verbessern, und hebt schließlich die von Flutter bereitgestellten Tools zum Anpassen von Anwendungen an unterschiedliche Bildschirmgrößen und Betriebssysteme hervor.",
                                // Chinese
                                "中国人": "视频模块最后强调了利用 Flutter 中的媒体查询和平台自适应功能等各种技术来构建响应式用户界面的重要性，这些界面在不同屏幕尺寸和方向上看起来都很好。它强调了为 Cupertino 和 Material Design 元素配置不同小部件的必要性，建议使用自适应和响应式小部件来简化代码并提高可维护性。视频强调了将应用程序拆分为小部件的好处，以增强组织和在更大的代码库中导航的便利性，最终强调了 Flutter 提供的用于调整应用程序以适应不同屏幕尺寸和操作系统的工具。",
                                // Russian
                                "Русский": "Видеомодуль завершается подчеркиванием важности использования различных методов, таких как медиа-запросы и адаптивные функции платформы во Flutter, для создания адаптивных пользовательских интерфейсов, которые хорошо выглядят на экранах разных размеров и ориентаций. Он подчеркивает необходимость по-разному настраивать виджеты для элементов дизайна Cupertino и Material, предлагая использовать адаптивные и отзывчивые виджеты для оптимизации кода и улучшения удобства обслуживания. Видео подчеркивает преимущества разделения приложения на виджеты для улучшения организации и упрощения навигации в более крупных кодовых базах, в конечном итоге подчеркивая инструменты, предоставляемые Flutter для настройки приложений под разные размеры экрана и операционные системы.",
                                // French
                                "Français": "Le module vidéo conclut en soulignant l'importance d'utiliser diverses techniques telles que les requêtes multimédias et les fonctionnalités adaptatives de la plateforme dans Flutter pour créer des interfaces utilisateur réactives qui s'adaptent bien à différentes tailles et orientations d'écran. Il souligne la nécessité de configurer les widgets différemment pour les éléments de conception de Cupertino et de Material, suggérant l'utilisation de widgets adaptatifs et réactifs pour rationaliser le code et améliorer la maintenabilité. La vidéo souligne les avantages de la division de l'application en widgets pour améliorer l'organisation et la facilité de navigation au sein de bases de code plus vastes, en mettant finalement l'accent sur les outils fournis par Flutter pour ajuster les applications à différentes tailles d'écran et systèmes d'exploitation.",
                                // Japanese
                                "日本語": "ビデオ モジュールの最後では、Flutter のメディア クエリやプラットフォーム適応機能などのさまざまな手法を活用して、さまざまな画面サイズや向きで見栄えのよいレスポンシブなユーザー インターフェイスを構築することの重要性を強調しています。また、Cupertino とマテリアル デザイン要素でウィジェットを異なる方法で構成する必要性を強調し、コードを合理化して保守性を向上させるために、適応型およびレスポンシブ ウィジェットの使用を提案しています。ビデオでは、アプリをウィジェットに分割して、大規模なコードベース内での整理とナビゲーションのしやすさを向上させる利点を強調し、最終的には、さまざまな画面サイズやオペレーティング システムに合わせてアプリケーションを調整するための Flutter が提供するツールを強調しています。",
                                // Korean
                                "한국인": "비디오 모듈은 다양한 화면 크기와 방향에서 보기 좋은 반응형 사용자 인터페이스를 구축하기 위해 Flutter에서 미디어 쿼리 및 플랫폼 적응형 기능과 같은 다양한 기술을 활용하는 것의 중요성을 강조하면서 마무리합니다. Cupertino와 머티리얼 디자인 요소에 맞게 위젯을 다르게 구성해야 할 필요성을 강조하고, 코드를 간소화하고 유지 관리를 개선하기 위해 적응형 및 반응형 위젯을 사용할 것을 제안합니다. 비디오는 대규모 코드베이스 내에서 구성과 탐색 용이성을 향상시키기 위해 앱을 위젯으로 분할하는 것의 이점을 강조하고, 궁극적으로 Flutter가 제공하는 도구를 강조하여 다양한 화면 크기와 운영 체제에 맞게 애플리케이션을 조정합니다.",
                                // Spanish
                                "Español": "El módulo de video concluye enfatizando la importancia de utilizar varias técnicas como consultas de medios y funciones adaptables de la plataforma en Flutter para crear interfaces de usuario responsivas que se vean bien en diferentes tamaños y orientaciones de pantalla. Destaca la necesidad de configurar los widgets de manera diferente para los elementos de diseño de Cupertino y Material Design, y sugiere el uso de widgets adaptables y responsivos para optimizar el código y mejorar la capacidad de mantenimiento. El video destaca los beneficios de dividir la aplicación en widgets para mejorar la organización y la facilidad de navegación dentro de bases de código más grandes, y finalmente enfatiza las herramientas proporcionadas por Flutter para ajustar las aplicaciones a diferentes tamaños de pantalla y sistemas operativos.",
                                // Hindi
                                "हिंदी": "वीडियो मॉड्यूल फ़्लटर में मीडिया क्वेरी और प्लेटफ़ॉर्म अनुकूली सुविधाओं जैसी विभिन्न तकनीकों के उपयोग के महत्व पर ज़ोर देकर समाप्त होता है ताकि अलग-अलग स्क्रीन साइज़ और ओरिएंटेशन पर अच्छे दिखने वाले रिस्पॉन्सिव यूज़र इंटरफ़ेस बनाए जा सकें। यह क्यूपर्टिनो और मटेरियल डिज़ाइन तत्वों के लिए विजेट को अलग-अलग तरीके से कॉन्फ़िगर करने की आवश्यकता पर प्रकाश डालता है, कोड को सुव्यवस्थित करने और रखरखाव में सुधार करने के लिए अनुकूली और उत्तरदायी विजेट के उपयोग का सुझाव देता है। वीडियो बड़े कोडबेस के भीतर संगठन और नेविगेशन की आसानी को बढ़ाने के लिए ऐप को विजेट में विभाजित करने के लाभों पर ज़ोर देता है, अंततः फ़्लटर द्वारा विभिन्न स्क्रीन साइज़ और ऑपरेटिंग सिस्टम के लिए एप्लिकेशन को समायोजित करने के लिए प्रदान किए गए टूल पर ज़ोर देता है।",
                                // Portuguese
                                "Português": "O módulo de vídeo conclui enfatizando a importância de utilizar várias técnicas, como media queries e recursos adaptativos de plataforma no Flutter, para construir interfaces de utilizador responsivas que ficam bem em diferentes tamanhos e orientações de ecrã. Destaca a necessidade de configurar os widgets de forma diferente para Cupertino e elementos de material design, sugerindo a utilização de widgets adaptativos e responsivos para agilizar o código e melhorar a capacidade de manutenção. O vídeo enfatiza os benefícios de dividir a aplicação em widgets para melhorar a organização e facilitar a navegação em bases de código maiores, enfatizando, em última análise, as ferramentas fornecidas pelo Flutter para ajustar as aplicações a diferentes tamanhos de ecrã e sistemas operativos.",
                                // Bengali
                                "বাংলা": "ভিডিও মডিউলটি বিভিন্ন কৌশল যেমন মিডিয়া কোয়েরি এবং প্ল্যাটফর্ম অভিযোজিত বৈশিষ্ট্যগুলিকে ফ্লটারে ব্যবহার করার গুরুত্বের উপর জোর দিয়ে শেষ হয়েছে প্রতিক্রিয়াশীল ব্যবহারকারী ইন্টারফেস তৈরি করতে যা বিভিন্ন স্ক্রীনের আকার এবং অভিযোজনগুলিতে ভাল দেখায়। এটি কুপারটিনো এবং উপাদান নকশা উপাদানগুলির জন্য ভিন্নভাবে উইজেটগুলি কনফিগার করার প্রয়োজনীয়তাকে হাইলাইট করে, কোডকে স্ট্রীমলাইন করতে এবং রক্ষণাবেক্ষণযোগ্যতা উন্নত করতে অভিযোজিত এবং প্রতিক্রিয়াশীল উইজেটগুলির ব্যবহারের পরামর্শ দেয়। ভিডিওটি বৃহত্তর কোডবেসের মধ্যে সংগঠন এবং নেভিগেশন সহজতর করার জন্য অ্যাপটিকে উইজেটগুলিতে বিভক্ত করার সুবিধাগুলির উপর জোর দেয়, শেষ পর্যন্ত বিভিন্ন স্ক্রীন আকার এবং অপারেটিং সিস্টেমে অ্যাপ্লিকেশনগুলিকে সামঞ্জস্য করার জন্য ফ্লটার দ্বারা সরবরাহিত সরঞ্জামগুলির উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "تختتم وحدة الفيديو بالتأكيد على أهمية الاستفادة من تقنيات مختلفة مثل استعلامات الوسائط وميزات التكيف مع المنصة في Flutter لبناء واجهات مستخدم متجاوبة تبدو جيدة على أحجام شاشات وتوجهات مختلفة. كما تسلط الضوء على الحاجة إلى تكوين عناصر واجهة المستخدم بشكل مختلف لعناصر تصميم Cupertino والمواد، مما يشير إلى استخدام عناصر واجهة المستخدم المتكيفة والمستجيبة لتبسيط التعليمات البرمجية وتحسين إمكانية الصيانة. ويؤكد الفيديو على فوائد تقسيم التطبيق إلى عناصر واجهة مستخدم لتحسين التنظيم وسهولة التنقل داخل قواعد بيانات أكبر، مع التأكيد في النهاية على الأدوات التي يوفرها Flutter لضبط التطبيقات على أحجام شاشات وأنظمة تشغيل مختلفة.",
                                // Persian
                                "فارسی": "ماژول ویدیویی با تأکید بر اهمیت استفاده از تکنیک‌های مختلف مانند پرسش‌های رسانه‌ای و ویژگی‌های تطبیقی ​​پلتفرم در Flutter برای ایجاد رابط‌های کاربری پاسخگو که در اندازه‌ها و جهت‌های مختلف صفحه نمایش خوب به نظر می‌رسند، به پایان می‌رسد. این نیاز به پیکربندی متفاوت ویجت‌ها برای عناصر کوپرتینویی و طراحی متریال را برجسته می‌کند و استفاده از ویجت‌های تطبیقی ​​و پاسخ‌گو را برای ساده‌سازی کد و بهبود قابلیت نگهداری پیشنهاد می‌کند. این ویدئو بر مزایای تقسیم برنامه به ویجت‌ها برای افزایش سازماندهی و سهولت پیمایش در پایگاه‌های کد بزرگ‌تر تاکید می‌کند و در نهایت بر ابزارهای ارائه‌شده توسط Flutter برای تنظیم برنامه‌ها با اندازه‌های مختلف صفحه نمایش و سیستم‌های عامل تاکید می‌کند.",
                            },
                        },
                    ]
                },
                // Section 6 : Widget & Flutter Internals - Deep Dive
                {
                    "SectionName": "Widget & Flutter Internals - Deep Dive",
                    "Videos": [
                        // 122 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Module Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker introduces a new module that goes deeper into Flutter, covering behind the scenes aspects such as how the user interface is rebuilt and how to make code more efficient. The focus is on advanced features and writing good Flutter code to improve app performance, readability, and maintainability. The module aims to transition learners from basic to more advanced Flutter app development, providing key insights and skills necessary for becoming a proficient Flutter developer.",
                                // German
                                "Deutsch": "In diesem Video stellt der Sprecher ein neues Modul vor, das tiefer auf Flutter eingeht und Aspekte hinter den Kulissen behandelt, z. B. wie die Benutzeroberfläche neu aufgebaut wird und wie Code effizienter gestaltet werden kann. Der Schwerpunkt liegt auf erweiterten Funktionen und dem Schreiben von gutem Flutter-Code, um die Leistung, Lesbarkeit und Wartbarkeit der App zu verbessern. Das Modul zielt darauf ab, den Lernenden den Übergang von der grundlegenden zur fortgeschritteneren Flutter-App-Entwicklung zu erleichtern und wichtige Erkenntnisse und Fähigkeiten zu vermitteln, die erforderlich sind, um ein kompetenter Flutter-Entwickler zu werden.",
                                // Chinese
                                "中国人": "在本视频中，演讲者介绍了一个深入介绍 Flutter 的新模块，涵盖了幕后方面，例如如何重建用户界面以及如何提高代码效率。重点是高级功能和编写良好的 Flutter 代码以提高应用性能、可读性和可维护性。该模块旨在帮助学习者从基础 Flutter 应用开发过渡到更高级的 Flutter 应用开发，提供成为熟练 Flutter 开发人员所必需的关键见解和技能。",
                                // Russian
                                "Русский": "В этом видео докладчик представляет новый модуль, который глубже проникает во Flutter, охватывая закулисные аспекты, такие как то, как перестраивается пользовательский интерфейс и как сделать код более эффективным. Основное внимание уделяется расширенным функциям и написанию хорошего кода Flutter для улучшения производительности, читаемости и удобства обслуживания приложения. Цель модуля — перевести учащихся с базового уровня разработки приложений Flutter на более продвинутый, предоставляя ключевые идеи и навыки, необходимые для того, чтобы стать опытным разработчиком Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant présente un nouveau module qui approfondit Flutter, couvrant des aspects en coulisses tels que la façon dont l'interface utilisateur est reconstruite et comment rendre le code plus efficace. L'accent est mis sur les fonctionnalités avancées et l'écriture de bon code Flutter pour améliorer les performances, la lisibilité et la maintenabilité des applications. Le module vise à faire passer les apprenants du développement d'applications Flutter de base au développement d'applications Flutter plus avancé, en fournissant des informations et des compétences clés nécessaires pour devenir un développeur Flutter compétent.",
                                // Japanese
                                "日本語": "このビデオでは、スピーカーが Flutter についてさらに深く掘り下げた新しいモジュールを紹介し、ユーザー インターフェースの再構築方法やコードの効率化方法などの舞台裏の側面を取り上げています。高度な機能と、アプリのパフォーマンス、可読性、保守性を向上させる優れた Flutter コードの記述に重点を置いています。このモジュールは、学習者を基本的な Flutter アプリ開発からより高度な Flutter アプリ開発に移行させ、熟練した Flutter 開発者になるために必要な重要な洞察とスキルを提供することを目指しています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter에 대해 더 깊이 파고드는 새로운 모듈을 소개하며, 사용자 인터페이스가 어떻게 재구성되는지, 코드를 더 효율적으로 만드는 방법 등과 같은 비하인드 스토리를 다룹니다. 초점은 고급 기능과 앱 성능, 가독성, 유지 관리를 개선하기 위한 좋은 Flutter 코드 작성에 맞춰져 있습니다. 이 모듈은 학습자를 기본에서 고급 Flutter 앱 개발로 전환하여 능숙한 Flutter 개발자가 되는 데 필요한 핵심 통찰력과 기술을 제공하는 것을 목표로 합니다.",
                                // Spanish
                                "Español": "En este video, el orador presenta un nuevo módulo que profundiza en Flutter y cubre aspectos detrás de escena, como cómo se reconstruye la interfaz de usuario y cómo hacer que el código sea más eficiente. El enfoque está en las funciones avanzadas y en escribir un buen código de Flutter para mejorar el rendimiento, la legibilidad y la facilidad de mantenimiento de la aplicación. El módulo tiene como objetivo hacer que los estudiantes pasen del desarrollo básico de aplicaciones de Flutter al más avanzado, brindando conocimientos y habilidades clave necesarios para convertirse en un desarrollador competente de Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता एक नए मॉड्यूल का परिचय देता है जो फ़्लटर में गहराई से जाता है, पर्दे के पीछे के पहलुओं को कवर करता है जैसे कि उपयोगकर्ता इंटरफ़ेस को कैसे फिर से बनाया जाता है और कोड को और अधिक कुशल कैसे बनाया जाता है। ऐप के प्रदर्शन, पठनीयता और रखरखाव को बेहतर बनाने के लिए उन्नत सुविधाओं और अच्छे फ़्लटर कोड लिखने पर ध्यान केंद्रित किया गया है। मॉड्यूल का उद्देश्य शिक्षार्थियों को बुनियादी से अधिक उन्नत फ़्लटर ऐप विकास में स्थानांतरित करना है, जो एक कुशल फ़्लटर डेवलपर बनने के लिए आवश्यक महत्वपूर्ण अंतर्दृष्टि और कौशल प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador apresenta um novo módulo que aprofunda o Flutter, abordando aspetos dos bastidores, como a forma como a interface do utilizador é reconstruída e como tornar o código mais eficiente. O foco está em funcionalidades avançadas e na escrita de bom código Flutter para melhorar o desempenho, a legibilidade e a capacidade de manutenção da aplicação. O módulo tem como objetivo fazer a transição dos alunos do desenvolvimento básico de aplicações Flutter para o mais avançado, fornecendo importantes insights e competências necessárias para se tornar um Flutter Developer proficiente.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি নতুন মডিউল প্রবর্তন করেছে যা ফ্লটারের গভীরে যায়, পর্দার পিছনের দিকগুলি যেমন ইউজার ইন্টারফেসটি কীভাবে পুনর্নির্মাণ করা হয় এবং কীভাবে কোডকে আরও দক্ষ করে তোলা যায়। অ্যাপের কার্যক্ষমতা, পঠনযোগ্যতা এবং রক্ষণাবেক্ষণযোগ্যতা উন্নত করতে উন্নত বৈশিষ্ট্য এবং ভাল ফ্লটার কোড লেখার উপর ফোকাস। মডিউলটির লক্ষ্য হল শিক্ষার্থীদের মৌলিক থেকে আরও উন্নত ফ্লাটার অ্যাপ ডেভেলপমেন্টে রূপান্তর করা, যা একজন দক্ষ ফ্লাটার ডেভেলপার হওয়ার জন্য প্রয়োজনীয় মূল অন্তর্দৃষ্টি এবং দক্ষতা প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يقدم المتحدث وحدة جديدة تتعمق في Flutter، وتغطي جوانب خلف الكواليس مثل كيفية إعادة بناء واجهة المستخدم وكيفية جعل الكود أكثر كفاءة. يركز على الميزات المتقدمة وكتابة كود Flutter جيد لتحسين أداء التطبيق وقابليته للقراءة وقابليته للصيانة. تهدف الوحدة إلى تحويل المتعلمين من تطوير تطبيقات Flutter الأساسية إلى تطوير تطبيقات أكثر تقدمًا، مما يوفر رؤى ومهارات أساسية ضرورية ليصبحوا مطوري Flutter ماهرين.",
                                // Persian
                                "فارسی": "در این ویدئو، بلندگو ماژول جدیدی را معرفی می‌کند که عمیق‌تر به Flutter می‌رود و جنبه‌های پشت صحنه مانند نحوه بازسازی رابط کاربری و نحوه کارآمدتر کردن کد را پوشش می‌دهد. تمرکز بر روی ویژگی‌های پیشرفته و نوشتن کد Flutter خوب برای بهبود عملکرد، خوانایی و قابلیت نگهداری برنامه است. هدف این ماژول انتقال زبان‌آموزان از توسعه برنامه‌های Flutter اولیه به پیشرفته‌تر است، و بینش‌ها و مهارت‌های کلیدی لازم برای تبدیل شدن به یک توسعه‌دهنده ماهر Flutter را ارائه می‌دهد.",
                            },
                        },
                        // 123 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "The Problem At Hand",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker delves into the behind-the-scenes workings of Flutter by examining how the application draws content on the screen and the implications of executing the build method. The video uses a personal expenses planner app as an example to explore advanced concepts, such as how Flutter achieves a 60fps (frames per second) application by efficiently updating the screen without the need to redraw the entire UI on every build call. The focus is on understanding Flutter's optimization techniques to ensure smooth performance and efficiency in app development.",
                                // German
                                "Deutsch": "In diesem Video geht der Sprecher auf die Funktionsweise von Flutter hinter den Kulissen ein, indem er untersucht, wie die Anwendung Inhalte auf dem Bildschirm darstellt und welche Auswirkungen die Ausführung der Build-Methode hat. Das Video verwendet eine App zur Planung persönlicher Ausgaben als Beispiel, um fortgeschrittene Konzepte zu untersuchen, z. B. wie Flutter eine Anwendung mit 60 Bildern pro Sekunde (Frames per Second) erreicht, indem der Bildschirm effizient aktualisiert wird, ohne dass die gesamte Benutzeroberfläche bei jedem Build-Aufruf neu gezeichnet werden muss. Der Schwerpunkt liegt auf dem Verständnis der Optimierungstechniken von Flutter, um eine reibungslose Leistung und Effizienz bei der App-Entwicklung sicherzustellen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者通过研究应用程序如何在屏幕上绘制内容以及执行构建方法的含义，深入探讨了 Flutter 的幕后工作原理。该视频以个人开支规划器应用程序为例，探讨了高级概念，例如 Flutter 如何通过高效更新屏幕来实现 60fps（每秒帧数）的应用程序，而无需在每次构建调用时重新绘制整个 UI。重点是了解 Flutter 的优化技术，以确保应用程序开发的流畅性能和效率。",
                                // Russian
                                "Русский": "В этом видео докладчик углубляется в закулисную работу Flutter, изучая, как приложение рисует контент на экране, и последствия выполнения метода сборки. В видео в качестве примера используется приложение для планирования личных расходов, чтобы исследовать продвинутые концепции, например, как Flutter достигает 60 кадров в секунду (кадров в секунду) приложения, эффективно обновляя экран без необходимости перерисовывать весь пользовательский интерфейс при каждом вызове сборки. Основное внимание уделяется пониманию методов оптимизации Flutter для обеспечения плавной производительности и эффективности при разработке приложений.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant se penche sur le fonctionnement en coulisses de Flutter en examinant la manière dont l'application dessine le contenu à l'écran et les implications de l'exécution de la méthode de création. La vidéo utilise une application de planification des dépenses personnelles comme exemple pour explorer des concepts avancés, tels que la façon dont Flutter atteint une application à 60 images par seconde (images par seconde) en mettant à jour efficacement l'écran sans avoir à redessiner l'intégralité de l'interface utilisateur à chaque appel de création. L'accent est mis sur la compréhension des techniques d'optimisation de Flutter pour garantir des performances et une efficacité fluides dans le développement d'applications.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が Flutter の舞台裏の仕組みを詳しく解説し、アプリケーションが画面にコンテンツを描画する方法と、ビルド メソッドを実行することの影響について考察します。ビデオでは、個人経費プランナー アプリを例に、ビルド呼び出しごとに UI 全体を再描画することなく画面を効率的に更新することで、Flutter が 60fps (フレーム/秒) アプリケーションを実現する方法など、高度な概念について説明します。アプリ開発でスムーズなパフォーマンスと効率性を確保するために、Flutter の最適化手法を理解することに重点が置かれています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter의 비하인드 스토리를 파헤쳐 애플리케이션이 화면에 콘텐츠를 그리는 방식과 빌드 방법을 실행하는 의미를 살펴봅니다. 이 영상에서는 개인 지출 플래너 앱을 예로 들어 Flutter가 모든 빌드 호출에서 전체 UI를 다시 그릴 필요 없이 화면을 효율적으로 업데이트하여 60fps(초당 프레임) 애플리케이션을 달성하는 방법과 같은 고급 개념을 살펴봅니다. 초점은 앱 개발에서 원활한 성능과 효율성을 보장하기 위한 Flutter의 최적화 기술을 이해하는 것입니다.",
                                // Spanish
                                "Español": "En este video, el orador profundiza en el funcionamiento detrás de escena de Flutter al examinar cómo la aplicación dibuja contenido en la pantalla y las implicaciones de ejecutar el método de compilación. El video utiliza una aplicación de planificación de gastos personales como ejemplo para explorar conceptos avanzados, como cómo Flutter logra una aplicación de 60 fps (fotogramas por segundo) al actualizar eficientemente la pantalla sin la necesidad de volver a dibujar toda la interfaz de usuario en cada llamada de compilación. El enfoque está en comprender las técnicas de optimización de Flutter para garantizar un rendimiento fluido y eficiencia en el desarrollo de aplicaciones.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर के पीछे के कामों के बारे में विस्तार से बताता है कि एप्लीकेशन स्क्रीन पर कंटेंट कैसे खींचता है और बिल्ड विधि को निष्पादित करने के निहितार्थ क्या हैं। वीडियो में उन्नत अवधारणाओं का पता लगाने के लिए एक उदाहरण के रूप में एक व्यक्तिगत व्यय योजनाकार ऐप का उपयोग किया गया है, जैसे कि फ़्लटर प्रत्येक बिल्ड कॉल पर संपूर्ण UI को फिर से बनाने की आवश्यकता के बिना स्क्रीन को कुशलतापूर्वक अपडेट करके 60fps (फ़्रेम प्रति सेकंड) एप्लिकेशन कैसे प्राप्त करता है। ऐप विकास में सुचारू प्रदर्शन और दक्षता सुनिश्चित करने के लिए फ़्लटर की अनुकूलन तकनीकों को समझने पर ध्यान केंद्रित किया गया है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador investiga o funcionamento dos bastidores do Flutter, examinando como a aplicação desenha conteúdo no ecrã e as implicações da execução do método de construção. O vídeo utiliza uma aplicação de planeamento de despesas pessoais como exemplo para explorar conceitos avançados, como a forma como o Flutter atinge uma aplicação de 60 fps (frames por segundo) atualizando o ecrã de forma eficiente, sem a necessidade de redesenhar toda a IU em cada chamada de construção. O foco está na compreensão das técnicas de otimização do Flutter para garantir um bom desempenho e eficiência no desenvolvimento de aplicações.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার পর্দায় অ্যাপ্লিকেশন কীভাবে বিষয়বস্তু আঁকেন এবং বিল্ড পদ্ধতি কার্যকর করার প্রভাবগুলি পরীক্ষা করে ফ্লটার-এর নেপথ্য-দ্যা-সিনে কাজগুলিকে দেখেন৷ ভিডিওটি উন্নত ধারণাগুলি অন্বেষণ করার জন্য একটি উদাহরণ হিসাবে একটি ব্যক্তিগত খরচ পরিকল্পনাকারী অ্যাপ ব্যবহার করে, যেমন Flutter প্রতিটি বিল্ড কলে সম্পূর্ণ UI পুনরায় আঁকার প্রয়োজন ছাড়াই দক্ষতার সাথে স্ক্রীন আপডেট করে একটি 60fps (ফ্রেম প্রতি সেকেন্ড) অ্যাপ্লিকেশন অর্জন করে৷ অ্যাপ বিকাশে মসৃণ কর্মক্ষমতা এবং দক্ষতা নিশ্চিত করতে ফ্লটারের অপ্টিমাইজেশান কৌশলগুলি বোঝার উপর ফোকাস করা হয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتعمق المتحدث في العمل خلف الكواليس لبرنامج Flutter من خلال فحص كيفية قيام التطبيق برسم المحتوى على الشاشة والآثار المترتبة على تنفيذ طريقة البناء. يستخدم الفيديو تطبيقًا للتخطيط للنفقات الشخصية كمثال لاستكشاف المفاهيم المتقدمة، مثل كيفية تحقيق Flutter لتطبيق بمعدل 60 إطارًا في الثانية من خلال تحديث الشاشة بكفاءة دون الحاجة إلى إعادة رسم واجهة المستخدم بالكامل في كل مكالمة بناء. يركز الفيديو على فهم تقنيات التحسين الخاصة بـ Flutter لضمان الأداء السلس والكفاءة في تطوير التطبيقات.",
                                // Persian
                                "فارسی": "در این ویدیو، گوینده با بررسی نحوه ترسیم محتوا بر روی صفحه توسط برنامه و پیامدهای اجرای روش ساخت، به بررسی عملکردهای پشت صحنه فلاتر می پردازد. این ویدئو از یک برنامه برنامه‌ریز هزینه‌های شخصی به عنوان مثال برای بررسی مفاهیم پیشرفته استفاده می‌کند، مانند اینکه چگونه Flutter با به‌روزرسانی کارآمد صفحه، بدون نیاز به ترسیم مجدد کل رابط کاربری در هر تماس ساخت، به یک برنامه کاربردی 60 فریم در ثانیه (فریم در ثانیه) دست می‌یابد. تمرکز بر درک تکنیک‌های بهینه‌سازی فلاتر برای اطمینان از عملکرد روان و کارایی در توسعه برنامه است.",
                            },
                        },
                        // 124 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Widget Tree & Element Tree - What, Why and How_",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker explains the intricate workings of Flutter by introducing the concept of multiple trees within the framework: the widget tree, element tree, and render tree. The widget tree, controlled by the developer through code, serves as a configuration setting for what should be displayed on the screen. The element tree, automatically created by Flutter based on the widget tree, links widgets to rendered objects and is managed differently from the widget tree, as it does not rebuild with every call to the build method. The render tree represents what is actually displayed on the screen and is rarely rebuilt. The video provides a detailed breakdown of how Flutter handles elements, widgets, and rendering in order to optimize screen updates and ensure efficient performance. Additionally, the relationship between set state, the build method, and triggers for rebuilding the widget tree are explained, highlighting the importance of understanding these concepts in Flutter app development.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Sprecher die komplizierte Funktionsweise von Flutter, indem er das Konzept mehrerer Bäume innerhalb des Frameworks vorstellt: den Widget-Baum, den Elementbaum und den Renderbaum. Der Widget-Baum, der vom Entwickler über Code gesteuert wird, dient als Konfigurationseinstellung für das, was auf dem Bildschirm angezeigt werden soll. Der Elementbaum, der von Flutter automatisch basierend auf dem Widget-Baum erstellt wird, verknüpft Widgets mit gerenderten Objekten und wird anders verwaltet als der Widget-Baum, da er nicht bei jedem Aufruf der Build-Methode neu erstellt wird. Der Renderbaum stellt dar, was tatsächlich auf dem Bildschirm angezeigt wird, und wird selten neu erstellt. Das Video bietet eine detaillierte Aufschlüsselung, wie Flutter Elemente, Widgets und Rendering handhabt, um Bildschirmaktualisierungen zu optimieren und eine effiziente Leistung sicherzustellen. Darüber hinaus wird die Beziehung zwischen festgelegtem Status, der Build-Methode und Auslösern zum Neuaufbau des Widget-Baums erklärt, was die Bedeutung des Verständnisses dieser Konzepte bei der Entwicklung von Flutter-Apps unterstreicht.",
                                // Chinese
                                "中国人": "在本视频中，演讲者通过介绍框架内的多个树的概念来解释 Flutter 的复杂工作原理：控件树、元素树和渲染树。控件树由开发人员通过代码控制，用作屏幕上应显示内容的配置设置。元素树由 Flutter 根据控件树自动创建，它将控件链接到渲染对象，其管理方式与控件树不同，因为它不会在每次调用 build 方法时重建。渲染树表示屏幕上实际显示的内容，很少重建。视频详细介绍了 Flutter 如何处理元素、控件和渲染，以优化屏幕更新并确保高效的性能。此外，视频还解释了设置状态、构建方法和重建控件树的触发器之间的关系，强调了理解这些概念在 Flutter 应用开发中的重要性。",
                                // Russian
                                "Русский": "В этом видео докладчик объясняет сложную работу Flutter, представляя концепцию нескольких деревьев в рамках: дерево виджетов, дерево элементов и дерево рендеринга. Дерево виджетов, контролируемое разработчиком через код, служит в качестве настройки конфигурации для того, что должно отображаться на экране. Дерево элементов, автоматически созданное Flutter на основе дерева виджетов, связывает виджеты с визуализированными объектами и управляется иначе, чем дерево виджетов, поскольку оно не перестраивается при каждом вызове метода сборки. Дерево рендеринга представляет то, что фактически отображается на экране, и редко перестраивается. Видео дает подробный анализ того, как Flutter обрабатывает элементы, виджеты и рендеринг для оптимизации обновлений экрана и обеспечения эффективной производительности. Кроме того, объясняется связь между установленным состоянием, методом сборки и триггерами для перестройки дерева виджетов, подчеркивая важность понимания этих концепций при разработке приложений Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique le fonctionnement complexe de Flutter en introduisant le concept d'arbres multiples au sein du framework : l'arbre des widgets, l'arbre des éléments et l'arbre de rendu. L'arbre des widgets, contrôlé par le développeur via le code, sert de paramètre de configuration pour ce qui doit être affiché à l'écran. L'arbre des éléments, créé automatiquement par Flutter sur la base de l'arbre des widgets, relie les widgets aux objets rendus et est géré différemment de l'arbre des widgets, car il ne se reconstruit pas à chaque appel à la méthode build. L'arbre de rendu représente ce qui est réellement affiché à l'écran et est rarement reconstruit. La vidéo fournit une analyse détaillée de la manière dont Flutter gère les éléments, les widgets et le rendu afin d'optimiser les mises à jour de l'écran et de garantir des performances efficaces. De plus, la relation entre l'état défini, la méthode build et les déclencheurs de reconstruction de l'arbre des widgets sont expliqués, soulignant l'importance de comprendre ces concepts dans le développement d'applications Flutter.",
                                // Japanese
                                "日本語": "この動画では、講演者がフレームワーク内の複数のツリー（ウィジェット ツリー、要素ツリー、レンダリング ツリー）の概念を紹介しながら、Flutter の複雑な仕組みを説明しています。開発者がコードを通じて制御するウィジェット ツリーは、画面に表示される内容の構成設定として機能します。ウィジェット ツリーに基づいて Flutter によって自動的に作成される要素ツリーは、ウィジェットをレンダリングされたオブジェクトにリンクします。ウィジェット ツリーとは管理方法が異なり、ビルド メソッドの呼び出しごとに再構築されることはありません。レンダリング ツリーは、画面に実際に表示される内容を表し、再構築されることはほとんどありません。この動画では、画面の更新を最適化し、効率的なパフォーマンスを確保するために、Flutter が要素、ウィジェット、レンダリングを処理する方法について詳しく説明しています。さらに、設定状態、ビルド メソッド、ウィジェット ツリーを再構築するためのトリガーの関係についても説明し、Flutter アプリ開発でこれらの概念を理解することの重要性を強調しています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 프레임워크 내의 여러 트리, 즉 위젯 트리, 요소 트리, 렌더 트리의 개념을 소개하여 Flutter의 복잡한 작동 방식을 설명합니다. 개발자가 코드를 통해 제어하는 ​​위젯 트리는 화면에 표시해야 하는 내용에 대한 구성 설정 역할을 합니다. 위젯 트리를 기반으로 Flutter에서 자동으로 생성하는 요소 트리는 위젯을 렌더링된 객체에 연결하며, 모든 빌드 메서드 호출 시 다시 빌드하지 않기 때문에 위젯 트리와 다르게 관리됩니다. 렌더 트리는 실제로 화면에 표시되는 내용을 나타내며 거의 다시 빌드되지 않습니다. 이 영상에서는 Flutter가 화면 업데이트를 최적화하고 효율적인 성능을 보장하기 위해 요소, 위젯 및 렌더링을 처리하는 방법에 대한 자세한 분석을 제공합니다. 또한 설정 상태, 빌드 메서드, 위젯 트리를 다시 빌드하기 위한 트리거 간의 관계를 설명하여 Flutter 앱 개발에서 이러한 개념을 이해하는 것이 중요함을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el orador explica el intrincado funcionamiento de Flutter al presentar el concepto de múltiples árboles dentro del marco: el árbol de widgets, el árbol de elementos y el árbol de renderizado. El árbol de widgets, controlado por el desarrollador a través del código, sirve como un parámetro de configuración para lo que se debe mostrar en la pantalla. El árbol de elementos, creado automáticamente por Flutter en función del árbol de widgets, vincula los widgets a los objetos renderizados y se administra de manera diferente al árbol de widgets, ya que no se reconstruye con cada llamada al método de compilación. El árbol de renderizado representa lo que realmente se muestra en la pantalla y rara vez se reconstruye. El video proporciona un desglose detallado de cómo Flutter maneja los elementos, los widgets y el renderizado para optimizar las actualizaciones de pantalla y garantizar un rendimiento eficiente. Además, se explica la relación entre el estado establecido, el método de compilación y los activadores para reconstruir el árbol de widgets, destacando la importancia de comprender estos conceptos en el desarrollo de aplicaciones Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ्रेमवर्क के भीतर कई पेड़ों की अवधारणा को पेश करके फ़्लटर के जटिल कामकाज को समझाता है: विजेट ट्री, एलिमेंट ट्री और रेंडर ट्री। डेवलपर द्वारा कोड के माध्यम से नियंत्रित विजेट ट्री, स्क्रीन पर क्या प्रदर्शित किया जाना चाहिए, इसके लिए कॉन्फ़िगरेशन सेटिंग के रूप में कार्य करता है। विजेट ट्री के आधार पर फ़्लटर द्वारा स्वचालित रूप से बनाया गया एलिमेंट ट्री, विजेट को रेंडर किए गए ऑब्जेक्ट से जोड़ता है और विजेट ट्री से अलग तरीके से प्रबंधित किया जाता है, क्योंकि यह बिल्ड विधि के प्रत्येक कॉल के साथ पुनर्निर्माण नहीं करता है। रेंडर ट्री दर्शाता है कि स्क्रीन पर वास्तव में क्या प्रदर्शित होता है और शायद ही कभी पुनर्निर्माण किया जाता है। वीडियो स्क्रीन अपडेट को अनुकूलित करने और कुशल प्रदर्शन सुनिश्चित करने के लिए फ़्लटर तत्वों, विजेट और रेंडरिंग को कैसे संभालता है, इसका विस्तृत विवरण प्रदान करता है। इसके अतिरिक्त, विजेट ट्री के पुनर्निर्माण के लिए सेट स्टेट, बिल्ड विधि और ट्रिगर्स के बीच संबंध को समझाया गया है, जो फ़्लटर ऐप डेवलपमेंट में इन अवधारणाओं को समझने के महत्व पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador explica o intrincado funcionamento do Flutter, introduzindo o conceito de múltiplas árvores dentro da estrutura: a árvore de widgets, a árvore de elementos e a árvore de renderização. A árvore de widgets, controlada pelo programador através de código, serve como configuração do que deve ser apresentado no ecrã. A árvore de elementos, criada automaticamente pelo Flutter com base na árvore de widgets, liga os widgets aos objetos renderizados e é gerida de forma diferente da árvore de widgets, uma vez que não é reconstruída a cada chamada ao método build. A árvore de renderização representa o que é realmente apresentado no ecrã e raramente é reconstruído. O vídeo fornece uma análise detalhada de como o Flutter lida com os elementos, widgets e renderização para otimizar as atualizações do ecrã e garantir um desempenho eficiente. Além disso, é explicada a relação entre o estado definido, o método de construção e os gatilhos para reconstruir a árvore de widgets, destacando a importância de compreender estes conceitos no desenvolvimento de aplicações Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার কাঠামোর মধ্যে একাধিক গাছের ধারণাটি প্রবর্তন করে ফ্লটারের জটিল কাজগুলি ব্যাখ্যা করেছেন: উইজেট ট্রি, এলিমেন্ট ট্রি এবং রেন্ডার ট্রি৷ উইজেট ট্রি, কোডের মাধ্যমে বিকাশকারী দ্বারা নিয়ন্ত্রিত, স্ক্রিনে কী প্রদর্শিত হবে তার জন্য একটি কনফিগারেশন সেটিং হিসাবে কাজ করে। এলিমেন্ট ট্রি, উইজেট ট্রির উপর ভিত্তি করে ফ্লটার দ্বারা স্বয়ংক্রিয়ভাবে তৈরি, উইজেটগুলিকে রেন্ডার করা বস্তুর সাথে লিঙ্ক করে এবং উইজেট ট্রি থেকে আলাদাভাবে পরিচালিত হয়, কারণ এটি বিল্ড পদ্ধতিতে প্রতিটি কলের সাথে পুনর্নির্মাণ করে না। রেন্ডার ট্রি প্রকৃতপক্ষে পর্দায় যা প্রদর্শিত হয় তা উপস্থাপন করে এবং খুব কমই পুনর্নির্মিত হয়। স্ক্রিন আপডেট অপ্টিমাইজ করতে এবং দক্ষ কর্মক্ষমতা নিশ্চিত করার জন্য ফ্লটার কীভাবে উপাদান, উইজেট এবং রেন্ডারিং পরিচালনা করে তার একটি বিশদ বিভাজন ভিডিওটি প্রদান করে। উপরন্তু, সেট স্টেট, বিল্ড পদ্ধতি এবং উইজেট ট্রি পুনর্নির্মাণের জন্য ট্রিগারগুলির মধ্যে সম্পর্ক ব্যাখ্যা করা হয়েছে, ফ্লাটার অ্যাপ ডেভেলপমেন্টে এই ধারণাগুলি বোঝার গুরুত্ব তুলে ধরে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المتحدث العمليات المعقدة لـ Flutter من خلال تقديم مفهوم الأشجار المتعددة داخل الإطار: شجرة الأدوات، وشجرة العناصر، وشجرة العرض. تعمل شجرة الأدوات، التي يتحكم فيها المطور من خلال الكود، كإعداد تكوين لما يجب عرضه على الشاشة. تربط شجرة العناصر، التي تم إنشاؤها تلقائيًا بواسطة Flutter استنادًا إلى شجرة الأدوات، الأدوات بالكائنات المعروضة ويتم إدارتها بشكل مختلف عن شجرة الأدوات، حيث لا يتم إعادة بنائها مع كل استدعاء لطريقة البناء. تمثل شجرة العرض ما يتم عرضه بالفعل على الشاشة ونادرًا ما يتم إعادة بنائها. يوفر الفيديو تفصيلاً مفصلاً لكيفية تعامل Flutter مع العناصر والأدوات والعرض من أجل تحسين تحديثات الشاشة وضمان الأداء الفعال. بالإضافة إلى ذلك، يتم شرح العلاقة بين حالة التعيين وطريقة البناء والمحفزات لإعادة بناء شجرة الأدوات، مما يسلط الضوء على أهمية فهم هذه المفاهيم في تطوير تطبيقات Flutter.",
                                // Persian
                                "فارسی": "در این ویدئو، سخنران با معرفی مفهوم درخت های متعدد در چارچوب: درخت ویجت، درخت عنصر و درخت رندر، عملکرد پیچیده فلاتر را توضیح می دهد. درخت ویجت، که توسط توسعه دهنده از طریق کد کنترل می شود، به عنوان یک تنظیمات پیکربندی برای آنچه که باید روی صفحه نمایش داده شود عمل می کند. درخت عنصر که به طور خودکار توسط Flutter بر اساس درخت ویجت ایجاد می‌شود، ویجت‌ها را به اشیاء رندر شده پیوند می‌دهد و متفاوت از درخت ویجت مدیریت می‌شود، زیرا با هر فراخوانی به متد ساخت، بازسازی نمی‌شود. درخت رندر نشان دهنده چیزی است که در واقع روی صفحه نمایش داده می شود و به ندرت بازسازی می شود. این ویدئو به تفصیل جزئیاتی از نحوه استفاده از Flutter با عناصر، ویجت‌ها و رندر به منظور بهینه‌سازی به‌روزرسانی‌های صفحه و اطمینان از عملکرد کارآمد ارائه می‌دهد. علاوه بر این، رابطه بین حالت تنظیم، روش ساخت، و محرک‌های بازسازی درخت ویجت توضیح داده شده است و اهمیت درک این مفاهیم در توسعه اپلیکیشن فلاتر را برجسته می‌کند.",
                            },
                        },
                        // 125 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "How Flutter Rebuilds & Repaints the Screen",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker discusses the interactions between the widget tree, element tree, and render tree in Flutter when the build method is called, typically triggered by calling set state. The video explains how set state marks a widget as dirty, leading to the creation of a new widget instance connecting to the state object. Despite the creation of new widget instances, the elements in the element tree are not necessarily replaced completely. Instead, they update their references to point to the new widget, maintaining efficiency in rendering updates. The video emphasizes the importance of understanding these concepts for optimizing Flutter app performance, showcasing the framework's sophisticated management of configuration data and screen updates through the different tree structures.",
                                // German
                                "Deutsch": "In diesem Video bespricht der Sprecher die Interaktionen zwischen dem Widget-Baum, dem Elementbaum und dem Renderbaum in Flutter, wenn die Build-Methode aufgerufen wird, was normalerweise durch den Aufruf von „Set State“ ausgelöst wird. Das Video erklärt, wie „Set State“ ein Widget als „Dirty“ markiert, was zur Erstellung einer neuen Widget-Instanz führt, die eine Verbindung zum Statusobjekt herstellt. Trotz der Erstellung neuer Widget-Instanzen werden die Elemente im Elementbaum nicht unbedingt vollständig ersetzt. Stattdessen aktualisieren sie ihre Referenzen, um auf das neue Widget zu verweisen, wodurch die Effizienz beim Rendern von Updates erhalten bleibt. Das Video betont, wie wichtig es ist, diese Konzepte zu verstehen, um die Leistung von Flutter-Apps zu optimieren, und zeigt das ausgeklügelte Management von Konfigurationsdaten und Bildschirmaktualisierungen durch das Framework über die verschiedenen Baumstrukturen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了 Flutter 中在调用 build 方法时（通常通过调用 set state 触发）widget 树、元素树和渲染树之间的交互。视频解释了 set state 如何将 widget 标记为 dirty，从而创建连接到状态对象的新 widget 实例。尽管创建了新的 widget 实例，但元素树中的元素不一定会被完全替换。相反，它们会更新其引用以指向新的 widget，从而保持渲染更新的效率。视频强调了理解这些概念对于优化 Flutter 应用性能的重要性，展示了框架通过不同的树结构对配置数据和屏幕更新的复杂管理。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает взаимодействие между деревом виджетов, деревом элементов и деревом рендеринга во Flutter при вызове метода сборки, обычно запускаемого вызовом set state. Видео объясняет, как set state помечает виджет как грязный, что приводит к созданию нового экземпляра виджета, подключающегося к объекту состояния. Несмотря на создание новых экземпляров виджета, элементы в дереве элементов не обязательно заменяются полностью. Вместо этого они обновляют свои ссылки, чтобы указывать на новый виджет, поддерживая эффективность при рендеринге обновлений. Видео подчеркивает важность понимания этих концепций для оптимизации производительности приложения Flutter, демонстрируя сложное управление фреймворком данными конфигурации и обновлениями экрана через различные древовидные структуры.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant discute des interactions entre l'arborescence des widgets, l'arborescence des éléments et l'arborescence de rendu dans Flutter lorsque la méthode build est appelée, généralement déclenchée par l'appel de set state. La vidéo explique comment set state marque un widget comme sale, ce qui conduit à la création d'une nouvelle instance de widget se connectant à l'objet state. Malgré la création de nouvelles instances de widget, les éléments de l'arborescence des éléments ne sont pas nécessairement remplacés complètement. Au lieu de cela, ils mettent à jour leurs références pour pointer vers le nouveau widget, préservant ainsi l'efficacité des mises à jour de rendu. La vidéo souligne l'importance de comprendre ces concepts pour optimiser les performances des applications Flutter, en présentant la gestion sophistiquée des données de configuration et des mises à jour d'écran par le framework à travers les différentes structures d'arborescence.",
                                // Japanese
                                "日本語": "この動画では、通常は set state の呼び出しによってトリガーされる build メソッドが呼び出されたときの、Flutter のウィジェット ツリー、要素ツリー、レンダリング ツリー間の相互作用について講演者が説明しています。動画では、set state がウィジェットをダーティとしてマークし、状態オブジェクトに接続する新しいウィジェット インスタンスを作成する仕組みを説明しています。新しいウィジェット インスタンスが作成されても、要素ツリー内の要素は必ずしも完全に置き換えられるわけではありません。代わりに、新しいウィジェットを指すように参照を更新し、レンダリング更新の効率を維持します。動画では、Flutter アプリのパフォーマンスを最適化するためにこれらの概念を理解することの重要性を強調し、さまざまなツリー構造を通じてフレームワークが構成データと画面更新を高度に管理する様子を紹介しています。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 일반적으로 set state를 호출하여 트리거되는 build 메서드가 호출될 때 Flutter에서 위젯 트리, 요소 트리 및 렌더 트리 간의 상호 작용에 대해 설명합니다. 이 비디오에서는 set state가 위젯을 dirty로 표시하여 state 객체에 연결되는 새 위젯 인스턴스를 만드는 방법을 설명합니다. 새 위젯 인스턴스를 만들었음에도 불구하고 요소 트리의 요소가 완전히 바뀌지는 않습니다. 대신 참조를 업데이트하여 새 위젯을 가리키고 렌더링 업데이트의 효율성을 유지합니다. 이 비디오에서는 Flutter 앱 성능을 최적화하기 위해 이러한 개념을 이해하는 것의 중요성을 강조하고 다양한 트리 구조를 통해 프레임워크의 정교한 구성 데이터 및 화면 업데이트 관리를 보여줍니다.",
                                // Spanish
                                "Español": "En este video, el orador analiza las interacciones entre el árbol de widgets, el árbol de elementos y el árbol de renderizado en Flutter cuando se llama al método de compilación, que generalmente se activa al llamar a set state. El video explica cómo set state marca un widget como sucio, lo que lleva a la creación de una nueva instancia de widget que se conecta al objeto de estado. A pesar de la creación de nuevas instancias de widget, los elementos en el árbol de elementos no necesariamente se reemplazan por completo. En cambio, actualizan sus referencias para apuntar al nuevo widget, lo que mantiene la eficiencia en las actualizaciones de renderizado. El video enfatiza la importancia de comprender estos conceptos para optimizar el rendimiento de la aplicación Flutter, mostrando la gestión sofisticada de los datos de configuración y las actualizaciones de pantalla del marco a través de las diferentes estructuras de árbol.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, स्पीकर फ़्लटर में विजेट ट्री, एलिमेंट ट्री और रेंडर ट्री के बीच की बातचीत पर चर्चा करता है जब बिल्ड विधि को कॉल किया जाता है, जो आमतौर पर सेट स्टेट को कॉल करके ट्रिगर किया जाता है। वीडियो बताता है कि कैसे सेट स्टेट एक विजेट को गंदा के रूप में चिह्नित करता है, जिससे स्टेट ऑब्जेक्ट से कनेक्ट होने वाले एक नए विजेट इंस्टेंस का निर्माण होता है। नए विजेट इंस्टेंस के निर्माण के बावजूद, एलिमेंट ट्री में तत्वों को पूरी तरह से प्रतिस्थापित नहीं किया जाता है। इसके बजाय, वे नए विजेट को इंगित करने के लिए अपने संदर्भों को अपडेट करते हैं, जिससे रेंडरिंग अपडेट में दक्षता बनी रहती है। वीडियो फ़्लटर ऐप प्रदर्शन को अनुकूलित करने के लिए इन अवधारणाओं को समझने के महत्व पर जोर देता है, जो विभिन्न ट्री संरचनाओं के माध्यम से कॉन्फ़िगरेशन डेटा और स्क्रीन अपडेट के फ्रेमवर्क के परिष्कृत प्रबंधन को प्रदर्शित करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador discute as interações entre a árvore de widgets, a árvore de elementos e a árvore de renderização no Flutter quando o método de construção é chamado, normalmente despoletado pela chamada do estado do conjunto. O vídeo explica como o set state marca um widget como sujo, levando à criação de uma nova instância de widget que se liga ao objeto de estado. Apesar da criação de novas instâncias de widgets, os elementos na árvore de elementos não são necessariamente substituídos completamente. Em vez disso, atualizam as suas referências para apontar para o novo widget, mantendo a eficiência na renderização das atualizações. O vídeo enfatiza a importância de compreender estes conceitos para otimizar o desempenho da aplicação Flutter, mostrando a gestão sofisticada de dados de configuração e atualizações de ecrã da framework através de diferentes estruturas em árvore.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার ফ্লটারে উইজেট ট্রি, এলিমেন্ট ট্রি এবং রেন্ডার ট্রির মধ্যে মিথস্ক্রিয়া নিয়ে আলোচনা করেছেন যখন বিল্ড মেথড কল করা হয়, সাধারণত সেট স্টেট কল করার মাধ্যমে ট্রিগার হয়। ভিডিওটি ব্যাখ্যা করে যে কিভাবে সেট স্টেট একটি উইজেটকে নোংরা হিসেবে চিহ্নিত করে, যার ফলে স্টেট অবজেক্টের সাথে সংযুক্ত একটি নতুন উইজেট ইন্সট্যান্স তৈরি হয়। নতুন উইজেট উদাহরণ তৈরি করা সত্ত্বেও, উপাদান গাছের উপাদানগুলি সম্পূর্ণরূপে প্রতিস্থাপিত হয় না। পরিবর্তে, তারা তাদের রেফারেন্স আপডেট করে নতুন উইজেটের দিকে নির্দেশ করতে, রেন্ডারিং আপডেটে দক্ষতা বজায় রাখে। ভিডিওটি বিভিন্ন গাছের কাঠামোর মাধ্যমে কনফিগারেশন ডেটা এবং স্ক্রিন আপডেটের ফ্রেমওয়ার্কের পরিশীলিত ব্যবস্থাপনা প্রদর্শন করে, Flutter অ্যাপের কর্মক্ষমতা অপ্টিমাইজ করার জন্য এই ধারণাগুলি বোঝার গুরুত্বের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث التفاعلات بين شجرة الأدوات وشجرة العناصر وشجرة العرض في Flutter عند استدعاء طريقة البناء، والتي يتم تشغيلها عادةً عن طريق استدعاء set state. يشرح الفيديو كيف تقوم set state بتمييز عنصر واجهة مستخدم على أنه متسخ، مما يؤدي إلى إنشاء مثيل جديد للأداة متصل بكائن الحالة. على الرغم من إنشاء مثيلات جديدة للأداة، فإن العناصر في شجرة العناصر لا يتم استبدالها بالضرورة بالكامل. بدلاً من ذلك، تقوم بتحديث مراجعها للإشارة إلى الأداة الجديدة، والحفاظ على الكفاءة في تحديثات العرض. يؤكد الفيديو على أهمية فهم هذه المفاهيم لتحسين أداء تطبيق Flutter، ويعرض إدارة الإطار المتطورة لبيانات التكوين وتحديثات الشاشة من خلال هياكل الشجرة المختلفة.",
                                // Persian
                                "فارسی": "در این ویدئو، گوینده در مورد تعاملات بین درخت ویجت، درخت عنصر و درخت رندر در Flutter هنگام فراخوانی متد ساخت بحث می‌کند، که معمولاً با فراخوانی وضعیت تنظیم راه‌اندازی می‌شود. این ویدیو توضیح می‌دهد که چگونه وضعیت تنظیم یک ویجت را به عنوان کثیف علامت‌گذاری می‌کند، که منجر به ایجاد یک نمونه ویجت جدید می‌شود که به شی حالت متصل می‌شود. علیرغم ایجاد نمونه های جدید ویجت، عناصر موجود در درخت عنصر لزوماً به طور کامل جایگزین نمی شوند. در عوض، آنها مراجع خود را به روز می کنند تا به ویجت جدید اشاره کنند و کارایی را در ارائه به روز رسانی حفظ کنند. این ویدیو بر اهمیت درک این مفاهیم برای بهینه‌سازی عملکرد برنامه Flutter تأکید می‌کند، و مدیریت پیچیده این چارچوب را برای داده‌های پیکربندی و به‌روزرسانی‌های صفحه نمایش از طریق ساختارهای درختی مختلف نشان می‌دهد.",
                            },
                        },
                        // 126 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "How Flutter Executes build()",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker explores the events that trigger the build method in various widgets within a Flutter app, using print statements to track when each build method is executed. By analyzing the debug logs, the video demonstrates how the build method is called for different widgets based on actions such as app initialization, changes in the media query, and interactions like tapping on a title. The speaker highlights the importance of understanding the rebuild process in Flutter and emphasizes the efficiency of the widget tree being rebuilt without necessitating a complete UI recalculation. Additionally, the video suggests strategies for efficient app organization by splitting code into widgets to control rebuild triggers effectively and optimize app performance.",
                                // German
                                "Deutsch": "In diesem Video untersucht der Sprecher die Ereignisse, die die Build-Methode in verschiedenen Widgets in einer Flutter-App auslösen, und verwendet Druckanweisungen, um zu verfolgen, wann jede Build-Methode ausgeführt wird. Durch die Analyse der Debug-Protokolle zeigt das Video, wie die Build-Methode für verschiedene Widgets basierend auf Aktionen wie App-Initialisierung, Änderungen in der Medienabfrage und Interaktionen wie dem Tippen auf einen Titel aufgerufen wird. Der Sprecher betont, wie wichtig es ist, den Wiederaufbauprozess in Flutter zu verstehen, und betont die Effizienz des Wiederaufbaus des Widget-Baums, ohne dass eine vollständige Neuberechnung der Benutzeroberfläche erforderlich ist. Darüber hinaus schlägt das Video Strategien für eine effiziente App-Organisation vor, indem Code in Widgets aufgeteilt wird, um Wiederaufbauauslöser effektiv zu steuern und die App-Leistung zu optimieren.",
                                // Chinese
                                "中国人": "在本视频中，演讲者探讨了 Flutter 应用中触发各种小部件的构建方法的事件，并使用打印语句来跟踪每个构建方法的执行时间。通过分析调试日志，视频演示了如何根据操作（例如应用初始化、媒体查询中的更改以及点击标题等交互）为不同的小部件调用构建方法。演讲者强调了了解 Flutter 中的重建过程的重要性，并强调了无需完全重新计算 UI 即可重建小部件树的效率。此外，视频还提出了有效的应用组织策略，即将代码拆分为小部件以有效控制重建触发器并优化应用性能。",
                                // Russian
                                "Русский": "В этом видео докладчик исследует события, которые запускают метод сборки в различных виджетах в приложении Flutter, используя операторы печати для отслеживания выполнения каждого метода сборки. Анализируя журналы отладки, видео демонстрирует, как метод сборки вызывается для различных виджетов на основе таких действий, как инициализация приложения, изменения в медиа-запросе и взаимодействия, такие как нажатие на заголовок. Докладчик подчеркивает важность понимания процесса перестройки во Flutter и подчеркивает эффективность перестройки дерева виджетов без необходимости полного пересчета пользовательского интерфейса. Кроме того, в видео предлагаются стратегии для эффективной организации приложения путем разделения кода на виджеты для эффективного управления триггерами перестройки и оптимизации производительности приложения.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explore les événements qui déclenchent la méthode build dans divers widgets au sein d'une application Flutter, en utilisant des instructions d'impression pour suivre le moment où chaque méthode build est exécutée. En analysant les journaux de débogage, la vidéo montre comment la méthode build est appelée pour différents widgets en fonction d'actions telles que l'initialisation de l'application, les modifications de la requête multimédia et les interactions telles que le fait d'appuyer sur un titre. L'intervenant souligne l'importance de comprendre le processus de reconstruction dans Flutter et met l'accent sur l'efficacité de la reconstruction de l'arborescence des widgets sans nécessiter un recalcul complet de l'interface utilisateur. De plus, la vidéo suggère des stratégies pour une organisation efficace des applications en divisant le code en widgets pour contrôler efficacement les déclencheurs de reconstruction et optimiser les performances de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、スピーカーが、Flutter アプリ内のさまざまなウィジェットでビルド メソッドをトリガーするイベントについて説明し、print ステートメントを使用して各ビルド メソッドがいつ実行されるかを追跡します。ビデオでは、デバッグ ログを分析することで、アプリの初期化、メディア クエリの変更、タイトルのタップなどの操作に基づいて、さまざまなウィジェットに対してビルド メソッドがどのように呼び出されるかを説明します。スピーカーは、Flutter での再構築プロセスを理解することの重要性を強調し、UI の完全な再計算を必要とせずにウィジェット ツリーを再構築する効率性を強調します。さらに、ビデオでは、コードをウィジェットに分割して再構築トリガーを効果的に制御し、アプリのパフォーマンスを最適化することで、アプリを効率的に整理するための戦略を提案します。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 앱 내의 다양한 위젯에서 빌드 메서드를 트리거하는 이벤트를 살펴보고, print 문을 사용하여 각 빌드 메서드가 실행되는 시점을 추적합니다. 이 영상은 디버그 로그를 분석하여 앱 초기화, 미디어 쿼리 변경, 제목 탭과 같은 상호 작용과 같은 동작에 따라 다양한 위젯에 대해 빌드 메서드가 호출되는 방식을 보여줍니다. 발표자는 Flutter에서 재빌드 프로세스를 이해하는 것의 중요성을 강조하고, UI를 완전히 다시 계산하지 않고도 위젯 트리를 재빌드하는 효율성을 강조합니다. 또한 이 영상은 코드를 위젯으로 분할하여 재빌드 트리거를 효과적으로 제어하고 앱 성능을 최적화하는 효율적인 앱 구성 전략을 제안합니다.",
                                // Spanish
                                "Español": "En este video, el orador explora los eventos que activan el método de compilación en varios widgets dentro de una aplicación Flutter, utilizando declaraciones de impresión para realizar un seguimiento de cuándo se ejecuta cada método de compilación. Al analizar los registros de depuración, el video demuestra cómo se llama al método de compilación para diferentes widgets en función de acciones como la inicialización de la aplicación, los cambios en la consulta de medios y las interacciones como tocar un título. El orador destaca la importancia de comprender el proceso de reconstrucción en Flutter y enfatiza la eficiencia del árbol de widgets que se está reconstruyendo sin necesidad de un recálculo completo de la interfaz de usuario. Además, el video sugiere estrategias para una organización eficiente de la aplicación al dividir el código en widgets para controlar los activadores de reconstrucción de manera efectiva y optimizar el rendimiento de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर ऐप के भीतर विभिन्न विजेट में बिल्ड विधि को ट्रिगर करने वाली घटनाओं का पता लगाता है, प्रिंट स्टेटमेंट का उपयोग करके ट्रैक करता है कि प्रत्येक बिल्ड विधि कब निष्पादित होती है। डिबग लॉग का विश्लेषण करके, वीडियो प्रदर्शित करता है कि ऐप इनिशियलाइज़ेशन, मीडिया क्वेरी में बदलाव और शीर्षक पर टैप करने जैसी बातचीत जैसी क्रियाओं के आधार पर विभिन्न विजेट के लिए बिल्ड विधि को कैसे कॉल किया जाता है। वक्ता फ़्लटर में पुनर्निर्माण प्रक्रिया को समझने के महत्व पर प्रकाश डालता है और पूर्ण UI पुनर्गणना की आवश्यकता के बिना पुनर्निर्माण किए जा रहे विजेट ट्री की दक्षता पर जोर देता है। इसके अतिरिक्त, वीडियो प्रभावी रूप से पुनर्निर्माण ट्रिगर्स को नियंत्रित करने और ऐप प्रदर्शन को अनुकूलित करने के लिए कोड को विजेट में विभाजित करके कुशल ऐप संगठन के लिए रणनीतियों का सुझाव देता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador explora os eventos que acionam o método de construção em vários widgets numa aplicação Flutter, utilizando instruções de impressão para rastrear quando cada método de construção é executado. Ao analisar os registos de depuração, o vídeo demonstra como o método de construção é chamado para diferentes widgets com base em ações como o arranque da aplicação, alterações na consulta de media e interações como tocar num título. O orador destaca a importância de compreender o processo de reconstrução no Flutter e enfatiza a eficiência da reconstrução da árvore de widgets sem a necessidade de um recálculo completo da IU. Além disso, o vídeo sugere estratégias para a organização eficiente das aplicações, dividindo o código em widgets para controlar os gatilhos de reconstrução de forma eficaz e otimizar o desempenho das aplicações.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার সেই ইভেন্টগুলি অন্বেষণ করে যা একটি ফ্লাটার অ্যাপের মধ্যে বিভিন্ন উইজেটে বিল্ড মেথড ট্রিগার করে, প্রতিটি বিল্ড মেথড এক্সিকিউট হলে ট্র্যাক করতে প্রিন্ট স্টেটমেন্ট ব্যবহার করে। ডিবাগ লগগুলি বিশ্লেষণ করে, ভিডিওটি দেখায় যে কীভাবে বিভিন্ন উইজেটগুলির জন্য বিল্ড পদ্ধতিটি কল করা হয় যেমন অ্যাপ্লিকেশান প্রাথমিককরণ, মিডিয়া ক্যোয়ারীতে পরিবর্তন এবং শিরোনামে আলতো চাপার মতো ইন্টারঅ্যাকশনের উপর ভিত্তি করে। স্পিকার ফ্লটারে পুনর্নির্মাণ প্রক্রিয়া বোঝার গুরুত্ব তুলে ধরেন এবং একটি সম্পূর্ণ UI পুনঃগণনার প্রয়োজন ছাড়াই উইজেট ট্রি পুনর্নির্মিত হওয়ার দক্ষতার উপর জোর দেন। উপরন্তু, ভিডিওটি কার্যকরভাবে পুনর্নির্মাণ ট্রিগারগুলি নিয়ন্ত্রণ করতে এবং অ্যাপের কার্যকারিতা অপ্টিমাইজ করতে উইজেটগুলিতে কোড বিভক্ত করে দক্ষ অ্যাপ সংস্থার জন্য কৌশলগুলির পরামর্শ দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يستكشف المتحدث الأحداث التي تؤدي إلى تشغيل طريقة البناء في عناصر واجهة مستخدم مختلفة داخل تطبيق Flutter، باستخدام عبارات الطباعة لتتبع وقت تنفيذ كل طريقة بناء. من خلال تحليل سجلات التصحيح، يوضح الفيديو كيفية استدعاء طريقة البناء لعناصر واجهة مستخدم مختلفة بناءً على إجراءات مثل تهيئة التطبيق والتغييرات في استعلام الوسائط والتفاعلات مثل النقر فوق عنوان. يسلط المتحدث الضوء على أهمية فهم عملية إعادة البناء في Flutter ويؤكد على كفاءة شجرة عناصر واجهة المستخدم التي يتم إعادة بنائها دون الحاجة إلى إعادة حساب واجهة المستخدم بالكامل. بالإضافة إلى ذلك، يقترح الفيديو استراتيجيات لتنظيم التطبيق بكفاءة من خلال تقسيم الكود إلى عناصر واجهة مستخدم للتحكم في عناصر واجهة المستخدم المحفزة بشكل فعال وتحسين أداء التطبيق.",
                                // Persian
                                "فارسی": "در این ویدیو، سخنران با استفاده از دستورات چاپی برای ردیابی زمانی که هر روش ساخت اجرا می‌شود، رویدادهایی را که باعث ایجاد روش ساخت در ویجت‌های مختلف در یک برنامه Flutter می‌شوند، بررسی می‌کند. با تجزیه و تحلیل گزارش‌های اشکال‌زدایی، ویدئو نشان می‌دهد که چگونه روش ساخت برای ویجت‌های مختلف بر اساس اقداماتی مانند مقداردهی اولیه برنامه، تغییرات در جستجوی رسانه و تعاملاتی مانند ضربه زدن روی عنوان فراخوانی می‌شود. سخنران اهمیت درک فرآیند بازسازی در Flutter را برجسته می کند و بر کارایی درخت ویجت که بدون نیاز به محاسبه مجدد کامل UI بازسازی می شود، تأکید می کند. علاوه بر این، این ویدئو با تقسیم کد به ابزارک ها برای کنترل موثر محرک های بازسازی و بهینه سازی عملکرد برنامه، استراتژی هایی را برای سازماندهی کارآمد برنامه پیشنهاد می کند.",
                            },
                        },
                        // 127 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Using _const_ Widgets & Constructors",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker explores the concept of const constructors and const widgets in Flutter to optimize app performance by avoiding unnecessary widget rebuilds. By marking certain widgets as const in the widget tree, developers can skip redundant object instantiations during rebuilds, particularly for elements that do not change dynamically during runtime. The video explains the usage of const constructors and const widgets with final unchangeable properties to create immutable objects that remain constant and unchangeable after compilation. While these optimizations may not drastically impact app speed, incorporating const declarations in appropriate areas can enhance overall performance and efficiency, providing a good coding practice for developers to consider during app development.",
                                // German
                                "Deutsch": "In diesem Video untersucht der Sprecher das Konzept von const-Konstruktoren und const-Widgets in Flutter, um die App-Leistung zu optimieren, indem unnötige Widget-Neuerstellungen vermieden werden. Indem Entwickler bestimmte Widgets im Widget-Baum als const markieren, können sie redundante Objektinstanziierungen während der Neuerstellungen überspringen, insbesondere bei Elementen, die sich während der Laufzeit nicht dynamisch ändern. Das Video erklärt die Verwendung von const-Konstruktoren und const-Widgets mit endgültigen unveränderlichen Eigenschaften, um unveränderliche Objekte zu erstellen, die nach der Kompilierung konstant und unveränderlich bleiben. Obwohl diese Optimierungen die App-Geschwindigkeit möglicherweise nicht drastisch beeinträchtigen, kann die Einbindung von const-Deklarationen in geeigneten Bereichen die Gesamtleistung und Effizienz verbessern und Entwicklern eine gute Codierungspraxis bieten, die sie bei der App-Entwicklung berücksichtigen sollten.",
                                // Chinese
                                "中国人": "在本视频中，演讲者探讨了 Flutter 中 const 构造函数和 const 小部件的概念，通过避免不必要的小部件重建来优化应用程序性能。通过在小部件树中将某些小部件标记为 const，开发人员可以在重建期间跳过冗余的对象实例化，特别是对于在运行时不会动态更改的元素。该视频解释了使用具有最终不可更改属性的 const 构造函数和 const 小部件来创建编译后保持不变且不可更改的不可变对象。虽然这些优化可能不会显著影响应用程序速度，但在适当的区域加入 const 声明可以提高整体性能和效率，为开发人员在应用程序开发过程中提供良好的编码实践。",
                                // Russian
                                "Русский": "В этом видео докладчик исследует концепцию конструкторов const и виджетов const во Flutter для оптимизации производительности приложения путем избежания ненужных пересборок виджетов. Отмечая определенные виджеты как const в дереве виджетов, разработчики могут пропустить избыточные инстанциации объектов во время пересборок, особенно для элементов, которые не изменяются динамически во время выполнения. Видео объясняет использование конструкторов const и виджетов const с окончательными неизменяемыми свойствами для создания неизменяемых объектов, которые остаются постоянными и неизменяемыми после компиляции. Хотя эти оптимизации могут не сильно повлиять на скорость приложения, включение объявлений const в соответствующие области может повысить общую производительность и эффективность, предоставляя разработчикам хорошую практику кодирования, которую следует учитывать при разработке приложений.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explore le concept de constructeurs const et de widgets const dans Flutter pour optimiser les performances des applications en évitant les reconstructions de widgets inutiles. En marquant certains widgets comme const dans l'arborescence des widgets, les développeurs peuvent ignorer les instanciations d'objets redondantes lors des reconstructions, en particulier pour les éléments qui ne changent pas de manière dynamique pendant l'exécution. La vidéo explique l'utilisation de constructeurs const et de widgets const avec des propriétés finales immuables pour créer des objets immuables qui restent constants et immuables après la compilation. Bien que ces optimisations n'aient pas d'impact drastique sur la vitesse de l'application, l'intégration de déclarations const dans les zones appropriées peut améliorer les performances et l'efficacité globales, offrant ainsi une bonne pratique de codage à prendre en compte par les développeurs lors du développement de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、スピーカーが Flutter の const コンストラクターと const ウィジェットの概念を説明し、不要なウィジェットの再構築を回避してアプリのパフォーマンスを最適化します。ウィジェット ツリーで特定のウィジェットを const としてマークすることで、開発者は、特に実行時に動的に変更されない要素の場合、再構築中に冗長なオブジェクトのインスタンス化をスキップできます。ビデオでは、最終的に変更できないプロパティを持つ const コンストラクターと const ウィジェットを使用して、コンパイル後も一定で変更できない不変オブジェクトを作成する方法について説明します。これらの最適化はアプリの速度に大きな影響を与えないかもしれませんが、適切な領域に const 宣言を組み込むことで、全体的なパフォーマンスと効率を向上させることができ、開発者がアプリ開発中に考慮すべき優れたコーディング プラクティスを提供します。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 불필요한 위젯 재구축을 피함으로써 앱 성능을 최적화하기 위해 Flutter에서 const 생성자와 const 위젯의 개념을 살펴봅니다. 위젯 트리에서 특정 위젯을 const로 표시하면 개발자는 특히 런타임 중에 동적으로 변경되지 않는 요소의 경우 재구축 중에 중복된 객체 인스턴스화를 건너뛸 수 있습니다. 이 영상에서는 컴파일 후에도 일정하고 변경 불가능한 불변 객체를 생성하기 위해 final unchangeable 속성이 있는 const 생성자와 const 위젯을 사용하는 방법을 설명합니다. 이러한 최적화가 앱 속도에 큰 영향을 미치지는 않지만 적절한 영역에 const 선언을 통합하면 전반적인 성능과 효율성을 향상시켜 개발자가 앱 개발 중에 고려할 수 있는 좋은 코딩 관행을 제공할 수 있습니다.",
                                // Spanish
                                "Español": "En este video, el orador explora el concepto de constructores y widgets constantes en Flutter para optimizar el rendimiento de la aplicación al evitar reconstrucciones innecesarias de widgets. Al marcar ciertos widgets como constantes en el árbol de widgets, los desarrolladores pueden omitir instancias de objetos redundantes durante las reconstrucciones, en particular para elementos que no cambian dinámicamente durante el tiempo de ejecución. El video explica el uso de constructores y widgets constantes con propiedades finales inmutables para crear objetos inmutables que permanecen constantes e inmutables después de la compilación. Si bien estas optimizaciones pueden no afectar drásticamente la velocidad de la aplicación, la incorporación de declaraciones constantes en áreas apropiadas puede mejorar el rendimiento y la eficiencia generales, lo que proporciona una buena práctica de codificación para que los desarrolladores la consideren durante el desarrollo de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता अनावश्यक विजेट पुनर्निर्माण से बचकर ऐप प्रदर्शन को अनुकूलित करने के लिए फ़्लटर में कॉन्स्ट कंस्ट्रक्टर और कॉन्स्ट विजेट की अवधारणा का पता लगाता है। विजेट ट्री में कुछ विजेट को कॉन्स्ट के रूप में चिह्नित करके, डेवलपर्स पुनर्निर्माण के दौरान अनावश्यक ऑब्जेक्ट इंस्टेंटिएशन को छोड़ सकते हैं, खासकर उन तत्वों के लिए जो रनटाइम के दौरान गतिशील रूप से नहीं बदलते हैं। वीडियो संकलन के बाद स्थिर और अपरिवर्तनीय रहने वाले अपरिवर्तनीय ऑब्जेक्ट बनाने के लिए अंतिम अपरिवर्तनीय गुणों के साथ कॉन्स्ट कंस्ट्रक्टर और कॉन्स्ट विजेट के उपयोग की व्याख्या करता है। हालांकि ये अनुकूलन ऐप की गति को बहुत अधिक प्रभावित नहीं कर सकते हैं, लेकिन उचित क्षेत्रों में कॉन्स्ट घोषणाओं को शामिल करने से समग्र प्रदर्शन और दक्षता में वृद्धि हो सकती है, जो डेवलपर्स को ऐप विकास के दौरान विचार करने के लिए एक अच्छा कोडिंग अभ्यास प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador explora o conceito de construtores const e widgets const no Flutter para otimizar o desempenho da aplicação, evitando reconstruções desnecessárias de widgets. Ao marcar determinados widgets como const na árvore de widgets, os programadores podem ignorar instanciações de objetos redundantes durante as reconstruções, especialmente para elementos que não mudam dinamicamente durante o tempo de execução. O vídeo explica a utilização de construtores const e widgets const com propriedades finais imutáveis ​​para criar objetos imutáveis ​​que permanecem constantes e imutáveis ​​após a compilação. Embora estas otimizações possam não ter impacto drasticamente na velocidade da aplicação, a incorporação de declarações const em áreas apropriadas pode melhorar o desempenho e a eficiência geral, proporcionando uma boa prática de codificação para os programadores considerarem durante o desenvolvimento da aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার অপ্রয়োজনীয় উইজেট পুনর্নির্মাণ এড়িয়ে অ্যাপ পারফরম্যান্সকে অপ্টিমাইজ করতে ফ্লটারে কনস্ট্রাক্টর এবং কনস্ট উইজেটগুলির ধারণাটি অন্বেষণ করেছেন। উইজেট ট্রিতে নির্দিষ্ট উইজেটগুলিকে const হিসাবে চিহ্নিত করে, বিকাশকারীরা পুনর্নির্মাণের সময় অপ্রয়োজনীয় বস্তুর ইন্সট্যান্টেশন এড়িয়ে যেতে পারে, বিশেষ করে এমন উপাদানগুলির জন্য যা রানটাইমের সময় গতিশীলভাবে পরিবর্তন হয় না। ভিডিওটি কম্পাইলেশনের পরেও অপরিবর্তনীয় বস্তু তৈরি করতে চূড়ান্ত অপরিবর্তনীয় বৈশিষ্ট্য সহ কনস্ট্রাক্টর এবং কনস্ট উইজেটগুলির ব্যবহার ব্যাখ্যা করে যা স্থির থাকে এবং অপরিবর্তনীয় থাকে। যদিও এই অপ্টিমাইজেশনগুলি অ্যাপের গতিতে ব্যাপকভাবে প্রভাব ফেলতে পারে না, উপযুক্ত এলাকায় কন্সট ঘোষণাগুলিকে অন্তর্ভুক্ত করা সামগ্রিক কর্মক্ষমতা এবং দক্ষতা বাড়াতে পারে, যা অ্যাপ বিকাশের সময় বিকাশকারীদের বিবেচনা করার জন্য একটি ভাল কোডিং অনুশীলন প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يستكشف المتحدث مفهوم منشئي العناصر الثابتة والأدوات الثابتة في Flutter لتحسين أداء التطبيق من خلال تجنب عمليات إعادة بناء الأدوات غير الضرورية. من خلال وضع علامة على بعض الأدوات على أنها ثابتة في شجرة الأدوات، يمكن للمطورين تخطي عمليات إنشاء الكائنات المكررة أثناء عمليات إعادة البناء، وخاصة للعناصر التي لا تتغير ديناميكيًا أثناء وقت التشغيل. يشرح الفيديو استخدام منشئي العناصر الثابتة والأدوات الثابتة مع خصائص نهائية غير قابلة للتغيير لإنشاء كائنات غير قابلة للتغيير تظل ثابتة وغير قابلة للتغيير بعد التجميع. في حين أن هذه التحسينات قد لا تؤثر بشكل كبير على سرعة التطبيق، فإن دمج إعلانات العناصر الثابتة في المناطق المناسبة يمكن أن يعزز الأداء العام والكفاءة، مما يوفر ممارسة ترميز جيدة للمطورين للنظر فيها أثناء تطوير التطبيق.",
                                // Persian
                                "فارسی": "در این ویدئو، سخنران مفهوم سازنده‌های const و ابزارک‌های const را در Flutter بررسی می‌کند تا با اجتناب از بازسازی‌های غیرضروری ویجت، عملکرد برنامه را بهینه کند. با علامت‌گذاری ویجت‌های خاص به‌عنوان const در درخت ویجت، توسعه‌دهندگان می‌توانند از نمونه‌های اضافی اشیاء در حین بازسازی‌ها صرفنظر کنند، به‌ویژه برای عناصری که در طول زمان اجرا به‌طور پویا تغییر نمی‌کنند. این ویدئو استفاده از سازنده‌های const و ویجت‌های const با ویژگی‌های غیرقابل تغییر نهایی را برای ایجاد اشیاء تغییرناپذیر که پس از کامپایل ثابت و غیرقابل تغییر می‌مانند، توضیح می‌دهد. در حالی که این بهینه‌سازی‌ها ممکن است به شدت بر سرعت برنامه تأثیر نگذارند، گنجاندن اعلان‌های مصرف در مناطق مناسب می‌تواند عملکرد و کارایی کلی را افزایش دهد و یک عمل کدنویسی خوب را برای توسعه‌دهندگان فراهم می‌کند تا در طول توسعه برنامه در نظر بگیرند.",
                            },
                        },
                        // 128 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Writing Good Code",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video explains the importance of writing good code in Flutter, focusing on readability, maintainability, and performance. Good code should be easy to understand and manage, both for the developer and potential collaborators. While following certain practices can improve performance, it's also important to balance this with overall development time. Continuous evaluation and exploration of new best practices are recommended to constantly improve code quality.",
                                // German
                                "Deutsch": "In diesem Video wird erklärt, wie wichtig es ist, guten Code in Flutter zu schreiben, wobei der Schwerpunkt auf Lesbarkeit, Wartbarkeit und Leistung liegt. Guter Code sollte sowohl für den Entwickler als auch für potenzielle Mitarbeiter leicht verständlich und handhabbar sein. Während die Einhaltung bestimmter Praktiken die Leistung verbessern kann, ist es auch wichtig, dies mit der Gesamtentwicklungszeit in Einklang zu bringen. Um die Codequalität ständig zu verbessern, wird eine kontinuierliche Evaluierung und Erforschung neuer Best Practices empfohlen.",
                                // Chinese
                                "中国人": "本视频介绍了在 Flutter 中编写优质代码的重要性，重点关注可读性、可维护性和性能。优秀的代码应该易于理解和管理，无论是对于开发人员还是潜在合作者而言。虽然遵循某些做法可以提高性能，但平衡性能与总体开发时间也很重要。建议持续评估和探索新的最佳实践，以不断提高代码质量。",
                                // Russian
                                "Русский": "В этом видео объясняется важность написания хорошего кода во Flutter, с упором на читаемость, удобство обслуживания и производительность. Хороший код должен быть простым для понимания и управления как для разработчика, так и для потенциальных соавторов. Хотя следование определенным практикам может повысить производительность, также важно сбалансировать это с общим временем разработки. Для постоянного улучшения качества кода рекомендуется постоянная оценка и исследование новых лучших практик.",
                                // French
                                "Français": "Cette vidéo explique l'importance d'écrire du bon code dans Flutter, en mettant l'accent sur la lisibilité, la maintenabilité et les performances. Un bon code doit être facile à comprendre et à gérer, tant pour le développeur que pour les collaborateurs potentiels. Bien que le respect de certaines pratiques puisse améliorer les performances, il est également important de trouver un équilibre avec le temps de développement global. Une évaluation continue et l'exploration de nouvelles bonnes pratiques sont recommandées pour améliorer constamment la qualité du code.",
                                // Japanese
                                "日本語": "この動画では、読みやすさ、保守性、パフォーマンスに重点を置き、Flutter で優れたコードを記述することの重要性について説明します。優れたコードは、開発者と潜在的な共同作業者の両方にとって理解しやすく、管理しやすいものでなければなりません。特定のプラクティスに従うことでパフォーマンスを向上させることができますが、全体的な開発時間とのバランスを取ることも重要です。コードの品質を常に向上させるには、新しいベスト プラクティスを継続的に評価し、調査することをお勧めします。",
                                // Korean
                                "한국인": "이 영상은 Flutter에서 좋은 코드를 작성하는 것의 중요성을 설명하며, 가독성, 유지 관리성, 성능에 초점을 맞춥니다. 좋은 코드는 개발자와 잠재적인 협력자 모두에게 이해하기 쉽고 관리하기 쉬워야 합니다. 특정 관행을 따르면 성능이 향상될 수 있지만, 전반적인 개발 시간과 균형을 맞추는 것도 중요합니다. 코드 품질을 지속적으로 개선하기 위해 새로운 모범 사례에 대한 지속적인 평가와 탐색이 권장됩니다.",
                                // Spanish
                                "Español": "Este video explica la importancia de escribir un buen código en Flutter, centrándose en la legibilidad, la facilidad de mantenimiento y el rendimiento. Un buen código debe ser fácil de entender y administrar, tanto para el desarrollador como para los posibles colaboradores. Si bien seguir ciertas prácticas puede mejorar el rendimiento, también es importante equilibrar esto con el tiempo de desarrollo general. Se recomienda la evaluación y exploración continuas de nuevas prácticas recomendadas para mejorar constantemente la calidad del código.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर में अच्छा कोड लिखने के महत्व को समझाता है, जिसमें पठनीयता, रखरखाव और प्रदर्शन पर ध्यान केंद्रित किया गया है। अच्छा कोड डेवलपर और संभावित सहयोगियों दोनों के लिए समझने और प्रबंधित करने में आसान होना चाहिए। जबकि कुछ प्रथाओं का पालन करने से प्रदर्शन में सुधार हो सकता है, इसे समग्र विकास समय के साथ संतुलित करना भी महत्वपूर्ण है। कोड की गुणवत्ता में लगातार सुधार करने के लिए नए सर्वोत्तम प्रथाओं का निरंतर मूल्यांकन और अन्वेषण की सिफारिश की जाती है।",
                                // Portuguese
                                "Português": "Este vídeo explica a importância de escrever bom código em Flutter, com foco na legibilidade, facilidade de manutenção e desempenho. Um bom código deve ser fácil de compreender e gerir, tanto para o developer como para potenciais colaboradores. Embora seguir determinadas práticas possa melhorar o desempenho, também é importante equilibrar isso com o tempo geral de desenvolvimento. A avaliação contínua e a exploração de novas melhores práticas são recomendadas para melhorar constantemente a qualidade do código.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি পঠনযোগ্যতা, রক্ষণাবেক্ষণযোগ্যতা এবং কর্মক্ষমতার উপর ফোকাস করে ফ্লটারে ভাল কোড লেখার গুরুত্ব ব্যাখ্যা করে। ডেভেলপার এবং সম্ভাব্য সহযোগী উভয়ের জন্যই ভালো কোড বুঝতে ও পরিচালনা করা সহজ হওয়া উচিত। যদিও কিছু অভ্যাস অনুসরণ করে কর্মক্ষমতা উন্নত করতে পারে, সামগ্রিক বিকাশের সময়ের সাথে এটির ভারসাম্য বজায় রাখাও গুরুত্বপূর্ণ। ক্রমাগত কোড গুণমান উন্নত করার জন্য ক্রমাগত মূল্যায়ন এবং নতুন সেরা অনুশীলনের অন্বেষণের সুপারিশ করা হয়।",
                                // Arabic
                                "عَرَبِيّ": "يوضح هذا الفيديو أهمية كتابة كود جيد في Flutter، مع التركيز على قابلية القراءة والصيانة والأداء. يجب أن يكون الكود الجيد سهل الفهم والإدارة، سواء بالنسبة للمطور أو المتعاونين المحتملين. وفي حين أن اتباع ممارسات معينة يمكن أن يحسن الأداء، فمن المهم أيضًا موازنة ذلك بوقت التطوير الإجمالي. يوصى بالتقييم المستمر واستكشاف أفضل الممارسات الجديدة لتحسين جودة الكود باستمرار.",
                                // Persian
                                "فارسی": "این ویدیو اهمیت نوشتن کد خوب در فلاتر را با تمرکز بر خوانایی، قابلیت نگهداری و عملکرد توضیح می دهد. کد خوب باید به راحتی قابل درک و مدیریت باشد، هم برای توسعه دهنده و هم برای همکاران احتمالی. در حالی که پیروی از روش های خاص می تواند عملکرد را بهبود بخشد، همچنین مهم است که این را با زمان کلی توسعه متعادل کنید. ارزیابی مستمر و کاوش بهترین شیوه های جدید برای بهبود مداوم کیفیت کد توصیه می شود.",
                            },
                        },
                        // 129 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Extracting Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video discusses potential improvements for code optimization in a Flutter application, focusing on performance and readability. The speaker suggests refactoring certain sections of code, such as separating content that utilizes the media query into separate widgets to avoid unnecessary rebuilds. The video also demonstrates the process of extracting a large widget chunk into a separate, more readable widget. While these changes may not directly impact performance, they can enhance code organization and make it easier for developers to understand and edit the code. The video emphasizes the importance of maintaining a balance between performance optimization and code readability.",
                                // German
                                "Deutsch": "In diesem Video werden mögliche Verbesserungen für die Codeoptimierung in einer Flutter-Anwendung erörtert, wobei der Schwerpunkt auf Leistung und Lesbarkeit liegt. Der Sprecher schlägt vor, bestimmte Codeabschnitte umzugestalten, z. B. Inhalte, die die Medienabfrage verwenden, in separate Widgets aufzuteilen, um unnötige Neuaufbauten zu vermeiden. Das Video zeigt auch den Prozess der Extraktion eines großen Widget-Blocks in ein separates, besser lesbares Widget. Diese Änderungen wirken sich zwar möglicherweise nicht direkt auf die Leistung aus, können jedoch die Codeorganisation verbessern und es Entwicklern erleichtern, den Code zu verstehen und zu bearbeiten. Das Video betont, wie wichtig es ist, ein Gleichgewicht zwischen Leistungsoptimierung und Codelesbarkeit aufrechtzuerhalten.",
                                // Chinese
                                "中国人": "本视频讨论了 Flutter 应用程序中代码优化的潜在改进，重点关注性能和可读性。演讲者建议重构某些代码部分，例如将使用媒体查询的内容分离到单独的小部件中，以避免不必要的重建。该视频还演示了将大型小部件块提取到单独的、更易读的小部件中的过程。虽然这些更改可能不会直接影响性能，但它们可以增强代码组织并使开发人员更容易理解和编辑代码。该视频强调了在性能优化和代码可读性之间保持平衡的重要性。",
                                // Russian
                                "Русский": "В этом видео обсуждаются потенциальные улучшения для оптимизации кода в приложении Flutter, с упором на производительность и читаемость. Докладчик предлагает рефакторинг определенных разделов кода, например, разделение контента, который использует медиа-запрос, на отдельные виджеты, чтобы избежать ненужных перестроек. В видео также демонстрируется процесс извлечения большого фрагмента виджета в отдельный, более читаемый виджет. Хотя эти изменения могут не влиять напрямую на производительность, они могут улучшить организацию кода и упростить разработчикам понимание и редактирование кода. В видео подчеркивается важность поддержания баланса между оптимизацией производительности и читаемостью кода.",
                                // French
                                "Français": "Cette vidéo présente les améliorations potentielles pour l'optimisation du code dans une application Flutter, en mettant l'accent sur les performances et la lisibilité. L'intervenant suggère de refactoriser certaines sections de code, par exemple en séparant le contenu qui utilise la requête multimédia en widgets distincts pour éviter les reconstructions inutiles. La vidéo montre également le processus d'extraction d'un gros morceau de widget dans un widget distinct et plus lisible. Bien que ces modifications n'aient pas d'impact direct sur les performances, elles peuvent améliorer l'organisation du code et permettre aux développeurs de comprendre et de modifier plus facilement le code. La vidéo souligne l'importance de maintenir un équilibre entre l'optimisation des performances et la lisibilité du code.",
                                // Japanese
                                "日本語": "このビデオでは、パフォーマンスと読みやすさに焦点を当てて、Flutter アプリケーションでのコード最適化の潜在的な改善点について説明します。講演者は、メディア クエリを使用するコンテンツを別のウィジェットに分離して不要な再構築を回避するなど、コードの特定のセクションをリファクタリングすることを提案しています。また、このビデオでは、大きなウィジェット チャンクを別の読みやすいウィジェットに抽出するプロセスも示しています。これらの変更はパフォーマンスに直接影響しないかもしれませんが、コードの構成を強化し、開発者がコードを理解し、編集しやすくなります。このビデオでは、パフォーマンスの最適化とコードの読みやすさのバランスを維持することの重要性を強調しています。",
                                // Korean
                                "한국인": "이 영상은 성능과 가독성에 초점을 맞춘 Flutter 애플리케이션의 코드 최적화를 위한 잠재적인 개선 사항을 논의합니다. 발표자는 불필요한 재구축을 피하기 위해 미디어 쿼리를 활용하는 콘텐츠를 별도의 위젯으로 분리하는 것과 같이 특정 코드 섹션을 리팩토링할 것을 제안합니다. 또한 이 영상은 큰 위젯 청크를 별도의 더 읽기 쉬운 위젯으로 추출하는 프로세스를 보여줍니다. 이러한 변경 사항이 성능에 직접적인 영향을 미치지는 않지만 코드 구성을 개선하고 개발자가 코드를 이해하고 편집하기 쉽게 만들 수 있습니다. 이 영상은 성능 최적화와 코드 가독성 간의 균형을 유지하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video se analizan posibles mejoras para la optimización del código en una aplicación Flutter, centrándose en el rendimiento y la legibilidad. El orador sugiere refactorizar ciertas secciones del código, como separar el contenido que utiliza la consulta de medios en widgets separados para evitar reconstrucciones innecesarias. El video también demuestra el proceso de extracción de un fragmento grande de widget en un widget separado y más legible. Si bien estos cambios pueden no afectar directamente el rendimiento, pueden mejorar la organización del código y facilitar que los desarrolladores comprendan y editen el código. El video enfatiza la importancia de mantener un equilibrio entre la optimización del rendimiento y la legibilidad del código.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर एप्लिकेशन में कोड ऑप्टिमाइज़ेशन के लिए संभावित सुधारों पर चर्चा करता है, जो प्रदर्शन और पठनीयता पर ध्यान केंद्रित करता है। वक्ता कोड के कुछ हिस्सों को फिर से बनाने का सुझाव देता है, जैसे कि मीडिया क्वेरी का उपयोग करने वाली सामग्री को अलग-अलग विजेट में अलग करना ताकि अनावश्यक पुनर्निर्माण से बचा जा सके। वीडियो एक बड़े विजेट खंड को एक अलग, अधिक पठनीय विजेट में निकालने की प्रक्रिया को भी प्रदर्शित करता है। हालांकि ये परिवर्तन सीधे प्रदर्शन को प्रभावित नहीं कर सकते हैं, वे कोड संगठन को बढ़ा सकते हैं और डेवलपर्स के लिए कोड को समझना और संपादित करना आसान बना सकते हैं। वीडियो प्रदर्शन अनुकूलन और कोड पठनीयता के बीच संतुलन बनाए रखने के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "Este vídeo discute possíveis melhorias para a otimização de código numa aplicação Flutter, com foco no desempenho e na legibilidade. O orador sugere refatorar certas secções do código, como separar o conteúdo que utiliza a media query em widgets separados para evitar reconstruções desnecessárias. O vídeo também demonstra o processo de extração de um grande pedaço de widget num widget separado e mais legível. Embora estas alterações possam não ter impacto direto no desempenho, podem melhorar a organização do código e facilitar a compreensão e edição do código por parte dos programadores. O vídeo enfatiza a importância de manter um equilíbrio entre a otimização do desempenho e a legibilidade do código.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি কর্মক্ষমতা এবং পঠনযোগ্যতার উপর ফোকাস করে, একটি ফ্লাটার অ্যাপ্লিকেশনে কোড অপ্টিমাইজেশনের সম্ভাব্য উন্নতি নিয়ে আলোচনা করে। অপ্রয়োজনীয় পুনর্নির্মাণ এড়াতে স্পিকার কোডের নির্দিষ্ট বিভাগগুলিকে রিফ্যাক্টর করার পরামর্শ দেন, যেমন বিষয়বস্তু আলাদা করা যা মিডিয়া ক্যোয়ারীকে আলাদা উইজেটে ব্যবহার করে। ভিডিওটি একটি পৃথক, আরও পঠনযোগ্য উইজেটে একটি বড় উইজেট খণ্ড বের করার প্রক্রিয়াও প্রদর্শন করে। যদিও এই পরিবর্তনগুলি কার্যক্ষমতাকে সরাসরি প্রভাবিত করতে পারে না, তারা কোড সংগঠনকে উন্নত করতে পারে এবং বিকাশকারীদের জন্য কোড বোঝা এবং সম্পাদনা করা সহজ করে তুলতে পারে। ভিডিওটি পারফরম্যান্স অপ্টিমাইজেশান এবং কোড পঠনযোগ্যতার মধ্যে ভারসাম্য বজায় রাখার গুরুত্বের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يناقش هذا الفيديو التحسينات المحتملة لتحسين الكود في تطبيق Flutter، مع التركيز على الأداء وسهولة القراءة. يقترح المتحدث إعادة هيكلة أقسام معينة من الكود، مثل فصل المحتوى الذي يستخدم استعلام الوسائط إلى عناصر واجهة مستخدم منفصلة لتجنب عمليات إعادة البناء غير الضرورية. يوضح الفيديو أيضًا عملية استخراج جزء كبير من عناصر واجهة المستخدم إلى عنصر واجهة مستخدم منفصل أكثر قابلية للقراءة. في حين أن هذه التغييرات قد لا تؤثر بشكل مباشر على الأداء، إلا أنها يمكن أن تعزز تنظيم الكود وتسهل على المطورين فهم الكود وتحريره. يؤكد الفيديو على أهمية الحفاظ على التوازن بين تحسين الأداء وسهولة قراءة الكود.",
                                // Persian
                                "فارسی": "این ویدیو به بهبودهای بالقوه برای بهینه سازی کد در یک برنامه Flutter با تمرکز بر عملکرد و خوانایی می پردازد. سخنران پیشنهاد می‌کند که بخش‌های خاصی از کد را مجدداً تنظیم کنید، مانند جدا کردن محتوایی که از جستجوی رسانه در ویجت‌های جداگانه استفاده می‌کند تا از بازسازی‌های غیرضروری جلوگیری شود. این ویدئو همچنین روند استخراج یک قطعه بزرگ ویجت را به یک ویجت جداگانه و خواناتر نشان می دهد. اگرچه این تغییرات ممکن است مستقیماً بر عملکرد تأثیر نگذارند، اما می‌توانند سازماندهی کد را بهبود بخشند و درک و ویرایش کد را برای توسعه‌دهندگان آسان‌تر کنند. این ویدئو بر اهمیت حفظ تعادل بین بهینه سازی عملکرد و خوانایی کد تاکید می کند.",
                            },
                        },
                        // 130 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Using Builder Methods",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video demonstrates the use of builder methods in the Flutter main.dart file to improve code readability by organizing the widget tree more effectively. By creating separate methods for different parts of the widget tree based on specific conditions like landscape or portrait mode, the code becomes easier to grasp. The video explains how to use the spread operator in Dart to flatten lists of widgets and return them as single widgets, aiding in simplifying the code structure and making it more understandable. The focus is on enhancing code organization and readability rather than reducing code length or improving performance.",
                                // German
                                "Deutsch": "Dieses Video zeigt die Verwendung von Builder-Methoden in der Flutter-Datei main.dart, um die Lesbarkeit des Codes durch eine effektivere Organisation des Widget-Baums zu verbessern. Durch die Erstellung separater Methoden für verschiedene Teile des Widget-Baums basierend auf bestimmten Bedingungen wie Quer- oder Hochformat wird der Code leichter verständlich. Das Video erklärt, wie man den Spread-Operator in Dart verwendet, um Widget-Listen zu reduzieren und sie als einzelne Widgets zurückzugeben, was zur Vereinfachung der Codestruktur beiträgt und sie verständlicher macht. Der Schwerpunkt liegt auf der Verbesserung der Code-Organisation und Lesbarkeit und nicht auf der Reduzierung der Codelänge oder der Verbesserung der Leistung.",
                                // Chinese
                                "中国人": "本视频演示了如何使用 Flutter main.dart 文件中的构建器方法更有效地组织 widget 树，从而提高代码的可读性。通过根据特定条件（例如横向或纵向模式）为 widget 树的不同部分创建单独的方法，代码变得更容易掌握。本视频解释了如何使用 Dart 中的展开运算符展平 widget 列表并将它们作为单个 widget 返回，从而简化代码结构并使其更易于理解。重点在于增强代码组织和可读性，而不是减少代码长度或提高性能。",
                                // Russian
                                "Русский": "В этом видео показано использование методов конструктора в файле Flutter main.dart для улучшения читаемости кода путем более эффективной организации дерева виджетов. Создавая отдельные методы для разных частей дерева виджетов на основе определенных условий, таких как альбомная или портретная ориентация, код становится более понятным. В видео объясняется, как использовать оператор расширения в Dart для выравнивания списков виджетов и возврата их в виде отдельных виджетов, что помогает упростить структуру кода и сделать ее более понятной. Основное внимание уделяется улучшению организации и читаемости кода, а не сокращению длины кода или повышению производительности.",
                                // French
                                "Français": "Cette vidéo montre l'utilisation des méthodes de création dans le fichier main.dart de Flutter pour améliorer la lisibilité du code en organisant l'arborescence des widgets plus efficacement. En créant des méthodes distinctes pour différentes parties de l'arborescence des widgets en fonction de conditions spécifiques telles que le mode paysage ou portrait, le code devient plus facile à comprendre. La vidéo explique comment utiliser l'opérateur de propagation dans Dart pour aplatir des listes de widgets et les renvoyer sous forme de widgets uniques, ce qui permet de simplifier la structure du code et de la rendre plus compréhensible. L'accent est mis sur l'amélioration de l'organisation et de la lisibilité du code plutôt que sur la réduction de la longueur du code ou l'amélioration des performances.",
                                // Japanese
                                "日本語": "Este video demuestra el uso de métodos de creación en el archivo main.dart de Flutter para mejorar la legibilidad del código mediante la organización del árbol de widgets de manera más eficaz. Al crear métodos separados para diferentes partes del árbol de widgets en función de condiciones específicas, como el modo horizontal o vertical, el código se vuelve más fácil de comprender. El video explica cómo usar el operador de propagación en Dart para aplanar listas de widgets y devolverlas como widgets individuales, lo que ayuda a simplificar la estructura del código y hacerlo más comprensible. El objetivo es mejorar la organización y la legibilidad del código en lugar de reducir la longitud del código o mejorar el rendimiento.",
                                // Korean
                                "한국인": "이 비디오는 위젯 트리를 보다 효과적으로 구성하여 코드 가독성을 개선하기 위해 Flutter main.dart 파일에서 빌더 메서드를 사용하는 방법을 보여줍니다. 가로 모드 또는 세로 모드와 같은 특정 조건에 따라 위젯 트리의 다른 부분에 대해 별도의 메서드를 만들면 코드를 이해하기가 더 쉬워집니다. 이 비디오는 Dart에서 스프레드 연산자를 사용하여 위젯 목록을 평면화하고 단일 위젯으로 반환하는 방법을 설명하여 코드 구조를 단순화하고 이해하기 쉽게 만듭니다. 코드 길이를 줄이거나 성능을 개선하는 것보다 코드 구성과 가독성을 향상시키는 데 중점을 둡니다.",
                                // Spanish
                                "Español": "Este video demuestra el uso de métodos de creación en el archivo main.dart de Flutter para mejorar la legibilidad del código mediante la organización del árbol de widgets de manera más eficaz. Al crear métodos separados para diferentes partes del árbol de widgets en función de condiciones específicas, como el modo horizontal o vertical, el código se vuelve más fácil de comprender. El video explica cómo usar el operador de propagación en Dart para aplanar listas de widgets y devolverlas como widgets individuales, lo que ayuda a simplificar la estructura del código y hacerlo más comprensible. El objetivo es mejorar la organización y la legibilidad del código en lugar de reducir la longitud del código o mejorar el rendimiento.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर main.dart फ़ाइल में बिल्डर विधियों के उपयोग को प्रदर्शित करता है, ताकि विजेट ट्री को अधिक प्रभावी ढंग से व्यवस्थित करके कोड पठनीयता में सुधार किया जा सके। लैंडस्केप या पोर्ट्रेट मोड जैसी विशिष्ट स्थितियों के आधार पर विजेट ट्री के विभिन्न भागों के लिए अलग-अलग विधियाँ बनाकर, कोड को समझना आसान हो जाता है। वीडियो बताता है कि विजेट की सूचियों को समतल करने और उन्हें एकल विजेट के रूप में वापस करने के लिए डार्ट में स्प्रेड ऑपरेटर का उपयोग कैसे करें, जिससे कोड संरचना को सरल बनाने और इसे अधिक समझने योग्य बनाने में सहायता मिलती है। कोड की लंबाई कम करने या प्रदर्शन में सुधार करने के बजाय कोड संगठन और पठनीयता को बढ़ाने पर ध्यान केंद्रित किया जाता है।",
                                // Portuguese
                                "Português": "Este vídeo demonstra a utilização de métodos construtores no ficheiro main.dart do Flutter para melhorar a legibilidade do código, organizando a árvore de widgets de forma mais eficaz. Ao criar métodos separados para diferentes partes da árvore de widgets com base em condições específicas, como o modo paisagem ou retrato, o código torna-se mais fácil de compreender. O vídeo explica como utilizar o operador spread no Dart para nivelar listas de widgets e devolvê-los como widgets únicos, ajudando a simplificar a estrutura do código e a torná-lo mais compreensível. O foco está em melhorar a organização e a legibilidade do código, em vez de reduzir o comprimento do código ou melhorar o desempenho.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি আরও কার্যকরভাবে উইজেট ট্রি সংগঠিত করার মাধ্যমে কোড পাঠযোগ্যতা উন্নত করতে Flutter main.dart ফাইলে নির্মাতা পদ্ধতির ব্যবহার প্রদর্শন করে। ল্যান্ডস্কেপ বা পোর্ট্রেট মোডের মতো নির্দিষ্ট অবস্থার উপর ভিত্তি করে উইজেট গাছের বিভিন্ন অংশের জন্য পৃথক পদ্ধতি তৈরি করে, কোডটি উপলব্ধি করা সহজ হয়ে যায়। ভিডিওটি ব্যাখ্যা করে যে কীভাবে ডার্টে স্প্রেড অপারেটর ব্যবহার করে উইজেটের তালিকা সমতল করতে হয় এবং সেগুলিকে একক উইজেট হিসাবে ফেরত দিতে হয়, কোড গঠনকে সরল করতে এবং এটিকে আরও বোধগম্য করতে সহায়তা করে। কোডের দৈর্ঘ্য কমানো বা কর্মক্ষমতা উন্নত করার পরিবর্তে কোড সংগঠন এবং পঠনযোগ্যতা বাড়ানোর উপর ফোকাস করা হয়।",
                                // Arabic
                                "عَرَبِيّ": "يوضح هذا الفيديو استخدام طرق البناء في ملف main.dart في Flutter لتحسين قابلية قراءة الكود من خلال تنظيم شجرة الأدوات بشكل أكثر فعالية. من خلال إنشاء طرق منفصلة لأجزاء مختلفة من شجرة الأدوات بناءً على شروط معينة مثل الوضع الأفقي أو الرأسي، يصبح الكود أسهل في الفهم. يشرح الفيديو كيفية استخدام عامل الانتشار في Dart لتسطيح قوائم الأدوات وإعادتها كأدوات مفردة، مما يساعد في تبسيط بنية الكود وجعلها أكثر قابلية للفهم. ينصب التركيز على تحسين تنظيم الكود وقابليته للقراءة بدلاً من تقليل طول الكود أو تحسين الأداء.",
                                // Persian
                                "فارسی": "این ویدیو استفاده از روش های سازنده در فایل Flutter main.dart را برای بهبود خوانایی کد با سازماندهی موثرتر درخت ویجت نشان می دهد. با ایجاد روش های جداگانه برای بخش های مختلف درخت ویجت بر اساس شرایط خاص مانند حالت افقی یا عمودی، درک کد آسان تر می شود. این ویدئو نحوه استفاده از عملگر spread در دارت را برای مسطح کردن لیست ویجت ها و برگرداندن آنها به عنوان ابزارک تک توضیح می دهد و به ساده سازی ساختار کد و قابل فهم تر کردن آن کمک می کند. تمرکز بر افزایش سازماندهی و خوانایی کد به جای کاهش طول کد یا بهبود عملکرد است.",
                            },
                        },
                        // 131 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Understanding the Widget Lifecycle",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "This video delves into the lifecycle of widgets in Flutter, discussing the different methods like initState, didUpdateWidget, and dispose, which can be added to state objects to perform specific actions at various stages of the widget's lifecycle. The video provides examples and explanations on when and how to utilize these methods, such as using initState for initial data fetching, didUpdateWidget for dynamic data updates, and dispose for cleaning up connections or listeners that are no longer needed. The demonstration in the provided example showcases the lifecycle of a widget within a modal bottom sheet, illustrating how these methods are executed during widget creation, update, and removal processes. The video emphasizes the significance of understanding and utilizing these widget lifecycle methods for effective and efficient code management.",
                                // German
                                "Deutsch": "Dieses Video befasst sich mit dem Lebenszyklus von Widgets in Flutter und bespricht die verschiedenen Methoden wie initState, didUpdateWidget und dispose, die zu Statusobjekten hinzugefügt werden können, um in verschiedenen Phasen des Lebenszyklus des Widgets bestimmte Aktionen auszuführen. Das Video bietet Beispiele und Erklärungen dazu, wann und wie diese Methoden verwendet werden, z. B. die Verwendung von initState zum anfänglichen Abrufen von Daten, didUpdateWidget für dynamische Datenaktualisierungen und dispose zum Bereinigen von Verbindungen oder Listenern, die nicht mehr benötigt werden. Die Demonstration im bereitgestellten Beispiel zeigt den Lebenszyklus eines Widgets innerhalb eines modalen unteren Blatts und veranschaulicht, wie diese Methoden während der Prozesse zum Erstellen, Aktualisieren und Entfernen von Widgets ausgeführt werden. Das Video betont, wie wichtig es ist, diese Methoden des Widget-Lebenszyklus für eine effektive und effiziente Codeverwaltung zu verstehen und zu verwenden.",
                                // Chinese
                                "中国人": "本视频深入探讨了 Flutter 中小部件的生命周期，讨论了 initState、didUpdateWidget 和 dispose 等不同方法，这些方法可以添加到状态对象中，以在小部件生命周期的各个阶段执行特定操作。视频提供了有关何时以及如何使用这些方法的示例和说明，例如使用 initState 进行初始数据提取、使用 didUpdateWidget 进行动态数据更新以及使用 dispose 清理不再需要的连接或侦听器。所提供示例中的演示展示了模态底部表单中小部件的生命周期，说明了在小部件创建、更新和删除过程中如何执行这些方法。视频强调了理解和利用这些小部件生命周期方法对于有效和高效的代码管理的重要性。",
                                // Russian
                                "Русский": "В этом видео рассматривается жизненный цикл виджетов во Flutter, обсуждаются различные методы, такие как initState, didUpdateWidget и dispose, которые можно добавлять к объектам состояния для выполнения определенных действий на различных этапах жизненного цикла виджета. В видео приводятся примеры и пояснения того, когда и как использовать эти методы, например, использование initState для первоначальной выборки данных, didUpdateWidget для динамических обновлений данных и dispose для очистки соединений или слушателей, которые больше не нужны. Демонстрация в представленном примере демонстрирует жизненный цикл виджета в модальном нижнем листе, иллюстрируя, как эти методы выполняются во время процессов создания, обновления и удаления виджета. В видео подчеркивается важность понимания и использования этих методов жизненного цикла виджета для эффективного и действенного управления кодом.",
                                // French
                                "Français": "Cette vidéo aborde le cycle de vie des widgets dans Flutter, en abordant les différentes méthodes telles que initState, didUpdateWidget et dispose, qui peuvent être ajoutées aux objets d'état pour effectuer des actions spécifiques à différentes étapes du cycle de vie du widget. La vidéo fournit des exemples et des explications sur le moment et la manière d'utiliser ces méthodes, comme l'utilisation de initState pour la récupération initiale des données, didUpdateWidget pour les mises à jour dynamiques des données et dispose pour nettoyer les connexions ou les écouteurs qui ne sont plus nécessaires. La démonstration de l'exemple fourni présente le cycle de vie d'un widget dans une feuille inférieure modale, illustrant comment ces méthodes sont exécutées pendant les processus de création, de mise à jour et de suppression de widgets. La vidéo souligne l'importance de comprendre et d'utiliser ces méthodes de cycle de vie des widgets pour une gestion de code efficace et efficiente.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter のウィジェットのライフサイクルについて詳しく説明し、initState、didUpdateWidget、dispose などのさまざまなメソッドについて説明します。これらのメソッドは、ウィジェットのライフサイクルのさまざまな段階で特定のアクションを実行するために状態オブジェクトに追加できます。ビデオでは、初期データ取得には initState、動的データ更新には didUpdateWidget、不要になった接続やリスナーをクリーンアップするには dispose を使用するなど、これらのメソッドをいつどのように使用するかについて例と説明を提供します。提供されている例のデモでは、モーダル ボトム シート内のウィジェットのライフサイクルを示し、ウィジェットの作成、更新、削除のプロセス中にこれらのメソッドがどのように実行されるかを示します。ビデオでは、効果的で効率的なコード管理のためにこれらのウィジェット ライフサイクル メソッドを理解して使用することの重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오는 Flutter에서 위젯의 수명 주기를 탐구하며 initState, didUpdateWidget, dispose와 같은 다양한 메서드에 대해 논의합니다. 이러한 메서드는 위젯 수명 주기의 다양한 단계에서 특정 작업을 수행하기 위해 상태 객체에 추가할 수 있습니다. 이 비디오는 초기 데이터 페칭을 위한 initState, 동적 데이터 업데이트에 didUpdateWidget, 더 이상 필요 없는 연결이나 리스너를 정리하기 위한 dispose와 같이 이러한 메서드를 언제 어떻게 사용할지에 대한 예와 설명을 제공합니다. 제공된 예제의 데모는 모달 바텀 시트 내에서 위젯의 수명 주기를 보여주며 이러한 메서드가 위젯 생성, 업데이트 및 제거 프로세스 중에 어떻게 실행되는지 보여줍니다. 이 비디오는 효과적이고 효율적인 코드 관리를 위해 이러한 위젯 수명 주기 메서드를 이해하고 활용하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "Este video profundiza en el ciclo de vida de los widgets en Flutter y analiza los diferentes métodos como initState, didUpdateWidget y dispose, que se pueden agregar a los objetos de estado para realizar acciones específicas en varias etapas del ciclo de vida del widget. El video proporciona ejemplos y explicaciones sobre cuándo y cómo utilizar estos métodos, como usar initState para la obtención de datos iniciales, didUpdateWidget para actualizaciones de datos dinámicas y dispose para limpiar conexiones o escuchas que ya no son necesarios. La demostración en el ejemplo proporcionado muestra el ciclo de vida de un widget dentro de una hoja inferior modal, que ilustra cómo se ejecutan estos métodos durante los procesos de creación, actualización y eliminación de widgets. El video enfatiza la importancia de comprender y utilizar estos métodos del ciclo de vida de los widgets para una gestión de código eficaz y eficiente.",
                                // Hindi
                                "हिंदी": "यह वीडियो फ़्लटर में विजेट के जीवनचक्र पर विस्तार से चर्चा करता है, जिसमें initState, didUpdateWidget और डिस्पोज़ जैसे विभिन्न तरीकों पर चर्चा की गई है, जिन्हें विजेट के जीवनचक्र के विभिन्न चरणों में विशिष्ट क्रियाएँ करने के लिए स्टेट ऑब्जेक्ट में जोड़ा जा सकता है। वीडियो इन तरीकों का उपयोग कब और कैसे करना है, इस पर उदाहरण और स्पष्टीकरण प्रदान करता है, जैसे कि प्रारंभिक डेटा फ़ेचिंग के लिए initState का उपयोग करना, गतिशील डेटा अपडेट के लिए didUpdateWidget का उपयोग करना और उन कनेक्शन या श्रोताओं को साफ़ करने के लिए डिस्पोज़ करना जिनकी अब आवश्यकता नहीं है। दिए गए उदाहरण में प्रदर्शन एक मॉडल बॉटम शीट के भीतर एक विजेट के जीवनचक्र को प्रदर्शित करता है, यह दर्शाता है कि विजेट निर्माण, अपडेट और हटाने की प्रक्रियाओं के दौरान इन तरीकों को कैसे निष्पादित किया जाता है। वीडियो प्रभावी और कुशल कोड प्रबंधन के लिए इन विजेट जीवनचक्र विधियों को समझने और उनका उपयोग करने के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "Este vídeo investiga o ciclo de vida dos widgets no Flutter, discutindo os diferentes métodos como initState, didUpdateWidget e descarte, que podem ser adicionados aos objetos de estado para executar ações específicas em várias fases do ciclo de vida do widget. O vídeo fornece exemplos e explicações sobre quando e como utilizar estes métodos, como utilizar o initState para a pesquisa inicial de dados, o didUpdateWidget para atualizações dinâmicas de dados e o descarte para limpar ligações ou listeners que já não são necessários. A demonstração no exemplo fornecido mostra o ciclo de vida de um widget dentro de uma folha de cálculo inferior modal, ilustrando como estes métodos são executados durante os processos de criação, atualização e remoção de widgets. O vídeo enfatiza a importância de compreender e utilizar estes métodos de ciclo de vida de widgets para uma gestão de código eficaz e eficiente.",
                                // Bengali
                                "বাংলা": "এই ভিডিওটি ফ্লটার-এ উইজেটগুলির জীবনচক্র সম্পর্কে বিস্তারিত আলোচনা করে, initState, didUpdateWidget এবং নিষ্পত্তি করার মতো বিভিন্ন পদ্ধতি নিয়ে আলোচনা করে, যা উইজেটের জীবনচক্রের বিভিন্ন পর্যায়ে নির্দিষ্ট ক্রিয়া সম্পাদনের জন্য রাষ্ট্রীয় বস্তুতে যোগ করা যেতে পারে। ভিডিওটি এই পদ্ধতিগুলি কখন এবং কীভাবে ব্যবহার করতে হয় তার উদাহরণ এবং ব্যাখ্যা প্রদান করে, যেমন প্রাথমিক ডেটা আনার জন্য initState ব্যবহার করা, ডাইনামিক ডেটা আপডেটের জন্য didUpdateWidget ব্যবহার করা এবং সংযোগগুলি বা শ্রোতাদের আর প্রয়োজন নেই পরিষ্কার করার জন্য নিষ্পত্তি করা৷ প্রদত্ত উদাহরণে প্রদর্শনটি একটি মডেল নীচের শীটের মধ্যে একটি উইজেটের জীবনচক্র প্রদর্শন করে, উইজেট তৈরি, আপডেট এবং অপসারণ প্রক্রিয়ার সময় এই পদ্ধতিগুলি কীভাবে কার্যকর করা হয় তা চিত্রিত করে। ভিডিওটি কার্যকর এবং দক্ষ কোড পরিচালনার জন্য এই উইজেট লাইফসাইকেল পদ্ধতিগুলি বোঝার এবং ব্যবহার করার তাত্পর্যের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "يتعمق هذا الفيديو في دورة حياة عناصر واجهة المستخدم في Flutter، ويناقش الطرق المختلفة مثل initState وdidUpdateWidget وdispose، والتي يمكن إضافتها إلى كائنات الحالة لأداء إجراءات محددة في مراحل مختلفة من دورة حياة عنصر واجهة المستخدم. يوفر الفيديو أمثلة وتفسيرات حول متى وكيف يمكن استخدام هذه الطرق، مثل استخدام initState لجلب البيانات الأولية، وdidUpdateWidget لتحديثات البيانات الديناميكية، وdispose لتنظيف الاتصالات أو المستمعين الذين لم تعد هناك حاجة إليهم. يعرض العرض التوضيحي في المثال المقدم دورة حياة عنصر واجهة مستخدم داخل ورقة سفلية نموذجية، موضحًا كيفية تنفيذ هذه الطرق أثناء عمليات إنشاء عنصر واجهة المستخدم وتحديثه وإزالته. يؤكد الفيديو على أهمية فهم واستخدام طرق دورة حياة عنصر واجهة المستخدم هذه لإدارة الكود بفعالية وكفاءة.",
                                // Persian
                                "فارسی": "این ویدیو به بررسی چرخه حیات ویجت‌ها در Flutter می‌پردازد و روش‌های مختلفی مانند initState، didUpdateWidget و dispose را مورد بحث قرار می‌دهد که می‌توانند به اشیاء حالت اضافه شوند تا اقدامات خاصی را در مراحل مختلف چرخه عمر ویجت انجام دهند. این ویدیو مثال‌ها و توضیحاتی را در مورد زمان و نحوه استفاده از این روش‌ها ارائه می‌دهد، مانند استفاده از initState برای واکشی اولیه داده، didUpdateWidget برای به‌روزرسانی‌های پویا داده‌ها، و از بین بردن برای تمیز کردن اتصالات یا شنوندگانی که دیگر مورد نیاز نیستند. نمایش در مثال ارائه شده چرخه حیات یک ویجت را در یک صفحه پایینی مدال نشان می‌دهد، و نشان می‌دهد که چگونه این روش‌ها در طول فرآیندهای ایجاد، به‌روزرسانی و حذف ویجت اجرا می‌شوند. این ویدیو بر اهمیت درک و استفاده از این روش‌های چرخه عمر ویجت برای مدیریت مؤثر و کارآمد کد تأکید می‌کند.",
                            },
                        },
                        // 132 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Understanding the App Lifecycle",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video discusses the lifecycle of an app, including different states such as inactive, paused, and resumed. It explains how to listen to app lifecycle events using WidgetsBindingObserver and demonstrates how to add a listener for app lifecycle changes in the main.dart file. The video also shows how different lifecycle states are triggered when the app is put into the background or removed from memory, emphasizing the importance of clearing listeners to avoid memory leaks. Additionally, it highlights the use of mix-ins to add features from multiple classes in Flutter.",
                                // German
                                "Deutsch": "Das Video erläutert den Lebenszyklus einer App, einschließlich verschiedener Zustände wie inaktiv, angehalten und fortgesetzt. Es erklärt, wie man mit WidgetsBindingObserver auf App-Lebenszyklusereignisse hört, und demonstriert, wie man in der Datei main.dart einen Listener für App-Lebenszyklusänderungen hinzufügt. Das Video zeigt auch, wie verschiedene Lebenszykluszustände ausgelöst werden, wenn die App in den Hintergrund gestellt oder aus dem Speicher entfernt wird, und betont, wie wichtig es ist, Listener zu löschen, um Speicherlecks zu vermeiden. Darüber hinaus wird die Verwendung von Mix-Ins hervorgehoben, um Funktionen aus mehreren Klassen in Flutter hinzuzufügen.",
                                // Chinese
                                "中国人": "该视频讨论了应用的生命周期，包括非活动、暂停和恢复等不同状态。它解释了如何使用 WidgetsBindingObserver 监听应用生命周期事件，并演示了如何在 main.dart 文件中添加应用生命周期更改的监听器。该视频还展示了当应用进入后台或从内存中移除时如何触发不同的生命周期状态，强调了清除监听器以避免内存泄漏的重要性。此外，它还强调了如何使用 mix-ins 从 Flutter 中的多个类中添加功能。",
                                // Russian
                                "Русский": "В видео обсуждается жизненный цикл приложения, включая различные состояния, такие как неактивное, приостановленное и возобновленное. В нем объясняется, как прослушивать события жизненного цикла приложения с помощью WidgetsBindingObserver, и демонстрируется, как добавить прослушиватель для изменений жизненного цикла приложения в файле main.dart. В видео также показано, как запускаются различные состояния жизненного цикла, когда приложение переводится в фоновый режим или удаляется из памяти, подчеркивая важность очистки прослушивателей для предотвращения утечек памяти. Кроме того, в нем подчеркивается использование микс-модулей для добавления функций из нескольких классов во Flutter.",
                                // French
                                "Français": "La vidéo décrit le cycle de vie d'une application, notamment les différents états tels qu'inactif, en pause et repris. Elle explique comment écouter les événements du cycle de vie d'une application à l'aide de WidgetsBindingObserver et montre comment ajouter un écouteur pour les modifications du cycle de vie de l'application dans le fichier main.dart. La vidéo montre également comment différents états du cycle de vie sont déclenchés lorsque l'application est mise en arrière-plan ou supprimée de la mémoire, soulignant l'importance de supprimer les écouteurs pour éviter les fuites de mémoire. En outre, elle met en évidence l'utilisation de mix-ins pour ajouter des fonctionnalités de plusieurs classes dans Flutter.",
                                // Japanese
                                "日本語": "この動画では、非アクティブ、一時停止、再開などのさまざまな状態を含むアプリのライフサイクルについて説明します。WidgetsBindingObserver を使用してアプリのライフサイクル イベントをリッスンする方法を説明し、main.dart ファイルにアプリのライフサイクルの変更のリスナーを追加する方法を示します。また、この動画では、アプリがバックグラウンドになったりメモリから削除されたりしたときにさまざまなライフサイクル状態がどのようにトリガーされるかを示し、メモリ リークを回避するためにリスナーをクリアすることの重要性を強調しています。さらに、Flutter の複数のクラスから機能を追加するためのミックスインの使用についても説明します。",
                                // Korean
                                "한국인": "이 비디오에서는 비활성, 일시 중지, 재개와 같은 다양한 상태를 포함하여 앱의 수명 주기를 설명합니다. WidgetsBindingObserver를 사용하여 앱 수명 주기 이벤트를 수신하는 방법을 설명하고 main.dart 파일에 앱 수명 주기 변경 사항에 대한 리스너를 추가하는 방법을 보여줍니다. 또한 이 비디오에서는 앱이 백그라운드로 이동하거나 메모리에서 제거될 때 다양한 수명 주기 상태가 트리거되는 방식을 보여주며 메모리 누수를 방지하기 위해 리스너를 지우는 것의 중요성을 강조합니다. 또한 Flutter에서 여러 클래스의 기능을 추가하기 위해 믹스인을 사용하는 방법을 강조합니다.",
                                // Spanish
                                "Español": "En el video se analiza el ciclo de vida de una aplicación, incluidos los diferentes estados, como inactivo, en pausa y reanudado. Se explica cómo escuchar los eventos del ciclo de vida de la aplicación mediante WidgetsBindingObserver y se demuestra cómo agregar un detector para los cambios del ciclo de vida de la aplicación en el archivo main.dart. El video también muestra cómo se activan los diferentes estados del ciclo de vida cuando la aplicación se pone en segundo plano o se elimina de la memoria, y se enfatiza la importancia de borrar los detectores para evitar fugas de memoria. Además, se destaca el uso de combinaciones para agregar funciones de varias clases en Flutter.",
                                // Hindi
                                "हिंदी": "वीडियो में ऐप के जीवनचक्र पर चर्चा की गई है, जिसमें निष्क्रिय, रुका हुआ और फिर से शुरू होने जैसी विभिन्न स्थितियाँ शामिल हैं। यह बताता है कि WidgetsBindingObserver का उपयोग करके ऐप जीवनचक्र की घटनाओं को कैसे सुनना है और यह दर्शाता है कि main.dart फ़ाइल में ऐप जीवनचक्र परिवर्तनों के लिए श्रोता कैसे जोड़ा जाए। वीडियो यह भी दिखाता है कि ऐप को बैकग्राउंड में रखने या मेमोरी से हटाने पर अलग-अलग जीवनचक्र स्थितियाँ कैसे ट्रिगर होती हैं, मेमोरी लीक से बचने के लिए श्रोताओं को साफ़ करने के महत्व पर ज़ोर दिया गया है। इसके अतिरिक्त, यह फ़्लटर में कई क्लास से सुविधाएँ जोड़ने के लिए मिक्स-इन के उपयोग पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "O vídeo discute o ciclo de vida de uma aplicação, incluindo diferentes estados, como inativo, pausado e retomado. Explica como ouvir eventos do ciclo de vida da aplicação utilizando o WidgetsBindingObserver e demonstra como adicionar um listener para alterações no ciclo de vida da aplicação no ficheiro main.dart. O vídeo mostra também como os diferentes estados do ciclo de vida são acionados quando a aplicação é colocada em segundo plano ou removida da memória, enfatizando a importância de limpar os ouvintes para evitar fugas de memória. Além disso, destaca a utilização de mix-ins para adicionar recursos de várias classes no Flutter.",
                                // Bengali
                                "বাংলা": "ভিডিওটি একটি অ্যাপের জীবনচক্র নিয়ে আলোচনা করে, যার মধ্যে বিভিন্ন অবস্থা যেমন নিষ্ক্রিয়, বিরতি দেওয়া এবং পুনরায় চালু করা হয়েছে। এটি ব্যাখ্যা করে কিভাবে WidgetsBindingObserver ব্যবহার করে অ্যাপের লাইফসাইকেল ইভেন্টগুলি শুনতে হয় এবং মেইন.dart ফাইলে অ্যাপ লাইফসাইকেল পরিবর্তনের জন্য কীভাবে একজন শ্রোতা যোগ করতে হয় তা প্রদর্শন করে। ভিডিওটি আরও দেখায় যে অ্যাপটিকে ব্যাকগ্রাউন্ডে রাখা হলে বা মেমরি থেকে সরানো হলে কীভাবে বিভিন্ন লাইফসাইকেল স্টেট ট্রিগার হয়, মেমরি লিক এড়াতে শ্রোতাদের পরিষ্কার করার গুরুত্বের উপর জোর দেয়। উপরন্তু, এটি ফ্লাটারে একাধিক ক্লাস থেকে বৈশিষ্ট্য যোগ করতে মিক্স-ইন ব্যবহারকে হাইলাইট করে।",
                                // Arabic
                                "عَرَبِيّ": "يناقش الفيديو دورة حياة التطبيق، بما في ذلك الحالات المختلفة مثل غير النشط والمتوقف مؤقتًا والمستأنف. ويشرح كيفية الاستماع إلى أحداث دورة حياة التطبيق باستخدام WidgetsBindingObserver ويوضح كيفية إضافة مستمع لتغييرات دورة حياة التطبيق في ملف main.dart. كما يوضح الفيديو كيف يتم تشغيل حالات مختلفة لدورة الحياة عند وضع التطبيق في الخلفية أو إزالته من الذاكرة، مع التأكيد على أهمية مسح المستمعين لتجنب تسرب الذاكرة. بالإضافة إلى ذلك، يسلط الضوء على استخدام المزيجات لإضافة ميزات من فئات متعددة في Flutter.",
                                // Persian
                                "فارسی": "این ویدئو چرخه عمر یک برنامه را شامل حالات مختلف مانند غیرفعال، توقف موقت و از سرگیری شده مورد بحث قرار می دهد. نحوه گوش دادن به رویدادهای چرخه حیات برنامه با استفاده از WidgetsBindingObserver را توضیح می دهد و نحوه اضافه کردن شنونده برای تغییرات چرخه عمر برنامه در فایل main.dart را نشان می دهد. این ویدئو همچنین نشان می‌دهد که چگونه حالت‌های مختلف چرخه حیات زمانی که برنامه در پس‌زمینه قرار می‌گیرد یا از حافظه حذف می‌شود، فعال می‌شود و بر اهمیت پاک کردن شنوندگان برای جلوگیری از نشت حافظه تأکید می‌کند. علاوه بر این، استفاده از میکس‌های را برای افزودن ویژگی‌های چند کلاس در Flutter برجسته می‌کند.",
                            },
                        },
                        // 134 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Understanding Context",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the concept of context in Flutter is explained, detailing how each widget has its own context that represents its position in the widget tree. The video demonstrates the use of context in methods like showModalBottomSheet and explains how context is essential for efficient communication between widgets in the widget tree. The video also introduces the InheritedWidget feature which allows for easy sharing of data across the widget tree without passing data through constructors. The importance of context in establishing a direct communication channel for data exchange within the widget tree is emphasized, with a preview of how it will be used in state management in future lessons. Overall, the video provides a comprehensive understanding of the role of context in managing data within Flutter applications.",
                                // German
                                "Deutsch": "In diesem Video wird das Kontextkonzept in Flutter erklärt. Dabei wird detailliert erläutert, wie jedes Widget seinen eigenen Kontext hat, der seine Position im Widget-Baum darstellt. Das Video demonstriert die Verwendung von Kontext in Methoden wie showModalBottomSheet und erklärt, wie wichtig Kontext für eine effiziente Kommunikation zwischen Widgets im Widget-Baum ist. Das Video stellt außerdem die Funktion InheritedWidget vor, die eine einfache gemeinsame Nutzung von Daten im Widget-Baum ermöglicht, ohne dass die Daten durch Konstruktoren geleitet werden müssen. Die Bedeutung von Kontext beim Aufbau eines direkten Kommunikationskanals für den Datenaustausch innerhalb des Widget-Baums wird hervorgehoben. Außerdem wird eine Vorschau darauf gegeben, wie er in zukünftigen Lektionen in der Statusverwaltung verwendet wird. Insgesamt bietet das Video ein umfassendes Verständnis der Rolle von Kontext bei der Verwaltung von Daten in Flutter-Anwendungen.",
                                // Chinese
                                "中国人": "本视频解释了 Flutter 中的上下文概念，详细说明了每个小部件如何拥有自己的上下文，该上下文代表了其在小部件树中的位置。视频演示了如何在 showModalBottomSheet 等方法中使用上下文，并解释了上下文对于小部件树中小部件之间的有效通信至关重要。视频还介绍了 InheritedWidget 功能，该功能允许在小部件树之间轻松共享数据，而无需通过构造函数传递数据。视频强调了上下文在小部件树内建立直接数据交换通信渠道方面的重要性，并预览了未来课程中它将如何在状态管理中使用。总体而言，该视频全面介绍了上下文在 Flutter 应用程序内管理数据中的作用。",
                                // Russian
                                "Русский": "В этом видео объясняется концепция контекста во Flutter, подробно описывая, как каждый виджет имеет свой собственный контекст, который представляет его положение в дереве виджетов. Видео демонстрирует использование контекста в таких методах, как showModalBottomSheet, и объясняет, почему контекст необходим для эффективной коммуникации между виджетами в дереве виджетов. Видео также знакомит с функцией InheritedWidget, которая позволяет легко обмениваться данными по дереву виджетов без передачи данных через конструкторы. Подчеркивается важность контекста в установлении прямого канала связи для обмена данными в дереве виджетов, с предварительным просмотром того, как он будет использоваться в управлении состоянием в будущих уроках. В целом, видео дает полное понимание роли контекста в управлении данными в приложениях Flutter.",
                                // French
                                "Français": "Dans cette vidéo, le concept de contexte dans Flutter est expliqué, en détaillant comment chaque widget possède son propre contexte qui représente sa position dans l'arborescence des widgets. La vidéo montre l'utilisation du contexte dans des méthodes comme showModalBottomSheet et explique comment le contexte est essentiel pour une communication efficace entre les widgets dans l'arborescence des widgets. La vidéo présente également la fonctionnalité InheritedWidget qui permet de partager facilement des données dans l'arborescence des widgets sans passer de données par des constructeurs. L'importance du contexte dans l'établissement d'un canal de communication direct pour l'échange de données au sein de l'arborescence des widgets est soulignée, avec un aperçu de la manière dont il sera utilisé dans la gestion des états dans les prochaines leçons. Dans l'ensemble, la vidéo offre une compréhension complète du rôle du contexte dans la gestion des données au sein des applications Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter のコンテキストの概念について説明し、各ウィジェットがウィジェット ツリー内の位置を表す独自のコンテキストを持つ仕組みについて詳しく説明します。ビデオでは、showModalBottomSheet などのメソッドでのコンテキストの使用方法を示し、ウィジェット ツリー内のウィジェット間の効率的な通信にコンテキストが不可欠である理由を説明します。また、コンストラクターを介してデータを渡すことなくウィジェット ツリー全体でデータを簡単に共有できる InheritedWidget 機能も紹介します。ウィジェット ツリー内でデータを交換するための直接通信チャネルを確立する上でのコンテキストの重要性を強調し、今後のレッスンで状態管理でコンテキストがどのように使用されるかをプレビューします。全体として、このビデオでは、Flutter アプリケーション内でのデータ管理におけるコンテキストの役割について包括的に理解できます。",
                                // Korean
                                "한국인": "이 영상에서는 Flutter의 컨텍스트 개념을 설명하며, 각 위젯이 위젯 트리에서 위치를 나타내는 고유한 컨텍스트를 갖는 방식을 자세히 설명합니다. 이 영상은 showModalBottomSheet와 같은 메서드에서 컨텍스트를 사용하는 방법을 보여주고, 위젯 트리에서 위젯 간의 효율적인 통신에 컨텍스트가 필수적인 이유를 설명합니다. 또한 이 영상은 생성자를 통해 데이터를 전달하지 않고도 위젯 트리에서 데이터를 쉽게 공유할 수 있는 InheritedWidget 기능을 소개합니다. 위젯 트리 내에서 데이터 교환을 위한 직접 통신 채널을 설정하는 데 있어서 컨텍스트의 중요성이 강조되며, 향후 수업에서 상태 관리에 컨텍스트를 사용하는 방법을 미리 살펴봅니다. 전반적으로 이 영상은 Flutter 애플리케이션 내에서 데이터를 관리하는 데 있어서 컨텍스트의 역할에 대한 포괄적인 이해를 제공합니다.",
                                // Spanish
                                "Español": "En este video, se explica el concepto de contexto en Flutter y se detalla cómo cada widget tiene su propio contexto que representa su posición en el árbol de widgets. El video demuestra el uso del contexto en métodos como showModalBottomSheet y explica cómo el contexto es esencial para una comunicación eficiente entre widgets en el árbol de widgets. El video también presenta la función InheritedWidget que permite compartir datos fácilmente en todo el árbol de widgets sin pasar datos a través de constructores. Se enfatiza la importancia del contexto para establecer un canal de comunicación directo para el intercambio de datos dentro del árbol de widgets, con una vista previa de cómo se usará en la administración de estados en lecciones futuras. En general, el video proporciona una comprensión integral del rol del contexto en la administración de datos dentro de las aplicaciones de Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, फ़्लटर में संदर्भ की अवधारणा को समझाया गया है, जिसमें विस्तार से बताया गया है कि कैसे प्रत्येक विजेट का अपना संदर्भ होता है जो विजेट ट्री में उसकी स्थिति को दर्शाता है। वीडियो शोमोडलबॉटमशीट जैसी विधियों में संदर्भ के उपयोग को प्रदर्शित करता है और बताता है कि विजेट ट्री में विजेट के बीच कुशल संचार के लिए संदर्भ कैसे आवश्यक है। वीडियो में इनहेरिटेडविजेट सुविधा भी पेश की गई है जो कंस्ट्रक्टर के माध्यम से डेटा पास किए बिना विजेट ट्री में डेटा को आसानी से साझा करने की अनुमति देती है। विजेट ट्री के भीतर डेटा एक्सचेंज के लिए एक सीधा संचार चैनल स्थापित करने में संदर्भ के महत्व पर जोर दिया गया है, साथ ही भविष्य के पाठों में स्टेट मैनेजमेंट में इसका उपयोग कैसे किया जाएगा, इसका पूर्वावलोकन भी दिया गया है। कुल मिलाकर, वीडियो फ़्लटर अनुप्रयोगों के भीतर डेटा के प्रबंधन में संदर्भ की भूमिका की व्यापक समझ प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo é explicado o conceito de contexto no Flutter, detalhando como cada widget tem o seu próprio contexto que representa a sua posição na árvore de widgets. O vídeo demonstra a utilização do contexto em métodos como o showModalBottomSheet e explica como o contexto é essencial para a comunicação eficiente entre widgets na árvore de widgets. O vídeo apresenta também a funcionalidade InheritedWidget que permite uma fácil partilha de dados na árvore de widgets sem passar dados por construtores. É enfatizada a importância do contexto no estabelecimento de um canal de comunicação direto para troca de dados dentro da árvore de widgets, com uma antevisão de como será utilizado na gestão do estado em lições futuras. No geral, o vídeo fornece uma compreensão abrangente da função do contexto na gestão de dados em aplicações Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, ফ্লটারে প্রসঙ্গ ধারণাটি ব্যাখ্যা করা হয়েছে, কীভাবে প্রতিটি উইজেটের নিজস্ব প্রসঙ্গ রয়েছে যা উইজেট ট্রিতে তার অবস্থানকে উপস্থাপন করে তা বিশদভাবে বর্ণনা করা হয়েছে। ভিডিওটি showModalBottomSheet-এর মতো পদ্ধতিতে প্রসঙ্গ ব্যবহার প্রদর্শন করে এবং উইজেট ট্রিতে উইজেটগুলির মধ্যে দক্ষ যোগাযোগের জন্য প্রসঙ্গ কীভাবে অপরিহার্য তা ব্যাখ্যা করে৷ ভিডিওটি ইনহেরিটেড উইজেট বৈশিষ্ট্যও প্রবর্তন করে যা কনস্ট্রাক্টরের মাধ্যমে ডেটা পাস না করেই উইজেট ট্রি জুড়ে ডেটা সহজে ভাগ করে নেওয়ার অনুমতি দেয়। উইজেট ট্রির মধ্যে ডেটা আদান-প্রদানের জন্য একটি প্রত্যক্ষ যোগাযোগের চ্যানেল প্রতিষ্ঠার ক্ষেত্রে প্রেক্ষাপটের গুরুত্বের উপর জোর দেওয়া হয়েছে, ভবিষ্যতের পাঠে এটি কীভাবে রাষ্ট্রীয় ব্যবস্থাপনায় ব্যবহার করা হবে তার একটি প্রিভিউ সহ। সামগ্রিকভাবে, ভিডিওটি ফ্লাটার অ্যাপ্লিকেশনের মধ্যে ডেটা পরিচালনার ক্ষেত্রে প্রেক্ষাপটের ভূমিকার একটি বিস্তৃত ধারণা প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتم شرح مفهوم السياق في Flutter، مع تفصيل كيفية وجود سياق خاص بكل عنصر واجهة مستخدم يمثل موقعه في شجرة عناصر واجهة المستخدم. يوضح الفيديو استخدام السياق في طرق مثل showModalBottomSheet ويشرح كيف أن السياق ضروري للتواصل الفعال بين عناصر واجهة المستخدم في شجرة عناصر واجهة المستخدم. يقدم الفيديو أيضًا ميزة InheritedWidget التي تسمح بمشاركة البيانات بسهولة عبر شجرة عناصر واجهة المستخدم دون تمرير البيانات عبر المنشئين. يتم التأكيد على أهمية السياق في إنشاء قناة اتصال مباشرة لتبادل البيانات داخل شجرة عناصر واجهة المستخدم، مع معاينة لكيفية استخدامه في إدارة الحالة في الدروس المستقبلية. بشكل عام، يوفر الفيديو فهمًا شاملاً لدور السياق في إدارة البيانات داخل تطبيقات Flutter.",
                                // Persian
                                "فارسی": "در این ویدئو، مفهوم زمینه در فلاتر توضیح داده شده است، و توضیح می دهد که چگونه هر ویجت دارای زمینه خاص خود است که نشان دهنده موقعیت آن در درخت ویجت است. این ویدئو استفاده از زمینه را در روش‌هایی مانند showModalBottomSheet نشان می‌دهد و توضیح می‌دهد که چگونه زمینه برای ارتباط کارآمد بین ویجت‌ها در درخت ویجت ضروری است. این ویدیو همچنین ویژگی InheritedWidget را معرفی می‌کند که امکان اشتراک‌گذاری آسان داده‌ها در درخت ویجت را بدون ارسال داده‌ها از طریق سازنده‌ها فراهم می‌کند. اهمیت زمینه در ایجاد یک کانال ارتباطی مستقیم برای تبادل داده در درخت ویجت، با پیش نمایشی از نحوه استفاده از آن در مدیریت ایالت در درس های آینده، تاکید می شود. به طور کلی، این ویدیو درک جامعی از نقش زمینه در مدیریت داده ها در برنامه های Flutter ارائه می دهد.",
                            },
                        },
                        // 135 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "A Problem with Lists & Stateful Widgets",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the concept of keys in Flutter widgets is explored, demonstrating how keys can be used to uniquely identify and manage widgets within the widget tree. The video explains that while most widgets don't require keys, there are scenarios where keys are essential for proper widget management. A practical example is shown where a transaction item widget is converted from stateless to stateful to dynamically assign background colors to list items using initState. The video introduces the Dart random package for generating random colors and explains the importance of not using setState in initState due to the execution order of initState and build methods. The video concludes with a demonstration of assigning random background colors to list items and discussing a discrepancy in background color assignment when deleting list elements.",
                                // German
                                "Deutsch": "In diesem Video wird das Konzept von Schlüsseln in Flutter-Widgets untersucht und gezeigt, wie Schlüssel verwendet werden können, um Widgets innerhalb des Widget-Baums eindeutig zu identifizieren und zu verwalten. Das Video erklärt, dass die meisten Widgets zwar keine Schlüssel benötigen, es jedoch Szenarien gibt, in denen Schlüssel für eine ordnungsgemäße Widget-Verwaltung unerlässlich sind. Es wird ein praktisches Beispiel gezeigt, bei dem ein Transaktionselement-Widget von zustandslos in zustandsbehaftet konvertiert wird, um Listenelementen mithilfe von initState dynamisch Hintergrundfarben zuzuweisen. Das Video stellt das Dart-Random-Paket zum Generieren von zufälligen Farben vor und erklärt, wie wichtig es ist, aufgrund der Ausführungsreihenfolge von initState und Build-Methoden setState nicht in initState zu verwenden. Das Video schließt mit einer Demonstration der Zuweisung zufälliger Hintergrundfarben zu Listenelementen und einer Erörterung einer Diskrepanz bei der Hintergrundfarbzuweisung beim Löschen von Listenelementen.",
                                // Chinese
                                "中国人": "本视频探讨了 Flutter 小部件中的键的概念，演示了如何使用键来唯一地标识和管理小部件树中的小部件。视频解释说，虽然大多数小部件不需要键，但在某些情况下，键对于正确的小部件管理至关重要。视频展示了一个实际示例，其中交易项小部件从无状态转换为有状态，以使用 initState 动态分配列表项的背景颜色。视频介绍了用于生成随机颜色的 Dart random 包，并解释了由于 initState 和 build 方法的执行顺序，不在 initState 中使用 setState 的重要性。视频最后演示了如何为列表项分配随机背景颜色，并讨论了删除列表元素时背景颜色分配的差异。",
                                // Russian
                                "Русский": "В этом видео рассматривается концепция ключей в виджетах Flutter, демонстрируя, как ключи могут использоваться для уникальной идентификации и управления виджетами в дереве виджетов. Видео объясняет, что, хотя большинству виджетов не требуются ключи, существуют сценарии, в которых ключи необходимы для правильного управления виджетами. Показан практический пример, в котором виджет элемента транзакции преобразуется из не имеющего состояния в имеющий состояние для динамического назначения фоновых цветов элементам списка с помощью initState. Видео знакомит с пакетом Dart random для генерации случайных цветов и объясняет важность отказа от использования setState в initState из-за порядка выполнения методов initState и build. Видео завершается демонстрацией назначения случайных фоновых цветов элементам списка и обсуждением несоответствия в назначении фонового цвета при удалении элементов списка.",
                                // French
                                "Français": "Dans cette vidéo, le concept de clés dans les widgets Flutter est exploré, démontrant comment les clés peuvent être utilisées pour identifier et gérer de manière unique les widgets dans l'arborescence des widgets. La vidéo explique que même si la plupart des widgets ne nécessitent pas de clés, il existe des scénarios dans lesquels les clés sont essentielles pour une gestion appropriée des widgets. Un exemple pratique est présenté où un widget d'élément de transaction est converti de sans état à avec état pour attribuer dynamiquement des couleurs d'arrière-plan aux éléments de liste à l'aide d'initState. La vidéo présente le package aléatoire Dart pour générer des couleurs aléatoires et explique l'importance de ne pas utiliser setState dans initState en raison de l'ordre d'exécution des méthodes initState et build. La vidéo se termine par une démonstration de l'attribution de couleurs d'arrière-plan aléatoires aux éléments de liste et discute d'une différence dans l'attribution des couleurs d'arrière-plan lors de la suppression d'éléments de liste.",
                                // Japanese
                                "日本語": "このビデオでは、Flutter ウィジェットのキーの概念について説明し、キーを使用してウィジェット ツリー内のウィジェットを一意に識別および管理する方法を説明します。ビデオでは、ほとんどのウィジェットはキーを必要としませんが、適切なウィジェット管理にはキーが不可欠なシナリオがあることを説明しています。実用的な例として、トランザクション アイテム ウィジェットをステートレスからステートフルに変換し、initState を使用してリスト アイテムに背景色を動的に割り当てる方法を示します。ビデオでは、ランダムな色を生成するための Dart ランダム パッケージを紹介し、initState とビルド メソッドの実行順序のため、initState で setState を使用しないことの重要性を説明します。ビデオの最後には、リスト アイテムにランダムな背景色を割り当てるデモを行い、リスト要素を削除するときに背景色の割り当てに矛盾が生じることについて説明します。",
                                // Korean
                                "한국인": "이 비디오에서는 Flutter 위젯의 키 개념을 살펴보고 키를 사용하여 위젯 트리 내에서 위젯을 고유하게 식별하고 관리하는 방법을 보여줍니다. 이 비디오에서는 대부분의 위젯에 키가 필요하지 않지만 적절한 위젯 관리에 키가 필수적인 시나리오가 있다고 설명합니다. 트랜잭션 항목 위젯을 상태 없음에서 상태 있음으로 변환하여 initState를 사용하여 목록 항목에 배경색을 동적으로 지정하는 실제 예를 보여줍니다. 이 비디오에서는 무작위 색상을 생성하기 위한 Dart random 패키지를 소개하고 initState 및 build 메서드의 실행 순서로 인해 initState에서 setState를 사용하지 않는 것의 중요성을 설명합니다. 이 비디오는 목록 항목에 무작위 배경색을 지정하는 방법과 목록 요소를 삭제할 때 배경색 지정의 불일치에 대해 설명하는 데모로 마무리됩니다.",
                                // Spanish
                                "Español": "En este video, se explora el concepto de claves en los widgets de Flutter y se demuestra cómo se pueden usar las claves para identificar y administrar de forma única los widgets dentro del árbol de widgets. El video explica que, si bien la mayoría de los widgets no requieren claves, existen situaciones en las que las claves son esenciales para una administración adecuada de los widgets. Se muestra un ejemplo práctico en el que un widget de elemento de transacción se convierte de sin estado a con estado para asignar dinámicamente colores de fondo a los elementos de la lista mediante initState. El video presenta el paquete aleatorio Dart para generar colores aleatorios y explica la importancia de no usar setState en initState debido al orden de ejecución de los métodos initState y build. El video concluye con una demostración de cómo asignar colores de fondo aleatorios a los elementos de la lista y se analiza una discrepancia en la asignación de colores de fondo al eliminar elementos de la lista.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, फ़्लटर विजेट में कुंजियों की अवधारणा का पता लगाया गया है, जिसमें दिखाया गया है कि कैसे कुंजियों का उपयोग विजेट ट्री के भीतर विजेट को विशिष्ट रूप से पहचानने और प्रबंधित करने के लिए किया जा सकता है। वीडियो बताता है कि जबकि अधिकांश विजेट को कुंजियों की आवश्यकता नहीं होती है, ऐसे परिदृश्य हैं जहाँ उचित विजेट प्रबंधन के लिए कुंजियाँ आवश्यक हैं। एक व्यावहारिक उदाहरण दिखाया गया है जहाँ एक ट्रांजेक्शन आइटम विजेट को initState का उपयोग करके सूची आइटम को गतिशील रूप से पृष्ठभूमि रंग असाइन करने के लिए स्टेटलेस से स्टेटफुल में परिवर्तित किया जाता है। वीडियो यादृच्छिक रंग उत्पन्न करने के लिए डार्ट रैंडम पैकेज का परिचय देता है और initState और बिल्ड विधियों के निष्पादन क्रम के कारण initState में setState का उपयोग न करने के महत्व को समझाता है। वीडियो सूची आइटम को यादृच्छिक पृष्ठभूमि रंग असाइन करने और सूची तत्वों को हटाते समय पृष्ठभूमि रंग असाइनमेंट में विसंगति पर चर्चा करने के प्रदर्शन के साथ समाप्त होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, é explorado o conceito de chaves nos widgets Flutter, demonstrando como as chaves podem ser utilizadas para identificar e gerir widgets de forma única na árvore de widgets. O vídeo explica que, embora a maioria dos widgets não exija chaves, existem cenários em que as chaves são essenciais para a gestão adequada dos widgets. É mostrado um exemplo prático onde um widget de item de transação é convertido de stateless para stateful para atribuir dinamicamente cores de fundo aos itens de lista utilizando initState. O vídeo apresenta o pacote Dart random para gerar cores aleatórias e explica a importância de não utilizar setState em initState devido à ordem de execução dos métodos initState e build. O vídeo termina com uma demonstração de como atribuir cores de fundo aleatórias aos itens da lista e discutir uma discrepância na atribuição de cores de fundo ao eliminar elementos da lista.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, ফ্লটার উইজেটগুলিতে কীগুলির ধারণাটি অন্বেষণ করা হয়েছে, প্রদর্শন করা হয়েছে কীভাবে উইজেট গাছের মধ্যে উইজেটগুলিকে অনন্যভাবে সনাক্ত করতে এবং পরিচালনা করতে কীগুলি ব্যবহার করা যেতে পারে৷ ভিডিওটি ব্যাখ্যা করে যে বেশিরভাগ উইজেটগুলির কীগুলির প্রয়োজন হয় না, এমন পরিস্থিতিতে রয়েছে যেখানে সঠিক উইজেট পরিচালনার জন্য কীগুলি অপরিহার্য৷ একটি বাস্তব উদাহরণ দেখানো হয়েছে যেখানে একটি লেনদেন আইটেম উইজেটকে স্টেটলেস থেকে স্টেটফুলে রূপান্তরিত করা হয় যাতে initState ব্যবহার করে তালিকা আইটেমগুলিতে গতিশীলভাবে পটভূমির রঙ নির্ধারণ করা হয়। ভিডিওটি এলোমেলো রঙ তৈরি করার জন্য ডার্ট র্যান্ডম প্যাকেজ উপস্থাপন করে এবং initState এবং বিল্ড পদ্ধতির কার্যকরী আদেশের কারণে initState-এ সেটস্টেট ব্যবহার না করার গুরুত্ব ব্যাখ্যা করে। ভিডিওটি তালিকা আইটেমগুলিতে র্যান্ডম পটভূমির রঙগুলি বরাদ্দ করার একটি প্রদর্শনের সাথে এবং তালিকার উপাদানগুলি মুছে দেওয়ার সময় পটভূমির রঙের অ্যাসাইনমেন্টে একটি অসঙ্গতি নিয়ে আলোচনা করে শেষ হয়৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتم استكشاف مفهوم المفاتيح في عناصر واجهة المستخدم الرسومية Flutter، مع توضيح كيفية استخدام المفاتيح لتحديد عناصر واجهة المستخدم الرسومية وإدارتها بشكل فريد داخل شجرة عناصر واجهة المستخدم الرسومية. يوضح الفيديو أنه في حين أن معظم عناصر واجهة المستخدم الرسومية لا تتطلب مفاتيح، إلا أن هناك سيناريوهات تكون فيها المفاتيح ضرورية لإدارة عناصر واجهة المستخدم الرسومية بشكل صحيح. يتم عرض مثال عملي حيث يتم تحويل عنصر واجهة المستخدم الرسومية لمعاملة من عديم الحالة إلى حالة لتعيين ألوان الخلفية بشكل ديناميكي لعناصر القائمة باستخدام initState. يقدم الفيديو حزمة Dart random لتوليد ألوان عشوائية ويشرح أهمية عدم استخدام setState في initState بسبب ترتيب تنفيذ initState وطرق البناء. ويختتم الفيديو بعرض توضيحي لتعيين ألوان خلفية عشوائية لعناصر القائمة ومناقشة التناقض في تعيين لون الخلفية عند حذف عناصر القائمة.",
                                // Persian
                                "فارسی": "در این ویدئو، مفهوم کلیدها در ویجت‌های فلاتر بررسی می‌شود و نشان می‌دهد که چگونه می‌توان از کلیدها برای شناسایی و مدیریت منحصربه‌فرد ویجت‌ها در درخت ویجت استفاده کرد. این ویدئو توضیح می دهد که در حالی که اکثر ویجت ها به کلید نیاز ندارند، سناریوهایی وجود دارد که کلیدها برای مدیریت صحیح ویجت ضروری هستند. یک مثال عملی نشان داده شده است که در آن ویجت مورد تراکنش از حالت بدون حالت به حالت حالت تبدیل می شود تا به صورت پویا رنگ پس زمینه به موارد لیست با استفاده از initState اختصاص داده شود. این ویدئو بسته تصادفی Dart را برای تولید رنگ های تصادفی معرفی می کند و اهمیت عدم استفاده از setState در initState را به دلیل ترتیب اجرای روش های initState و build توضیح می دهد. این ویدئو با نمایشی از اختصاص دادن رنگ‌های پس‌زمینه تصادفی به موارد فهرست و بحث در مورد اختلاف در تخصیص رنگ پس‌زمینه هنگام حذف عناصر فهرست به پایان می‌رسد.",
                            },
                        },
                        // 136 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Understanding the Problem Root",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the process of determining when a widget's state is deleted in Flutter is explained, highlighting the separation between the widget tree and the element tree. It is shown that when a widget is deleted from the widget tree, its state is not immediately removed, as Flutter first checks whether the element associated with the state is still needed. The video demonstrates how Flutter evaluates whether the element is still required by analyzing the element tree structure, ultimately determining whether the state should be deleted based on the presence of matching widgets in the updated tree. The need for a way to specify unique identifiers for items to prevent incorrect state retention is discussed, with Flutter providing a solution for passing additional information to elements for accurate state management.",
                                // German
                                "Deutsch": "In diesem Video wird der Prozess der Bestimmung, wann der Status eines Widgets in Flutter gelöscht wird, erklärt, wobei die Trennung zwischen dem Widget-Baum und dem Element-Baum hervorgehoben wird. Es wird gezeigt, dass beim Löschen eines Widgets aus dem Widget-Baum sein Status nicht sofort entfernt wird, da Flutter zunächst prüft, ob das mit dem Status verknüpfte Element noch benötigt wird. Das Video zeigt, wie Flutter durch Analyse der Element-Baumstruktur auswertet, ob das Element noch benötigt wird, und schließlich anhand des Vorhandenseins übereinstimmender Widgets im aktualisierten Baum bestimmt, ob der Status gelöscht werden soll. Die Notwendigkeit einer Möglichkeit, eindeutige Kennungen für Elemente anzugeben, um eine falsche Statusbeibehaltung zu verhindern, wird erörtert, wobei Flutter eine Lösung zum Übergeben zusätzlicher Informationen an Elemente für eine genaue Statusverwaltung bietet.",
                                // Chinese
                                "中国人": "本视频解释了 Flutter 中确定何时删除 widget 状态的过程，强调了 widget 树和元素树之间的分离。视频显示，当 widget 从 widget 树中删除时，其状态不会立即被删除，因为 Flutter 首先检查与状态关联的元素是否仍然需要。视频演示了 Flutter 如何通过分析元素树结构来评估元素是否仍然需要，最终根据更新后的树中是否存在匹配的 widget 来确定是否应删除状态。视频讨论了需要一种方法来为项目指定唯一标识符以防止不正确的状态保留，Flutter 提供了一种解决方案，用于将附加信息传递给元素以实现准确的状态管理。",
                                // Russian
                                "Русский": "В этом видео объясняется процесс определения того, когда состояние виджета удаляется во Flutter, подчеркивая разделение между деревом виджетов и деревом элементов. Показано, что когда виджет удаляется из дерева виджетов, его состояние не удаляется немедленно, так как Flutter сначала проверяет, нужен ли еще элемент, связанный с состоянием. Видео демонстрирует, как Flutter оценивает, нужен ли еще элемент, анализируя структуру дерева элементов, в конечном итоге определяя, следует ли удалить состояние, на основе наличия соответствующих виджетов в обновленном дереве. Обсуждается необходимость способа указания уникальных идентификаторов для элементов для предотвращения неправильного сохранения состояния, при этом Flutter предоставляет решение для передачи дополнительной информации элементам для точного управления состоянием.",
                                // French
                                "Français": "Dans cette vidéo, le processus de détermination du moment où l'état d'un widget est supprimé dans Flutter est expliqué, en soulignant la séparation entre l'arborescence des widgets et l'arborescence des éléments. Il est démontré que lorsqu'un widget est supprimé de l'arborescence des widgets, son état n'est pas immédiatement supprimé, car Flutter vérifie d'abord si l'élément associé à l'état est toujours nécessaire. La vidéo montre comment Flutter évalue si l'élément est toujours nécessaire en analysant la structure de l'arborescence des éléments, déterminant finalement si l'état doit être supprimé en fonction de la présence de widgets correspondants dans l'arborescence mise à jour. La nécessité d'un moyen de spécifier des identifiants uniques pour les éléments afin d'éviter une conservation incorrecte de l'état est abordée, Flutter fournissant une solution pour transmettre des informations supplémentaires aux éléments pour une gestion précise de l'état.",
                                // Japanese
                                "日本語": "このビデオでは、ウィジェット ツリーと要素ツリーの分離に焦点を当てながら、Flutter でウィジェットの状態がいつ削除されるかを判断するプロセスについて説明します。ウィジェットがウィジェット ツリーから削除されても、その状態はすぐには削除されないことが示されています。これは、Flutter が最初に状態に関連付けられた要素がまだ必要かどうかをチェックするためです。ビデオでは、Flutter が要素ツリー構造を分析して要素がまだ必要かどうかを評価し、最終的に更新されたツリーに一致するウィジェットが存在するかどうかに基づいて状態を削除するかどうかを決定する方法を示しています。誤った状態保持を防ぐためにアイテムに一意の識別子を指定する方法の必要性について説明し、Flutter は正確な状態管理のために要素に追加情報を渡すソリューションを提供します。",
                                // Korean
                                "한국인": "이 영상에서는 Flutter에서 위젯의 상태가 삭제되는 시점을 판별하는 프로세스를 설명하며, 위젯 트리와 요소 트리의 분리를 강조합니다. 위젯이 위젯 트리에서 삭제될 때, Flutter가 먼저 상태와 연관된 요소가 여전히 필요한지 확인하기 때문에 해당 상태가 즉시 삭제되지 않는다는 것을 보여줍니다. 이 영상에서는 Flutter가 요소 트리 구조를 분석하여 요소가 여전히 필요한지 평가하고, 궁극적으로 업데이트된 트리에 일치하는 위젯이 있는지에 따라 상태를 삭제해야 하는지 여부를 판별하는 방법을 보여줍니다. 잘못된 상태 보존을 방지하기 위해 항목에 대한 고유 식별자를 지정하는 방법의 필요성에 대해 설명하며, Flutter는 정확한 상태 관리를 위해 요소에 추가 정보를 전달하는 솔루션을 제공합니다.",
                                // Spanish
                                "Español": "En este video, se explica el proceso para determinar cuándo se elimina el estado de un widget en Flutter, destacando la separación entre el árbol de widgets y el árbol de elementos. Se muestra que cuando se elimina un widget del árbol de widgets, su estado no se elimina de inmediato, ya que Flutter primero verifica si el elemento asociado con el estado aún es necesario. El video demuestra cómo Flutter evalúa si el elemento aún es necesario mediante el análisis de la estructura del árbol de elementos y, en última instancia, determina si el estado debe eliminarse en función de la presencia de widgets coincidentes en el árbol actualizado. Se analiza la necesidad de una forma de especificar identificadores únicos para los elementos para evitar la retención incorrecta del estado, y Flutter proporciona una solución para pasar información adicional a los elementos para una gestión precisa del estado.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, फ़्लटर में विजेट की स्थिति को कब हटाया जाता है, यह निर्धारित करने की प्रक्रिया को समझाया गया है, जिसमें विजेट ट्री और एलिमेंट ट्री के बीच अलगाव को हाइलाइट किया गया है। यह दिखाया गया है कि जब विजेट को विजेट ट्री से हटा दिया जाता है, तो उसकी स्थिति तुरंत नहीं हटाई जाती है, क्योंकि फ़्लटर पहले जाँचता है कि क्या स्थिति से जुड़ा तत्व अभी भी ज़रूरी है। वीडियो दर्शाता है कि फ़्लटर कैसे मूल्यांकन करता है कि तत्व ट्री संरचना का विश्लेषण करके तत्व अभी भी ज़रूरी है या नहीं, अंततः यह निर्धारित करता है कि अपडेट किए गए ट्री में मिलान करने वाले विजेट की उपस्थिति के आधार पर स्थिति को हटाया जाना चाहिए या नहीं। गलत स्थिति प्रतिधारण को रोकने के लिए आइटम के लिए अद्वितीय पहचानकर्ता निर्दिष्ट करने के तरीके की आवश्यकता पर चर्चा की गई है, जिसमें फ़्लटर सटीक स्थिति प्रबंधन के लिए तत्वों को अतिरिक्त जानकारी पास करने के लिए एक समाधान प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, é explicado o processo de determinação de quando o estado de um widget é eliminado no Flutter, destacando a separação entre a árvore de widgets e a árvore de elementos. É mostrado que quando um widget é eliminado da árvore de widgets, o seu estado não é removido imediatamente, pois o Flutter verifica primeiro se o elemento associado ao estado ainda é necessário. O vídeo demonstra como o Flutter avalia se o elemento ainda é necessário analisando a estrutura da árvore do elemento e, em última análise, determinando se o estado deve ser eliminado com base na presença de widgets correspondentes na árvore atualizada. A necessidade de uma forma de especificar identificadores únicos para os itens para evitar a retenção incorreta do estado é discutida, com o Flutter a fornecer uma solução para passar informações adicionais aos elementos para uma gestão precisa do estado.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, ফ্লটারে একটি উইজেটের অবস্থা কখন মুছে ফেলা হয় তা নির্ধারণের প্রক্রিয়া ব্যাখ্যা করা হয়েছে, উইজেট ট্রি এবং উপাদান গাছের মধ্যে বিচ্ছেদ হাইলাইট করে। এটি দেখানো হয়েছে যে যখন উইজেট গাছ থেকে একটি উইজেট মুছে ফেলা হয়, তখন তার অবস্থা অবিলম্বে সরানো হয় না, কারণ Flutter প্রথমে পরীক্ষা করে যে রাজ্যের সাথে যুক্ত উপাদানটি এখনও প্রয়োজন কিনা। ভিডিওটি দেখায় কিভাবে Flutter মূল্যায়ন করে যে উপাদানটির গাছের গঠন বিশ্লেষণ করে উপাদানটির এখনও প্রয়োজন আছে কিনা, শেষ পর্যন্ত আপডেট করা ট্রিতে ম্যাচিং উইজেটগুলির উপস্থিতির উপর ভিত্তি করে স্টেটটি মুছে ফেলা উচিত কিনা তা নির্ধারণ করে৷ ভুল রাষ্ট্র ধারণ প্রতিরোধ করার জন্য আইটেমগুলির জন্য অনন্য শনাক্তকারী নির্দিষ্ট করার একটি উপায়ের প্রয়োজনীয়তা নিয়ে আলোচনা করা হয়েছে, Flutter সঠিক রাষ্ট্র পরিচালনার জন্য উপাদানগুলিতে অতিরিক্ত তথ্য দেওয়ার জন্য একটি সমাধান প্রদান করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتم شرح عملية تحديد وقت حذف حالة عنصر واجهة المستخدم في Flutter، مع تسليط الضوء على الفصل بين شجرة عناصر واجهة المستخدم وشجرة العناصر. يُظهِر الفيديو أنه عند حذف عنصر واجهة مستخدم من شجرة عناصر واجهة المستخدم، لا تتم إزالة حالته على الفور، حيث يتحقق Flutter أولاً مما إذا كان العنصر المرتبط بالحالة لا يزال مطلوبًا. يوضح الفيديو كيف يقوم Flutter بتقييم ما إذا كان العنصر لا يزال مطلوبًا من خلال تحليل بنية شجرة العناصر، وتحديد ما إذا كان يجب حذف الحالة في النهاية بناءً على وجود عناصر واجهة مستخدم مطابقة في الشجرة المحدثة. تتم مناقشة الحاجة إلى طريقة لتحديد معرفات فريدة للعناصر لمنع الاحتفاظ بالحالة بشكل غير صحيح، حيث يوفر Flutter حلاً لتمرير معلومات إضافية إلى العناصر لإدارة الحالة بدقة.",
                                // Persian
                                "فارسی": "در این ویدیو، فرآیند تعیین زمان حذف وضعیت یک ویجت در فلوتر توضیح داده شده است و جدایی بین درخت ویجت و درخت عنصر را برجسته می کند. نشان داده شده است که وقتی یک ویجت از درخت ویجت حذف می شود، وضعیت آن فورا حذف نمی شود، زیرا Flutter ابتدا بررسی می کند که آیا عنصر مرتبط با وضعیت هنوز مورد نیاز است یا خیر. این ویدئو نشان می‌دهد که چگونه Flutter با تجزیه و تحلیل ساختار درخت عنصر، ارزیابی می‌کند که آیا عنصر همچنان مورد نیاز است یا خیر، و در نهایت تعیین می‌کند که آیا وضعیت باید بر اساس وجود ویجت‌های منطبق در درخت به‌روز شده حذف شود یا خیر. نیاز به راهی برای تعیین شناسه های منحصر به فرد برای موارد برای جلوگیری از حفظ حالت نادرست مورد بحث قرار گرفته است، با Flutter راه حلی برای انتقال اطلاعات اضافی به عناصر برای مدیریت دقیق وضعیت ارائه می دهد.",
                            },
                        },
                        // 137 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Using Keys",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter discusses the importance of using keys in Flutter widgets, specifically when dealing with ListView.builder. The video demonstrates how to implement keys in a custom transaction item widget to avoid bugs and ensure correct state management. The unique key and value key concepts are explained, with the value key being recommended for custom identifiers. The video emphasizes that keys should only be used when necessary and highlights the scenarios where keys are essential for proper widget identification and state management. The use of keys prevents Flutter from incorrectly matching items and attaching state, ensuring smooth operation of the application.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Moderator die Bedeutung der Verwendung von Schlüsseln in Flutter-Widgets, insbesondere beim Umgang mit ListView.builder. Das Video zeigt, wie Schlüssel in einem benutzerdefinierten Transaktionselement-Widget implementiert werden, um Fehler zu vermeiden und eine korrekte Statusverwaltung sicherzustellen. Die Konzepte eindeutiger Schlüssel und Wertschlüssel werden erläutert, wobei der Wertschlüssel für benutzerdefinierte Bezeichner empfohlen wird. Das Video betont, dass Schlüssel nur bei Bedarf verwendet werden sollten, und hebt die Szenarien hervor, in denen Schlüssel für eine ordnungsgemäße Widget-Identifizierung und Statusverwaltung unerlässlich sind. Die Verwendung von Schlüsseln verhindert, dass Flutter Elemente falsch zuordnet und Status anfügt, und gewährleistet so einen reibungslosen Betrieb der Anwendung.",
                                // Chinese
                                "中国人": "在本视频中，演示者讨论了在 Flutter 小部件中使用键的重要性，特别是在处理 ListView.builder 时。该视频演示了如何在自定义交易项目小部件中实现键，以避免错误并确保正确的状态管理。解释了唯一键和值键的概念，其中值键是建议用于自定义标识符的键。该视频强调仅在必要时使用键，并强调了键对于正确的小部件识别和状态管理至关重要的场景。使用键可以防止 Flutter 错误地匹配项目和附加状态，从而确保应用程序的平稳运行。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает важность использования ключей в виджетах Flutter, особенно при работе с ListView.builder. Видео демонстрирует, как реализовать ключи в пользовательском виджете элемента транзакции, чтобы избежать ошибок и обеспечить правильное управление состоянием. Объясняются концепции уникального ключа и ключа значения, причем ключ значения рекомендуется для пользовательских идентификаторов. Видео подчеркивает, что ключи следует использовать только при необходимости, и выделяет сценарии, в которых ключи необходимы для правильной идентификации виджета и управления состоянием. Использование ключей предотвращает неправильное сопоставление элементов и присоединение состояния Flutter, обеспечивая бесперебойную работу приложения.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur explique l'importance d'utiliser des clés dans les widgets Flutter, en particulier lorsqu'il s'agit de ListView.builder. La vidéo montre comment implémenter des clés dans un widget d'élément de transaction personnalisé pour éviter les bugs et garantir une gestion correcte de l'état. Les concepts de clé unique et de clé de valeur sont expliqués, la clé de valeur étant recommandée pour les identifiants personnalisés. La vidéo souligne que les clés ne doivent être utilisées que lorsque cela est nécessaire et met en évidence les scénarios dans lesquels les clés sont essentielles pour une identification et une gestion d'état correctes des widgets. L'utilisation de clés empêche Flutter de faire correspondre de manière incorrecte les éléments et d'attacher l'état, garantissant ainsi le bon fonctionnement de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが Flutter ウィジェットでキーを使用することの重要性について、特に ListView.builder を扱う場合について説明します。このビデオでは、カスタム トランザクション アイテム ウィジェットにキーを実装してバグを回避し、正しい状態管理を確実に行う方法を示します。一意のキーと値キーの概念について説明し、カスタム識別子には値キーが推奨されます。このビデオでは、キーは必要な場合にのみ使用する必要があることを強調し、適切なウィジェット識別と状態管理にキーが不可欠なシナリオに焦点を当てています。キーを使用すると、Flutter がアイテムを誤って一致させたり状態を添付したりすることがなくなり、アプリケーションのスムーズな操作が保証されます。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 위젯에서 키를 사용하는 것의 중요성, 특히 ListView.builder를 다룰 때의 중요성을 설명합니다. 이 비디오는 버그를 피하고 올바른 상태 관리를 보장하기 위해 사용자 지정 트랜잭션 항목 위젯에서 키를 구현하는 방법을 보여줍니다. 고유한 키와 값 키 개념이 설명되며, 값 키는 사용자 지정 식별자에 권장됩니다. 이 비디오는 키는 필요할 때만 사용해야 하며 키가 적절한 위젯 식별 및 상태 관리에 필수적인 시나리오를 강조합니다. 키를 사용하면 Flutter가 항목을 잘못 일치시키고 상태를 첨부하는 것을 방지하여 애플리케이션의 원활한 작동을 보장합니다.",
                                // Spanish
                                "Español": "En este video, el presentador analiza la importancia de usar claves en los widgets de Flutter, específicamente cuando se trabaja con ListView.builder. El video demuestra cómo implementar claves en un widget de elemento de transacción personalizado para evitar errores y garantizar una gestión correcta del estado. Se explican los conceptos de clave única y clave de valor, y se recomienda la clave de valor para los identificadores personalizados. El video enfatiza que las claves solo deben usarse cuando sea necesario y destaca los escenarios en los que las claves son esenciales para la identificación adecuada de los widgets y la gestión del estado. El uso de claves evita que Flutter empareje elementos de manera incorrecta y adjunte estados, lo que garantiza el funcionamiento sin problemas de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर विजेट में कुंजियों का उपयोग करने के महत्व पर चर्चा करता है, विशेष रूप से ListView.builder से निपटने के दौरान। वीडियो प्रदर्शित करता है कि बग से बचने और सही स्थिति प्रबंधन सुनिश्चित करने के लिए कस्टम ट्रांजेक्शन आइटम विजेट में कुंजियों को कैसे लागू किया जाए। अद्वितीय कुंजी और मान कुंजी अवधारणाओं को समझाया गया है, जिसमें कस्टम पहचानकर्ताओं के लिए मान कुंजी की सिफारिश की गई है। वीडियो इस बात पर जोर देता है कि कुंजियों का उपयोग केवल तभी किया जाना चाहिए जब आवश्यक हो और उन परिदृश्यों पर प्रकाश डाला गया है जहाँ कुंजियाँ उचित विजेट पहचान और स्थिति प्रबंधन के लिए आवश्यक हैं। कुंजियों का उपयोग फ़्लटर को गलत तरीके से आइटम मिलान करने और स्थिति संलग्न करने से रोकता है, जिससे एप्लिकेशन का सुचारू संचालन सुनिश्चित होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador discute a importância da utilização de chaves nos widgets Flutter, especificamente quando se lida com ListView.builder. O vídeo demonstra como implementar chaves num widget de item de transação personalizado para evitar bugs e garantir a gestão correta do estado. Os conceitos de chave única e chave de valor são explicados, sendo a chave de valor recomendada para identificadores personalizados. O vídeo realça que as chaves só devem ser utilizadas quando necessário e destaca os cenários em que as chaves são essenciais para a identificação adequada do widget e para a gestão do estado. A utilização de chaves evita que o Flutter combine itens e anexe itens incorretamente, garantindo o bom funcionamento da aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক ফ্লটার উইজেটগুলিতে কী ব্যবহার করার গুরুত্ব নিয়ে আলোচনা করেছেন, বিশেষ করে যখন ListView.builder-এর সাথে কাজ করেন। বাগ এড়াতে এবং সঠিক রাষ্ট্র পরিচালনা নিশ্চিত করতে একটি কাস্টম লেনদেন আইটেম উইজেটে কীগুলি কীভাবে প্রয়োগ করতে হয় তা ভিডিওটি প্রদর্শন করে৷ অনন্য কী এবং মান কী ধারণা ব্যাখ্যা করা হয়েছে, মান কী কাস্টম শনাক্তকারীদের জন্য সুপারিশ করা হচ্ছে। ভিডিওতে জোর দেওয়া হয়েছে যে কীগুলি শুধুমাত্র প্রয়োজন হলেই ব্যবহার করা উচিত এবং সেই পরিস্থিতিতে হাইলাইট করে যেখানে কীগুলি সঠিক উইজেট সনাক্তকরণ এবং রাষ্ট্র পরিচালনার জন্য অপরিহার্য। কীগুলির ব্যবহার ফ্লটারকে আইটেমগুলিকে ভুলভাবে মেলানো এবং অ্যাটাচিং স্টেট থেকে অ্যাপ্লিকেশানের মসৃণ অপারেশন নিশ্চিত করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش مقدم العرض أهمية استخدام المفاتيح في عناصر واجهة المستخدم الرسومية Flutter، وخاصة عند التعامل مع ListView.builder. يوضح الفيديو كيفية تنفيذ المفاتيح في عنصر واجهة مستخدم مخصص لمعاملات لتجنب الأخطاء وضمان إدارة الحالة بشكل صحيح. يتم شرح مفاهيم المفتاح الفريد ومفتاح القيمة، مع التوصية بمفتاح القيمة للمعرفات المخصصة. يؤكد الفيديو على أنه يجب استخدام المفاتيح فقط عند الضرورة ويسلط الضوء على السيناريوهات التي تكون فيها المفاتيح ضرورية لتحديد عناصر واجهة المستخدم الرسومية وإدارة الحالة بشكل صحيح. يمنع استخدام المفاتيح Flutter من مطابقة العناصر بشكل غير صحيح وإرفاق الحالة، مما يضمن التشغيل السلس للتطبيق.",
                                // Persian
                                "فارسی": "در این ویدئو، مجری در مورد اهمیت استفاده از کلیدها در ویجت های فلاتر، به ویژه در هنگام برخورد با ListView.builder صحبت می کند. این ویدئو نحوه پیاده‌سازی کلیدها را در ویجت مورد تراکنش سفارشی برای جلوگیری از اشکالات و اطمینان از مدیریت صحیح وضعیت نشان می‌دهد. مفاهیم کلید منحصر به فرد و کلید ارزش توضیح داده شده است، با کلید ارزش برای شناسه های سفارشی توصیه می شود. این ویدئو تاکید می کند که کلیدها فقط باید در مواقع ضروری استفاده شوند و سناریوهایی را که کلیدها برای شناسایی صحیح ویجت و مدیریت وضعیت ضروری هستند، برجسته می کند. استفاده از کلیدها از تطبیق نادرست آیتم‌ها و حالت اتصال Flutter جلوگیری می‌کند و عملکرد روان برنامه را تضمین می‌کند.",
                            },
                        },
                        // 138 [Video Number]
                        {
                            "SectionName": "Widget & Flutter Internals - Deep Dive",
                            "VideoName": "Wrap Up",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this module, the presenter covers advanced topics and functionalities of Flutter, focusing on writing clean code and understanding internal workings to optimize apps. The video addresses potential bugs and optimizations, emphasizing the importance of finding a balance between performance improvements and readability. The presenter reassures viewers that missing optimizations does not always result in a bad app and encourages them to find an approach that works best for their team. The module is meant to be a useful reference for understanding Flutter's operations behind the scenes and what aspects require attention, without feeling overwhelmed by the amount of information provided.",
                                // German
                                "Deutsch": "In diesem Modul behandelt der Moderator fortgeschrittene Themen und Funktionen von Flutter, wobei er sich auf das Schreiben von sauberem Code und das Verstehen interner Abläufe zur Optimierung von Apps konzentriert. Das Video befasst sich mit potenziellen Fehlern und Optimierungen und betont, wie wichtig es ist, ein Gleichgewicht zwischen Leistungsverbesserungen und Lesbarkeit zu finden. Der Moderator versichert den Zuschauern, dass fehlende Optimierungen nicht immer zu einer schlechten App führen, und ermutigt sie, einen Ansatz zu finden, der für ihr Team am besten funktioniert. Das Modul soll ein nützliches Nachschlagewerk sein, um die Vorgänge hinter den Kulissen von Flutter und die Aspekte, die Aufmerksamkeit erfordern, zu verstehen, ohne sich von der Menge der bereitgestellten Informationen überwältigt zu fühlen.",
                                // Chinese
                                "中国人": "在本模块中，演示者将介绍 Flutter 的高级主题和功能，重点介绍如何编写干净的代码并了解内部工作原理以优化应用程序。视频介绍了潜在的错误和优化，强调了在性能改进和可读性之间找到平衡的重要性。演示者向观众保证，缺少优化并不总是会导致应用程序质量低下，并鼓励他们找到最适合其团队的方法。该模块旨在成为了解 Flutter 幕后操作以及需要注意哪些方面的有用参考，而不会因提供的信息量而感到不知所措。",
                                // Russian
                                "Русский": "В этом модуле докладчик рассматривает продвинутые темы и функции Flutter, уделяя особое внимание написанию чистого кода и пониманию внутренних механизмов для оптимизации приложений. Видео рассматривает потенциальные ошибки и оптимизации, подчеркивая важность поиска баланса между улучшением производительности и читаемостью. Докладчик заверяет зрителей, что отсутствие оптимизации не всегда приводит к плохому приложению, и призывает их найти подход, который лучше всего подходит для их команды. Модуль призван стать полезным справочником для понимания операций Flutter за кулисами и аспектов, требующих внимания, без ощущения перегруженности объемом предоставленной информации.",
                                // French
                                "Français": "Dans ce module, le présentateur aborde les sujets et fonctionnalités avancés de Flutter, en se concentrant sur l'écriture de code propre et la compréhension du fonctionnement interne pour optimiser les applications. La vidéo aborde les bugs et optimisations potentiels, en soulignant l'importance de trouver un équilibre entre les améliorations de performances et la lisibilité. Le présentateur rassure les spectateurs sur le fait que l'absence d'optimisations n'entraîne pas toujours une mauvaise application et les encourage à trouver l'approche qui convient le mieux à leur équipe. Le module est destiné à être une référence utile pour comprendre les opérations de Flutter en coulisses et les aspects qui nécessitent une attention particulière, sans se sentir dépassé par la quantité d'informations fournies.",
                                // Japanese
                                "日本語": "このモジュールでは、プレゼンターが Flutter の高度なトピックと機能について説明し、クリーンなコードの作成とアプリを最適化するための内部の仕組みの理解に重点を置いています。ビデオでは潜在的なバグと最適化について取り上げ、パフォーマンスの向上と読みやすさのバランスを取ることの重要性を強調しています。プレゼンターは、最適化を怠っても必ずしもアプリの品質が低下するわけではないことを視聴者に保証し、チームに最適なアプローチを見つけるよう促しています。このモジュールは、提供される情報量に圧倒されることなく、舞台裏での Flutter の動作と注意が必要な側面を理解するための便利なリファレンスとなることを目的としています。",
                                // Korean
                                "한국인": "이 모듈에서 발표자는 Flutter의 고급 주제와 기능을 다루며, 깔끔한 코드를 작성하고 앱을 최적화하기 위한 내부 작동 방식을 이해하는 데 중점을 둡니다. 이 비디오는 잠재적인 버그와 최적화를 다루며 성능 개선과 가독성 간의 균형을 찾는 것의 중요성을 강조합니다. 발표자는 최적화를 놓쳤다고 해서 항상 나쁜 앱이 나오는 것은 아니라고 시청자에게 안심시키고 팀에 가장 적합한 접근 방식을 찾도록 권장합니다. 이 모듈은 제공되는 정보의 양에 압도당하지 않고도 Flutter의 내부 운영과 어떤 측면에 주의를 기울여야 하는지 이해하는 데 유용한 참고 자료가 되도록 의도되었습니다.",
                                // Spanish
                                "Español": "En este módulo, el presentador cubre temas y funcionalidades avanzadas de Flutter, centrándose en escribir código limpio y comprender el funcionamiento interno para optimizar las aplicaciones. El video aborda posibles errores y optimizaciones, enfatizando la importancia de encontrar un equilibrio entre las mejoras de rendimiento y la legibilidad. El presentador asegura a los espectadores que la falta de optimizaciones no siempre da como resultado una mala aplicación y los alienta a encontrar un enfoque que funcione mejor para su equipo. El módulo está destinado a ser una referencia útil para comprender las operaciones de Flutter detrás de escena y qué aspectos requieren atención, sin sentirse abrumado por la cantidad de información proporcionada.",
                                // Hindi
                                "हिंदी": "इस मॉड्यूल में, प्रस्तुतकर्ता फ़्लटर के उन्नत विषयों और कार्यात्मकताओं को शामिल करता है, जो स्वच्छ कोड लिखने और ऐप्स को अनुकूलित करने के लिए आंतरिक कामकाज को समझने पर ध्यान केंद्रित करता है। वीडियो संभावित बग और अनुकूलन को संबोधित करता है, प्रदर्शन सुधार और पठनीयता के बीच संतुलन खोजने के महत्व पर जोर देता है। प्रस्तुतकर्ता दर्शकों को आश्वस्त करता है कि अनुकूलन की कमी हमेशा खराब ऐप का परिणाम नहीं होती है और उन्हें एक ऐसा तरीका खोजने के लिए प्रोत्साहित करता है जो उनकी टीम के लिए सबसे अच्छा काम करता है। मॉड्यूल का उद्देश्य फ़्लटर के पर्दे के पीछे के संचालन को समझने और किन पहलुओं पर ध्यान देने की आवश्यकता है, यह समझने के लिए एक उपयोगी संदर्भ होना है, बिना प्रदान की गई जानकारी की मात्रा से अभिभूत हुए।",
                                // Portuguese
                                "Português": "Neste módulo, o apresentador aborda os tópicos e funcionalidades avançadas do Flutter, com foco na escrita de código limpo e na compreensão do funcionamento interno para otimizar as aplicações. O vídeo aborda possíveis bugs e otimizações, enfatizando a importância de encontrar um equilíbrio entre melhorias de desempenho e legibilidade. O apresentador garante aos espectadores que a falta de otimizações nem sempre resulta numa má aplicação e incentiva-os a encontrar uma abordagem que funcione melhor para a sua equipa. O módulo pretende ser uma referência útil para compreender as operações do Flutter nos bastidores e quais os aspetos que requerem atenção, sem se sentir sobrecarregado pela quantidade de informação fornecida.",
                                // Bengali
                                "বাংলা": "এই মডিউলে, উপস্থাপক ফ্লটারের উন্নত বিষয় এবং কার্যকারিতাগুলি কভার করে, পরিষ্কার কোড লেখার উপর ফোকাস করে এবং অ্যাপগুলিকে অপ্টিমাইজ করার জন্য অভ্যন্তরীণ কাজগুলি বোঝার উপর ফোকাস করে৷ ভিডিওটি সম্ভাব্য বাগ এবং অপ্টিমাইজেশানগুলিকে সম্বোধন করে, পারফরম্যান্সের উন্নতি এবং পঠনযোগ্যতার মধ্যে একটি ভারসাম্য খোঁজার গুরুত্বের উপর জোর দেয়৷ উপস্থাপক দর্শকদের আশ্বস্ত করেন যে অপ্টিমাইজেশন অনুপস্থিত সবসময় একটি খারাপ অ্যাপে পরিণত হয় না এবং তাদের দলের জন্য সবচেয়ে ভালো কাজ করে এমন একটি পদ্ধতি খুঁজে পেতে উত্সাহিত করে। মডিউলটি প্রদত্ত তথ্যের পরিমাণ দ্বারা অভিভূত বোধ না করে পর্দার পিছনে ফ্লাটারের ক্রিয়াকলাপ এবং কোন দিকগুলিতে মনোযোগের প্রয়োজন তা বোঝার জন্য একটি দরকারী রেফারেন্স হিসাবে বোঝানো হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذه الوحدة، يتناول مقدم العرض مواضيع ووظائف متقدمة في Flutter، مع التركيز على كتابة التعليمات البرمجية النظيفة وفهم العمليات الداخلية لتحسين التطبيقات. يتناول الفيديو الأخطاء المحتملة والتحسينات، مع التأكيد على أهمية إيجاد التوازن بين تحسينات الأداء وقابلية القراءة. يطمئن مقدم العرض المشاهدين إلى أن عدم إجراء التحسينات لا يؤدي دائمًا إلى تطبيق سيئ ويشجعهم على إيجاد نهج يناسب فريقهم بشكل أفضل. تهدف الوحدة إلى أن تكون مرجعًا مفيدًا لفهم عمليات Flutter خلف الكواليس والجوانب التي تتطلب الاهتمام، دون الشعور بالإرهاق بسبب كمية المعلومات المقدمة.",
                                // Persian
                                "فارسی": "در این ماژول، ارائه دهنده موضوعات و قابلیت های پیشرفته Flutter را پوشش می دهد، با تمرکز بر نوشتن کد تمیز و درک عملکرد داخلی برای بهینه سازی برنامه ها. این ویدیو به اشکالات و بهینه‌سازی‌های احتمالی می‌پردازد و بر اهمیت یافتن تعادل بین بهبود عملکرد و خوانایی تأکید می‌کند. ارائه‌دهنده به بینندگان اطمینان می‌دهد که بهینه‌سازی‌های از دست رفته همیشه منجر به یک برنامه بد نمی‌شود و آنها را تشویق می‌کند تا رویکردی را پیدا کنند که بهترین کار را برای تیمشان داشته باشد. این ماژول یک مرجع مفید برای درک عملیات فلاتر در پشت صحنه و جنبه هایی است که نیاز به توجه دارند، بدون اینکه تحت تأثیر حجم اطلاعات ارائه شده قرار بگیرند.",
                            },
                        },
                    ]
                },
                // Section 7 : Navigation & Multiple Screens [MEALS APP]
                {
                    "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                    "Videos": [
                        // 139 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Module Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this course module, the instructor delves into the concept of navigation and multiple screens in Flutter apps, which expands on the previous single-page applications covered. The module focuses on understanding navigation and screens in Flutter, including techniques for pushing, popping pages, and adding tabs and drawers for smooth app navigation. Additionally, the module covers passing data between screens and introduces the development of a meal browsing application with various functionalities such as filtering and favoriting meals. Through this module, viewers can learn how to build visually appealing applications with new features and widgets while mastering navigation and user interaction within the app.",
                                // German
                                "Deutsch": "In diesem Kursmodul befasst sich der Kursleiter mit dem Konzept der Navigation und mehrerer Bildschirme in Flutter-Apps, das die zuvor behandelten Einzelseitenanwendungen erweitert. Das Modul konzentriert sich auf das Verständnis von Navigation und Bildschirmen in Flutter, einschließlich Techniken zum Pushen, Aufpoppen von Seiten und Hinzufügen von Registerkarten und Schubladen für eine reibungslose App-Navigation. Darüber hinaus behandelt das Modul die Datenübertragung zwischen Bildschirmen und führt in die Entwicklung einer Anwendung zum Durchsuchen von Mahlzeiten mit verschiedenen Funktionen wie dem Filtern und Favoriten von Mahlzeiten ein. In diesem Modul können die Zuschauer lernen, wie sie optisch ansprechende Anwendungen mit neuen Funktionen und Widgets erstellen und gleichzeitig die Navigation und Benutzerinteraktion innerhalb der App meistern.",
                                // Chinese
                                "中国人": "在本课程模块中，讲师将深入探讨 Flutter 应用中导航和多屏幕的概念，这扩展了之前介绍的单页应用。该模块侧重于了解 Flutter 中的导航和屏幕，包括推送、弹出页面以及添加选项卡和抽屉以实现流畅的应用导航的技术。此外，该模块还介绍了如何在屏幕之间传递数据，并介绍了如何开发具有各种功能的餐食浏览应用程序，例如筛选和收藏餐食。通过本模块，观众可以学习如何使用新功能和小部件构建具有视觉吸引力的应用程序，同时掌握应用程序内的导航和用户交互。",
                                // Russian
                                "Русский": "В этом модуле курса преподаватель углубляется в концепцию навигации и нескольких экранов в приложениях Flutter, которая расширяет предыдущие одностраничные приложения, рассмотренные. Модуль фокусируется на понимании навигации и экранов во Flutter, включая методы для нажатия, выталкивания страниц и добавления вкладок и ящиков для плавной навигации по приложению. Кроме того, модуль охватывает передачу данных между экранами и знакомит с разработкой приложения для просмотра блюд с различными функциями, такими как фильтрация и добавление блюд в избранное. С помощью этого модуля зрители могут узнать, как создавать визуально привлекательные приложения с новыми функциями и виджетами, одновременно осваивая навигацию и взаимодействие с пользователем в приложении.",
                                // French
                                "Français": "Dans ce module de cours, l'instructeur se penche sur le concept de navigation et d'écrans multiples dans les applications Flutter, qui s'appuie sur les applications monopages précédentes abordées. Le module se concentre sur la compréhension de la navigation et des écrans dans Flutter, y compris les techniques de poussée, d'affichage de pages et d'ajout d'onglets et de tiroirs pour une navigation fluide dans les applications. De plus, le module couvre le transfert de données entre les écrans et présente le développement d'une application de navigation de repas avec diverses fonctionnalités telles que le filtrage et la mise en favoris des repas. Grâce à ce module, les spectateurs peuvent apprendre à créer des applications visuellement attrayantes avec de nouvelles fonctionnalités et de nouveaux widgets tout en maîtrisant la navigation et l'interaction utilisateur au sein de l'application.",
                                // Japanese
                                "日本語": "このコース モジュールでは、講師が Flutter アプリのナビゲーションと複数画面の概念について詳しく説明します。これは、これまで取り上げたシングル ページ アプリケーションを拡張したものです。このモジュールでは、Flutter のナビゲーションと画面を理解することに重点を置いています。これには、ページのプッシュ、ポップ、タブとドロワーの追加など、スムーズなアプリ ナビゲーションを実現するテクニックが含まれます。さらに、このモジュールでは画面間でのデータの受け渡しについて取り上げ、食事のフィルタリングやお気に入り登録などのさまざまな機能を備えた食事閲覧アプリケーションの開発を紹介します。このモジュールを通じて、視聴者は新しい機能やウィジェットを備えた視覚的に魅力的なアプリケーションを構築する方法を学びながら、アプリ内でのナビゲーションとユーザー インタラクションを習得できます。",
                                // Korean
                                "한국인": "이 과정 모듈에서 강사는 이전에 다룬 단일 페이지 애플리케이션을 확장하여 Flutter 앱의 탐색 및 여러 화면 개념을 탐구합니다. 이 모듈은 Flutter의 탐색 및 화면을 이해하는 데 중점을 두고 있으며, 여기에는 푸시, 페이지 팝, 탭 및 서랍을 추가하여 매끄러운 앱 탐색을 위한 기술이 포함됩니다. 또한 이 모듈은 화면 간 데이터 전달을 다루고 필터링 및 식사 즐겨찾기와 같은 다양한 기능이 있는 식사 탐색 애플리케이션 개발을 소개합니다. 이 모듈을 통해 시청자는 앱 내에서 탐색 및 사용자 상호 작용을 마스터하는 동시에 새로운 기능과 위젯을 사용하여 시각적으로 매력적인 애플리케이션을 만드는 방법을 배울 수 있습니다.",
                                // Spanish
                                "Español": "En este módulo del curso, el instructor profundiza en el concepto de navegación y pantallas múltiples en las aplicaciones Flutter, lo que amplía las aplicaciones de una sola página cubiertas anteriormente. El módulo se centra en comprender la navegación y las pantallas en Flutter, incluidas las técnicas para empujar, hacer estallar páginas y agregar pestañas y cajones para una navegación fluida en la aplicación. Además, el módulo cubre el paso de datos entre pantallas y presenta el desarrollo de una aplicación de navegación de comidas con varias funcionalidades, como filtrar y marcar comidas como favoritas. A través de este módulo, los espectadores pueden aprender a crear aplicaciones visualmente atractivas con nuevas funciones y widgets mientras dominan la navegación y la interacción del usuario dentro de la aplicación.",
                                // Hindi
                                "हिंदी": "इस कोर्स मॉड्यूल में, प्रशिक्षक फ़्लटर ऐप में नेविगेशन और कई स्क्रीन की अवधारणा पर गहन चर्चा करता है, जो पिछले कवर किए गए सिंगल-पेज एप्लिकेशन पर विस्तार करता है। मॉड्यूल फ़्लटर में नेविगेशन और स्क्रीन को समझने पर ध्यान केंद्रित करता है, जिसमें पुश करने, पेज पॉप करने और सुचारू ऐप नेविगेशन के लिए टैब और ड्रॉअर जोड़ने की तकनीकें शामिल हैं। इसके अतिरिक्त, मॉड्यूल स्क्रीन के बीच डेटा पास करने को कवर करता है और भोजन को फ़िल्टर करने और पसंदीदा बनाने जैसी विभिन्न कार्यक्षमताओं के साथ भोजन ब्राउज़िंग एप्लिकेशन के विकास का परिचय देता है। इस मॉड्यूल के माध्यम से, दर्शक सीख सकते हैं कि ऐप के भीतर नेविगेशन और उपयोगकर्ता इंटरैक्शन में महारत हासिल करते हुए नई सुविधाओं और विजेट के साथ आकर्षक एप्लिकेशन कैसे बनाएं।",
                                // Portuguese
                                "Português": "Neste módulo do curso, o instrutor aprofunda o conceito de navegação e múltiplos ecrãs nas aplicações Flutter, que expande as aplicações de página única abordadas anteriormente. O módulo centra-se na compreensão da navegação e dos ecrãs no Flutter, incluindo técnicas para empurrar, abrir páginas e adicionar separadores e gavetas para uma navegação tranquila na aplicação. Adicionalmente, o módulo abrange a passagem de dados entre ecrãs e introduz o desenvolvimento de uma aplicação de navegação de refeições com diversas funcionalidades como filtrar e favoritar refeições. Através deste módulo, os visualizadores podem aprender como construir aplicações visualmente apelativas com novas funcionalidades e widgets enquanto dominam a navegação e a interação do utilizador dentro da aplicação.",
                                // Bengali
                                "বাংলা": "এই কোর্স মডিউলে, প্রশিক্ষক ফ্লাটার অ্যাপে নেভিগেশন এবং একাধিক স্ক্রীনের ধারণা নিয়ে আলোচনা করেন, যা কভার করা আগের একক-পৃষ্ঠার অ্যাপ্লিকেশনগুলিতে প্রসারিত হয়। মডিউলটি ফ্লটারে নেভিগেশন এবং স্ক্রিন বোঝার উপর ফোকাস করে, যার মধ্যে ঠেলাঠেলি, পৃষ্ঠাগুলি পপিং করার কৌশল এবং মসৃণ অ্যাপ নেভিগেশনের জন্য ট্যাব এবং ড্রয়ার যোগ করা। অতিরিক্তভাবে, মডিউলটি স্ক্রিনগুলির মধ্যে পাস করা ডেটা কভার করে এবং বিভিন্ন কার্যকারিতা যেমন ফিল্টারিং এবং পছন্দের খাবারের সাথে একটি খাবার ব্রাউজিং অ্যাপ্লিকেশনের বিকাশের পরিচয় দেয়। এই মডিউলটির মাধ্যমে, দর্শকরা অ্যাপের মধ্যে নেভিগেশন এবং ব্যবহারকারীর ইন্টারঅ্যাকশন আয়ত্ত করার সাথে সাথে নতুন বৈশিষ্ট্য এবং উইজেটগুলির সাথে দৃশ্যমান আকর্ষণীয় অ্যাপ্লিকেশনগুলি কীভাবে তৈরি করতে হয় তা শিখতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "في وحدة الدورة التدريبية هذه، يتعمق المدرب في مفهوم التنقل والشاشات المتعددة في تطبيقات Flutter، وهو ما يوسع من تطبيقات الصفحة الواحدة التي تم تناولها سابقًا. تركز الوحدة على فهم التنقل والشاشات في Flutter، بما في ذلك تقنيات الدفع وفتح الصفحات وإضافة علامات التبويب والأدراج للتنقل السلس في التطبيق. بالإضافة إلى ذلك، تغطي الوحدة تمرير البيانات بين الشاشات وتقدم تطوير تطبيق تصفح الوجبات مع وظائف مختلفة مثل تصفية الوجبات وإضافتها إلى المفضلة. من خلال هذه الوحدة، يمكن للمشاهدين تعلم كيفية إنشاء تطبيقات جذابة بصريًا بميزات وأدوات جديدة أثناء إتقان التنقل والتفاعل مع المستخدم داخل التطبيق.",
                                // Persian
                                "فارسی": "در این ماژول دوره، مدرس به مفهوم ناوبری و چند صفحه نمایش در برنامه های Flutter می پردازد، که در برنامه های تک صفحه ای قبلی که پوشش داده شده بود، گسترش می یابد. این ماژول بر درک ناوبری و صفحه نمایش در Flutter تمرکز دارد، از جمله تکنیک هایی برای فشار دادن، باز کردن صفحات، و افزودن زبانه ها و کشوها برای ناوبری نرم افزارها. علاوه بر این، ماژول انتقال داده ها بین صفحه نمایش ها را پوشش می دهد و توسعه یک برنامه مرور غذا را با قابلیت های مختلف مانند فیلتر کردن و غذاهای دلخواه معرفی می کند. از طریق این ماژول، بینندگان می توانند یاد بگیرند که چگونه برنامه های بصری جذاب با ویژگی ها و ویجت های جدید بسازند و در عین حال بر ناوبری و تعامل کاربر در برنامه مسلط شوند.",
                            },
                        },
                        // 140 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Planning the App",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor outlines the plan for building a multi-screen app that includes various functionalities and navigation options. The app will feature a hamburger icon in the app bar for accessing different sections, a backdrop menu with links to the meals page and settings page. The default meals page will include tabs for all meal categories and favorite meals, with the ability to mark meals as favorites. The video discusses the flow of navigating through screens, viewing recipes, and accessing settings, with a focus on passing data between screens for a seamless user experience. The instructional video aims to create a comprehensive and realistic application, highlighting the tools and capabilities provided by Flutter for building such complex apps.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Kursleiter den Plan zum Erstellen einer Multi-Screen-App mit verschiedenen Funktionen und Navigationsoptionen. Die App verfügt über ein Hamburger-Symbol in der App-Leiste zum Zugriff auf verschiedene Abschnitte sowie ein Hintergrundmenü mit Links zur Seite mit Mahlzeiten und zur Seite mit den Einstellungen. Die Seite mit den Standardmahlzeiten enthält Registerkarten für alle Mahlzeitenkategorien und Lieblingsmahlzeiten mit der Möglichkeit, Mahlzeiten als Favoriten zu markieren. Das Video erläutert den Ablauf der Navigation durch Bildschirme, das Anzeigen von Rezepten und den Zugriff auf Einstellungen, wobei der Schwerpunkt auf der Datenübertragung zwischen Bildschirmen für ein nahtloses Benutzererlebnis liegt. Das Lehrvideo zielt darauf ab, eine umfassende und realistische Anwendung zu erstellen, die die von Flutter bereitgestellten Tools und Funktionen zum Erstellen derart komplexer Apps hervorhebt.",
                                // Chinese
                                "中国人": "在本视频中，讲师概述了构建包含各种功能和导航选项的多屏应用的计划。该应用将在应用栏中显示一个汉堡图标，用于访问不同的部分，背景菜单包含指向餐点页面和设置页面的链接。默认餐点页面将包含所有餐点类别和喜爱餐点的选项卡，并能够将餐点标记为收藏。该视频讨论了在屏幕之间导航、查看食谱和访问设置的流程，重点介绍了在屏幕之间传递数据以实现无缝的用户体验。该教学视频旨在创建一个全面而逼真的应用程序，重点介绍了 Flutter 为构建此类复杂应用提供的工具和功能。",
                                // Russian
                                "Русский": "В этом видео инструктор излагает план создания многоэкранного приложения, включающего различные функции и параметры навигации. Приложение будет иметь значок гамбургера на панели приложения для доступа к различным разделам, фоновое меню со ссылками на страницу блюд и страницу настроек. Страница блюд по умолчанию будет включать вкладки для всех категорий блюд и избранных блюд с возможностью отмечать блюда как избранные. В видео обсуждается поток навигации по экранам, просмотр рецептов и доступ к настройкам с акцентом на передачу данных между экранами для бесперебойного пользовательского опыта. Целью обучающего видео является создание всеобъемлющего и реалистичного приложения, подчеркивающего инструменты и возможности, предоставляемые Flutter для создания таких сложных приложений.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur décrit le plan de création d'une application multi-écrans qui comprend diverses fonctionnalités et options de navigation. L'application comportera une icône de hamburger dans la barre d'applications pour accéder aux différentes sections, un menu d'arrière-plan avec des liens vers la page des repas et la page des paramètres. La page des repas par défaut comprendra des onglets pour toutes les catégories de repas et les repas favoris, avec la possibilité de marquer les repas comme favoris. La vidéo décrit le flux de navigation dans les écrans, la visualisation des recettes et l'accès aux paramètres, en mettant l'accent sur la transmission de données entre les écrans pour une expérience utilisateur transparente. La vidéo pédagogique vise à créer une application complète et réaliste, mettant en évidence les outils et les capacités fournis par Flutter pour créer des applications aussi complexes.",
                                // Japanese
                                "日本語": "このビデオでは、インストラクターがさまざまな機能とナビゲーション オプションを含むマルチスクリーン アプリの構築計画の概要を説明します。アプリには、さまざまなセクションにアクセスするためのアプリ バーのハンバーガー アイコン、食事ページと設定ページへのリンクを含む背景メニューが含まれます。デフォルトの食事ページには、すべての食事カテゴリとお気に入りの食事のタブが含まれ、食事をお気に入りとしてマークする機能があります。ビデオでは、画面間の移動、レシピの表示、設定へのアクセスの流れについて説明し、シームレスなユーザー エクスペリエンスのために画面間でデータを渡すことに重点を置いています。この指導ビデオの目的は、包括的で現実的なアプリケーションを作成することであり、このような複雑なアプリを構築するために Flutter が提供するツールと機能を強調しています。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 다양한 기능과 탐색 옵션을 포함하는 멀티스크린 앱을 빌드하기 위한 계획을 설명합니다. 앱에는 다양한 섹션에 액세스할 수 있는 앱 바에 햄버거 아이콘, 식사 페이지와 설정 페이지로 연결되는 배경 메뉴가 있습니다. 기본 식사 페이지에는 모든 식사 카테고리와 즐겨찾는 식사에 대한 탭이 포함되며, 식사를 즐겨찾는 것으로 표시할 수 있습니다. 이 비디오에서는 화면 간 탐색, 레시피 보기, 설정 액세스의 흐름에 대해 설명하며, 원활한 사용자 경험을 위해 화면 간에 데이터를 전달하는 데 중점을 둡니다. 교육 비디오는 포괄적이고 현실적인 애플리케이션을 만들고, 이러한 복잡한 앱을 빌드하기 위해 Flutter가 제공하는 도구와 기능을 강조하는 것을 목표로 합니다.",
                                // Spanish
                                "Español": "En este video, el instructor describe el plan para crear una aplicación multipantalla que incluye varias funcionalidades y opciones de navegación. La aplicación contará con un ícono de hamburguesa en la barra de aplicaciones para acceder a diferentes secciones, un menú de fondo con enlaces a la página de comidas y la página de configuración. La página de comidas predeterminada incluirá pestañas para todas las categorías de comidas y comidas favoritas, con la capacidad de marcar comidas como favoritas. El video analiza el flujo de navegación a través de pantallas, visualización de recetas y acceso a configuraciones, con un enfoque en pasar datos entre pantallas para una experiencia de usuario fluida. El video instructivo tiene como objetivo crear una aplicación integral y realista, destacando las herramientas y capacidades proporcionadas por Flutter para crear aplicaciones tan complejas.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक एक मल्टी-स्क्रीन ऐप बनाने की योजना की रूपरेखा प्रस्तुत करता है जिसमें विभिन्न कार्यक्षमताएँ और नेविगेशन विकल्प शामिल हैं। ऐप में विभिन्न अनुभागों तक पहुँचने के लिए ऐप बार में एक हैमबर्गर आइकन, भोजन पृष्ठ और सेटिंग पृष्ठ के लिंक के साथ एक बैकड्रॉप मेनू होगा। डिफ़ॉल्ट भोजन पृष्ठ में सभी भोजन श्रेणियों और पसंदीदा भोजन के लिए टैब शामिल होंगे, जिसमें भोजन को पसंदीदा के रूप में चिह्नित करने की क्षमता होगी। वीडियो स्क्रीन के माध्यम से नेविगेट करने, व्यंजनों को देखने और सेटिंग्स तक पहुँचने के प्रवाह पर चर्चा करता है, जिसमें एक सहज उपयोगकर्ता अनुभव के लिए स्क्रीन के बीच डेटा पास करने पर ध्यान केंद्रित किया गया है। निर्देशात्मक वीडियो का उद्देश्य एक व्यापक और यथार्थवादी एप्लिकेशन बनाना है, जो ऐसे जटिल ऐप बनाने के लिए फ़्लटर द्वारा प्रदान किए गए टूल और क्षमताओं को उजागर करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor descreve o plano para construir uma aplicação multi-ecrã que inclua diversas funcionalidades e opções de navegação. A aplicação contará com um ícone de hambúrguer na barra de aplicações para aceder a diferentes secções, um menu de fundo com links para a página de refeições e página de definições. A página de refeições padrão incluirá separadores para todas as categorias de refeições e refeições favoritas, com a possibilidade de marcar as refeições como favoritas. O vídeo discute o fluxo de navegação pelos ecrãs, a visualização de receitas e o acesso às definições, com foco na passagem de dados entre ecrãs para uma experiência de utilizador perfeita. O vídeo instrutivo visa criar uma aplicação abrangente e realista, destacando as ferramentas e recursos fornecidos pelo Flutter para a construção de aplicações tão complexas.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক একটি মাল্টি-স্ক্রিন অ্যাপ তৈরির পরিকল্পনার রূপরেখা দিয়েছেন যাতে বিভিন্ন কার্যকারিতা এবং নেভিগেশন বিকল্প রয়েছে। অ্যাপটি বিভিন্ন বিভাগে অ্যাক্সেস করার জন্য অ্যাপ বারে একটি হ্যামবার্গার আইকন, খাবারের পৃষ্ঠা এবং সেটিংস পৃষ্ঠার লিঙ্ক সহ একটি ব্যাকড্রপ মেনু থাকবে। ডিফল্ট খাবারের পৃষ্ঠায় খাবারের পছন্দের হিসাবে চিহ্নিত করার ক্ষমতা সহ সমস্ত খাবারের বিভাগ এবং প্রিয় খাবারের জন্য ট্যাব অন্তর্ভুক্ত থাকবে। ভিডিওটি একটি নির্বিঘ্ন ব্যবহারকারীর অভিজ্ঞতার জন্য স্ক্রিনগুলির মধ্যে ডেটা পাস করার উপর ফোকাস সহ স্ক্রীনগুলির মাধ্যমে নেভিগেট করার, রেসিপিগুলি দেখার এবং সেটিংস অ্যাক্সেস করার প্রবাহ নিয়ে আলোচনা করে৷ নির্দেশমূলক ভিডিওটির লক্ষ্য একটি ব্যাপক এবং বাস্তবসম্মত অ্যাপ্লিকেশন তৈরি করা, যা এই ধরনের জটিল অ্যাপ তৈরির জন্য Flutter দ্বারা প্রদত্ত সরঞ্জাম এবং ক্ষমতাগুলিকে হাইলাইট করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المدرب خطة بناء تطبيق متعدد الشاشات يتضمن وظائف وخيارات تنقل متنوعة. سيحتوي التطبيق على أيقونة همبرغر في شريط التطبيق للوصول إلى أقسام مختلفة، وقائمة خلفية بها روابط لصفحة الوجبات وصفحة الإعدادات. ستتضمن صفحة الوجبات الافتراضية علامات تبويب لجميع فئات الوجبات والوجبات المفضلة، مع إمكانية وضع علامة على الوجبات كمفضلة. يناقش الفيديو تدفق التنقل عبر الشاشات وعرض الوصفات والوصول إلى الإعدادات، مع التركيز على تمرير البيانات بين الشاشات للحصول على تجربة مستخدم سلسة. يهدف الفيديو التعليمي إلى إنشاء تطبيق شامل وواقعي، مع تسليط الضوء على الأدوات والقدرات التي توفرها Flutter لبناء مثل هذه التطبيقات المعقدة.",
                                // Persian
                                "فارسی": "در این ویدئو، مدرس طرح ساخت یک اپلیکیشن چند صفحه‌ای را که شامل قابلیت‌های مختلف و گزینه‌های ناوبری می‌شود، تشریح می‌کند. این برنامه یک نماد همبرگر را در نوار برنامه برای دسترسی به بخش‌های مختلف، یک منوی پس‌زمینه با پیوندهایی به صفحه غذا و صفحه تنظیمات نشان می‌دهد. صفحه پیش‌فرض وعده‌های غذایی شامل برگه‌هایی برای همه دسته‌های وعده‌های غذایی و وعده‌های غذایی مورد علاقه، با قابلیت علامت‌گذاری وعده‌های غذایی به‌عنوان دلخواه خواهد بود. این ویدئو جریان پیمایش در صفحه نمایش، مشاهده دستور العمل ها و دسترسی به تنظیمات را با تمرکز بر انتقال داده ها بین صفحه نمایش ها برای تجربه کاربری یکپارچه مورد بحث قرار می دهد. هدف این ویدیوی آموزشی ایجاد یک برنامه کاربردی جامع و واقعی است که ابزارها و قابلیت های ارائه شده توسط Flutter برای ساخت چنین برنامه های پیچیده ای را برجسته می کند.",
                            },
                        },
                        // 141 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Starting With The App - Adding Base Data",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the instructor explains the process of building a Flutter application starting with setting up a screen to display categories of meals. The video covers creating a grid layout with GridView, defining a Category class with ID, title, and color properties, creating dummy data for the categories, and ensuring immutability of objects in the data list. The video emphasizes the importance of structuring the layout using gridDelegate and provides a step-by-step guide on designing the look of the grid and rendering the categories on the screen. Additionally, the video introduces the concept of models and data management in Flutter applications.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Kursleiter den Prozess der Erstellung einer Flutter-Anwendung, beginnend mit dem Einrichten eines Bildschirms zur Anzeige von Essenskategorien. Das Video behandelt das Erstellen eines Rasterlayouts mit GridView, das Definieren einer Kategorieklasse mit ID-, Titel- und Farbeigenschaften, das Erstellen von Dummy-Daten für die Kategorien und das Sicherstellen der Unveränderlichkeit von Objekten in der Datenliste. Das Video betont die Bedeutung der Strukturierung des Layouts mit gridDelegate und bietet eine Schritt-für-Schritt-Anleitung zum Entwerfen des Aussehens des Rasters und zum Rendern der Kategorien auf dem Bildschirm. Darüber hinaus führt das Video in das Konzept von Modellen und Datenverwaltung in Flutter-Anwendungen ein.",
                                // Chinese
                                "中国人": "在本视频中，讲师将介绍构建 Flutter 应用程序的过程，从设置屏幕以显示餐食类别开始。视频介绍了如何使用 GridView 创建网格布局、使用 ID、标题和颜色属性定义 Category 类、为类别创建虚拟数据以及确保数据列表中对象的不变性。视频强调了使用 gridDelegate 构建布局的重要性，并提供了设计网格外观和在屏幕上呈现类别的分步指南。此外，视频还介绍了 Flutter 应用程序中的模型和数据管理概念。",
                                // Russian
                                "Русский": "В этом видео инструктор объясняет процесс создания приложения Flutter, начиная с настройки экрана для отображения категорий блюд. Видео охватывает создание макета сетки с помощью GridView, определение класса Category со свойствами ID, title и color, создание фиктивных данных для категорий и обеспечение неизменности объектов в списке данных. Видео подчеркивает важность структурирования макета с помощью gridDelegate и предоставляет пошаговое руководство по проектированию внешнего вида сетки и отображению категорий на экране. Кроме того, видео знакомит с концепцией моделей и управления данными в приложениях Flutter.",
                                // French
                                "Français": "Dans cette vidéo, l'instructeur explique le processus de création d'une application Flutter en commençant par la configuration d'un écran pour afficher les catégories de repas. La vidéo couvre la création d'une mise en page de grille avec GridView, la définition d'une classe Category avec des propriétés d'ID, de titre et de couleur, la création de données factices pour les catégories et la garantie de l'immuabilité des objets dans la liste de données. La vidéo souligne l'importance de structurer la mise en page à l'aide de gridDelegate et fournit un guide étape par étape sur la conception de l'apparence de la grille et le rendu des catégories à l'écran. De plus, la vidéo présente le concept de modèles et de gestion des données dans les applications Flutter.",
                                // Japanese
                                "日本語": "このビデオでは、インストラクターが、食事のカテゴリを表示する画面の設定から始めて、Flutter アプリケーションを構築するプロセスについて説明します。ビデオでは、GridView を使用したグリッド レイアウトの作成、ID、タイトル、および色のプロパティを持つ Category クラスの定義、カテゴリのダミー データの作成、およびデータ リスト内のオブジェクトの不変性の確保について説明します。ビデオでは、gridDelegate を使用してレイアウトを構造化することの重要性を強調し、グリッドの外観を設計して画面にカテゴリをレンダリングするための手順を説明しています。さらに、ビデオでは、Flutter アプリケーションにおけるモデルとデータ管理の概念についても紹介しています。",
                                // Korean
                                "한국인": "이 비디오에서 강사는 식사 카테고리를 표시하는 화면을 설정하는 것으로 시작하는 Flutter 애플리케이션을 빌드하는 프로세스를 설명합니다. 이 비디오는 GridView를 사용하여 그리드 레이아웃을 만들고, ID, 제목 및 색상 속성이 있는 Category 클래스를 정의하고, 카테고리에 대한 더미 데이터를 만들고, 데이터 목록에서 객체의 불변성을 보장하는 방법을 다룹니다. 이 비디오는 gridDelegate를 사용하여 레이아웃을 구조화하는 것의 중요성을 강조하고 그리드의 모양을 디자인하고 화면에 카테고리를 렌더링하는 방법에 대한 단계별 가이드를 제공합니다. 또한 이 비디오는 Flutter 애플리케이션에서 모델과 데이터 관리의 개념을 소개합니다.",
                                // Spanish
                                "Español": "En este video, el instructor explica el proceso de creación de una aplicación Flutter, comenzando por configurar una pantalla para mostrar categorías de comidas. El video cubre la creación de un diseño de cuadrícula con GridView, la definición de una clase Category con propiedades de ID, título y color, la creación de datos ficticios para las categorías y la garantía de la inmutabilidad de los objetos en la lista de datos. El video enfatiza la importancia de estructurar el diseño con gridDelegate y proporciona una guía paso a paso sobre el diseño del aspecto de la cuadrícula y la representación de las categorías en la pantalla. Además, el video presenta el concepto de modelos y administración de datos en aplicaciones Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रशिक्षक फ़्लटर एप्लिकेशन बनाने की प्रक्रिया को समझाता है, जिसमें भोजन की श्रेणियों को प्रदर्शित करने के लिए स्क्रीन सेट अप करना शामिल है। वीडियो में ग्रिड व्यू के साथ ग्रिड लेआउट बनाना, आईडी, शीर्षक और रंग गुणों के साथ एक श्रेणी वर्ग को परिभाषित करना, श्रेणियों के लिए डमी डेटा बनाना और डेटा सूची में ऑब्जेक्ट की अपरिवर्तनीयता सुनिश्चित करना शामिल है। वीडियो ग्रिडडेलीगेट का उपयोग करके लेआउट को संरचित करने के महत्व पर जोर देता है और ग्रिड के लुक को डिजाइन करने और स्क्रीन पर श्रेणियों को प्रस्तुत करने के बारे में चरण-दर-चरण मार्गदर्शिका प्रदान करता है। इसके अतिरिक्त, वीडियो फ़्लटर एप्लिकेशन में मॉडल और डेटा प्रबंधन की अवधारणा का परिचय देता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o instrutor explica o processo de construção de uma aplicação Flutter começando pela configuração de um ecrã para exibir categorias de refeições. O vídeo aborda a criação de um layout de grelha com o GridView, a definição de uma classe de categoria com propriedades de ID, título e cor, a criação de dados fictícios para as categorias e a garantia da imutabilidade dos objetos na lista de dados. O vídeo enfatiza a importância de estruturar o layout utilizando o gridDelegate e fornece um guia passo a passo sobre como projetar a aparência da grelha e renderizar as categorias no ecrã. Além disso, o vídeo apresenta o conceito de modelos e gestão de dados em aplicações Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, প্রশিক্ষক খাবারের বিভাগগুলি প্রদর্শন করার জন্য একটি স্ক্রিন সেট আপ করার সাথে শুরু করে একটি ফ্লটার অ্যাপ্লিকেশন তৈরির প্রক্রিয়া ব্যাখ্যা করেছেন। ভিডিওটি গ্রিডভিউ দিয়ে একটি গ্রিড বিন্যাস তৈরি করা, আইডি, শিরোনাম এবং রঙের বৈশিষ্ট্য সহ একটি বিভাগ শ্রেণি সংজ্ঞায়িত করা, বিভাগগুলির জন্য ডামি ডেটা তৈরি করা এবং ডেটা তালিকায় অবজেক্টের অপরিবর্তনীয়তা নিশ্চিত করা কভার করে। ভিডিওটি গ্রিডডেলিগেট ব্যবহার করে লেআউট গঠনের গুরুত্বের উপর জোর দেয় এবং গ্রিডের চেহারা ডিজাইন করা এবং স্ক্রিনে বিভাগগুলি রেন্ডার করার জন্য একটি ধাপে ধাপে নির্দেশিকা প্রদান করে। উপরন্তু, ভিডিওটি ফ্লটার অ্যাপ্লিকেশনে মডেল এবং ডেটা ম্যানেজমেন্টের ধারণা উপস্থাপন করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المدرب عملية بناء تطبيق Flutter بدءًا من إعداد شاشة لعرض فئات الوجبات. ويغطي الفيديو إنشاء تخطيط شبكة باستخدام GridView، وتحديد فئة Category بخصائص ID وtitle وcolor، وإنشاء بيانات وهمية للفئات، وضمان ثبات الكائنات في قائمة البيانات. ويؤكد الفيديو على أهمية هيكلة التخطيط باستخدام gridDelegate ويوفر دليلًا خطوة بخطوة حول تصميم مظهر الشبكة وعرض الفئات على الشاشة. بالإضافة إلى ذلك، يقدم الفيديو مفهوم النماذج وإدارة البيانات في تطبيقات Flutter.",
                                // Persian
                                "فارسی": "در این ویدئو، مربی روند ساخت اپلیکیشن فلاتر را با تنظیم صفحه نمایش برای نمایش دسته‌بندی‌های وعده‌های غذایی، توضیح می‌دهد. این ویدیو شامل ایجاد یک طرح بندی شبکه با GridView، تعریف کلاس Category با ویژگی های ID، عنوان و رنگ، ایجاد داده های ساختگی برای دسته ها، و اطمینان از تغییر ناپذیری اشیاء در لیست داده ها است. این ویدئو بر اهمیت ساختار بندی طرح با استفاده از gridDelegate تاکید می کند و راهنمای گام به گام طراحی ظاهر شبکه و ارائه دسته ها بر روی صفحه را ارائه می دهد. علاوه بر این، این ویدئو مفهوم مدل‌ها و مدیریت داده‌ها را در برنامه‌های Flutter معرفی می‌کند.",
                            },
                        },
                        // 142 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Creating a Grid & Working with Linear Gradients",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video tutorial, the instructor focuses on creating category items for a Flutter application. The video covers the process of creating a separate file for the category_item widget, which will output a single category item in the grid of categories. The instructor explains the design and structure of the category item widget, including setting up the layout, using containers for padding, and adding text widgets for displaying category titles. Additionally, the video delves into styling the category item with background colors, gradients, and border radius. The instructor also demonstrates how to use dummy data to render multiple category items in the categories screen by mapping data to widgets. Throughout the video, the instructor provides detailed explanations and step-by-step instructions on creating and implementing category items in the Flutter application.",
                                // German
                                "Deutsch": "In diesem Video-Tutorial konzentriert sich der Kursleiter auf das Erstellen von Kategorieelementen für eine Flutter-Anwendung. Das Video behandelt den Prozess des Erstellens einer separaten Datei für das Widget „category_item“, das ein einzelnes Kategorieelement im Kategorienraster ausgibt. Der Kursleiter erklärt das Design und die Struktur des Kategorieelement-Widgets, einschließlich der Einrichtung des Layouts, der Verwendung von Containern zum Auffüllen und des Hinzufügens von Text-Widgets zum Anzeigen von Kategorietiteln. Darüber hinaus geht das Video auf das Stylen des Kategorieelements mit Hintergrundfarben, Farbverläufen und Rahmenradius ein. Der Kursleiter demonstriert auch, wie man Dummy-Daten verwendet, um mehrere Kategorieelemente im Kategorienbildschirm darzustellen, indem man Daten Widgets zuordnet. Während des gesamten Videos liefert der Kursleiter detaillierte Erklärungen und schrittweise Anleitungen zum Erstellen und Implementieren von Kategorieelementen in der Flutter-Anwendung.",
                                // Chinese
                                "中国人": "在本视频教程中，讲师重点介绍如何为 Flutter 应用程序创建类别项目。视频介绍了为 category_item 小部件创建单独文件的过程，该文件将在类别网格中输出单个类别项目。讲师讲解了类别项目小部件的设计和结构，包括设置布局、使用容器进行填充以及添加文本小部件以显示类别标题。此外，视频还深入介绍了使用背景颜色、渐变和边框半径来设置类别项目的样式。讲师还演示了如何使用虚拟数据通过将数据映射到小部件来在类别屏幕中呈现多个类别项目。在整个视频中，讲师提供了有关在 Flutter 应用程序中创建和实现类别项目的详细说明和分步说明。",
                                // Russian
                                "Русский": "В этом видеоуроке инструктор фокусируется на создании элементов категории для приложения Flutter. Видео охватывает процесс создания отдельного файла для виджета category_item, который будет выводить один элемент категории в сетке категорий. Инструктор объясняет дизайн и структуру виджета элемента категории, включая настройку макета, использование контейнеров для отступов и добавление текстовых виджетов для отображения названий категорий. Кроме того, видео углубляется в стилизацию элемента категории с помощью фоновых цветов, градиентов и радиуса границы. Инструктор также демонстрирует, как использовать фиктивные данные для отображения нескольких элементов категории на экране категорий путем сопоставления данных с виджетами. На протяжении всего видео инструктор дает подробные объяснения и пошаговые инструкции по созданию и внедрению элементов категории в приложение Flutter.",
                                // French
                                "Français": "Dans ce didacticiel vidéo, l'instructeur se concentre sur la création d'éléments de catégorie pour une application Flutter. La vidéo couvre le processus de création d'un fichier distinct pour le widget category_item, qui générera un seul élément de catégorie dans la grille de catégories. L'instructeur explique la conception et la structure du widget d'élément de catégorie, y compris la configuration de la mise en page, l'utilisation de conteneurs pour le remplissage et l'ajout de widgets de texte pour afficher les titres de catégorie. En outre, la vidéo se penche sur le style de l'élément de catégorie avec des couleurs d'arrière-plan, des dégradés et un rayon de bordure. L'instructeur montre également comment utiliser des données factices pour afficher plusieurs éléments de catégorie dans l'écran des catégories en mappant des données à des widgets. Tout au long de la vidéo, l'instructeur fournit des explications détaillées et des instructions étape par étape sur la création et l'implémentation d'éléments de catégorie dans l'application Flutter.",
                                // Japanese
                                "日本語": "このビデオ チュートリアルでは、講師は Flutter アプリケーションのカテゴリ アイテムの作成に焦点を当てています。ビデオでは、カテゴリ グリッドに 1 つのカテゴリ アイテムを出力する category_item ウィジェットの別のファイルを作成するプロセスについて説明します。講師は、レイアウトの設定、パディング用のコンテナーの使用、カテゴリ タイトルを表示するためのテキスト ウィジェットの追加など、カテゴリ アイテム ウィジェットの設計と構造について説明します。さらに、ビデオでは、背景色、グラデーション、境界線の半径を使用してカテゴリ アイテムをスタイル設定する方法についても詳しく説明します。また、ダミー データを使用してウィジェットにデータをマッピングし、カテゴリ画面に複数のカテゴリ アイテムをレンダリングする方法も示します。ビデオ全体を通して、講師は Flutter アプリケーションでカテゴリ アイテムを作成して実装する詳細な説明と手順を説明します。",
                                // Korean
                                "한국인": "이 비디오 튜토리얼에서 강사는 Flutter 애플리케이션의 카테고리 항목을 만드는 데 중점을 둡니다. 이 비디오는 카테고리 그리드에 단일 카테고리 항목을 출력하는 category_item 위젯에 대한 별도 파일을 만드는 프로세스를 다룹니다. 강사는 레이아웃 설정, 패딩을 위한 컨테이너 사용, 카테고리 제목을 표시하기 위한 텍스트 위젯 추가를 포함하여 카테고리 항목 위젯의 디자인과 구조를 설명합니다. 또한 이 비디오는 배경색, 그라데이션 및 테두리 반경으로 카테고리 항목의 스타일을 지정하는 방법을 자세히 설명합니다. 강사는 또한 데이터를 위젯에 매핑하여 더미 데이터를 사용하여 카테고리 화면에서 여러 카테고리 항목을 렌더링하는 방법을 보여줍니다. 비디오 전체에서 강사는 Flutter 애플리케이션에서 카테고리 항목을 만들고 구현하는 방법에 대한 자세한 설명과 단계별 지침을 제공합니다.",
                                // Spanish
                                "Español": "En este videotutorial, el instructor se centra en la creación de elementos de categoría para una aplicación Flutter. El video cubre el proceso de creación de un archivo independiente para el widget category_item, que generará un solo elemento de categoría en la cuadrícula de categorías. El instructor explica el diseño y la estructura del widget de elemento de categoría, incluida la configuración del diseño, el uso de contenedores para el relleno y la adición de widgets de texto para mostrar los títulos de las categorías. Además, el video profundiza en el estilo del elemento de categoría con colores de fondo, degradados y radio de borde. El instructor también demuestra cómo usar datos ficticios para representar múltiples elementos de categoría en la pantalla de categorías mediante la asignación de datos a widgets. A lo largo del video, el instructor brinda explicaciones detalladas e instrucciones paso a paso sobre la creación e implementación de elementos de categoría en la aplicación Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो ट्यूटोरियल में, प्रशिक्षक फ़्लटर एप्लिकेशन के लिए श्रेणी आइटम बनाने पर ध्यान केंद्रित करता है। वीडियो में कैटेगरी_आइटम विजेट के लिए एक अलग फ़ाइल बनाने की प्रक्रिया को शामिल किया गया है, जो श्रेणियों के ग्रिड में एक एकल श्रेणी आइटम आउटपुट करेगा। प्रशिक्षक श्रेणी आइटम विजेट के डिज़ाइन और संरचना की व्याख्या करता है, जिसमें लेआउट सेट करना, पैडिंग के लिए कंटेनर का उपयोग करना और श्रेणी शीर्षक प्रदर्शित करने के लिए टेक्स्ट विजेट जोड़ना शामिल है। इसके अतिरिक्त, वीडियो बैकग्राउंड कलर, ग्रेडिएंट और बॉर्डर रेडियस के साथ श्रेणी आइटम को स्टाइल करने के बारे में बताता है। प्रशिक्षक यह भी प्रदर्शित करता है कि डेटा को विजेट में मैप करके श्रेणियों की स्क्रीन में कई श्रेणी आइटम रेंडर करने के लिए डमी डेटा का उपयोग कैसे करें। पूरे वीडियो में, प्रशिक्षक फ़्लटर एप्लिकेशन में श्रेणी आइटम बनाने और लागू करने के बारे में विस्तृत स्पष्टीकरण और चरण-दर-चरण निर्देश प्रदान करता है।",
                                // Portuguese
                                "Português": "Neste tutorial em vídeo, o instrutor concentra-se na criação de itens de categoria para uma aplicação Flutter. O vídeo aborda o processo de criação de um ficheiro separado para o widget category_item, que irá gerar um único item de categoria na grelha de categorias. O instrutor explica o design e a estrutura do widget de itens de categoria, incluindo a configuração do layout, a utilização de contentores para o preenchimento e a adição de widgets de texto para exibir os títulos das categorias. Além disso, o vídeo investiga o estilo do item da categoria com cores de fundo, gradientes e raio da borda. O instrutor também demonstra como utilizar dados fictícios para renderizar vários itens de categoria no ecrã de categorias, mapeando os dados para widgets. Ao longo do vídeo, o instrutor fornece explicações detalhadas e instruções passo a passo sobre como criar e implementar itens de categoria na aplicação Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিও টিউটোরিয়ালে, প্রশিক্ষক একটি ফ্লাটার অ্যাপ্লিকেশনের জন্য ক্যাটাগরি আইটেম তৈরিতে ফোকাস করেন। ভিডিওটি বিভাগ_আইটেম উইজেটের জন্য একটি পৃথক ফাইল তৈরি করার প্রক্রিয়াকে কভার করে, যা বিভাগগুলির গ্রিডে একটি একক বিভাগ আইটেম আউটপুট করবে। প্রশিক্ষক বিভাগ আইটেম উইজেটের নকশা এবং কাঠামো ব্যাখ্যা করেন, লেআউট সেট আপ করা, প্যাডিংয়ের জন্য কন্টেইনার ব্যবহার করা এবং বিভাগ শিরোনাম প্রদর্শনের জন্য পাঠ্য উইজেট যোগ করা। উপরন্তু, ভিডিওটি ব্যাকগ্রাউন্ডের রঙ, গ্রেডিয়েন্ট এবং বর্ডার ব্যাসার্ধ সহ ক্যাটাগরি আইটেমটিকে স্টাইল করার জন্য বিস্তৃত। প্রশিক্ষক আরও দেখান কিভাবে ডামি ডেটা ব্যবহার করতে হয় ক্যাটাগরি স্ক্রিনে একাধিক ক্যাটাগরির আইটেমকে উইজেটগুলিতে ম্যাপ করার মাধ্যমে। পুরো ভিডিও জুড়ে, প্রশিক্ষক ফ্লাটার অ্যাপ্লিকেশনে ক্যাটাগরি আইটেম তৈরি এবং প্রয়োগ করার বিষয়ে বিস্তারিত ব্যাখ্যা এবং ধাপে ধাপে নির্দেশনা প্রদান করেন।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو التعليمي، يركز المدرب على إنشاء عناصر فئة لتطبيق Flutter. يغطي الفيديو عملية إنشاء ملف منفصل لعنصر category_item، والذي سيخرج عنصر فئة واحد في شبكة الفئات. يشرح المدرب تصميم وبنية عنصر الفئة، بما في ذلك إعداد التخطيط واستخدام الحاويات للحشو وإضافة عناصر نصية لعرض عناوين الفئات. بالإضافة إلى ذلك، يتعمق الفيديو في تصميم عنصر الفئة بألوان الخلفية والتدرجات ونصف قطر الحدود. يوضح المدرب أيضًا كيفية استخدام البيانات الوهمية لعرض عناصر فئة متعددة في شاشة الفئات عن طريق تعيين البيانات إلى عناصر واجهة المستخدم. طوال الفيديو، يقدم المدرب تفسيرات مفصلة وتعليمات خطوة بخطوة حول إنشاء عناصر الفئة وتنفيذها في تطبيق Flutter.",
                                // Persian
                                "فارسی": "در این فیلم آموزشی، مدرس بر روی ایجاد آیتم های دسته بندی برای یک اپلیکیشن فلاتر تمرکز می کند. این ویدئو روند ایجاد یک فایل جداگانه برای ویجت category_item را پوشش می دهد که یک آیتم دسته بندی واحد را در شبکه دسته ها خروجی می دهد. مدرس طراحی و ساختار ویجت آیتم دسته را توضیح می دهد، از جمله تنظیم طرح، استفاده از ظروف برای padding، و افزودن ویجت های متنی برای نمایش عناوین دسته ها. به‌علاوه، ویدئو به طراحی آیتم دسته‌بندی با رنگ‌های پس‌زمینه، شیب‌ها و شعاع حاشیه می‌پردازد. مربی همچنین نحوه استفاده از داده‌های ساختگی را برای ارائه چندین مورد دسته‌بندی در صفحه دسته‌بندی با نگاشت داده‌ها به ویجت‌ها نشان می‌دهد. در طول ویدئو، مدرس توضیحات دقیق و دستورالعمل های گام به گام در مورد ایجاد و پیاده سازی آیتم های دسته بندی در اپلیکیشن فلاتر ارائه می دهد.",
                            },
                        },
                        // 143 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Registering a Screen as the Main Screen",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the instructor explains how to set the categories screen as the starting screen of a Flutter application by using the home argument in the main.dart file. The video demonstrates the importance of the home argument in marking the entry point of the application and explains how to point to the categories screen widget as the starting widget. The instructor emphasizes the need to import the categories screen widget and to add a scaffold widget to the categories screen for additional screen elements like an appBar. The tutorial also covers restarting the app to view the scrollable grid of categories and discusses potential improvements such as customizing text, themes, fonts, and spacing before focusing on making the categories tappable for displaying recipes.",
                                // German
                                "Deutsch": "In diesem Tutorial erklärt der Kursleiter, wie man den Kategorienbildschirm als Startbildschirm einer Flutter-Anwendung einstellt, indem man das Home-Argument in der Datei main.dart verwendet. Das Video zeigt die Bedeutung des Home-Arguments bei der Markierung des Einstiegspunkts der Anwendung und erklärt, wie man auf das Kategorienbildschirm-Widget als Start-Widget verweist. Der Kursleiter betont die Notwendigkeit, das Kategorienbildschirm-Widget zu importieren und dem Kategorienbildschirm ein Scaffold-Widget für zusätzliche Bildschirmelemente wie eine AppBar hinzuzufügen. Das Tutorial behandelt auch den Neustart der App, um das scrollbare Kategorienraster anzuzeigen, und bespricht mögliche Verbesserungen wie das Anpassen von Text, Designs, Schriftarten und Abständen, bevor es sich darauf konzentriert, die Kategorien antippbar zu machen, um Rezepte anzuzeigen.",
                                // Chinese
                                "中国人": "在本教程中，讲师将解释如何使用 main.dart 文件中的 home 参数将类别屏幕设置为 Flutter 应用程序的起始屏幕。视频演示了 home 参数在标记应用程序入口点方面的重要性，并解释了如何将类别屏幕小部件指向为起始小部件。讲师强调需要导入类别屏幕小部件，并向类别屏幕添加一个脚手架小部件，以添加 appBar 等其他屏幕元素。本教程还介绍了如何重新启动应用程序以查看可滚动的类别网格，并讨论了潜在的改进，例如自定义文本、主题、字体和间距，然后重点介绍如何使类别可点击以显示食谱。",
                                // Russian
                                "Русский": "В этом руководстве инструктор объясняет, как установить экран категорий в качестве начального экрана приложения Flutter, используя аргумент home в файле main.dart. Видео демонстрирует важность аргумента home в обозначении точки входа приложения и объясняет, как указать виджет экрана категорий в качестве начального виджета. Инструктор подчеркивает необходимость импорта виджета экрана категорий и добавления виджета scaffold на экран категорий для дополнительных элементов экрана, таких как appBar. В руководстве также рассматривается перезапуск приложения для просмотра прокручиваемой сетки категорий и обсуждаются потенциальные улучшения, такие как настройка текста, тем, шрифтов и интервалов, прежде чем сосредоточиться на том, чтобы сделать категории нажимаемыми для отображения рецептов.",
                                // French
                                "Français": "Dans ce didacticiel, l'instructeur explique comment définir l'écran des catégories comme écran de démarrage d'une application Flutter en utilisant l'argument home dans le fichier main.dart. La vidéo démontre l'importance de l'argument home pour marquer le point d'entrée de l'application et explique comment pointer vers le widget de l'écran des catégories comme widget de démarrage. L'instructeur souligne la nécessité d'importer le widget de l'écran des catégories et d'ajouter un widget d'échafaudage à l'écran des catégories pour des éléments d'écran supplémentaires comme une barre d'application. Le didacticiel couvre également le redémarrage de l'application pour afficher la grille déroulante des catégories et aborde les améliorations potentielles telles que la personnalisation du texte, des thèmes, des polices et de l'espacement avant de se concentrer sur la possibilité de toucher les catégories pour afficher des recettes.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講師が main.dart ファイルの home 引数を使用して、カテゴリ画面を Flutter アプリケーションの開始画面として設定する方法を説明します。ビデオでは、アプリケーションのエントリ ポイントをマークするための home 引数の重要性を示し、開始ウィジェットとしてカテゴリ画面ウィジェットを指定する方法を説明しています。講師は、カテゴリ画面ウィジェットをインポートし、appBar などの追加の画面要素用にカテゴリ画面にスキャフォールド ウィジェットを追加する必要性を強調しています。このチュートリアルでは、スクロール可能なカテゴリ グリッドを表示するためにアプリを再起動する方法についても説明し、テキスト、テーマ、フォント、間隔のカスタマイズなどの潜在的な改善点について説明してから、レシピを表示するためにカテゴリをタップ可能にすることに焦点を当てます。",
                                // Korean
                                "한국인": "이 튜토리얼에서 강사는 main.dart 파일에서 home 인수를 사용하여 Flutter 애플리케이션의 시작 화면으로 카테고리 화면을 설정하는 방법을 설명합니다. 이 비디오는 애플리케이션의 진입점을 표시하는 데 있어 home 인수의 중요성을 보여주고 카테고리 화면 위젯을 시작 위젯으로 가리키는 방법을 설명합니다. 강사는 카테고리 화면 위젯을 가져와서 appBar와 같은 추가 화면 요소를 위해 카테고리 화면에 스캐폴드 위젯을 추가해야 할 필요성을 강조합니다. 이 튜토리얼에서는 스크롤 가능한 카테고리 그리드를 보기 위해 앱을 다시 시작하는 방법도 다루고, 레시피를 표시하기 위해 카테고리를 탭할 수 있도록 만드는 데 집중하기 전에 텍스트, 테마, 글꼴 및 간격을 사용자 지정하는 것과 같은 잠재적인 개선 사항에 대해서도 설명합니다.",
                                // Spanish
                                "Español": "En este tutorial, el instructor explica cómo configurar la pantalla de categorías como la pantalla de inicio de una aplicación Flutter mediante el uso del argumento home en el archivo main.dart. El video demuestra la importancia del argumento home para marcar el punto de entrada de la aplicación y explica cómo señalar el widget de la pantalla de categorías como el widget de inicio. El instructor enfatiza la necesidad de importar el widget de la pantalla de categorías y agregar un widget de estructura a la pantalla de categorías para elementos de pantalla adicionales como una barra de aplicaciones. El tutorial también cubre el reinicio de la aplicación para ver la cuadrícula desplazable de categorías y analiza posibles mejoras como la personalización de texto, temas, fuentes y espaciado antes de centrarse en hacer que las categorías se puedan tocar para mostrar recetas.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, प्रशिक्षक बताता है कि main.dart फ़ाइल में होम तर्क का उपयोग करके फ़्लटर एप्लिकेशन की शुरुआती स्क्रीन के रूप में कैटेगरी स्क्रीन को कैसे सेट किया जाए। वीडियो एप्लिकेशन के प्रवेश बिंदु को चिह्नित करने में होम तर्क के महत्व को प्रदर्शित करता है और बताता है कि शुरुआती विजेट के रूप में कैटेगरी स्क्रीन विजेट को कैसे इंगित किया जाए। प्रशिक्षक कैटेगरी स्क्रीन विजेट को आयात करने और ऐपबार जैसे अतिरिक्त स्क्रीन तत्वों के लिए कैटेगरी स्क्रीन में एक स्कैफ़ोल्ड विजेट जोड़ने की आवश्यकता पर जोर देता है। ट्यूटोरियल में कैटेगरी के स्क्रॉल करने योग्य ग्रिड को देखने के लिए ऐप को फिर से शुरू करना भी शामिल है और संभावित सुधारों पर चर्चा करता है जैसे कि व्यंजनों को प्रदर्शित करने के लिए श्रेणियों को टैप करने योग्य बनाने पर ध्यान केंद्रित करने से पहले टेक्स्ट, थीम, फ़ॉन्ट और स्पेसिंग को कस्टमाइज़ करना।",
                                // Portuguese
                                "Português": "Neste tutorial, o instrutor explica como definir o ecrã de categorias como ecrã inicial de uma aplicação Flutter utilizando o argumento home no ficheiro main.dart. O vídeo demonstra a importância do argumento home na marcação do ponto de entrada da aplicação e explica como apontar o widget do ecrã de categorias como widget inicial. O instrutor enfatiza a necessidade de importar o widget do ecrã de categorias e adicionar um widget de scaffold ao ecrã de categorias para elementos adicionais do ecrã, como um appBar. O tutorial também aborda a reinicialização da aplicação para visualizar a grelha de categorias rolável e discute possíveis melhorias, como a personalização de texto, temas, tipos de letra e espaçamento, antes de se concentrar em tornar as categorias tocáveis ​​para exibir receitas.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, প্রশিক্ষক ব্যাখ্যা করেছেন কিভাবে main.dart ফাইলে হোম আর্গুমেন্ট ব্যবহার করে একটি ফ্লাটার অ্যাপ্লিকেশনের প্রারম্ভিক স্ক্রীন হিসেবে ক্যাটাগরি স্ক্রীন সেট করতে হয়। ভিডিওটি অ্যাপ্লিকেশানের এন্ট্রি পয়েন্ট চিহ্নিত করার ক্ষেত্রে হোম আর্গুমেন্টের গুরুত্ব প্রদর্শন করে এবং সূচনা উইজেট হিসাবে স্ক্রীন উইজেট বিভাগগুলিকে কীভাবে নির্দেশ করতে হয় তা ব্যাখ্যা করে৷ প্রশিক্ষক ক্যাটাগরি স্ক্রীন উইজেট ইম্পোর্ট করার এবং অ্যাপবারের মত অতিরিক্ত স্ক্রীন এলিমেন্টের জন্য ক্যাটাগরি স্ক্রিনে একটি স্ক্যাফোল্ড উইজেট যোগ করার প্রয়োজনীয়তার উপর জোর দেন। টিউটোরিয়ালটি বিভাগগুলির স্ক্রোলযোগ্য গ্রিড দেখার জন্য অ্যাপটি পুনরায় চালু করা কভার করে এবং রেসিপিগুলি প্রদর্শনের জন্য বিভাগগুলিকে ট্যাপযোগ্য করার উপর ফোকাস করার আগে পাঠ্য, থিম, ফন্ট এবং স্পেসিং কাস্টমাইজ করার মতো সম্ভাব্য উন্নতি নিয়ে আলোচনা করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يشرح المدرب كيفية تعيين شاشة الفئات كشاشة بدء لتطبيق Flutter باستخدام وسيطة home في ملف main.dart. يوضح الفيديو أهمية وسيطة home في تحديد نقطة دخول التطبيق ويشرح كيفية الإشارة إلى عنصر واجهة مستخدم شاشة الفئات كأداة بدء. يؤكد المدرب على الحاجة إلى استيراد عنصر واجهة مستخدم شاشة الفئات وإضافة عنصر واجهة مستخدم سقالة إلى شاشة الفئات للحصول على عناصر شاشة إضافية مثل شريط التطبيقات. يغطي البرنامج التعليمي أيضًا إعادة تشغيل التطبيق لعرض الشبكة القابلة للتمرير للفئات ويناقش التحسينات المحتملة مثل تخصيص النص والموضوعات والخطوط والتباعد قبل التركيز على جعل الفئات قابلة للنقر لعرض الوصفات.",
                                // Persian
                                "فارسی": "در این آموزش، مدرس نحوه تنظیم صفحه دسته ها را به عنوان صفحه شروع برنامه Flutter با استفاده از آرگومان خانه در فایل main.dart توضیح می دهد. این ویدئو اهمیت آرگومان خانه را در علامت گذاری نقطه ورود برنامه نشان می دهد و توضیح می دهد که چگونه به ویجت صفحه نمایش دسته ها به عنوان ویجت شروع اشاره کنیم. مربی بر نیاز به وارد کردن ویجت صفحه دسته‌ها و افزودن ویجت داربست به صفحه دسته‌ها برای عناصر اضافی صفحه مانند نوار برنامه تأکید می‌کند. این آموزش همچنین راه‌اندازی مجدد برنامه برای مشاهده شبکه قابل پیمایش دسته‌ها را پوشش می‌دهد و در مورد پیشرفت‌های بالقوه مانند سفارشی‌سازی متن، تم‌ها، فونت‌ها و فاصله قبل از تمرکز بر روی دسته‌ها برای نمایش دستور غذاها بحث می‌کند.",
                            },
                        },
                        // 144 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Styling & Theming",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this tutorial, the instructor focuses on styling the categories screen in a Flutter application by adding padding around the GridView and setting up a general theme with custom fonts. The tutorial covers adding font files to the assets folder, registering the fonts in the pubspec.yaml file, and configuring the theme data in the main.dart file with custom colors, fonts, and text styles. The instructor demonstrates adjusting the visual aspects of text styles for body and title in the theme, implementing the updated styles in the category_item widget, and restarting the app to view the changes. Additionally, the tutorial highlights the process of tapping on a category to navigate to a screen displaying recipes for that category, setting the stage for further development in the application.",
                                // German
                                "Deutsch": "In diesem Tutorial konzentriert sich der Kursleiter auf die Gestaltung des Kategorienbildschirms in einer Flutter-Anwendung, indem er um die GridView herum Polsterung hinzufügt und ein allgemeines Design mit benutzerdefinierten Schriftarten einrichtet. Das Tutorial behandelt das Hinzufügen von Schriftdateien zum Assets-Ordner, das Registrieren der Schriftarten in der Datei pubspec.yaml und das Konfigurieren der Designdaten in der Datei main.dart mit benutzerdefinierten Farben, Schriftarten und Textstilen. Der Kursleiter demonstriert das Anpassen der visuellen Aspekte von Textstilen für Textkörper und Titel im Design, das Implementieren der aktualisierten Stile im Widget category_item und das Neustarten der App, um die Änderungen anzuzeigen. Darüber hinaus hebt das Tutorial den Vorgang hervor, wie man durch Tippen auf eine Kategorie zu einem Bildschirm mit Rezepten für diese Kategorie navigiert und so die Grundlage für die weitere Entwicklung in der Anwendung schafft.",
                                // Chinese
                                "中国人": "在本教程中，讲师将重点介绍如何在 Flutter 应用程序中设置类别屏幕的样式，方法是在 GridView 周围添加填充并使用自定义字体设置通用主题。本教程涵盖了如何将字体文件添加到 assets 文件夹、在 pubspec.yaml 文件中注册字体以及在 main.dart 文件中使用自定义颜色、字体和文本样式配置主题数据。讲师将演示如何调整主题中正文和标题文本样式的视觉效果、在 category_item 小部件中实现更新后的样式以及重新启动应用程序以查看更改。此外，本教程还重点介绍了点击类别以导航到显示该类别食谱的屏幕的过程，为应用程序的进一步开发奠定了基础。",
                                // Russian
                                "Русский": "В этом руководстве инструктор фокусируется на стилизации экрана категорий в приложении Flutter, добавляя отступы вокруг GridView и настраивая общую тему с пользовательскими шрифтами. В руководстве рассматривается добавление файлов шрифтов в папку assets, регистрация шрифтов в файле pubspec.yaml и настройка данных темы в файле main.dart с пользовательскими цветами, шрифтами и стилями текста. Инструктор демонстрирует настройку визуальных аспектов стилей текста для тела и заголовка в теме, реализацию обновленных стилей в виджете category_item и перезапуск приложения для просмотра изменений. Кроме того, в руководстве освещается процесс нажатия на категорию для перехода на экран, отображающий рецепты для этой категории, что создает основу для дальнейшей разработки в приложении.",
                                // French
                                "Français": "Dans ce didacticiel, l'instructeur se concentre sur le style de l'écran des catégories dans une application Flutter en ajoutant un remplissage autour du GridView et en configurant un thème général avec des polices personnalisées. Le didacticiel couvre l'ajout de fichiers de polices au dossier assets, l'enregistrement des polices dans le fichier pubspec.yaml et la configuration des données de thème dans le fichier main.dart avec des couleurs, des polices et des styles de texte personnalisés. L'instructeur montre comment ajuster les aspects visuels des styles de texte pour le corps et le titre dans le thème, implémenter les styles mis à jour dans le widget category_item et redémarrer l'application pour afficher les modifications. De plus, le didacticiel met en évidence le processus consistant à appuyer sur une catégorie pour accéder à un écran affichant des recettes pour cette catégorie, préparant ainsi le terrain pour un développement ultérieur de l'application.",
                                // Japanese
                                "日本語": "このチュートリアルでは、講師は、GridView の周囲にパディングを追加し、カスタム フォントを使用して一般的なテーマを設定することで、Flutter アプリケーションのカテゴリ画面のスタイル設定に焦点を当てます。チュートリアルでは、assets フォルダーにフォント ファイルを追加し、pubspec.yaml ファイルにフォントを登録し、main.dart ファイルにカスタム カラー、フォント、テキスト スタイルを使用してテーマ データを構成する方法について説明します。講師は、テーマの本文とタイトルのテキスト スタイルの視覚的な側面を調整し、更新されたスタイルを category_item ウィジェットに実装し、アプリを再起動して変更を表示する方法を示します。さらに、チュートリアルでは、カテゴリをタップしてそのカテゴリのレシピを表示する画面に移動するプロセスを強調し、アプリケーションのさらなる開発の準備を整えます。",
                                // Korean
                                "한국인": "이 튜토리얼에서 강사는 GridView 주위에 패딩을 추가하고 사용자 정의 글꼴로 일반 테마를 설정하여 Flutter 애플리케이션에서 카테고리 화면의 스타일을 지정하는 데 중점을 둡니다. 이 튜토리얼에서는 assets 폴더에 글꼴 파일을 추가하고, pubspec.yaml 파일에 글꼴을 등록하고, main.dart 파일에 사용자 정의 색상, 글꼴 및 텍스트 스타일로 테마 데이터를 구성하는 방법을 다룹니다. 강사는 테마에서 본문과 제목의 텍스트 스타일의 시각적 측면을 조정하고, category_item 위젯에서 업데이트된 스타일을 구현하고, 앱을 다시 시작하여 변경 사항을 확인하는 방법을 보여줍니다. 또한 이 튜토리얼에서는 카테고리를 탭하여 해당 카테고리의 레시피를 표시하는 화면으로 이동하는 프로세스를 강조하여 애플리케이션에서 추가 개발을 위한 토대를 마련합니다.",
                                // Spanish
                                "Español": "En este tutorial, el instructor se centra en diseñar la pantalla de categorías en una aplicación Flutter agregando relleno alrededor de GridView y configurando un tema general con fuentes personalizadas. El tutorial cubre la adición de archivos de fuentes a la carpeta assets, el registro de las fuentes en el archivo pubspec.yaml y la configuración de los datos del tema en el archivo main.dart con colores, fuentes y estilos de texto personalizados. El instructor demuestra cómo ajustar los aspectos visuales de los estilos de texto para el cuerpo y el título en el tema, implementar los estilos actualizados en el widget category_item y reiniciar la aplicación para ver los cambios. Además, el tutorial destaca el proceso de tocar una categoría para navegar a una pantalla que muestra recetas para esa categoría, lo que prepara el escenario para un mayor desarrollo en la aplicación.",
                                // Hindi
                                "हिंदी": "इस ट्यूटोरियल में, प्रशिक्षक फ़्लटर एप्लिकेशन में श्रेणियों की स्क्रीन को ग्रिडव्यू के चारों ओर पैडिंग जोड़कर और कस्टम फ़ॉन्ट के साथ एक सामान्य थीम सेट करके स्टाइल करने पर ध्यान केंद्रित करता है। ट्यूटोरियल में एसेट फ़ोल्डर में फ़ॉन्ट फ़ाइलें जोड़ना, pubspec.yaml फ़ाइल में फ़ॉन्ट पंजीकृत करना और कस्टम रंग, फ़ॉन्ट और टेक्स्ट शैलियों के साथ main.dart फ़ाइल में थीम डेटा को कॉन्फ़िगर करना शामिल है। प्रशिक्षक थीम में बॉडी और शीर्षक के लिए टेक्स्ट शैलियों के दृश्य पहलुओं को समायोजित करना, category_item विजेट में अपडेट की गई शैलियों को लागू करना और परिवर्तनों को देखने के लिए ऐप को पुनरारंभ करना प्रदर्शित करता है। इसके अतिरिक्त, ट्यूटोरियल उस श्रेणी के लिए व्यंजनों को प्रदर्शित करने वाली स्क्रीन पर नेविगेट करने के लिए श्रेणी पर टैप करने की प्रक्रिया पर प्रकाश डालता है, जो एप्लिकेशन में आगे के विकास के लिए मंच तैयार करता है।",
                                // Portuguese
                                "Português": "Neste tutorial, o instrutor concentra-se no estilo do ecrã de categorias numa aplicação Flutter adicionando preenchimento em torno do GridView e configurando um tema geral com tipos de letra personalizados. O tutorial aborda a adição de ficheiros de fontes à pasta de ativos, o registo das fontes no ficheiro pubspec.yaml e a configuração dos dados do tema no ficheiro main.dart com cores, fontes e estilos de texto personalizados. O instrutor demonstra o ajuste dos aspetos visuais dos estilos de texto para corpo e título no tema, implementando os estilos atualizados no widget category_item e reiniciando a aplicação para visualizar as alterações. Além disso, o tutorial destaca o processo de tocar numa categoria para navegar até um ecrã que exibe receitas para essa categoria, preparando o terreno para um maior desenvolvimento na aplicação.",
                                // Bengali
                                "বাংলা": "এই টিউটোরিয়ালে, প্রশিক্ষক গ্রিডভিউ-এর চারপাশে প্যাডিং যোগ করে এবং কাস্টম ফন্টগুলির সাথে একটি সাধারণ থিম সেট আপ করার মাধ্যমে একটি ফ্লাটার অ্যাপ্লিকেশনে ক্যাটাগরি স্ক্রীন স্টাইল করার উপর ফোকাস করেন। টিউটোরিয়ালটি সম্পদ ফোল্ডারে ফন্ট ফাইল যোগ করা, pubspec.yaml ফাইলে ফন্ট নিবন্ধন করা এবং main.dart ফাইলে কাস্টম রঙ, ফন্ট এবং পাঠ্য শৈলী সহ থিম ডেটা কনফিগার করাকে কভার করে। প্রশিক্ষক থিমের বডি এবং শিরোনামের জন্য টেক্সট শৈলীর ভিজ্যুয়াল দিকগুলি সামঞ্জস্য করা, category_item উইজেটে আপডেট করা স্টাইলগুলি প্রয়োগ করা এবং পরিবর্তনগুলি দেখতে অ্যাপটি পুনরায় চালু করা দেখান। অতিরিক্তভাবে, টিউটোরিয়ালটি সেই বিভাগের জন্য রেসিপি প্রদর্শনকারী একটি স্ক্রিনে নেভিগেট করতে একটি বিভাগে ট্যাপ করার প্রক্রিয়া হাইলাইট করে, অ্যাপ্লিকেশনটির আরও বিকাশের জন্য পর্যায় সেট করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا البرنامج التعليمي، يركز المدرب على تصميم شاشة الفئات في تطبيق Flutter عن طريق إضافة حشو حول GridView وإعداد سمة عامة بخطوط مخصصة. يغطي البرنامج التعليمي إضافة ملفات الخطوط إلى مجلد الأصول، وتسجيل الخطوط في ملف pubspec.yaml، وتكوين بيانات السمة في ملف main.dart بألوان وخطوط وأنماط نص مخصصة. يوضح المدرب ضبط الجوانب المرئية لأنماط النص للنص والعنوان في السمة، وتنفيذ الأنماط المحدثة في عنصر واجهة المستخدم category_item، وإعادة تشغيل التطبيق لعرض التغييرات. بالإضافة إلى ذلك، يسلط البرنامج التعليمي الضوء على عملية النقر على فئة للانتقال إلى شاشة تعرض وصفات لهذه الفئة، مما يمهد الطريق لمزيد من التطوير في التطبيق.",
                                // Persian
                                "فارسی": "در این آموزش، مدرس با افزودن padding در اطراف GridView و تنظیم یک موضوع کلی با فونت های سفارشی، بر روی صفحه نمایش دسته ها در یک برنامه Flutter تمرکز می کند. این آموزش شامل افزودن فایل‌های فونت به پوشه دارایی‌ها، ثبت فونت‌ها در فایل pubspec.yaml و پیکربندی داده‌های موضوع در فایل main.dart با رنگ‌ها، فونت‌ها و سبک‌های متن سفارشی است. مربی تنظیم جنبه های بصری سبک های متن را برای متن و عنوان در موضوع، پیاده سازی سبک های به روز شده در ویجت category_item و راه اندازی مجدد برنامه برای مشاهده تغییرات را نشان می دهد. علاوه بر این، این آموزش فرآیند ضربه زدن روی یک دسته را برای پیمایش به صفحه ای که دستور العمل های مربوط به آن دسته را نشان می دهد، برجسته می کند و زمینه را برای توسعه بیشتر در برنامه فراهم می کند.",
                            },
                        },
                        // 145 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Navigating to a New Page",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker talks about creating a new screen called CategoryMealsScreen to display recipes for a chosen category. They discuss adding a GestureDetector or InkWell to make category items tappable, and using the navigator class to push a new page when a category is selected. The MaterialPageRoute class is used to define the new page and handle the transition between screens. Overall, the video focuses on navigating between screens in a Flutter app and creating a seamless user experience.",
                                // German
                                "Deutsch": "In diesem Video spricht der Sprecher über die Erstellung eines neuen Bildschirms namens CategoryMealsScreen, um Rezepte für eine ausgewählte Kategorie anzuzeigen. Er bespricht das Hinzufügen eines GestureDetector oder InkWell, um Kategorieelemente antippbar zu machen, und die Verwendung der Navigator-Klasse, um eine neue Seite zu öffnen, wenn eine Kategorie ausgewählt wird. Die Klasse MaterialPageRoute wird verwendet, um die neue Seite zu definieren und den Übergang zwischen Bildschirmen zu handhaben. Insgesamt konzentriert sich das Video auf die Navigation zwischen Bildschirmen in einer Flutter-App und die Schaffung einer nahtlosen Benutzererfahrung.",
                                // Chinese
                                "中国人": "在此视频中，演讲者谈到了如何创建一个名为 CategoryMealsScreen 的新屏幕来显示所选类别的食谱。他们讨论了如何添加 GestureDetector 或 InkWell 以使类别项可点击，以及如何使用 navigator 类在选择类别时推送新页面。MaterialPageRoute 类用于定义新页面并处理屏幕之间的过渡。总体而言，该视频重点介绍了如何在 Flutter 应用中的屏幕之间导航以及如何打造无缝的用户体验。",
                                // Russian
                                "Русский": "В этом видео докладчик рассказывает о создании нового экрана под названием CategoryMealsScreen для отображения рецептов для выбранной категории. Они обсуждают добавление GestureDetector или InkWell для того, чтобы сделать элементы категории нажимаемыми, и использование класса навигатора для выдвижения новой страницы при выборе категории. Класс MaterialPageRoute используется для определения новой страницы и обработки перехода между экранами. В целом, видео фокусируется на навигации между экранами в приложении Flutter и создании бесшовного пользовательского опыта.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique comment créer un nouvel écran appelé CategoryMealsScreen pour afficher les recettes d'une catégorie choisie. Il explique comment ajouter un GestureDetector ou InkWell pour rendre les éléments de catégorie accessibles au toucher et comment utiliser la classe navigator pour ouvrir une nouvelle page lorsqu'une catégorie est sélectionnée. La classe MaterialPageRoute est utilisée pour définir la nouvelle page et gérer la transition entre les écrans. Dans l'ensemble, la vidéo se concentre sur la navigation entre les écrans d'une application Flutter et sur la création d'une expérience utilisateur fluide.",
                                // Japanese
                                "日本語": "このビデオでは、選択したカテゴリのレシピを表示する CategoryMealsScreen という新しい画面の作成について説明しています。また、カテゴリ項目をタップ可能にするために GestureDetector または InkWell を追加すること、カテゴリが選択されたときにナビゲーター クラスを使用して新しいページをプッシュすることについても説明しています。MaterialPageRoute クラスは、新しいページを定義し、画面間の遷移を処理するために使用されます。全体として、このビデオは Flutter アプリの画面間の移動とシームレスなユーザー エクスペリエンスの作成に重点を置いています。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 선택한 카테고리의 레시피를 표시하는 CategoryMealsScreen이라는 새 화면을 만드는 방법에 대해 설명합니다. GestureDetector 또는 InkWell을 추가하여 카테고리 항목을 탭할 수 있게 하고, navigator 클래스를 사용하여 카테고리를 선택하면 새 페이지를 푸시하는 방법에 대해 설명합니다. MaterialPageRoute 클래스는 새 페이지를 정의하고 화면 간 전환을 처리하는 데 사용됩니다. 전반적으로 이 영상은 Flutter 앱에서 화면 간을 탐색하고 원활한 사용자 경험을 만드는 데 중점을 둡니다.",
                                // Spanish
                                "Español": "En este video, el orador habla sobre la creación de una nueva pantalla llamada CategoryMealsScreen para mostrar recetas de una categoría elegida. Habla sobre la incorporación de un GestureDetector o InkWell para que los elementos de la categoría se puedan tocar y sobre el uso de la clase navigator para enviar una nueva página cuando se selecciona una categoría. La clase MaterialPageRoute se utiliza para definir la nueva página y gestionar la transición entre pantallas. En general, el video se centra en la navegación entre pantallas en una aplicación Flutter y en la creación de una experiencia de usuario fluida.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता CategoryMealsScreen नामक एक नई स्क्रीन बनाने के बारे में बात करता है, ताकि चुनी गई श्रेणी के लिए रेसिपी प्रदर्शित की जा सके। वे श्रेणी आइटम को टैप करने योग्य बनाने के लिए GestureDetector या InkWell जोड़ने और श्रेणी चुने जाने पर नया पेज पुश करने के लिए नेविगेटर क्लास का उपयोग करने पर चर्चा करते हैं। नए पेज को परिभाषित करने और स्क्रीन के बीच संक्रमण को संभालने के लिए MaterialPageRoute क्लास का उपयोग किया जाता है। कुल मिलाकर, वीडियो फ़्लटर ऐप में स्क्रीन के बीच नेविगेट करने और एक सहज उपयोगकर्ता अनुभव बनाने पर केंद्रित है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador fala sobre a criação de um novo ecrã chamado CategoryMealsScreen para exibir receitas de uma categoria escolhida. Discutem a adição de um GestureDetector ou InkWell para tornar os itens da categoria tocáveis ​​e a utilização da classe navigator para enviar uma nova página quando uma categoria é selecionada. A classe MaterialPageRoute é utilizada para definir a nova página e tratar da transição entre ecrãs. No geral, o vídeo centra-se na navegação entre os ecrãs de uma aplicação Flutter e na criação de uma experiência de utilizador perfeita.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি নির্বাচিত বিভাগের জন্য রেসিপি প্রদর্শন করার জন্য CategoryMealsScreen নামে একটি নতুন স্ক্রিন তৈরি করার বিষয়ে কথা বলেছেন। তারা বিভাগ আইটেমগুলিকে ট্যাপযোগ্য করার জন্য একটি GestureDetector বা InkWell যোগ করার বিষয়ে আলোচনা করে এবং একটি বিভাগ নির্বাচন করা হলে একটি নতুন পৃষ্ঠা পুশ করার জন্য নেভিগেটর ক্লাস ব্যবহার করে। MaterialPageRoute ক্লাসটি নতুন পৃষ্ঠা সংজ্ঞায়িত করতে এবং স্ক্রিনগুলির মধ্যে পরিবর্তন পরিচালনা করতে ব্যবহৃত হয়। সামগ্রিকভাবে, ভিডিওটি একটি ফ্লাটার অ্যাপে স্ক্রিনগুলির মধ্যে নেভিগেট করা এবং একটি নিরবচ্ছিন্ন ব্যবহারকারীর অভিজ্ঞতা তৈরি করার উপর ফোকাস করে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتحدث المتحدث عن إنشاء شاشة جديدة تسمى CategoryMealsScreen لعرض الوصفات لفئة مختارة. ويناقشون إضافة GestureDetector أو InkWell لجعل عناصر الفئة قابلة للنقر، واستخدام فئة المستعرض لدفع صفحة جديدة عند تحديد فئة. تُستخدم فئة MaterialPageRoute لتحديد الصفحة الجديدة والتعامل مع الانتقال بين الشاشات. بشكل عام، يركز الفيديو على التنقل بين الشاشات في تطبيق Flutter وإنشاء تجربة مستخدم سلسة.",
                                // Persian
                                "فارسی": "در این ویدئو، سخنران در مورد ایجاد یک صفحه نمایش جدید به نام CategoryMealsScreen برای نمایش دستور العمل های یک دسته انتخابی صحبت می کند. آنها در مورد افزودن GestureDetector یا InkWell برای قابل لمس کردن آیتم های دسته و استفاده از کلاس ناوبر برای ارسال صفحه جدید در هنگام انتخاب یک دسته بحث می کنند. کلاس MaterialPageRoute برای تعریف صفحه جدید و مدیریت انتقال بین صفحه ها استفاده می شود. به طور کلی، ویدیو بر روی حرکت بین صفحه‌های نمایش در یک برنامه Flutter و ایجاد یک تجربه کاربری یکپارچه تمرکز دارد.",
                            },
                        },
                        // 146 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Passing Data via the Constructor",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker discusses the importance of displaying the correct recipes for a chosen category on the CategoryMealsScreen by passing information about the category to the screen. They explain adding properties for category ID and category title, creating a constructor to assign values to these properties, and then forwarding this information to the CategoryMealsScreen. By doing this, the speaker demonstrates how to show the category title in the app bar of the CategoryMealsScreen, thereby ensuring the correct category information is displayed when a category is selected. Additionally, they mention that this data can be passed to a new page using navigator push, suggesting there are alternative ways of loading pages that will be explored further.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Sprecher, wie wichtig es ist, die richtigen Rezepte für eine ausgewählte Kategorie auf dem CategoryMealsScreen anzuzeigen, indem Informationen über die Kategorie an den Bildschirm weitergegeben werden. Er erklärt, wie man Eigenschaften für Kategorie-ID und Kategorietitel hinzufügt, einen Konstruktor erstellt, um diesen Eigenschaften Werte zuzuweisen, und diese Informationen dann an den CategoryMealsScreen weiterleitet. Auf diese Weise demonstriert der Sprecher, wie der Kategorietitel in der App-Leiste des CategoryMealsScreen angezeigt wird, wodurch sichergestellt wird, dass die richtigen Kategorieinformationen angezeigt werden, wenn eine Kategorie ausgewählt wird. Darüber hinaus erwähnt er, dass diese Daten mithilfe von Navigator Push an eine neue Seite weitergegeben werden können, was darauf hindeutet, dass es alternative Möglichkeiten zum Laden von Seiten gibt, die weiter untersucht werden.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了通过将类别信息传递到屏幕，在 CategoryMealsScreen 上显示所选类别的正确食谱的重要性。他们解释了如何添加类别 ID 和类别标题的属性，如何创建构造函数来为这些属性赋值，以及如何将这些信息转发到 CategoryMealsScreen。通过这样做，演讲者演示了如何在 CategoryMealsScreen 的应用栏中显示类别标题，从而确保在选择类别时显示正确的类别信息。此外，他们提到可以使用导航器推送将这些数据传递到新页面，这表明还有其他加载页面的方法，我们将进一步探讨。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает важность отображения правильных рецептов для выбранной категории на CategoryMealsScreen путем передачи информации о категории на экран. Они объясняют добавление свойств для идентификатора категории и заголовка категории, создание конструктора для назначения значений этим свойствам и последующую пересылку этой информации на CategoryMealsScreen. Делая это, докладчик демонстрирует, как отобразить заголовок категории в панели приложений CategoryMealsScreen, тем самым гарантируя отображение правильной информации о категории при выборе категории. Кроме того, они упоминают, что эти данные можно передать на новую страницу с помощью push-навигатора, что предполагает наличие альтернативных способов загрузки страниц, которые будут рассмотрены далее.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique l'importance d'afficher les bonnes recettes pour une catégorie choisie sur l'écran CategoryMealsScreen en transmettant des informations sur la catégorie à l'écran. Il explique comment ajouter des propriétés pour l'ID de catégorie et le titre de catégorie, créer un constructeur pour attribuer des valeurs à ces propriétés, puis transmettre ces informations à l'écran CategoryMealsScreen. Ce faisant, l'intervenant montre comment afficher le titre de la catégorie dans la barre d'applications de l'écran CategoryMealsScreen, garantissant ainsi que les informations de catégorie correctes s'affichent lorsqu'une catégorie est sélectionnée. De plus, il mentionne que ces données peuvent être transmises à une nouvelle page à l'aide de la fonction push du navigateur, ce qui suggère qu'il existe d'autres moyens de charger des pages qui seront explorés plus en détail.",
                                // Japanese
                                "日本語": "このビデオでは、講演者は、カテゴリに関する情報を画面に渡すことで、選択したカテゴリの正しいレシピを CategoryMealsScreen に表示することの重要性について説明しています。カテゴリ ID とカテゴリ タイトルのプロパティを追加し、これらのプロパティに値を割り当てるコンストラクターを作成し、この情報を CategoryMealsScreen に転送する方法を説明します。これにより、講演者は CategoryMealsScreen のアプリ バーにカテゴリ タイトルを表示し、カテゴリが選択されたときに正しいカテゴリ情報が表示されるようにする方法を示します。さらに、このデータはナビゲーター プッシュを使用して新しいページに渡すことができると述べており、ページを読み込む別の方法があることを示唆しています。これについては後で詳しく説明します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 CategoryMealsScreen에 선택한 카테고리에 대한 올바른 레시피를 표시하는 것의 중요성에 대해 논의합니다. 카테고리에 대한 정보를 화면으로 전달합니다. 발표자는 카테고리 ID와 카테고리 제목에 대한 속성을 추가하고, 이러한 속성에 값을 할당하는 생성자를 만든 다음, 이 정보를 CategoryMealsScreen에 전달하는 방법을 설명합니다. 발표자는 이를 통해 CategoryMealsScreen의 앱 바에 카테고리 제목을 표시하는 방법을 보여 주며, 이를 통해 카테고리를 선택할 때 올바른 카테고리 정보가 표시되도록 합니다. 또한 발표자는 이 데이터를 navigator push를 사용하여 새 페이지로 전달할 수 있다고 언급하며, 페이지를 로드하는 다른 방법이 있으며 이에 대해서는 나중에 자세히 살펴보겠습니다.",
                                // Spanish
                                "Español": "En este video, el orador analiza la importancia de mostrar las recetas correctas para una categoría elegida en CategoryMealsScreen al pasar información sobre la categoría a la pantalla. Explica cómo agregar propiedades para la identificación y el título de la categoría, crear un constructor para asignar valores a estas propiedades y luego reenviar esta información a CategoryMealsScreen. Al hacer esto, el orador demuestra cómo mostrar el título de la categoría en la barra de aplicaciones de CategoryMealsScreen, lo que garantiza que se muestre la información de categoría correcta cuando se selecciona una categoría. Además, menciona que estos datos se pueden pasar a una nueva página mediante la función push del navegador, lo que sugiere que existen formas alternativas de cargar páginas que se explorarán más a fondo.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता CategoryMealsScreen पर चुनी गई श्रेणी के लिए सही रेसिपी प्रदर्शित करने के महत्व पर चर्चा करता है, श्रेणी के बारे में जानकारी स्क्रीन पर भेजता है। वे श्रेणी आईडी और श्रेणी शीर्षक के लिए गुण जोड़ने, इन गुणों को मान निर्दिष्ट करने के लिए एक कंस्ट्रक्टर बनाने और फिर इस जानकारी को CategoryMealsScreen पर अग्रेषित करने के बारे में बताते हैं। ऐसा करके, वक्ता प्रदर्शित करता है कि CategoryMealsScreen के ऐप बार में श्रेणी शीर्षक कैसे दिखाया जाए, जिससे यह सुनिश्चित हो सके कि श्रेणी का चयन करने पर सही श्रेणी की जानकारी प्रदर्शित हो। इसके अतिरिक्त, वे उल्लेख करते हैं कि इस डेटा को नेविगेटर पुश का उपयोग करके एक नए पृष्ठ पर भेजा जा सकता है, यह सुझाव देते हुए कि पृष्ठों को लोड करने के वैकल्पिक तरीके हैं जिन्हें आगे खोजा जाएगा।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador discute a importância de exibir as receitas corretas para uma categoria escolhida no ecrã CategoryMealsScreen, passando informação sobre a categoria para o ecrã. Explicam a adição de propriedades para o ID e o título da categoria, a criação de um construtor para atribuir valores a essas propriedades e, em seguida, o encaminhamento dessa informação para o CategoryMealsScreen. Ao fazê-lo, o orador demonstra como mostrar o título da categoria na barra de aplicações do ecrã CategoryMealsScreen, garantindo assim que as informações corretas da categoria são apresentadas quando uma categoria é selecionada. Além disso, referem que estes dados podem ser passados ​​para uma nova página utilizando o navegador push, sugerindo que existem formas alternativas de carregar páginas que serão exploradas mais à frente.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার ক্যাটাগরিমেলসস্ক্রিনে ক্যাটাগরিমিলসস্ক্রিনে ক্যাটাগরি সম্পর্কে তথ্য দিয়ে নির্বাচিত বিভাগের জন্য সঠিক রেসিপি প্রদর্শনের গুরুত্ব নিয়ে আলোচনা করেছেন। তারা ক্যাটাগরি আইডি এবং ক্যাটাগরির শিরোনামের জন্য প্রোপার্টি যোগ করার ব্যাখ্যা দেয়, এই প্রোপার্টিগুলির মান নির্ধারণ করার জন্য একটি কনস্ট্রাক্টর তৈরি করে এবং তারপর এই তথ্যটি ক্যাটাগরিমেলসস্ক্রিনে ফরওয়ার্ড করে। এটি করার মাধ্যমে, স্পিকার ক্যাটাগরিমেলসস্ক্রিনের অ্যাপ বারে কীভাবে বিভাগের শিরোনামটি দেখাতে হয় তা প্রদর্শন করে, যাতে একটি বিভাগ নির্বাচন করা হলে সঠিক বিভাগের তথ্য প্রদর্শিত হয় তা নিশ্চিত করে। অতিরিক্তভাবে, তারা উল্লেখ করেছে যে এই ডেটা নেভিগেটর পুশ ব্যবহার করে একটি নতুন পৃষ্ঠায় প্রেরণ করা যেতে পারে, পরামর্শ দেয় যে পৃষ্ঠাগুলি লোড করার বিকল্প উপায় রয়েছে যা আরও অন্বেষণ করা হবে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث أهمية عرض الوصفات الصحيحة لفئة مختارة على CategoryMealsScreen من خلال تمرير معلومات حول الفئة إلى الشاشة. ويشرح إضافة خصائص لمعرف الفئة وعنوان الفئة، وإنشاء منشئ لتعيين قيم لهذه الخصائص، ثم إعادة توجيه هذه المعلومات إلى CategoryMealsScreen. ومن خلال القيام بذلك، يوضح المتحدث كيفية عرض عنوان الفئة في شريط التطبيق في CategoryMealsScreen، وبالتالي ضمان عرض معلومات الفئة الصحيحة عند تحديد فئة. بالإضافة إلى ذلك، يذكر أنه يمكن تمرير هذه البيانات إلى صفحة جديدة باستخدام الدفع من خلال المتصفح، مما يشير إلى وجود طرق بديلة لتحميل الصفحات والتي سيتم استكشافها بشكل أكبر.",
                                // Persian
                                "فارسی": "در این ویدئو، سخنران اهمیت نمایش دستور العمل های صحیح برای یک دسته انتخابی در CategoryMealsScreen را با انتقال اطلاعات مربوط به دسته به صفحه مورد بحث قرار می دهد. آنها اضافه کردن خواص برای ID دسته و عنوان دسته، ایجاد سازنده ای برای اختصاص مقادیر به این ویژگی ها و سپس ارسال این اطلاعات به CategoryMealsScreen را توضیح می دهند. با انجام این کار، بلندگو نشان می دهد که چگونه عنوان دسته را در نوار برنامه CategoryMealsScreen نشان دهد، بنابراین اطمینان حاصل می کند که هنگام انتخاب یک دسته، اطلاعات دسته بندی صحیح نمایش داده می شود. علاوه بر این، آنها اشاره می کنند که این داده ها را می توان با استفاده از فشار ناوبر به یک صفحه جدید منتقل کرد، که نشان می دهد راه های دیگری برای بارگیری صفحات وجود دارد که بیشتر مورد بررسی قرار خواهند گرفت.",
                            },
                        },
                        // 145 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Using Named Routes & Passing Data With Named Routes",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker explains how to set up named routes in Flutter as an alternative to using navigator push and MaterialPageRoute. They describe named routes as a cleaner and easier way to manage app navigation, especially in larger apps where manually setting up routes can become cumbersome. By adding a routes table in the main.dart file with string keys identifying routes and corresponding creation functions for screens, the speaker demonstrates how to pass data between routes using pushNamed and arguments. They explain how to extract route arguments in CategoryMealsScreen and access the data to display the correct information on the screen. Overall, named routes offer a structured and organized approach to app navigation, simplifying the process of managing different screens and their respective routes.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Sprecher, wie man benannte Routen in Flutter als Alternative zur Verwendung von Navigator Push und MaterialPageRoute einrichtet. Er beschreibt benannte Routen als eine sauberere und einfachere Möglichkeit, die App-Navigation zu verwalten, insbesondere in größeren Apps, bei denen das manuelle Einrichten von Routen mühsam werden kann. Durch Hinzufügen einer Routentabelle in der Datei main.dart mit Zeichenfolgenschlüsseln, die Routen identifizieren, und entsprechenden Erstellungsfunktionen für Bildschirme demonstriert der Sprecher, wie man Daten zwischen Routen mit pushNamed und Argumenten übergibt. Er erklärt, wie man Routenargumente in CategoryMealsScreen extrahiert und auf die Daten zugreift, um die richtigen Informationen auf dem Bildschirm anzuzeigen. Insgesamt bieten benannte Routen einen strukturierten und organisierten Ansatz für die App-Navigation und vereinfachen den Prozess der Verwaltung verschiedener Bildschirme und ihrer jeweiligen Routen.",
                                // Chinese
                                "中国人": "在本视频中，演讲者解释了如何在 Flutter 中设置命名路由，作为使用 navigator push 和 MaterialPageRoute 的替代方案。他们将命名路由描述为一种更简洁、更简单的应用导航管理方法，尤其是在大型应用中，手动设置路由可能会变得很麻烦。通过在 main.dart 文件中添加路由表，其中包含用于标识路由的字符串键和用于屏幕的相应创建函数，演讲者演示了如何使用 pushNamed 和参数在路由之间传递数据。他们解释了如何在 CategoryMealsScreen 中提取路由参数并访问数据以在屏幕上显示正确的信息。总体而言，命名路由为应用导航提供了一种结构化且有组织的方法，简化了管理不同屏幕及其各自路由的过程。",
                                // Russian
                                "Русский": "В этом видео докладчик объясняет, как настроить именованные маршруты во Flutter в качестве альтернативы использованию navigator push и MaterialPageRoute. Они описывают именованные маршруты как более чистый и простой способ управления навигацией приложения, особенно в больших приложениях, где ручная настройка маршрутов может стать обременительной. Добавив таблицу маршрутов в файл main.dart со строковыми ключами, идентифицирующими маршруты и соответствующие функции создания для экранов, докладчик демонстрирует, как передавать данные между маршрутами с помощью pushNamed и аргументов. Они объясняют, как извлекать аргументы маршрута в CategoryMealsScreen и получать доступ к данным для отображения правильной информации на экране. В целом именованные маршруты предлагают структурированный и организованный подход к навигации приложения, упрощая процесс управления различными экранами и их соответствующими маршрутами.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique comment configurer des itinéraires nommés dans Flutter comme alternative à l'utilisation de Navigator Push et MaterialPageRoute. Il décrit les itinéraires nommés comme un moyen plus propre et plus simple de gérer la navigation dans les applications, en particulier dans les applications plus volumineuses où la configuration manuelle des itinéraires peut devenir fastidieuse. En ajoutant une table d'itinéraires dans le fichier main.dart avec des clés de chaîne identifiant les itinéraires et les fonctions de création correspondantes pour les écrans, l'intervenant montre comment transmettre des données entre les itinéraires à l'aide de pushNamed et d'arguments. Il explique comment extraire les arguments d'itinéraire dans CategoryMealsScreen et accéder aux données pour afficher les informations correctes sur l'écran. Dans l'ensemble, les itinéraires nommés offrent une approche structurée et organisée de la navigation dans les applications, simplifiant le processus de gestion des différents écrans et de leurs itinéraires respectifs.",
                                // Japanese
                                "日本語": "この動画では、講演者が、ナビゲーター プッシュと MaterialPageRoute を使用する代わりに、Flutter で名前付きルートを設定する方法について説明しています。名前付きルートは、特に手動でルートを設定するのが面倒になる可能性がある大規模なアプリで、アプリのナビゲーションを管理するためのよりクリーンで簡単な方法であると説明しています。ルートを識別する文字列キーと画面に対応する作成関数を含むルート テーブルを main.dart ファイルに追加することで、講演者は pushNamed と引数を使用してルート間でデータを渡す方法を示します。また、CategoryMealsScreen でルート引数を抽出し、データにアクセスして画面に正しい情報を表示する方法についても説明します。全体として、名前付きルートは、アプリのナビゲーションに構造化され整理されたアプローチを提供し、さまざまな画面とそれぞれのルートを管理するプロセスを簡素化します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 navigator push와 MaterialPageRoute를 사용하는 대신 Flutter에서 명명된 경로를 설정하는 방법을 설명합니다. 발표자는 명명된 경로를 앱 탐색을 관리하는 더 깔끔하고 쉬운 방법으로 설명하며, 특히 수동으로 경로를 설정하는 것이 번거로울 수 있는 대규모 앱에서 더욱 그렇습니다. 발표자는 main.dart 파일에 경로와 화면의 해당 생성 함수를 식별하는 문자열 키가 있는 경로 테이블을 추가하여 pushNamed와 인수를 사용하여 경로 간에 데이터를 전달하는 방법을 보여줍니다. 발표자는 CategoryMealsScreen에서 경로 인수를 추출하고 데이터에 액세스하여 화면에 올바른 정보를 표시하는 방법을 설명합니다. 전반적으로 명명된 경로는 앱 탐색에 대한 체계적이고 조직적인 접근 방식을 제공하여 다양한 화면과 해당 경로를 관리하는 프로세스를 단순화합니다.",
                                // Spanish
                                "Español": "En este video, el orador explica cómo configurar rutas con nombre en Flutter como una alternativa al uso de Navigator Push y MaterialPageRoute. Describe las rutas con nombre como una forma más clara y sencilla de administrar la navegación de la aplicación, especialmente en aplicaciones más grandes donde la configuración manual de rutas puede volverse engorrosa. Al agregar una tabla de rutas en el archivo main.dart con claves de cadena que identifican las rutas y las funciones de creación correspondientes para las pantallas, el orador demuestra cómo pasar datos entre rutas usando pushNamed y argumentos. Explica cómo extraer argumentos de ruta en CategoryMealsScreen y acceder a los datos para mostrar la información correcta en la pantalla. En general, las rutas con nombre ofrecen un enfoque estructurado y organizado para la navegación de la aplicación, lo que simplifica el proceso de administración de diferentes pantallas y sus respectivas rutas.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता बताता है कि नेविगेटर पुश और मटेरियलपेजरूट का उपयोग करने के विकल्प के रूप में फ़्लटर में नामित रूट कैसे सेट करें। वे नामित रूट को ऐप नेविगेशन को प्रबंधित करने का एक साफ और आसान तरीका बताते हैं, खासकर बड़े ऐप में जहाँ मैन्युअल रूप से रूट सेट करना बोझिल हो सकता है। स्क्रीन के लिए रूट और संबंधित निर्माण फ़ंक्शन की पहचान करने वाली स्ट्रिंग कुंजियों के साथ main.dart फ़ाइल में रूट टेबल जोड़कर, वक्ता यह प्रदर्शित करता है कि पुशनेम और तर्कों का उपयोग करके रूट के बीच डेटा कैसे पास किया जाए। वे बताते हैं कि CategoryMealsScreen में रूट तर्क कैसे निकालें और स्क्रीन पर सही जानकारी प्रदर्शित करने के लिए डेटा तक कैसे पहुँचें। कुल मिलाकर, नामित रूट ऐप नेविगेशन के लिए एक संरचित और संगठित दृष्टिकोण प्रदान करते हैं, जो विभिन्न स्क्रीन और उनके संबंधित रूट को प्रबंधित करने की प्रक्रिया को सरल बनाता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador explica como configurar rotas nomeadas no Flutter como alternativa à utilização de navigator push e MaterialPageRoute. Descrevem as rotas nomeadas como uma forma mais limpa e fácil de gerir a navegação em aplicações, especialmente em aplicações maiores, onde a configuração manual de rotas pode tornar-se complicada. Ao adicionar uma tabela de rotas no ficheiro main.dart com chaves de string identificando rotas e funções de criação correspondentes para ecrãs, o orador demonstra como passar dados entre rotas utilizando pushNamed e argumentos. Explicam como extrair argumentos de rota em CategoryMealsScreen e aceder aos dados para exibir as informações corretas no ecrã. No geral, as rotas nomeadas oferecem uma abordagem estruturada e organizada à navegação da aplicação, simplificando o processo de gestão dos diferentes ecrãs e das suas respetivas rotas.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার ব্যাখ্যা করেছেন কীভাবে নেভিগেটর পুশ এবং মেটেরিয়ালপেজরুট ব্যবহার করার বিকল্প হিসাবে ফ্লটারে নামযুক্ত রুটগুলি সেট আপ করতে হয়। তারা নামযুক্ত রুটগুলিকে অ্যাপ নেভিগেশন পরিচালনা করার একটি ক্লিনার এবং সহজ উপায় হিসাবে বর্ণনা করে, বিশেষত বড় অ্যাপগুলিতে যেখানে ম্যানুয়ালি রুট সেট আপ করা কঠিন হয়ে উঠতে পারে। মেইন ডার্ট ফাইলে একটি রুট টেবিল যোগ করে স্ট্রিং কী দিয়ে রুট শনাক্ত করে এবং স্ক্রিনের জন্য সংশ্লিষ্ট ক্রিয়েশন ফাংশন, স্পিকার দেখায় কিভাবে পুশনামড এবং আর্গুমেন্ট ব্যবহার করে রুটের মধ্যে ডেটা পাস করতে হয়। তারা ব্যাখ্যা করে কিভাবে ক্যাটাগরিমেলসস্ক্রিনে রুট আর্গুমেন্ট বের করতে হয় এবং স্ক্রিনে সঠিক তথ্য প্রদর্শন করতে ডেটা অ্যাক্সেস করতে হয়। সামগ্রিকভাবে, নামযুক্ত রুটগুলি অ্যাপ নেভিগেশনের জন্য একটি কাঠামোগত এবং সংগঠিত পদ্ধতির অফার করে, যা বিভিন্ন স্ক্রীন এবং তাদের নিজ নিজ রুট পরিচালনার প্রক্রিয়াকে সরল করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المتحدث كيفية إعداد مسارات مسماة في Flutter كبديل لاستخدام دفع المستكشف وMaterialPageRoute. يصفون المسارات المسماة كطريقة أنظف وأسهل لإدارة التنقل في التطبيق، وخاصة في التطبيقات الأكبر حجمًا حيث يمكن أن يصبح إعداد المسارات يدويًا مرهقًا. من خلال إضافة جدول مسارات في ملف main.dart مع مفاتيح سلسلة تحدد المسارات ووظائف الإنشاء المقابلة للشاشات، يوضح المتحدث كيفية تمرير البيانات بين المسارات باستخدام pushNamed والحجج. يشرحون كيفية استخراج حجج المسار في CategoryMealsScreen والوصول إلى البيانات لعرض المعلومات الصحيحة على الشاشة. بشكل عام، تقدم المسارات المسماة نهجًا منظمًا ومنظمًا للتنقل في التطبيق، مما يبسط عملية إدارة الشاشات المختلفة والمسارات الخاصة بها.",
                                // Persian
                                "فارسی": "در این ویدئو، سخنران نحوه تنظیم مسیرهای نامگذاری شده در فلاتر را به عنوان جایگزینی برای استفاده از فشار ناوبری و MaterialPageRoute توضیح می دهد. آنها مسیرهای نامگذاری شده را راهی تمیزتر و آسان تر برای مدیریت ناوبری برنامه ها توصیف می کنند، به ویژه در برنامه های بزرگتر که در آن راه اندازی دستی مسیرها می تواند دست و پا گیر شود. با افزودن جدول مسیرها در فایل main.dart با کلیدهای رشته‌ای که مسیرها و توابع ایجاد مربوطه را برای صفحه‌ها شناسایی می‌کنند، بلندگو نحوه انتقال داده‌ها را با استفاده از pushNamed و آرگومان‌ها بین مسیرها نشان می‌دهد. آنها نحوه استخراج آرگومان های مسیر را در CategoryMealsScreen و دسترسی به داده ها برای نمایش اطلاعات صحیح روی صفحه توضیح می دهند. به طور کلی، مسیرهای نام‌گذاری‌شده یک رویکرد ساختاریافته و سازمان‌یافته برای ناوبری برنامه‌ها ارائه می‌کنند که فرآیند مدیریت صفحه‌های مختلف و مسیرهای مربوطه را ساده می‌کند.",
                            },
                        },
                        // 146 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Diving Deeper into Named Routes",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker discusses setting up named routes in Flutter as an alternative to manually typing route names when using pushNamed. They explain that the default named route is " / ", representing the home screen, and demonstrate how to add initial route arguments to MaterialApp to specify which route to load first. The speaker also emphasizes the importance of avoiding typos in route names by using static constant properties in the screen widgets to store route names. By referencing these static properties in the main.dart file when defining routes, developers can reduce errors and make the app more error-proof, especially in larger applications. Overall, the video highlights the benefits of using named routes for a more organized and error-resistant approach to app navigation.",
                                // German
                                "Deutsch": "In diesem Video bespricht der Sprecher das Einrichten benannter Routen in Flutter als Alternative zum manuellen Eintippen von Routennamen bei Verwendung von pushNamed. Er erklärt, dass die standardmäßige benannte Route „/“ ist, was den Startbildschirm darstellt, und demonstriert, wie man anfängliche Routenargumente zu MaterialApp hinzufügt, um anzugeben, welche Route zuerst geladen werden soll. Der Sprecher betont auch, wie wichtig es ist, Tippfehler in Routennamen zu vermeiden, indem man statische Konstanteneigenschaften in den Bildschirm-Widgets verwendet, um Routennamen zu speichern. Indem Entwickler beim Definieren von Routen auf diese statischen Eigenschaften in der Datei main.dart verweisen, können sie Fehler reduzieren und die App fehlersicherer machen, insbesondere bei größeren Anwendungen. Insgesamt hebt das Video die Vorteile der Verwendung benannter Routen für einen organisierteren und fehlerresistenteren Ansatz zur App-Navigation hervor.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了如何在 Flutter 中设置命名路由，以替代使用 pushNamed 时手动输入路由名称。他们解释说，默认的命名路由是“/”，代表主屏幕，并演示了如何向 MaterialApp 添加初始路由参数以指定首先加载哪个路由。演讲者还强调了避免路由名称拼写错误的重要性，方法是在屏幕小部件中使用静态常量属性来存储路由名称。通过在定义路由时引用 main.dart 文件中的这些静态属性，开发人员可以减少错误并使应用程序更防错，尤其是在大型应用程序中。总的来说，该视频强调了使用命名路由的好处，使应用程序导航更具条理，更防错。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает настройку именованных маршрутов во Flutter в качестве альтернативы ручному вводу имен маршрутов при использовании pushNamed. Они объясняют, что именованный маршрут по умолчанию — «/», представляющий домашний экран, и демонстрируют, как добавлять начальные аргументы маршрута в MaterialApp, чтобы указать, какой маршрут загружать первым. Докладчик также подчеркивает важность избегания опечаток в именах маршрутов, используя статические константные свойства в виджетах экрана для хранения имен маршрутов. Ссылаясь на эти статические свойства в файле main.dart при определении маршрутов, разработчики могут уменьшить количество ошибок и сделать приложение более защищенным от ошибок, особенно в крупных приложениях. В целом, видео подчеркивает преимущества использования именованных маршрутов для более организованного и устойчивого к ошибкам подхода к навигации приложения.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique comment configurer des routes nommées dans Flutter comme alternative à la saisie manuelle des noms de route lors de l'utilisation de pushNamed. Il explique que la route nommée par défaut est " / ", représentant l'écran d'accueil, et montre comment ajouter des arguments de route initiaux à MaterialApp pour spécifier la route à charger en premier. L'intervenant souligne également l'importance d'éviter les fautes de frappe dans les noms de route en utilisant des propriétés constantes statiques dans les widgets d'écran pour stocker les noms de route. En référençant ces propriétés statiques dans le fichier main.dart lors de la définition des routes, les développeurs peuvent réduire les erreurs et rendre l'application plus résistante aux erreurs, en particulier dans les applications plus volumineuses. Dans l'ensemble, la vidéo met en évidence les avantages de l'utilisation de routes nommées pour une approche plus organisée et résistante aux erreurs de la navigation dans les applications.",
                                // Japanese
                                "日本語": "このビデオでは、pushNamed を使用する際にルート名を手動で入力する代わりに、Flutter で名前付きルートを設定する方法について説明します。デフォルトの名前付きルートはホーム画面を表す「/」であることを説明し、どのルートを最初に読み込むかを指定するために MaterialApp に初期ルート引数を追加する方法を示します。また、画面ウィジェットでルート名を格納するために静的定数プロパティを使用することで、ルート名の入力ミスを避けることの重要性も強調しています。ルートを定義するときに main.dart ファイルでこれらの静的プロパティを参照することで、開発者はエラーを減らし、特に大規模なアプリケーションでアプリのエラー防止を強化できます。全体として、このビデオでは、アプリのナビゲーションをより整理されたエラー防止アプローチにするために名前付きルートを使用する利点を強調しています。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 pushNamed를 사용할 때 경로 이름을 수동으로 입력하는 대신 Flutter에서 명명된 경로를 설정하는 방법에 대해 설명합니다. 발표자는 기본 명명된 경로가 홈 화면을 나타내는 " / "이며, MaterialApp에 초기 경로 인수를 추가하여 먼저 로드할 경로를 지정하는 방법을 보여줍니다. 발표자는 또한 화면 위젯에서 정적 상수 속성을 사용하여 경로 이름을 저장함으로써 경로 이름의 오타를 피하는 것의 중요성을 강조합니다. 개발자는 경로를 정의할 때 main.dart 파일에서 이러한 정적 속성을 참조함으로써 오류를 줄이고 앱을 오류 방지로 만들 수 있으며, 특히 대규모 애플리케이션에서 그렇습니다. 전반적으로 이 비디오는 앱 탐색에 대한 보다 체계적이고 오류에 강한 접근 방식을 위해 명명된 경로를 사용하는 것의 이점을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el orador analiza la configuración de rutas con nombre en Flutter como una alternativa a escribir manualmente los nombres de las rutas cuando se usa pushNamed. Explica que la ruta con nombre predeterminada es " / ", que representa la pantalla de inicio, y demuestra cómo agregar argumentos de ruta iniciales a MaterialApp para especificar qué ruta se cargará primero. El orador también enfatiza la importancia de evitar errores tipográficos en los nombres de las rutas mediante el uso de propiedades constantes estáticas en los widgets de pantalla para almacenar los nombres de las rutas. Al hacer referencia a estas propiedades estáticas en el archivo main.dart al definir las rutas, los desarrolladores pueden reducir los errores y hacer que la aplicación sea más a prueba de errores, especialmente en aplicaciones más grandes. En general, el video destaca los beneficios de usar rutas con nombre para un enfoque más organizado y resistente a errores para la navegación de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता पुशनेम का उपयोग करते समय मैन्युअल रूप से रूट नाम टाइप करने के विकल्प के रूप में फ़्लटर में नामित रूट सेट अप करने पर चर्चा करता है। वे बताते हैं कि डिफ़ॉल्ट नामित रूट " / " है, जो होम स्क्रीन का प्रतिनिधित्व करता है, और प्रदर्शित करता है कि पहले कौन सा रूट लोड करना है, यह निर्दिष्ट करने के लिए मटीरियलऐप में प्रारंभिक रूट तर्क कैसे जोड़ें। वक्ता रूट नामों को संग्रहीत करने के लिए स्क्रीन विजेट में स्थिर स्थिर गुणों का उपयोग करके रूट नामों में टाइपो से बचने के महत्व पर भी जोर देता है। रूट परिभाषित करते समय main.dart फ़ाइल में इन स्थिर गुणों को संदर्भित करके, डेवलपर्स त्रुटियों को कम कर सकते हैं और ऐप को अधिक त्रुटि-रहित बना सकते हैं, खासकर बड़े अनुप्रयोगों में। कुल मिलाकर, वीडियो ऐप नेविगेशन के लिए अधिक संगठित और त्रुटि-प्रतिरोधी दृष्टिकोण के लिए नामित रूट का उपयोग करने के लाभों पर प्रकाश डालता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador discute a configuração de rotas nomeadas no Flutter como alternativa à digitação manual de nomes de rotas quando se utiliza o pushNamed. Explicam que a rota nomeada predefinida é " / ", representando o ecrã inicial, e demonstram como adicionar argumentos de rota iniciais ao MaterialApp para especificar qual a rota a carregar primeiro. O orador realça ainda a importância de evitar erros de digitação nos nomes das rotas, utilizando propriedades constantes estáticas nos widgets do ecrã para armazenar os nomes das rotas. Ao fazer referência a estas propriedades estáticas no ficheiro main.dart ao definir rotas, os programadores podem reduzir os erros e tornar a aplicação mais à prova de erros, especialmente em aplicações maiores. No geral, o vídeo destaca os benefícios da utilização de rotas nomeadas para uma abordagem mais organizada e resistente a erros na navegação da aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার pushNamed ব্যবহার করার সময় রুটের নাম ম্যানুয়ালি টাইপ করার বিকল্প হিসাবে Flutter-এ নামযুক্ত রুট সেট আপ করার বিষয়ে আলোচনা করেছেন। তারা ব্যাখ্যা করে যে ডিফল্ট নামের রুটটি হল " / ", হোম স্ক্রীনের প্রতিনিধিত্ব করে, এবং কোন রুটটি প্রথমে লোড করতে হবে তা নির্দিষ্ট করতে MaterialApp-এ কীভাবে প্রাথমিক রুট আর্গুমেন্ট যোগ করতে হয় তা প্রদর্শন করে। স্পিকার রুটের নামগুলি সংরক্ষণ করতে স্ক্রীন উইজেটগুলিতে স্ট্যাটিক ধ্রুবক বৈশিষ্ট্যগুলি ব্যবহার করে রুটের নামের টাইপ এড়ানোর গুরুত্বের উপরও জোর দেয়। রুট সংজ্ঞায়িত করার সময় main.dart ফাইলে এই স্ট্যাটিক বৈশিষ্ট্যগুলি উল্লেখ করে, বিকাশকারীরা ত্রুটি কমাতে পারে এবং অ্যাপটিকে আরও ত্রুটি-প্রমাণ করতে পারে, বিশেষ করে বড় অ্যাপ্লিকেশনগুলিতে। সামগ্রিকভাবে, ভিডিওটি অ্যাপ নেভিগেশনে আরও সংগঠিত এবং ত্রুটি-প্রতিরোধী পদ্ধতির জন্য নামযুক্ত রুটগুলি ব্যবহার করার সুবিধাগুলি হাইলাইট করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث إعداد مسارات مسماة في Flutter كبديل لكتابة أسماء المسارات يدويًا عند استخدام pushNamed. ويشرح أن المسار المسمى الافتراضي هو " / "، الذي يمثل الشاشة الرئيسية، ويوضح كيفية إضافة وسيطات المسار الأولية إلى MaterialApp لتحديد المسار الذي سيتم تحميله أولاً. ويؤكد المتحدث أيضًا على أهمية تجنب الأخطاء المطبعية في أسماء المسارات باستخدام خصائص ثابتة ثابتة في أدوات الشاشة لتخزين أسماء المسارات. من خلال الرجوع إلى هذه الخصائص الثابتة في ملف main.dart عند تحديد المسارات، يمكن للمطورين تقليل الأخطاء وجعل التطبيق أكثر مقاومة للأخطاء، خاصة في التطبيقات الأكبر حجمًا. بشكل عام، يسلط الفيديو الضوء على فوائد استخدام المسارات المسماة للحصول على نهج أكثر تنظيمًا ومقاومة للأخطاء للتنقل في التطبيق.",
                                // Persian
                                "فارسی": "در این ویدئو، گوینده در مورد تنظیم مسیرهای نامگذاری شده در Flutter به عنوان جایگزینی برای تایپ دستی نام مسیرها هنگام استفاده از pushNamed بحث می کند. آنها توضیح می‌دهند که مسیر نام‌گذاری شده پیش‌فرض «/» است، که نمایانگر صفحه اصلی است، و نشان می‌دهد که چگونه آرگومان‌های مسیر اولیه را به MaterialApp اضافه کنیم تا مشخص شود کدام مسیر ابتدا بارگیری شود. سخنران همچنین بر اهمیت اجتناب از اشتباهات تایپی در نام مسیرها با استفاده از ویژگی های ثابت ثابت در ویجت های صفحه نمایش برای ذخیره نام مسیرها تاکید می کند. با ارجاع به این ویژگی های ثابت در فایل main.dart هنگام تعریف مسیرها، توسعه دهندگان می توانند خطاها را کاهش دهند و برنامه را به ویژه در برنامه های بزرگتر ضد خطا کنند. به طور کلی، این ویدئو مزایای استفاده از مسیرهای نام‌گذاری شده را برای رویکردی سازمان‌یافته‌تر و مقاوم‌تر در برابر خطا برای ناوبری برنامه‌ها برجسته می‌کند.",
                            },
                        },
                        // 147 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Adding a Meal Model & Data",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker continues working on the app by focusing on displaying recipes when a category is selected in the CategoryMealsScreen. To achieve this, they first discuss creating a model for a meal by defining properties such as unique ID, category IDs, name, image, ingredients, steps, duration, complexity, and affordability using an enum for simplicity. They emphasize naming enums to ensure error-free typing and use the @required decorator to specify mandatory arguments in the meal constructor. The speaker then adds a list of dummy meal data to the existing categories in dummy_data.dart, ensuring the Meal class is imported to the file for the data to be accessible. Additionally, they stress the importance of using a const constructor for immutability and the const keyword when defining the list of dummy meals.",
                                // German
                                "Deutsch": "In diesem Video arbeitet der Sprecher weiter an der App, indem er sich auf die Anzeige von Rezepten konzentriert, wenn eine Kategorie im CategoryMealsScreen ausgewählt wird. Um dies zu erreichen, bespricht er zunächst die Erstellung eines Modells für eine Mahlzeit, indem er Eigenschaften wie eindeutige ID, Kategorie-IDs, Name, Bild, Zutaten, Schritte, Dauer, Komplexität und Erschwinglichkeit der Einfachheit halber mithilfe einer Aufzählung definiert. Er betont die Benennung von Aufzählungen, um fehlerfreies Tippen sicherzustellen, und verwendet den @required-Dekorator, um obligatorische Argumente im Mahlzeitenkonstruktor anzugeben. Der Sprecher fügt dann eine Liste mit Dummy-Mahlzeitendaten zu den vorhandenen Kategorien in dummy_data.dart hinzu und stellt sicher, dass die Meal-Klasse in die Datei importiert wird, damit die Daten zugänglich sind. Darüber hinaus betont er die Bedeutung der Verwendung eines const-Konstruktors für Unveränderlichkeit und des const-Schlüsselworts beim Definieren der Liste der Dummy-Mahlzeiten.",
                                // Chinese
                                "中国人": "在本视频中，演讲者继续开发应用程序，重点介绍如何在 CategoryMealsScreen 中选择类别时显示食谱。为了实现这一点，他们首先讨论了如何创建膳食模型，即使用枚举定义唯一 ID、类别 ID、名称、图像、配料、步骤、持续时间、复杂性和可负担性等属性。他们强调命名枚举以确保无错误输入，并使用 @required 装饰器在膳食构造函数中指定强制参数。然后，演讲者将虚拟膳食数据列表添加到 dummy_data.dart 中的现有类别中，确保将 Meal 类导入文件以便访问数据。此外，他们还强调了使用 const 构造函数实现不变性以及在定义虚拟膳食列表时使用 const 关键字的重要性。",
                                // Russian
                                "Русский": "В этом видео докладчик продолжает работать над приложением, сосредоточившись на отображении рецептов при выборе категории на экране CategoryMealsScreen. Чтобы добиться этого, они сначала обсуждают создание модели для еды, определяя такие свойства, как уникальный идентификатор, идентификаторы категорий, название, изображение, ингредиенты, шаги, продолжительность, сложность и доступность, используя перечисление для простоты. Они подчеркивают именование перечислений, чтобы гарантировать безошибочный ввод, и используют декоратор @required для указания обязательных аргументов в конструкторе еды. Затем докладчик добавляет список фиктивных данных еды к существующим категориям в dummy_data.dart, гарантируя, что класс Meal импортируется в файл для доступности данных. Кроме того, они подчеркивают важность использования конструктора const для неизменяемости и ключевого слова const при определении списка фиктивных блюд.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant continue de travailler sur l'application en se concentrant sur l'affichage des recettes lorsqu'une catégorie est sélectionnée dans CategoryMealsScreen. Pour y parvenir, il discute d'abord de la création d'un modèle pour un repas en définissant des propriétés telles que l'ID unique, les ID de catégorie, le nom, l'image, les ingrédients, les étapes, la durée, la complexité et l'accessibilité à l'aide d'une énumération pour plus de simplicité. Il met l'accent sur la dénomination des énumérations pour garantir une saisie sans erreur et utilise le décorateur @required pour spécifier les arguments obligatoires dans le constructeur de repas. L'intervenant ajoute ensuite une liste de données de repas factices aux catégories existantes dans dummy_data.dart, en s'assurant que la classe Meal est importée dans le fichier pour que les données soient accessibles. De plus, il souligne l'importance d'utiliser un constructeur const pour l'immuabilité et le mot-clé const lors de la définition de la liste de repas factices.",
                                // Japanese
                                "日本語": "このビデオでは、講演者はアプリの開発を続け、CategoryMealsScreen でカテゴリが選択されたときにレシピを表示することに焦点を当てています。これを実現するために、講演者はまず、一意の ID、カテゴリ ID、名前、画像、材料、手順、所要時間、複雑さ、および簡潔さのために列挙型を使用して手頃な価格などのプロパティを定義し、食事のモデルを作成する方法について説明します。また、列挙型に名前を付けてエラーのない入力を確実にし、@required デコレータを使用して食事コンストラクターで必須の引数を指定することを強調しています。次に、講演者は dummy_data.dart の既存のカテゴリにダミーの食事データのリストを追加し、データにアクセスできるように Meal クラスがファイルにインポートされるようにします。さらに、不変性のために const コンストラクターを使用することの重要性と、ダミーの食事のリストを定義するときに const キーワードを使用することを強調しています。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 CategoryMealsScreen에서 카테고리를 선택하면 레시피를 표시하는 데 집중하여 앱 작업을 계속합니다. 이를 위해 먼저 고유 ID, 카테고리 ID, 이름, 이미지, 재료, 단계, 기간, 복잡성, 간편성을 위한 열거형을 사용하여 식사 모델을 만드는 방법을 논의합니다. 오류 없는 타이핑을 보장하기 위해 열거형의 이름을 지정하고 @required 데코레이터를 사용하여 식사 생성자에서 필수 인수를 지정하는 방법을 강조합니다. 그런 다음 발표자는 dummy_data.dart의 기존 카테고리에 더미 식사 데이터 목록을 추가하여 데이터에 액세스할 수 있도록 Meal 클래스를 파일에 가져옵니다. 또한 불변성을 위해 const 생성자를 사용하고 더미 식사 목록을 정의할 때 const 키워드를 사용하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el orador continúa trabajando en la aplicación y se enfoca en mostrar recetas cuando se selecciona una categoría en CategoryMealsScreen. Para lograr esto, primero analiza la creación de un modelo para una comida definiendo propiedades como ID único, ID de categoría, nombre, imagen, ingredientes, pasos, duración, complejidad y asequibilidad utilizando una enumeración para simplificar. Hace hincapié en nombrar las enumeraciones para garantizar una escritura sin errores y utiliza el decorador @required para especificar argumentos obligatorios en el constructor de comidas. Luego, el orador agrega una lista de datos de comidas ficticias a las categorías existentes en dummy_data.dart, lo que garantiza que la clase Meal se importe al archivo para que los datos sean accesibles. Además, enfatiza la importancia de utilizar un constructor const para la inmutabilidad y la palabra clave const al definir la lista de comidas ficticias.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता CategoryMealsScreen में किसी श्रेणी का चयन किए जाने पर व्यंजनों को प्रदर्शित करने पर ध्यान केंद्रित करके ऐप पर काम करना जारी रखता है। इसे प्राप्त करने के लिए, वे सबसे पहले सरलता के लिए एक enum का उपयोग करके अद्वितीय ID, श्रेणी ID, नाम, छवि, सामग्री, चरण, अवधि, जटिलता और सामर्थ्य जैसे गुणों को परिभाषित करके भोजन के लिए एक मॉडल बनाने पर चर्चा करते हैं। वे त्रुटि-मुक्त टाइपिंग सुनिश्चित करने के लिए enums के नामकरण पर जोर देते हैं और भोजन निर्माता में अनिवार्य तर्कों को निर्दिष्ट करने के लिए @required डेकोरेटर का उपयोग करते हैं। इसके बाद वक्ता dummy_data.dart में मौजूदा श्रेणियों में डमी भोजन डेटा की एक सूची जोड़ता है, यह सुनिश्चित करता है कि डेटा को सुलभ बनाने के लिए मील क्लास को फ़ाइल में आयात किया गया है। इसके अतिरिक्त, वे अपरिवर्तनीयता के लिए एक const निर्माता और डमी भोजन की सूची को परिभाषित करते समय const कीवर्ड का उपयोग करने के महत्व पर जोर देते हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador continua a trabalhar na aplicação, concentrando-se na exibição de receitas quando uma categoria é selecionada no ecrã CategoryMealsScreen. Para o conseguir, discutem primeiro a criação de um modelo para uma refeição, definindo propriedades como ID único, IDs de categoria, nome, imagem, ingredientes, passos, duração, complexidade e acessibilidade utilizando um enum para simplificar. Enfatizam a nomenclatura dos enums para garantir uma digitação sem erros e utilizam o decorador @required para especificar argumentos obrigatórios no construtor de refeições. O orador adiciona então uma lista de dados fictícios de refeições às categorias existentes em dummy_data.dart, garantindo que a classe Refeição é importada para o ficheiro para que os dados fiquem acessíveis. Além disso, enfatizam a importância de utilizar um construtor const para a imutabilidade e a palavra-chave const ao definir a lista de refeições fictícias.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, ক্যাটাগরিমেলসস্ক্রিনে একটি বিভাগ নির্বাচন করা হলে স্পিকার রেসিপি প্রদর্শনের উপর ফোকাস করে অ্যাপটিতে কাজ চালিয়ে যাচ্ছেন। এটি অর্জন করার জন্য, তারা প্রথমে সরলতার জন্য একটি enum ব্যবহার করে অনন্য আইডি, বিভাগ আইডি, নাম, চিত্র, উপাদান, পদক্ষেপ, সময়কাল, জটিলতা এবং সামর্থ্যের মতো বৈশিষ্ট্যগুলি সংজ্ঞায়িত করে একটি খাবারের জন্য একটি মডেল তৈরি করার বিষয়ে আলোচনা করে। তারা ভুল-মুক্ত টাইপিং নিশ্চিত করতে enums নামকরণের উপর জোর দেয় এবং খাবার কনস্ট্রাক্টরে বাধ্যতামূলক আর্গুমেন্ট নির্দিষ্ট করতে @required ডেকোরেটর ব্যবহার করে। স্পিকার তারপর ডামি_ডাটা.ডার্টে বিদ্যমান বিভাগগুলিতে ডামি খাবারের ডেটার একটি তালিকা যুক্ত করে, যাতে ডেটা অ্যাক্সেসযোগ্য হওয়ার জন্য ফাইলে খাবারের শ্রেণী আমদানি করা হয়। অতিরিক্তভাবে, তারা অপরিবর্তনীয়তার জন্য একটি কনস্ট্রাক্টর এবং ডামি খাবারের তালিকা সংজ্ঞায়িত করার সময় const কীওয়ার্ড ব্যবহার করার গুরুত্বের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يواصل المتحدث العمل على التطبيق من خلال التركيز على عرض الوصفات عند تحديد فئة في CategoryMealsScreen. لتحقيق ذلك، يناقشون أولاً إنشاء نموذج لوجبة من خلال تحديد خصائص مثل معرف فريد ومعرفات الفئة والاسم والصورة والمكونات والخطوات والمدة والتعقيد والقدرة على تحمل التكاليف باستخدام enum للبساطة. ويؤكدون على تسمية enums لضمان الكتابة الخالية من الأخطاء واستخدام الديكور @required لتحديد الوسائط الإلزامية في منشئ الوجبة. ثم يضيف المتحدث قائمة ببيانات الوجبة الوهمية إلى الفئات الموجودة في dummy_data.dart، مما يضمن استيراد فئة Meal إلى الملف حتى يمكن الوصول إلى البيانات. بالإضافة إلى ذلك، يؤكدون على أهمية استخدام منشئ ثابت لعدم القابلية للتغيير وكلمة المفتاح const عند تحديد قائمة الوجبات الوهمية.",
                                // Persian
                                "فارسی": "در این ویدیو، سخنران با تمرکز بر نمایش دستور العمل ها هنگامی که یک دسته در CategoryMealsScreen انتخاب می شود، به کار روی برنامه ادامه می دهد. برای دستیابی به این هدف، آنها ابتدا با تعریف ویژگی هایی مانند شناسه منحصر به فرد، شناسه های دسته، نام، تصویر، مواد تشکیل دهنده، مراحل، مدت زمان، پیچیدگی و مقرون به صرفه بودن با استفاده از یک عدد برای سادگی، درباره ایجاد مدلی برای یک وعده غذایی بحث می کنند. آنها بر نام گذاری enum ها برای اطمینان از تایپ بدون خطا تاکید می کنند و از دکوراتور @required برای مشخص کردن آرگومان های اجباری در سازنده غذا استفاده می کنند. سپس گوینده فهرستی از داده‌های وعده غذایی ساختگی را به دسته‌های موجود در dummy_data.dart اضافه می‌کند، و اطمینان حاصل می‌کند که کلاس Meal به فایل وارد می‌شود تا داده‌ها در دسترس باشند. علاوه بر این، آنها بر اهمیت استفاده از سازنده const برای تغییر ناپذیری و کلمه کلیدی const هنگام تعریف لیست وعده های غذایی ساختگی تاکید می کنند.",
                            },
                        },
                        // 148 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Selecting Meals for a Chosen Category",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker demonstrates how to filter and display meals based on a selected category ID. By importing dummy data and filtering it using the 'where' method, the speaker is able to create a list of meals that match the selected category. The meals are then displayed on the screen, allowing users to navigate through different categories and view corresponding meals. The speaker also discusses the next steps in improving the presentation of the meals on the app.",
                                // German
                                "Deutsch": "In diesem Video demonstriert der Sprecher, wie man Mahlzeiten basierend auf einer ausgewählten Kategorie-ID filtert und anzeigt. Durch Importieren von Dummy-Daten und Filtern mit der „Where“-Methode kann der Sprecher eine Liste mit Mahlzeiten erstellen, die der ausgewählten Kategorie entsprechen. Die Mahlzeiten werden dann auf dem Bildschirm angezeigt, sodass Benutzer durch verschiedene Kategorien navigieren und entsprechende Mahlzeiten anzeigen können. Der Sprecher bespricht auch die nächsten Schritte zur Verbesserung der Präsentation der Mahlzeiten in der App.",
                                // Chinese
                                "中国人": "在本视频中，演讲者演示了如何根据所选类别 ID 筛选和显示餐点。通过导入虚拟数据并使用“where”方法进行筛选，演讲者能够创建与所选类别相匹配的餐点列表。然后，这些餐点会显示在屏幕上，让用户可以浏览不同的类别并查看相应的餐点。演讲者还讨论了改进应用程序上餐点展示的后续步骤。",
                                // Russian
                                "Русский": "В этом видео докладчик демонстрирует, как фильтровать и отображать блюда на основе выбранного идентификатора категории. Импортируя фиктивные данные и фильтруя их с помощью метода «where», докладчик может создать список блюд, соответствующих выбранной категории. Затем блюда отображаются на экране, что позволяет пользователям перемещаться по различным категориям и просматривать соответствующие блюда. Докладчик также обсуждает следующие шаги по улучшению представления блюд в приложении.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant montre comment filtrer et afficher les repas en fonction d'un identifiant de catégorie sélectionné. En important des données fictives et en les filtrant à l'aide de la méthode « where », l'intervenant est en mesure de créer une liste de repas correspondant à la catégorie sélectionnée. Les repas sont ensuite affichés à l'écran, ce qui permet aux utilisateurs de naviguer dans différentes catégories et d'afficher les repas correspondants. L'intervenant discute également des prochaines étapes pour améliorer la présentation des repas sur l'application.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が選択したカテゴリ ID に基づいて食事をフィルタリングして表示する方法を説明します。ダミー データをインポートし、「where」メソッドを使用してフィルタリングすることで、講演者は選択したカテゴリに一致する食事のリストを作成できます。食事は画面に表示され、ユーザーはさまざまなカテゴリをナビゲートして対応する食事を表示できます。講演者は、アプリでの食事の表示を改善するための次のステップについても説明します。",
                                // Korean
                                "한국인": "이 비디오에서 스피커는 선택한 카테고리 ID를 기준으로 식사를 필터링하고 표시하는 방법을 보여줍니다. 더미 데이터를 가져와 'where' 메서드를 사용하여 필터링하면 스피커는 선택한 카테고리와 일치하는 식사 목록을 만들 수 있습니다. 그런 다음 식사가 화면에 표시되어 사용자가 다양한 카테고리를 탐색하고 해당 식사를 볼 수 있습니다. 스피커는 또한 앱에서 식사의 프레젠테이션을 개선하기 위한 다음 단계에 대해 설명합니다.",
                                // Spanish
                                "Español": "En este video, el orador demuestra cómo filtrar y mostrar las comidas según el ID de una categoría seleccionada. Al importar datos ficticios y filtrarlos con el método 'where', el orador puede crear una lista de comidas que coinciden con la categoría seleccionada. Luego, las comidas se muestran en la pantalla, lo que permite a los usuarios navegar por diferentes categorías y ver las comidas correspondientes. El orador también analiza los próximos pasos para mejorar la presentación de las comidas en la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता यह दर्शाता है कि चयनित श्रेणी आईडी के आधार पर भोजन को कैसे फ़िल्टर और प्रदर्शित किया जाए। डमी डेटा आयात करके और 'कहाँ' विधि का उपयोग करके इसे फ़िल्टर करके, वक्ता चयनित श्रेणी से मेल खाने वाले भोजन की एक सूची बनाने में सक्षम है। फिर भोजन स्क्रीन पर प्रदर्शित होते हैं, जिससे उपयोगकर्ता विभिन्न श्रेणियों के माध्यम से नेविगेट कर सकते हैं और संबंधित भोजन देख सकते हैं। वक्ता ऐप पर भोजन की प्रस्तुति को बेहतर बनाने के अगले चरणों पर भी चर्चा करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador demonstra como filtrar e exibir refeições com base num ID de categoria selecionado. Ao importar dados fictícios e filtrá-los através do método 'onde', o orador consegue criar uma lista de refeições que correspondem à categoria selecionada. As refeições são então apresentadas no ecrã, permitindo ao utilizador navegar pelas diferentes categorias e visualizar as refeições correspondentes. O orador aborda ainda os próximos passos para melhorar a apresentação das refeições na app.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার প্রদর্শন করে যে কীভাবে একটি নির্বাচিত বিভাগের আইডির উপর ভিত্তি করে খাবার ফিল্টার এবং প্রদর্শন করতে হয়। ডামি ডেটা আমদানি করে এবং 'কোথায়' পদ্ধতি ব্যবহার করে ফিল্টার করে, স্পিকার নির্বাচিত বিভাগের সাথে মেলে এমন খাবারের একটি তালিকা তৈরি করতে সক্ষম হয়। খাবারগুলি তারপরে স্ক্রিনে প্রদর্শিত হয়, ব্যবহারকারীদের বিভিন্ন বিভাগে নেভিগেট করতে এবং সংশ্লিষ্ট খাবার দেখতে দেয়। স্পিকার অ্যাপে খাবারের উপস্থাপনা উন্নত করার পরবর্তী পদক্ষেপগুলি নিয়েও আলোচনা করেন।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المتحدث كيفية تصفية وعرض الوجبات بناءً على معرف فئة محدد. من خلال استيراد بيانات وهمية وتصفيتها باستخدام طريقة 'أين'، يتمكن المتحدث من إنشاء قائمة بالوجبات التي تتوافق مع الفئة المحددة. ثم يتم عرض الوجبات على الشاشة، مما يسمح للمستخدمين بالتنقل عبر فئات مختلفة وعرض الوجبات المقابلة. يناقش المتحدث أيضًا الخطوات التالية لتحسين عرض الوجبات على التطبيق.",
                                // Persian
                                "فارسی": "در این ویدئو، بلندگو نحوه فیلتر کردن و نمایش وعده‌های غذایی را بر اساس شناسه دسته‌بندی انتخابی نشان می‌دهد. با وارد کردن داده‌های ساختگی و فیلتر کردن آن با استفاده از روش «where»، گوینده می‌تواند فهرستی از وعده‌های غذایی را ایجاد کند که با دسته انتخابی مطابقت دارد. سپس وعده‌های غذایی روی صفحه نمایش داده می‌شوند و به کاربران اجازه می‌دهند در دسته‌های مختلف حرکت کنند و وعده‌های غذایی مربوطه را مشاهده کنند. سخنران همچنین گام های بعدی در بهبود ارائه وعده های غذایی در برنامه را مورد بحث قرار می دهد.",
                            },
                        },
                        // 149 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Displaying Recipe Items & Using Network Images",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker demonstrates the process of creating a new widget for a single list item, referred to as 'meal item', to display meals in a more organized and visually appealing manner. The speaker discusses the importance of maintaining a clear folder structure for different types of widgets and how to organize screen and widget files accordingly. The creation of the meal item widget involves configuring the layout using built-in Flutter widgets like InkWell, Card, ClipRRect, Image.network, and others. The speaker provides detailed explanations on how to set up the meal item widget to display meal images, titles, duration, affordability, and complexity, with a focus on styling and presentation. The video concludes with testing the meal item widget to display images in the app, with plans to further enhance the widget functionality by displaying additional meal information and making the items tappable.",
                                // German
                                "Deutsch": "In diesem Video demonstriert der Sprecher den Prozess der Erstellung eines neuen Widgets für einen einzelnen Listeneintrag, der als 'Essens-Element' bezeichnet wird, um Mahlzeiten auf eine organisierte und visuell ansprechende Weise anzuzeigen. Der Sprecher diskutiert die Bedeutung der Aufrechterhaltung einer klaren Ordnerstruktur für verschiedene Arten von Widgets und wie man Bildschirm- und Widget-Dateien entsprechend organisiert. Die Erstellung des Essens-Widgets beinhaltet das Konfigurieren des Layouts mithilfe von integrierten Flutter-Widgets wie InkWell, Card, ClipRRect, Image.network und anderen. Der Sprecher gibt ausführliche Erläuterungen dazu, wie man das Essens-Widget einrichtet, um Essensbilder, Titel, Dauer, Preis und Komplexität anzuzeigen, wobei der Schwerpunkt auf Styling und Präsentation liegt. Das Video endet mit dem Testen des Essens-Widgets zur Anzeige von Bildern in der App, mit Plänen, die Widget-Funktionalität weiter zu verbessern, indem zusätzliche Mahlzeiteninformationen angezeigt und die Elemente anklickbar gemacht werden.",
                                // Chinese
                                "中国人": "在本视频中，演讲者演示了为单个列表项（称为“餐点项目”）创建新小部件的过程，以便以更有条理、更具视觉吸引力的方式显示餐点。演讲者讨论了为不同类型的小部件保持清晰的文件夹结构的重要性，以及如何相应地组织屏幕和小部件文件。餐点项目小部件的创建涉及使用内置 Flutter 小部件（如 InkWell、Card、ClipRRect、Image.network 等）配置布局。演讲者详细说明了如何设置餐点项目小部件以显示餐点图像、标题、持续时间、可负担性和复杂性，重点是样式和演示。视频最后测试了餐点项目小部件以在应用中显示图像，并计划通过显示其他餐点信息并使项目可点击来进一步增强小部件功能。",
                                // Russian
                                "Русский": "В этом видео докладчик демонстрирует процесс создания нового виджета для одного элемента списка, называемого «элементом еды», для отображения блюд в более организованной и визуально привлекательной манере. Докладчик обсуждает важность поддержания четкой структуры папок для различных типов виджетов и то, как соответствующим образом организовать файлы экрана и виджета. Создание виджета элемента еды включает настройку макета с использованием встроенных виджетов Flutter, таких как InkWell, Card, ClipRRect, Image.network и других. Докладчик дает подробные объяснения о том, как настроить виджет элемента еды для отображения изображений блюд, названий, продолжительности, доступности и сложности, уделяя особое внимание стилю и представлению. Видео завершается тестированием виджета элемента еды для отображения изображений в приложении, с планами по дальнейшему улучшению функциональности виджета путем отображения дополнительной информации о еде и создания элементов, которые можно нажимать.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant montre le processus de création d'un nouveau widget pour un seul élément de liste, appelé « élément de repas », afin d'afficher les repas d'une manière plus organisée et visuellement plus attrayante. L'intervenant explique l'importance de maintenir une structure de dossiers claire pour différents types de widgets et comment organiser les fichiers d'écran et de widget en conséquence. La création du widget d'élément de repas implique la configuration de la mise en page à l'aide de widgets Flutter intégrés tels que InkWell, Card, ClipRRect, Image.network et autres. L'intervenant fournit des explications détaillées sur la façon de configurer le widget d'élément de repas pour afficher les images, les titres, la durée, l'accessibilité et la complexité des repas, en mettant l'accent sur le style et la présentation. La vidéo se termine par le test du widget d'élément de repas pour afficher les images dans l'application, avec des plans pour améliorer encore la fonctionnalité du widget en affichant des informations supplémentaires sur les repas et en rendant les éléments accessibles.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が「食事項目」と呼ばれる単一のリスト項目用の新しいウィジェットを作成し、食事をより整理された見栄えの良い方法で表示するプロセスを実演します。講演者は、さまざまな種類のウィジェットに対して明確なフォルダー構造を維持することの重要性と、それに応じて画面とウィジェット ファイルを整理する方法について説明します。食事項目ウィジェットの作成には、InkWell、Card、ClipRRect、Image.network などの組み込み Flutter ウィジェットを使用してレイアウトを構成することが含まれます。講演者は、スタイルとプレゼンテーションに重点を置いて、食事の画像、タイトル、期間、手頃な価格、複雑さを表示する食事項目ウィジェットの設定方法について詳しく説明します。ビデオの最後には、アプリで画像を表示する食事項目ウィジェットのテストが行​​われ、追加の食事情報を表示し、項目をタップ可能にすることでウィジェットの機能をさらに強化する予定です。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 '식사 항목'이라고 하는 단일 목록 항목에 대한 새 위젯을 만드는 과정을 보여 주며, 식사를 보다 체계적이고 시각적으로 매력적인 방식으로 표시합니다. 발표자는 다양한 유형의 위젯에 대해 명확한 폴더 구조를 유지하는 것의 중요성과 그에 따라 화면 및 위젯 파일을 구성하는 방법에 대해 설명합니다. 식사 항목 위젯을 만드는 데는 InkWell, Card, ClipRRect, Image.network 등과 같은 기본 제공 Flutter 위젯을 사용하여 레이아웃을 구성하는 것이 포함됩니다. 발표자는 스타일링과 프레젠테이션에 초점을 맞춰 식사 이미지, 제목, 기간, 저렴성 및 복잡성을 표시하도록 식사 항목 위젯을 설정하는 방법에 대한 자세한 설명을 제공합니다. 이 비디오는 앱에서 이미지를 표시하기 위해 식사 항목 위젯을 테스트하는 것으로 마무리되며, 추가 식사 정보를 표시하고 항목을 탭할 수 있도록 하여 위젯 기능을 더욱 향상시킬 계획입니다.",
                                // Spanish
                                "Español": "En este video, el orador demuestra el proceso de creación de un nuevo widget para un solo elemento de la lista, denominado 'elemento de comida', para mostrar las comidas de una manera más organizada y visualmente atractiva. El orador analiza la importancia de mantener una estructura de carpetas clara para los diferentes tipos de widgets y cómo organizar los archivos de pantalla y widget en consecuencia. La creación del widget de elemento de comida implica configurar el diseño utilizando widgets Flutter integrados como InkWell, Card, ClipRRect, Image.network y otros. El orador proporciona explicaciones detalladas sobre cómo configurar el widget de elemento de comida para mostrar imágenes de las comidas, títulos, duración, asequibilidad y complejidad, con un enfoque en el estilo y la presentación. El video concluye con la prueba del widget de elemento de comida para mostrar imágenes en la aplicación, con planes para mejorar aún más la funcionalidad del widget mostrando información adicional sobre las comidas y haciendo que los elementos se puedan tocar.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता एकल सूची आइटम के लिए एक नया विजेट बनाने की प्रक्रिया का प्रदर्शन करता है, जिसे 'भोजन आइटम' कहा जाता है, ताकि भोजन को अधिक संगठित और नेत्रहीन रूप से आकर्षक तरीके से प्रदर्शित किया जा सके। वक्ता विभिन्न प्रकार के विजेट्स के लिए एक स्पष्ट फ़ोल्डर संरचना बनाए रखने और स्क्रीन और विजेट फ़ाइलों को तदनुसार व्यवस्थित करने के महत्व पर चर्चा करता है। भोजन आइटम विजेट के निर्माण में इंकवेल, कार्ड, क्लिपआररेक्ट, इमेज.नेटवर्क और अन्य जैसे अंतर्निहित फ़्लटर विजेट्स का उपयोग करके लेआउट को कॉन्फ़िगर करना शामिल है। वक्ता भोजन की छवियों, शीर्षकों, अवधि, सामर्थ्य और जटिलता को प्रदर्शित करने के लिए भोजन आइटम विजेट को सेट करने के तरीके के बारे में विस्तृत स्पष्टीकरण प्रदान करता है, जिसमें स्टाइलिंग और प्रस्तुति पर ध्यान केंद्रित किया जाता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador demonstra o processo de criação de um novo widget para um único item da lista, denominado ‘item de refeição’, para exibir as refeições de forma mais organizada e visualmente apelativa. O orador discute a importância de manter uma estrutura de pastas clara para os diferentes tipos de widgets e como organizar os ficheiros de ecrã e de widgets em conformidade. A criação do widget de item de refeição envolve a configuração do layout utilizando widgets Flutter integrados, como InkWell, Card, ClipRRect, Image.network e outros. O orador fornece explicações detalhadas sobre como configurar o widget de item de refeição para exibir imagens, títulos, duração, preço acessível e complexidade das refeições, com foco no estilo e na apresentação. O vídeo termina com o teste do widget de item de refeição para exibir imagens na aplicação, com planos para melhorar ainda mais a funcionalidade do widget, exibindo informações adicionais sobre a refeição e tornando os itens tocáveis.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি একক তালিকা আইটেমের জন্য একটি নতুন উইজেট তৈরি করার প্রক্রিয়া প্রদর্শন করে, যাকে 'খাবারের আইটেম' হিসাবে উল্লেখ করা হয়, যাতে আরও সংগঠিত এবং দৃশ্যত আকর্ষণীয় পদ্ধতিতে খাবার প্রদর্শন করা যায়। স্পিকার বিভিন্ন ধরণের উইজেটগুলির জন্য একটি পরিষ্কার ফোল্ডার কাঠামো বজায় রাখার গুরুত্ব এবং সেই অনুযায়ী স্ক্রিন এবং উইজেট ফাইলগুলি কীভাবে সংগঠিত করা যায় সে সম্পর্কে আলোচনা করেন। খাবারের আইটেম উইজেট তৈরিতে অন্তর্নির্মিত ফ্লাটার উইজেটগুলি যেমন InkWell, Card, ClipRRect, Image.network এবং অন্যান্য ব্যবহার করে লেআউট কনফিগার করা জড়িত। স্পিকার খাবারের ছবি, শিরোনাম, সময়কাল, সামর্থ্য এবং জটিলতা প্রদর্শনের জন্য খাবারের আইটেম উইজেটটি কীভাবে সেট আপ করতে হয় সে সম্পর্কে বিস্তারিত ব্যাখ্যা প্রদান করে, স্টাইলিং এবং উপস্থাপনাকে কেন্দ্র করে। ভিডিওটি অ্যাপে ইমেজ প্রদর্শনের জন্য খাবারের আইটেম উইজেট পরীক্ষা করার মাধ্যমে শেষ হয়েছে, অতিরিক্ত খাবারের তথ্য প্রদর্শন করে এবং আইটেমগুলিকে ট্যাপযোগ্য করে তোলার মাধ্যমে উইজেটের কার্যকারিতা আরও উন্নত করার পরিকল্পনা নিয়ে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح المتحدث عملية إنشاء عنصر واجهة مستخدم جديد لعنصر قائمة واحد، يُشار إليه باسم 'عنصر الوجبة'، لعرض الوجبات بطريقة أكثر تنظيمًا وجاذبية بصريًا. يناقش المتحدث أهمية الحفاظ على بنية مجلد واضحة لأنواع مختلفة من عناصر واجهة المستخدم وكيفية تنظيم ملفات الشاشة وعناصر واجهة المستخدم وفقًا لذلك. يتضمن إنشاء عنصر واجهة مستخدم عنصر الوجبة تكوين التخطيط باستخدام عناصر واجهة مستخدم Flutter المضمنة مثل InkWell وCard وClipRRect وImage.network وغيرها. يقدم المتحدث تفسيرات مفصلة حول كيفية إعداد عنصر واجهة مستخدم عنصر الوجبة لعرض صور الوجبات والعناوين والمدة والقدرة على تحمل التكاليف والتعقيد، مع التركيز على التصميم والعرض. ويختتم الفيديو باختبار عنصر واجهة مستخدم عنصر الوجبة لعرض الصور في التطبيق، مع خطط لتعزيز وظائف عنصر واجهة المستخدم بشكل أكبر من خلال عرض معلومات إضافية عن الوجبة وجعل العناصر قابلة للنقر.",
                                // Persian
                                "فارسی": "در این ویدئو، گوینده روند ایجاد یک ویجت جدید برای یک آیتم فهرست را نشان می‌دهد که به آن 'مورد غذا' گفته می‌شود تا غذاها را به شیوه‌ای سازمان‌دهی‌شده‌تر و از نظر بصری جذاب‌تر نمایش دهد. سخنران در مورد اهمیت حفظ ساختار پوشه روشن برای انواع مختلف ویجت ها و نحوه سازماندهی صفحه نمایش و فایل های ویجت بر این اساس بحث می کند. ایجاد ویجت مورد غذا شامل پیکربندی چیدمان با استفاده از ویجت‌های Flutter داخلی مانند InkWell، Card، ClipRRect، Image.network و موارد دیگر است. سخنران توضیحات مفصلی در مورد نحوه تنظیم ویجت غذا برای نمایش تصاویر، عناوین، مدت زمان، مقرون به صرفه بودن و پیچیدگی غذا با تمرکز بر استایل و ارائه ارائه می دهد. این ویدئو با آزمایش ویجت مواد غذایی برای نمایش تصاویر در برنامه، با برنامه هایی برای بهبود بیشتر عملکرد ویجت با نمایش اطلاعات اضافی وعده های غذایی و قابل لمس کردن اقلام به پایان می رسد.",
                            },
                        },
                        // 150 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Finishing the Meal List Item",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker explains how to add rounded corners to images and text in a Flutter app. They show how to use ClipRRect to fix issues with overlapping corners and add text on top of images using the Positioned widget. The speaker also demonstrates how to display different pieces of information below the image, such as duration and complexity, by using enums and getters. Finally, they discuss adding affordability information and ensuring proper spacing between the information items in a row. The speaker concludes by mentioning their next steps of making the items clickable for navigation to a detail page.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Sprecher, wie man in einer Flutter-App abgerundete Ecken zu Bildern und Text hinzufügt. Er zeigt, wie man mit ClipRRect Probleme mit überlappenden Ecken behebt und mit dem Positioned-Widget Text über Bilder hinzufügt. Der Sprecher demonstriert auch, wie man mithilfe von Enumerationen und Gettern verschiedene Informationen unter dem Bild anzeigt, z. B. Dauer und Komplexität. Abschließend wird das Hinzufügen von Erschwinglichkeitsinformationen und das Sicherstellen des richtigen Abstands zwischen den Informationselementen in einer Reihe besprochen. Der Sprecher schließt mit der Erwähnung der nächsten Schritte, um die Elemente anklickbar zu machen, damit man zu einer Detailseite navigieren kann.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讲解了如何在 Flutter 应用中为图片和文本添加圆角。他们展示了如何使用 ClipRRect 修复重叠角的问题，以及如何使用 Positioned 小部件在图片顶部添加文本。演讲者还演示了如何使用枚举和 getter 在图片下方显示不同的信息，例如持续时间和复杂度。最后，他们讨论了如何添加可负担性信息，以及如何确保一行中的信息项之间有适当的间距。演讲者最后提到了他们的下一步计划，即使这些项目可点击以导航到详细信息页面。",
                                // Russian
                                "Русский": "В этом видео докладчик объясняет, как добавлять скругленные углы к изображениям и тексту в приложении Flutter. Они показывают, как использовать ClipRRect для устранения проблем с перекрывающимися углами и добавлять текст поверх изображений с помощью виджета Positioned. Докладчик также демонстрирует, как отображать различные фрагменты информации под изображением, такие как длительность и сложность, с помощью перечислений и геттеров. Наконец, они обсуждают добавление информации о доступности и обеспечение надлежащего интервала между элементами информации в строке. Докладчик завершает, упоминая их следующие шаги по созданию элементов, которые можно нажимать для навигации на страницу с подробностями.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique comment ajouter des coins arrondis aux images et au texte dans une application Flutter. Il montre comment utiliser ClipRRect pour résoudre les problèmes de chevauchement des coins et ajouter du texte au-dessus des images à l'aide du widget Positioned. L'intervenant montre également comment afficher différentes informations sous l'image, telles que la durée et la complexité, en utilisant des énumérations et des getters. Enfin, il discute de l'ajout d'informations sur l'accessibilité et de la garantie d'un espacement approprié entre les éléments d'information d'une ligne. L'intervenant conclut en mentionnant les prochaines étapes pour rendre les éléments cliquables pour la navigation vers une page de détails.",
                                // Japanese
                                "日本語": "このビデオでは、講演者が Flutter アプリで画像やテキストに丸い角を追加する方法について説明します。ClipRRect を使用して角が重なる問題を修正し、Positioned ウィジェットを使用して画像の上にテキストを追加する方法を示します。講演者はまた、列挙型とゲッターを使用して、画像の下に期間や複雑さなどのさまざまな情報を表示する方法も示します。最後に、手頃な価格の情報を追加し、行内の情報項目間の適切な間隔を確保する方法について説明します。講演者は最後に、詳細ページに移動するために項目をクリック可能にする次のステップについて言及して締めくくります。",
                                // Korean
                                "한국인": "이 영상에서 발표자는 Flutter 앱에서 이미지와 텍스트에 둥근 모서리를 추가하는 방법을 설명합니다. ClipRRect를 사용하여 모서리가 겹치는 문제를 해결하고 Positioned 위젯을 사용하여 이미지 위에 텍스트를 추가하는 방법을 보여줍니다. 발표자는 또한 열거형과 게터를 사용하여 지속 시간과 복잡도와 같은 다양한 정보를 이미지 아래에 표시하는 방법을 보여줍니다. 마지막으로, 저렴성 정보를 추가하고 행의 정보 항목 사이에 적절한 간격을 두는 방법에 대해 설명합니다. 발표자는 세부 정보 페이지로 이동하기 위해 항목을 클릭 가능하게 만드는 다음 단계를 언급하면서 마무리합니다.",
                                // Spanish
                                "Español": "En este video, el orador explica cómo agregar esquinas redondeadas a imágenes y texto en una aplicación Flutter. Muestra cómo usar ClipRRect para solucionar problemas con esquinas superpuestas y agregar texto sobre imágenes usando el widget Positioned. El orador también demuestra cómo mostrar diferentes piezas de información debajo de la imagen, como duración y complejidad, mediante enumeraciones y captadores. Por último, analiza cómo agregar información de asequibilidad y garantizar el espaciado adecuado entre los elementos de información en una fila. El orador concluye mencionando los próximos pasos para hacer que los elementos sean cliqueables para navegar a una página de detalles.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता बताते हैं कि फ़्लटर ऐप में छवियों और टेक्स्ट में गोल कोने कैसे जोड़े जाते हैं। वे दिखाते हैं कि ओवरलैपिंग कोनों के साथ समस्याओं को ठीक करने और पोजिशन्ड विजेट का उपयोग करके छवियों के शीर्ष पर टेक्स्ट जोड़ने के लिए क्लिपआररेक्ट का उपयोग कैसे करें। वक्ता यह भी प्रदर्शित करता है कि एनम और गेटर्स का उपयोग करके छवि के नीचे विभिन्न जानकारी, जैसे अवधि और जटिलता, कैसे प्रदर्शित की जाती है। अंत में, वे सामर्थ्य जानकारी जोड़ने और एक पंक्ति में सूचना आइटम के बीच उचित अंतर सुनिश्चित करने पर चर्चा करते हैं। वक्ता विवरण पृष्ठ पर नेविगेशन के लिए आइटम को क्लिक करने योग्य बनाने के अपने अगले चरणों का उल्लेख करके निष्कर्ष निकालते हैं।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador explica como adicionar cantos arredondados a imagens e texto numa aplicação Flutter. Mostram como utilizar o ClipRRect para corrigir problemas com cantos sobrepostos e adicionar texto sobre imagens utilizando o widget Posicionado. O orador demonstra também como exibir diferentes informações abaixo da imagem, como a duração e a complexidade, utilizando enums e getters. Por fim, discutem a adição de informação sobre acessibilidade e a garantia de um espaçamento adequado entre itens de informação consecutivos. O orador conclui mencionando os próximos passos para tornar os itens clicáveis ​​para a navegação até uma página de detalhes.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার ব্যাখ্যা করেছেন কীভাবে একটি ফ্লাটার অ্যাপে চিত্র এবং পাঠ্যের সাথে গোলাকার কোণগুলি যুক্ত করতে হয়। তারা দেখায় কিভাবে ওভারল্যাপিং কোণগুলির সমস্যাগুলি সমাধান করতে এবং অবস্থানযুক্ত উইজেট ব্যবহার করে চিত্রের উপরে পাঠ্য যোগ করতে ClipRRect ব্যবহার করতে হয়। স্পিকার এছাড়াও প্রদর্শন করে কিভাবে চিত্রের নীচে তথ্যের বিভিন্ন টুকরো প্রদর্শন করা যায়, যেমন সময়কাল এবং জটিলতা, enums এবং getters ব্যবহার করে। অবশেষে, তারা সাশ্রয়ী মূল্যের তথ্য যোগ করার বিষয়ে আলোচনা করে এবং একটি সারিতে তথ্য আইটেমগুলির মধ্যে সঠিক ব্যবধান নিশ্চিত করে। স্পিকার একটি বিস্তারিত পৃষ্ঠায় নেভিগেশনের জন্য আইটেমগুলিকে ক্লিকযোগ্য করার জন্য তাদের পরবর্তী পদক্ষেপগুলি উল্লেখ করে শেষ করেন।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المتحدث كيفية إضافة زوايا مستديرة للصور والنصوص في تطبيق Flutter. كما يوضح كيفية استخدام ClipRRect لإصلاح المشكلات المتعلقة بالزوايا المتداخلة وإضافة نص أعلى الصور باستخدام عنصر واجهة المستخدم Positioned. كما يوضح المتحدث كيفية عرض معلومات مختلفة أسفل الصورة، مثل المدة والتعقيد، باستخدام التعدادات والطرق. وأخيرًا، يناقش إضافة معلومات القدرة على تحمل التكاليف وضمان التباعد المناسب بين عناصر المعلومات في صف واحد. ويختتم المتحدث حديثه بذكر الخطوات التالية لجعل العناصر قابلة للنقر للانتقال إلى صفحة التفاصيل.",
                                // Persian
                                "فارسی": "در این ویدئو، بلندگو نحوه افزودن گوشه های گرد به تصاویر و متن در اپلیکیشن فلاتر را توضیح می دهد. آنها نحوه استفاده از ClipRRect را برای رفع مشکلات گوشه های همپوشانی و اضافه کردن متن در بالای تصاویر با استفاده از ویجت Positioned نشان می دهند. بلندگو همچنین نحوه نمایش اطلاعات مختلف در زیر تصویر مانند مدت زمان و پیچیدگی را با استفاده از enums و getter نشان می دهد. در نهایت، آنها در مورد افزودن اطلاعات مقرون به صرفه و اطمینان از فاصله مناسب بین موارد اطلاعاتی در یک ردیف بحث می کنند. سخنران با ذکر مراحل بعدی خود در مورد ایجاد موارد قابل کلیک برای پیمایش به یک صفحه جزئیات به پایان می رسد.",
                            },
                        },
                        // 151 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Navigating to the Meal Detail Page",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker discusses the process of creating a new screen in a Flutter app to display details about a single recipe. They demonstrate how to create the MealDetailScreen widget and register it as a route in the main.dart file using named routes. The speaker explains how to pass data, such as the meal ID, between screens and access this data in the MealDetailScreen using arguments. They also highlight the importance of using the scaffold widget for standalone pages to add background, an appBar, and connect the widget to the theme set up in the material app. The video concludes with a demonstration of successfully navigating between screens and passing data, with the next steps including displaying more information about a selected meal.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Sprecher den Prozess der Erstellung eines neuen Bildschirms in einer Flutter-App, um Details zu einem einzelnen Rezept anzuzeigen. Er zeigt, wie das MealDetailScreen-Widget erstellt und mithilfe benannter Routen als Route in der Datei main.dart registriert wird. Der Sprecher erklärt, wie Daten, wie z. B. die Mahlzeit-ID, zwischen Bildschirmen weitergegeben und mithilfe von Argumenten auf diese Daten im MealDetailScreen zugegriffen werden kann. Er hebt auch die Bedeutung der Verwendung des Scaffold-Widgets für eigenständige Seiten hervor, um einen Hintergrund und eine AppBar hinzuzufügen und das Widget mit dem in der Material-App eingerichteten Design zu verbinden. Das Video endet mit einer Demonstration der erfolgreichen Navigation zwischen Bildschirmen und der Datenübertragung. Die nächsten Schritte umfassen die Anzeige weiterer Informationen zu einer ausgewählten Mahlzeit.",
                                // Chinese
                                "中国人": "在本视频中，演讲者讨论了在 Flutter 应用中创建新屏幕以显示单个菜谱详细信息的过程。他们演示了如何创建 MealDetailScreen 小部件并使用命名路由将其注册为 main.dart 文件中的路由。演讲者解释了如何在屏幕之间传递数据（例如餐点 ID）以及如何使用参数在 MealDetailScreen 中访问这些数据。他们还强调了使用独立页面的脚手架小部件来添加背景、appBar 以及将小部件连接到材料应用中设置的主题的重要性。视频最后演示了如何在屏幕之间成功导航和传递数据，接下来的步骤包括显示有关所选餐点的更多信息。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает процесс создания нового экрана в приложении Flutter для отображения сведений об одном рецепте. Они демонстрируют, как создать виджет MealDetailScreen и зарегистрировать его в качестве маршрута в файле main.dart с использованием именованных маршрутов. Докладчик объясняет, как передавать данные, такие как идентификатор приема пищи, между экранами и получать доступ к этим данным в MealDetailScreen с использованием аргументов. Они также подчеркивают важность использования виджета scaffold для автономных страниц для добавления фона, appBar и подключения виджета к теме, настроенной в приложении Material. Видео завершается демонстрацией успешной навигации между экранами и передачи данных, а следующие шаги включают отображение дополнительной информации о выбранном приеме пищи.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique le processus de création d'un nouvel écran dans une application Flutter pour afficher les détails d'une seule recette. Il montre comment créer le widget MealDetailScreen et l'enregistrer en tant qu'itinéraire dans le fichier main.dart à l'aide d'itinéraires nommés. L'intervenant explique comment transmettre des données, telles que l'ID du repas, entre les écrans et accéder à ces données dans MealDetailScreen à l'aide d'arguments. Il souligne également l'importance d'utiliser le widget scaffold pour les pages autonomes afin d'ajouter un arrière-plan, une appBar et de connecter le widget au thème configuré dans l'application Material. La vidéo se termine par une démonstration de navigation réussie entre les écrans et de transmission de données, les étapes suivantes comprenant l'affichage de plus d'informations sur un repas sélectionné.",
                                // Japanese
                                "日本語": "この動画では、講師が Flutter アプリで新しい画面を作成し、1 つのレシピの詳細を表示するプロセスについて説明します。MealDetailScreen ウィジェットを作成し、名前付きルートを使用して main.dart ファイルにルートとして登録する方法を示します。また、画面間で食事 ID などのデータを渡し、引数を使用して MealDetailScreen でこのデータにアクセスする方法について説明します。また、スタンドアロン ページに scaffold ウィジェットを使用して背景や appBar を追加し、ウィジェットをマテリアル アプリで設定されたテーマに接続する重要性についても説明します。動画の最後には、画面間を正常にナビゲートしてデータを渡すデモが行われ、次のステップでは選択した食事の詳細情報を表示します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 앱에서 단일 레시피에 대한 세부 정보를 표시하기 위해 새 화면을 만드는 과정에 대해 설명합니다. 발표자는 MealDetailScreen 위젯을 만들고 명명된 경로를 사용하여 main.dart 파일에 경로로 등록하는 방법을 보여줍니다. 발표자는 식사 ID와 같은 데이터를 화면 간에 전달하고 인수를 사용하여 MealDetailScreen에서 이 데이터에 액세스하는 방법을 설명합니다. 또한 독립형 페이지에 대한 스캐폴드 위젯을 사용하여 배경, 앱바를 추가하고 위젯을 Material 앱에서 설정된 테마에 연결하는 것의 중요성을 강조합니다. 이 비디오는 화면 간에 성공적으로 탐색하고 데이터를 전달하는 방법을 보여주는 것으로 마무리되며, 다음 단계에는 선택한 식사에 대한 추가 정보를 표시하는 것이 포함됩니다.",
                                // Spanish
                                "Español": "En este video, el orador analiza el proceso de creación de una nueva pantalla en una aplicación Flutter para mostrar detalles sobre una sola receta. Demuestra cómo crear el widget MealDetailScreen y registrarlo como una ruta en el archivo main.dart mediante rutas con nombre. El orador explica cómo pasar datos, como el ID de la comida, entre pantallas y acceder a estos datos en MealDetailScreen mediante argumentos. También destaca la importancia de usar el widget de estructura para páginas independientes para agregar un fondo, una barra de aplicaciones y conectar el widget al tema configurado en la aplicación de material. El video concluye con una demostración de cómo navegar con éxito entre pantallas y pasar datos, y los próximos pasos incluyen mostrar más información sobre una comida seleccionada.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता फ़्लटर ऐप में एक नई स्क्रीन बनाने की प्रक्रिया पर चर्चा करता है, ताकि किसी एकल रेसिपी के बारे में विवरण प्रदर्शित किया जा सके। वे प्रदर्शित करते हैं कि MealDetailScreen विजेट कैसे बनाया जाता है और नामित रूट का उपयोग करके इसे main.dart फ़ाइल में रूट के रूप में पंजीकृत किया जाता है। वक्ता बताते हैं कि स्क्रीन के बीच मील आईडी जैसे डेटा को कैसे पास किया जाए और तर्कों का उपयोग करके MealDetailScreen में इस डेटा को कैसे एक्सेस किया जाए। वे स्टैंडअलोन पेजों के लिए बैकग्राउंड, ऐपबार जोड़ने और विजेट को मटेरियल ऐप में सेट अप की गई थीम से जोड़ने के लिए स्कैफ़ोल्ड विजेट का उपयोग करने के महत्व पर भी प्रकाश डालते हैं। वीडियो स्क्रीन के बीच सफलतापूर्वक नेविगेट करने और डेटा पास करने के प्रदर्शन के साथ समाप्त होता है, जिसमें अगले चरण में चयनित भोजन के बारे में अधिक जानकारी प्रदर्शित करना शामिल है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador discute o processo de criação de um novo ecrã numa aplicação Flutter para exibir detalhes sobre uma única receita. Demonstram como criar o widget MealDetailScreen e registá-lo como uma rota no ficheiro main.dart utilizando rotas nomeadas. O orador explica como passar dados, como o ID da refeição, entre ecrãs e aceder a esses dados no MealDetailScreen usando argumentos. Destacam também a importância de utilizar o widget scaffold para páginas autónomas para adicionar fundo, uma appBar e ligar o widget ao tema configurado na aplicação de material. O vídeo termina com uma demonstração de navegação bem-sucedida entre ecrãs e passagem de dados, com os próximos passos a incluir a exibição de mais informações sobre uma refeição selecionada.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার একটি একক রেসিপি সম্পর্কে বিশদ বিবরণ প্রদর্শন করতে একটি ফ্লাটার অ্যাপে একটি নতুন স্ক্রিন তৈরি করার প্রক্রিয়া নিয়ে আলোচনা করেছেন। তারা প্রদর্শন করে কিভাবে MealDetailScreen উইজেট তৈরি করতে হয় এবং নামযুক্ত রুট ব্যবহার করে main.dart ফাইলে একটি রুট হিসেবে নিবন্ধন করতে হয়। স্পিকার ব্যাখ্যা করে যে কীভাবে ডাটা পাস করতে হয়, যেমন খাবারের আইডি, স্ক্রীনের মধ্যে এবং আর্গুমেন্ট ব্যবহার করে MealDetailScreen-এ এই ডেটা অ্যাক্সেস করতে হয়। তারা ব্যাকগ্রাউন্ড, একটি অ্যাপবার যোগ করার জন্য স্বতন্ত্র পৃষ্ঠাগুলির জন্য স্ক্যাফোল্ড উইজেট ব্যবহার করার গুরুত্বও তুলে ধরে এবং উপাদান অ্যাপে সেট আপ করা থিমের সাথে উইজেটটিকে সংযুক্ত করে। ভিডিওটি একটি নির্বাচিত খাবার সম্পর্কে আরও তথ্য প্রদর্শন সহ পরবর্তী পদক্ষেপ সহ স্ক্রিনগুলির মধ্যে সফলভাবে নেভিগেট করার এবং ডেটা পাস করার একটি প্রদর্শনের সাথে শেষ হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش المتحدث عملية إنشاء شاشة جديدة في تطبيق Flutter لعرض تفاصيل حول وصفة واحدة. ويوضح كيفية إنشاء عنصر واجهة المستخدم MealDetailScreen وتسجيله كطريق في ملف main.dart باستخدام الطرق المسماة. ويشرح المتحدث كيفية تمرير البيانات، مثل معرف الوجبة، بين الشاشات والوصول إلى هذه البيانات في MealDetailScreen باستخدام الوسائط. كما يسلط الضوء على أهمية استخدام عنصر واجهة المستخدم scaffold للصفحات المستقلة لإضافة الخلفية وشريط التطبيق وتوصيل عنصر واجهة المستخدم بالموضوع الذي تم إعداده في تطبيق material. ويختتم الفيديو بعرض توضيحي للتنقل بنجاح بين الشاشات وتمرير البيانات، مع الخطوات التالية بما في ذلك عرض المزيد من المعلومات حول وجبة محددة.",
                                // Persian
                                "فارسی": "در این ویدیو، سخنران در مورد فرآیند ایجاد یک صفحه نمایش جدید در یک برنامه Flutter برای نمایش جزئیات یک دستور غذا صحبت می کند. آنها نحوه ایجاد ویجت MealDetailScreen و ثبت آن را به عنوان یک مسیر در فایل main.dart با استفاده از مسیرهای نامگذاری شده نشان می دهند. سخنران نحوه انتقال داده‌ها، مانند شناسه غذا، بین صفحه‌ها و دسترسی به این داده‌ها در MealDetailScreen را با استفاده از آرگومان‌ها توضیح می‌دهد. آنها همچنین بر اهمیت استفاده از ویجت داربست برای صفحات مستقل برای افزودن پس‌زمینه، نوار برنامه و اتصال ویجت به تم تنظیم شده در برنامه متریال تأکید می‌کنند. این ویدئو با نمایش موفقیت آمیز پیمایش بین صفحه نمایش ها و ارسال داده ها، با مراحل بعدی شامل نمایش اطلاعات بیشتر در مورد یک وعده غذایی انتخاب شده، به پایان می رسد.",
                            },
                        },
                        // 152 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "onGenerateRoute & onUnknownRoute",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the speaker explains the concept of loading pages in a Flutter app using push or pushNamed methods, with pushNamed requiring the registration of routes in the main.dart file while push creates routes on the fly. The speaker discusses the onGenerateRoute and onUnknownRoute methods, highlighting their importance for handling dynamically generated routes and fallback scenarios. They demonstrate how onUnknownRoute is used as a last resort to display a fallback page if a specific route cannot be built, ensuring that users always see content on the screen. The video emphasizes the importance of providing a fallback page to prevent app crashes and compares it to a 404 fallback page on the web.",
                                // German
                                "Deutsch": "In diesem Video erklärt der Sprecher das Konzept des Ladens von Seiten in einer Flutter-App mithilfe von Push- oder PushNamed-Methoden, wobei PushNamed die Registrierung von Routen in der Datei main.dart erfordert, während Push Routen im laufenden Betrieb erstellt. Der Sprecher erörtert die Methoden onGenerateRoute und onUnknownRoute und hebt ihre Bedeutung für die Handhabung dynamisch generierter Routen und Fallback-Szenarien hervor. Sie demonstrieren, wie onUnknownRoute als letzte Möglichkeit verwendet wird, um eine Fallback-Seite anzuzeigen, wenn eine bestimmte Route nicht erstellt werden kann, wodurch sichergestellt wird, dass Benutzer immer Inhalte auf dem Bildschirm sehen. Das Video betont die Bedeutung der Bereitstellung einer Fallback-Seite, um App-Abstürze zu verhindern, und vergleicht sie mit einer 404-Fallback-Seite im Web.",
                                // Chinese
                                "中国人": "在本视频中，演讲者解释了使用 push 或 pushNamed 方法在 Flutter 应用中加载页面的概念，其中 pushNamed 需要在 main.dart 文件中注册路由，而 push 会动态创建路由。演讲者讨论了 onGenerateRoute 和 onUnknownRoute 方法，强调了它们对于处理动态生成的路由和回退场景的重要性。他们演示了如何在无法构建特定路由时将 onUnknownRoute 用作最后手段来显示回退页面，以确保用户始终在屏幕上看到内容。该视频强调了提供回退页面以防止应用崩溃的重要性，并将其与网络上的 404 回退页面进行了比较。",
                                // Russian
                                "Русский": "В этом видео докладчик объясняет концепцию загрузки страниц в приложении Flutter с помощью методов push или pushNamed, при этом pushNamed требует регистрации маршрутов в файле main.dart, а push создает маршруты на лету. Докладчик обсуждает методы onGenerateRoute и onUnknownRoute, подчеркивая их важность для обработки динамически сгенерированных маршрутов и резервных сценариев. Они демонстрируют, как onUnknownRoute используется в качестве последнего средства для отображения резервной страницы, если определенный маршрут не может быть построен, гарантируя, что пользователи всегда будут видеть контент на экране. Видео подчеркивает важность предоставления резервной страницы для предотвращения сбоев приложения и сравнивает ее с резервной страницей 404 в Интернете.",
                                // French
                                "Français": "Dans cette vidéo, l'intervenant explique le concept de chargement de pages dans une application Flutter à l'aide des méthodes push ou pushNamed, pushNamed nécessitant l'enregistrement des routes dans le fichier main.dart tandis que push crée des routes à la volée. L'intervenant discute des méthodes onGenerateRoute et onUnknownRoute, soulignant leur importance pour la gestion des routes générées dynamiquement et des scénarios de secours. Il montre comment onUnknownRoute est utilisé en dernier recours pour afficher une page de secours si une route spécifique ne peut pas être créée, garantissant ainsi que les utilisateurs voient toujours le contenu à l'écran. La vidéo souligne l'importance de fournir une page de secours pour éviter les plantages d'applications et la compare à une page de secours 404 sur le Web.",
                                // Japanese
                                "日本語": "このビデオでは、push または pushNamed メソッドを使用して Flutter アプリでページをロードする概念について説明します。pushNamed では main.dart ファイルにルートを登録する必要がありますが、push ではルートがオンザフライで作成されます。また、onGenerateRoute メソッドと onUnknownRoute メソッドについて説明し、動的に生成されたルートとフォールバック シナリオの処理におけるこれらのメソッドの重要性を強調しています。また、特定のルートを構築できない場合にフォールバック ページを表示するための最後の手段として onUnknownRoute がどのように使用され、ユーザーが常に画面にコンテンツを表示できるようにするかを示します。このビデオでは、アプリのクラッシュを防ぐためにフォールバック ページを提供することの重要性を強調し、Web 上の 404 フォールバック ページと比較しています。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 push 또는 pushNamed 메서드를 사용하여 Flutter 앱에서 페이지를 로드하는 개념을 설명합니다. pushNamed는 main.dart 파일에 경로를 등록해야 하는 반면 push는 즉석에서 경로를 생성합니다. 발표자는 onGenerateRoute 및 onUnknownRoute 메서드에 대해 논의하며 동적으로 생성된 경로와 폴백 시나리오를 처리하는 데 있어서 이러한 메서드의 중요성을 강조합니다. 그들은 특정 경로를 빌드할 수 없는 경우 폴백 페이지를 표시하는 마지막 수단으로 onUnknownRoute를 사용하여 사용자가 항상 화면에서 콘텐츠를 볼 수 있도록 하는 방법을 보여줍니다. 이 비디오는 앱 충돌을 방지하기 위해 폴백 페이지를 제공하는 것의 중요성을 강조하고 이를 웹의 404 폴백 페이지와 비교합니다.",
                                // Spanish
                                "Español": "En este video, el orador explica el concepto de cargar páginas en una aplicación Flutter mediante métodos push o pushNamed, donde pushNamed requiere el registro de rutas en el archivo main.dart mientras que push crea rutas sobre la marcha. El orador analiza los métodos onGenerateRoute y onUnknownRoute, destacando su importancia para manejar rutas generadas dinámicamente y escenarios de respaldo. Demuestra cómo se usa onUnknownRoute como último recurso para mostrar una página de respaldo si no se puede crear una ruta específica, lo que garantiza que los usuarios siempre vean el contenido en la pantalla. El video enfatiza la importancia de proporcionar una página de respaldo para evitar fallas en la aplicación y la compara con una página de respaldo 404 en la web.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, वक्ता पुश या पुशनेम्ड विधियों का उपयोग करके फ़्लटर ऐप में पेज लोड करने की अवधारणा को समझाता है, जिसमें पुशनेम्ड को main.dart फ़ाइल में रूट के पंजीकरण की आवश्यकता होती है जबकि पुश तुरंत रूट बनाता है। वक्ता गतिशील रूप से उत्पन्न रूट और फ़ॉलबैक परिदृश्यों को संभालने के लिए उनके महत्व पर प्रकाश डालते हुए onGenerateRoute और onUnknownRoute विधियों पर चर्चा करता है। वे प्रदर्शित करते हैं कि यदि कोई विशिष्ट रूट नहीं बनाया जा सकता है, तो फ़ॉलबैक पेज प्रदर्शित करने के लिए onUnknownRoute का उपयोग अंतिम उपाय के रूप में कैसे किया जाता है, यह सुनिश्चित करते हुए कि उपयोगकर्ता हमेशा स्क्रीन पर सामग्री देखते हैं। वीडियो ऐप क्रैश को रोकने के लिए फ़ॉलबैक पेज प्रदान करने के महत्व पर जोर देता है और इसकी तुलना वेब पर 404 फ़ॉलबैक पेज से करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o orador explica o conceito de carregamento de páginas numa aplicação Flutter utilizando métodos push ou pushNamed, sendo que o pushNamed requer o registo de rotas no ficheiro main.dart enquanto o push cria rotas dinamicamente. O orador discute os métodos onGenerateRoute e onUnknownRoute, destacando a sua importância para lidar com rotas geradas dinamicamente e cenários de fallback. Demonstram como o onUnknownRoute é utilizado como último recurso para exibir uma página de substituição se uma rota específica não puder ser construída, garantindo que os utilizadores veem sempre o conteúdo no ecrã. O vídeo enfatiza a importância de fornecer uma página substituta para evitar falhas da aplicação e compara-a a uma página 404 substituta na web.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, স্পিকার পুশ বা পুশনামড পদ্ধতি ব্যবহার করে একটি ফ্লাটার অ্যাপে পৃষ্ঠা লোড করার ধারণা ব্যাখ্যা করেছেন, যেখানে পুশনাম মেইন ডার্ট ফাইলে রুট নিবন্ধন করতে হবে যখন পুশ ফ্লাইতে রুট তৈরি করে। স্পিকার onGenerateRoute এবং onUnknownRoute পদ্ধতি নিয়ে আলোচনা করেন, গতিশীলভাবে জেনারেট করা রুট এবং ফলব্যাক পরিস্থিতি পরিচালনার জন্য তাদের গুরুত্ব তুলে ধরে। তারা প্রদর্শন করে যে কিভাবে onUnknownRoute একটি ফলব্যাক পৃষ্ঠা প্রদর্শন করার জন্য একটি শেষ অবলম্বন হিসাবে ব্যবহার করা হয় যদি একটি নির্দিষ্ট রুট তৈরি করা না যায়, ব্যবহারকারীরা সর্বদা স্ক্রিনে সামগ্রী দেখতে পান তা নিশ্চিত করে৷ ভিডিওটি অ্যাপ ক্র্যাশ রোধ করতে একটি ফলব্যাক পৃষ্ঠা প্রদানের গুরুত্বের উপর জোর দেয় এবং এটিকে ওয়েবে একটি 404 ফলব্যাক পৃষ্ঠার সাথে তুলনা করে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يشرح المتحدث مفهوم تحميل الصفحات في تطبيق Flutter باستخدام طرق push أو pushNamed، حيث تتطلب pushNamed تسجيل المسارات في ملف main.dart بينما تنشئ push المسارات أثناء التنقل. يناقش المتحدث طريقتي onGenerateRoute وonUnknownRoute، مسلطًا الضوء على أهميتهما في التعامل مع المسارات المولدة ديناميكيًا وسيناريوهات الرجوع إلى الخلف. كما يوضح كيف يتم استخدام onUnknownRoute كملاذ أخير لعرض صفحة الرجوع إلى الخلف إذا تعذر إنشاء مسار معين، مما يضمن أن يرى المستخدمون دائمًا المحتوى على الشاشة. ويؤكد الفيديو على أهمية توفير صفحة الرجوع إلى الخلف لمنع تعطل التطبيق ويقارنه بصفحة الرجوع إلى الخلف 404 على الويب.",
                                // Persian
                                "فارسی": "در این ویدئو، گوینده مفهوم بارگذاری صفحات در یک برنامه فلاتر را با استفاده از روش های push یا pushNamed توضیح می دهد، در حالی که pushNamed نیاز به ثبت مسیرها در فایل main.dart دارد در حالی که فشار مسیرها را در حال ایجاد می کند. سخنران روش‌های onGenerateRoute و onUnknownRoute را مورد بحث قرار می‌دهد و اهمیت آنها را برای مدیریت مسیرهای تولید شده به صورت پویا و سناریوهای بازگشتی برجسته می‌کند. آن‌ها نشان می‌دهند که چگونه onUnknownRoute به عنوان آخرین راه‌حل برای نمایش یک صفحه بازگشتی در صورتی که مسیر خاصی ساخته نشود، استفاده می‌شود و تضمین می‌کند که کاربران همیشه محتوا را روی صفحه می‌بینند. این ویدئو بر اهمیت ارائه یک صفحه بازگشتی برای جلوگیری از خرابی برنامه تاکید می کند و آن را با یک صفحه بازگشتی 404 در وب مقایسه می کند.",
                            },
                        },
                        // 153 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Finishing the Meal Detail Page",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video demonstrates how to create a detailed meal description screen by adding images, ingredients, and steps using Flutter. The tutorial includes methods to dynamically retrieve and display information from a dummy data source. The instructor also introduces concepts like using containers, ListView, ListTile, and CircleAvatar to structure the layout. Additionally, the video covers creating reusable widgets and handling errors with cryptic messages. Finally, the instructor mentions future topics like implementing tabs or a side drawer for navigation in the app.",
                                // German
                                "Deutsch": "Das Video zeigt, wie Sie mit Flutter einen detaillierten Bildschirm mit einer Essensbeschreibung erstellen, indem Sie Bilder, Zutaten und Schritte hinzufügen. Das Tutorial enthält Methoden zum dynamischen Abrufen und Anzeigen von Informationen aus einer Dummy-Datenquelle. Der Kursleiter stellt außerdem Konzepte wie die Verwendung von Containern, ListView, ListTile und CircleAvatar zur Strukturierung des Layouts vor. Darüber hinaus behandelt das Video das Erstellen wiederverwendbarer Widgets und die Fehlerbehandlung mit kryptischen Nachrichten. Abschließend erwähnt der Kursleiter zukünftige Themen wie die Implementierung von Registerkarten oder einer Seitenleiste zur Navigation in der App.",
                                // Chinese
                                "中国人": "该视频演示了如何使用 Flutter 添加图片、配料和步骤来创建详细的餐点描述屏幕。本教程包括从虚拟数据源动态检索和显示信息的方法。讲师还介绍了使用容器、ListView、ListTile 和 CircleAvatar 来构造布局等概念。此外，视频还介绍了如何创建可重复使用的小部件以及如何使用神秘消息处理错误。最后，讲师提到了未来的主题，例如在应用中实现选项卡或侧边抽屉导航。",
                                // Russian
                                "Русский": "Видео демонстрирует, как создать подробный экран описания еды, добавляя изображения, ингредиенты и шаги с помощью Flutter. В руководстве представлены методы динамического извлечения и отображения информации из фиктивного источника данных. Преподаватель также знакомит с такими концепциями, как использование контейнеров, ListView, ListTile и CircleAvatar для структурирования макета. Кроме того, в видео рассматривается создание повторно используемых виджетов и обработка ошибок с помощью криптографических сообщений. Наконец, преподаватель упоминает будущие темы, такие как реализация вкладок или бокового ящика для навигации в приложении.",
                                // French
                                "Français": "La vidéo montre comment créer un écran de description de repas détaillé en ajoutant des images, des ingrédients et des étapes à l'aide de Flutter. Le didacticiel comprend des méthodes permettant de récupérer et d'afficher dynamiquement des informations à partir d'une source de données fictive. L'instructeur présente également des concepts tels que l'utilisation de conteneurs, ListView, ListTile et CircleAvatar pour structurer la mise en page. De plus, la vidéo couvre la création de widgets réutilisables et la gestion des erreurs avec des messages cryptés. Enfin, l'instructeur évoque des sujets futurs tels que la mise en œuvre d'onglets ou d'un tiroir latéral pour la navigation dans l'application.",
                                // Japanese
                                "日本語": "この動画では、Flutter を使用して画像、材料、手順を追加し、詳細な食事の説明画面を作成する方法を説明します。チュートリアルには、ダミー データ ソースから情報を動的に取得して表示するメソッドが含まれています。また、コンテナー、ListView、ListTile、CircleAvatar を使用してレイアウトを構成するなどの概念も紹介します。さらに、この動画では、再利用可能なウィジェットの作成と、暗号化されたメッセージによるエラーの処理についても説明します。最後に、アプリ内のナビゲーション用のタブやサイド ドロワーの実装など、今後のトピックについても触れています。",
                                // Korean
                                "한국인": "이 비디오는 Flutter를 사용하여 이미지, 재료 및 단계를 추가하여 자세한 식사 설명 화면을 만드는 방법을 보여줍니다. 이 튜토리얼에는 더미 데이터 소스에서 정보를 동적으로 검색하고 표시하는 방법이 포함되어 있습니다. 강사는 또한 컨테이너, ListView, ListTile 및 CircleAvatar를 사용하여 레이아웃을 구성하는 것과 같은 개념을 소개합니다. 또한 이 비디오는 재사용 가능한 위젯을 만들고 난해한 메시지로 오류를 처리하는 방법을 다룹니다. 마지막으로 강사는 앱에서 탭 또는 탐색을 위한 사이드 서랍을 구현하는 것과 같은 향후 주제를 언급합니다.",
                                // Spanish
                                "Español": "El video muestra cómo crear una pantalla de descripción detallada de comidas agregando imágenes, ingredientes y pasos usando Flutter. El tutorial incluye métodos para recuperar y mostrar dinámicamente información de una fuente de datos ficticia. El instructor también presenta conceptos como el uso de contenedores, ListView, ListTile y CircleAvatar para estructurar el diseño. Además, el video cubre la creación de widgets reutilizables y el manejo de errores con mensajes crípticos. Finalmente, el instructor menciona temas futuros como la implementación de pestañas o un cajón lateral para la navegación en la aplicación.",
                                // Hindi
                                "हिंदी": "वीडियो में दिखाया गया है कि फ़्लटर का उपयोग करके छवियों, अवयवों और चरणों को जोड़कर विस्तृत भोजन विवरण स्क्रीन कैसे बनाई जाए। ट्यूटोरियल में डमी डेटा स्रोत से गतिशील रूप से जानकारी प्राप्त करने और प्रदर्शित करने के तरीके शामिल हैं। प्रशिक्षक लेआउट की संरचना के लिए कंटेनर, लिस्टव्यू, लिस्टटाइल और सर्किल अवतार का उपयोग करने जैसी अवधारणाओं का भी परिचय देता है। इसके अतिरिक्त, वीडियो में पुन: प्रयोज्य विजेट बनाना और गुप्त संदेशों के साथ त्रुटियों को संभालना शामिल है। अंत में, प्रशिक्षक ऐप में नेविगेशन के लिए टैब या साइड ड्रॉअर को लागू करने जैसे भविष्य के विषयों का उल्लेख करता है।",
                                // Portuguese
                                "Português": "O vídeo demonstra como criar um ecrã de descrição detalhada da refeição, adicionando imagens, ingredientes e passos utilizando o Flutter. O tutorial inclui métodos para recuperar e exibir dinamicamente informações de uma fonte de dados fictícia. O instrutor apresenta também conceitos como a utilização de contentores, ListView, ListTile e CircleAvatar para estruturar o layout. Além disso, o vídeo aborda a criação de widgets reutilizáveis ​​e o tratamento de erros com mensagens enigmáticas. Por fim, o instrutor menciona tópicos futuros como a implementação de separadores ou gaveta lateral para navegação na aplicação.",
                                // Bengali
                                "বাংলা": "ভিডিওটি দেখায় কিভাবে ফ্লটার ব্যবহার করে ছবি, উপাদান এবং পদক্ষেপ যোগ করে একটি বিশদ খাবারের বর্ণনার স্ক্রীন তৈরি করতে হয়। টিউটোরিয়ালটিতে একটি ডামি ডেটা উৎস থেকে গতিশীলভাবে তথ্য পুনরুদ্ধার এবং প্রদর্শন করার পদ্ধতি অন্তর্ভুক্ত রয়েছে। প্রশিক্ষক লেআউট গঠনের জন্য ধারক, ListView, ListTile, এবং CircleAvatar ব্যবহার করার মত ধারণাগুলিও প্রবর্তন করেন। অতিরিক্তভাবে, ভিডিওটি পুনঃব্যবহারযোগ্য উইজেট তৈরি করা এবং ক্রিপ্টিক বার্তাগুলির সাথে ত্রুটিগুলি পরিচালনা করে৷ অবশেষে, প্রশিক্ষক অ্যাপে নেভিগেশনের জন্য ট্যাব বাস্তবায়ন বা সাইড ড্রয়ারের মতো ভবিষ্যতের বিষয়গুলি উল্লেখ করেছেন।",
                                // Arabic
                                "عَرَبِيّ": "يوضح الفيديو كيفية إنشاء شاشة تفصيلية لوصف الوجبة عن طريق إضافة الصور والمكونات والخطوات باستخدام Flutter. يتضمن البرنامج التعليمي طرقًا لاسترجاع المعلومات وعرضها ديناميكيًا من مصدر بيانات وهمي. يقدم المدرب أيضًا مفاهيم مثل استخدام الحاويات وListView وListTile وCircleAvatar لتنظيم التخطيط. بالإضافة إلى ذلك، يغطي الفيديو إنشاء عناصر واجهة مستخدم قابلة لإعادة الاستخدام والتعامل مع الأخطاء باستخدام الرسائل الغامضة. أخيرًا، يذكر المدرب موضوعات مستقبلية مثل تنفيذ علامات التبويب أو الدرج الجانبي للتنقل في التطبيق.",
                                // Persian
                                "فارسی": "این ویدئو نحوه ایجاد یک صفحه توصیف دقیق غذا را با افزودن تصاویر، مواد تشکیل دهنده و مراحل با استفاده از فلاتر نشان می دهد. این آموزش شامل روش هایی برای بازیابی و نمایش پویا اطلاعات از یک منبع داده ساختگی است. مربی همچنین مفاهیمی مانند استفاده از کانتینرها، ListView، ListTile و CircleAvatar را برای ساختاربندی طرح‌بندی معرفی می‌کند. علاوه بر این، ویدیو ایجاد ویجت‌های قابل استفاده مجدد و مدیریت خطاها با پیام‌های مرموز را پوشش می‌دهد. در نهایت، مربی موضوعات آینده مانند پیاده سازی تب ها یا کشوی کناری برای پیمایش در برنامه را ذکر می کند.",
                            },
                        },
                        // 154 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Adding a TabBar to the Appbar",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "The video tutorial focuses on implementing tabs in a Flutter application, starting with creating a TabsScreen widget that manages tabs for displaying categories and favorite recipes. The instructor demonstrates two approaches for adding tabs within the app using the default TabController widget. The tutorial covers setting up the TabBar with icons and text for each tab, connecting it to the TabBarView to display corresponding content, adjusting the default tab index, and customizing tab appearance and behavior. By incorporating tabs into the app layout, users can easily navigate between different sections via the tab bar located at the bottom or within the app's app bar.",
                                // German
                                "Deutsch": "Das Video-Tutorial konzentriert sich auf die Implementierung von Tabs in einer Flutter-Anwendung und beginnt mit der Erstellung eines TabsScreen-Widgets, das Tabs zum Anzeigen von Kategorien und Lieblingsrezepten verwaltet. Der Kursleiter demonstriert zwei Ansätze zum Hinzufügen von Tabs innerhalb der App mithilfe des standardmäßigen TabController-Widgets. Das Tutorial behandelt das Einrichten der TabBar mit Symbolen und Text für jede Registerkarte, das Verbinden mit der TabBarView zum Anzeigen entsprechender Inhalte, das Anpassen des standardmäßigen Tab-Indexes und das Anpassen des Aussehens und Verhaltens der Registerkarten. Durch die Integration von Tabs in das App-Layout können Benutzer über die Tab-Leiste unten oder innerhalb der App-Leiste der App problemlos zwischen verschiedenen Abschnitten navigieren.",
                                // Chinese
                                "中国人": "本视频教程重点介绍如何在 Flutter 应用中实现选项卡，首先创建一个 TabsScreen 小部件，用于管理用于显示类别和收藏食谱的选项卡。讲师演示了使用默认 TabController 小部件在应用内添加选项卡的两种方法。本教程介绍了如何为每个选项卡设置带有图标和文本的 TabBar、将其连接到 TabBarView 以显示相应内容、调整默认选项卡索引以及自定义选项卡的外观和行为。通过将选项卡合并到应用布局中，用户可以通过位于底部或应用栏内的选项卡栏轻松地在不同部分之间导航。",
                                // Russian
                                "Русский": "Видеоурок посвящен внедрению вкладок в приложение Flutter, начиная с создания виджета TabsScreen, который управляет вкладками для отображения категорий и любимых рецептов. Инструктор демонстрирует два подхода к добавлению вкладок в приложение с использованием виджета TabController по умолчанию. В уроке рассматривается настройка TabBar со значками и текстом для каждой вкладки, подключение ее к TabBarView для отображения соответствующего контента, настройка индекса вкладок по умолчанию и настройка внешнего вида и поведения вкладок. Включая вкладки в макет приложения, пользователи могут легко перемещаться между различными разделами с помощью панели вкладок, расположенной внизу или в панели приложений приложения.",
                                // French
                                "Français": "Le didacticiel vidéo se concentre sur l'implémentation des onglets dans une application Flutter, en commençant par la création d'un widget TabsScreen qui gère les onglets pour afficher les catégories et les recettes préférées. L'instructeur présente deux approches pour ajouter des onglets dans l'application à l'aide du widget TabController par défaut. Le didacticiel couvre la configuration de la TabBar avec des icônes et du texte pour chaque onglet, sa connexion à la TabBarView pour afficher le contenu correspondant, le réglage de l'index des onglets par défaut et la personnalisation de l'apparence et du comportement des onglets. En incorporant des onglets dans la mise en page de l'application, les utilisateurs peuvent facilement naviguer entre les différentes sections via la barre d'onglets située en bas ou dans la barre d'applications de l'application.",
                                // Japanese
                                "日本語": "このビデオ チュートリアルでは、Flutter アプリケーションにタブを実装することに焦点を当て、まず、カテゴリやお気に入りのレシピを表示するタブを管理する TabsScreen ウィジェットを作成します。講師は、デフォルトの TabController ウィジェットを使用してアプリ内にタブを追加する 2 つの方法を紹介します。このチュートリアルでは、各タブのアイコンとテキストを含む TabBar の設定、対応するコンテンツを表示するために TabBarView に接続する方法、デフォルトのタブ インデックスを調整する方法、タブの外観と動作をカスタマイズする方法を取り上げます。タブをアプリのレイアウトに組み込むことで、ユーザーは下部またはアプリのアプリ バー内にあるタブ バーを使用して、さまざまなセクション間を簡単に移動できます。",
                                // Korean
                                "한국인": "비디오 튜토리얼은 Flutter 애플리케이션에서 탭을 구현하는 데 중점을 두고, 카테고리와 즐겨찾는 레시피를 표시하는 탭을 관리하는 TabsScreen 위젯을 만드는 것으로 시작합니다. 강사는 기본 TabController 위젯을 사용하여 앱 내에 탭을 추가하는 두 가지 방법을 보여줍니다. 이 튜토리얼은 각 탭에 대한 아이콘과 텍스트로 TabBar를 설정하고, TabBarView에 연결하여 해당 콘텐츠를 표시하고, 기본 탭 인덱스를 조정하고, 탭 모양과 동작을 사용자 지정하는 방법을 다룹니다. 앱 레이아웃에 탭을 통합하면 사용자는 앱의 앱 바 또는 하단에 있는 탭 바를 통해 다른 섹션 간에 쉽게 탐색할 수 있습니다.",
                                // Spanish
                                "Español": "El videotutorial se centra en la implementación de pestañas en una aplicación Flutter, comenzando con la creación de un widget TabsScreen que administra las pestañas para mostrar categorías y recetas favoritas. El instructor demuestra dos enfoques para agregar pestañas dentro de la aplicación utilizando el widget TabController predeterminado. El tutorial cubre la configuración de TabBar con íconos y texto para cada pestaña, su conexión a TabBarView para mostrar el contenido correspondiente, el ajuste del índice de pestañas predeterminado y la personalización de la apariencia y el comportamiento de las pestañas. Al incorporar pestañas en el diseño de la aplicación, los usuarios pueden navegar fácilmente entre diferentes secciones a través de la barra de pestañas ubicada en la parte inferior o dentro de la barra de aplicaciones de la aplicación.",
                                // Hindi
                                "हिंदी": "वीडियो ट्यूटोरियल फ़्लटर एप्लिकेशन में टैब को लागू करने पर ध्यान केंद्रित करता है, जिसकी शुरुआत टैब्सस्क्रीन विजेट बनाने से होती है जो श्रेणियों और पसंदीदा व्यंजनों को प्रदर्शित करने के लिए टैब प्रबंधित करता है। प्रशिक्षक डिफ़ॉल्ट TabController विजेट का उपयोग करके ऐप के भीतर टैब जोड़ने के लिए दो दृष्टिकोण प्रदर्शित करता है। ट्यूटोरियल में प्रत्येक टैब के लिए आइकन और टेक्स्ट के साथ TabBar सेट करना, संबंधित सामग्री प्रदर्शित करने के लिए इसे TabBarView से कनेक्ट करना, डिफ़ॉल्ट टैब इंडेक्स को समायोजित करना और टैब की उपस्थिति और व्यवहार को अनुकूलित करना शामिल है। ऐप लेआउट में टैब को शामिल करके, उपयोगकर्ता नीचे या ऐप के ऐप बार में स्थित टैब बार के माध्यम से विभिन्न अनुभागों के बीच आसानी से नेविगेट कर सकते हैं।",
                                // Portuguese
                                "Português": "O tutorial em vídeo centra-se na implementação de separadores numa aplicação Flutter, começando com a criação de um widget TabsScreen que gere separadores para exibir categorias e receitas favoritas. O instrutor demonstra duas abordagens para adicionar separadores na aplicação utilizando o widget TabController padrão. O tutorial aborda a configuração do TabBar com ícones e texto para cada separador, ligando-o ao TabBarView para exibir o conteúdo correspondente, ajustando o índice do separador padrão e personalizando a aparência e o comportamento do separador. Ao incorporar separadores no layout da aplicação, os utilizadores podem navegar facilmente entre as diferentes secções através da barra de separadores localizada na parte inferior ou na barra de aplicações da aplicação.",
                                // Bengali
                                "বাংলা": "ভিডিও টিউটোরিয়ালটি একটি ফ্লাটার অ্যাপ্লিকেশনে ট্যাবগুলি প্রয়োগ করার উপর ফোকাস করে, একটি ট্যাবস্ক্রিন উইজেট তৈরি করা থেকে শুরু করে যা বিভাগ এবং প্রিয় রেসিপিগুলি প্রদর্শনের জন্য ট্যাবগুলি পরিচালনা করে৷ ডিফল্ট ট্যাবকন্ট্রোলার উইজেট ব্যবহার করে অ্যাপের মধ্যে ট্যাব যোগ করার জন্য প্রশিক্ষক দুটি পন্থা প্রদর্শন করে। প্রতিটি ট্যাবের জন্য আইকন এবং পাঠ্য সহ ট্যাববার সেট আপ করা, সংশ্লিষ্ট বিষয়বস্তু প্রদর্শনের জন্য এটিকে ট্যাববারভিউ-এর সাথে সংযুক্ত করা, ডিফল্ট ট্যাব সূচী সামঞ্জস্য করা এবং ট্যাবের চেহারা এবং আচরণ কাস্টমাইজ করা এই টিউটোরিয়ালটি কভার করে। অ্যাপ্লিকেশান লেআউটে ট্যাবগুলিকে অন্তর্ভুক্ত করে, ব্যবহারকারীরা সহজেই নীচে অবস্থিত ট্যাব বারের মাধ্যমে বা অ্যাপের অ্যাপ বারের মধ্যে বিভিন্ন বিভাগের মধ্যে নেভিগেট করতে পারে।",
                                // Arabic
                                "عَرَبِيّ": "يركز البرنامج التعليمي بالفيديو على تنفيذ علامات التبويب في تطبيق Flutter، بدءًا بإنشاء عنصر واجهة مستخدم TabsScreen الذي يدير علامات التبويب لعرض الفئات والوصفات المفضلة. يوضح المدرب طريقتين لإضافة علامات التبويب داخل التطبيق باستخدام عنصر واجهة المستخدم الافتراضي TabController. يغطي البرنامج التعليمي إعداد شريط علامات التبويب بالرموز والنص لكل علامة تبويب، وتوصيله بـ TabBarView لعرض المحتوى المقابل، وضبط فهرس علامات التبويب الافتراضي، وتخصيص مظهر علامات التبويب وسلوكها. من خلال دمج علامات التبويب في تخطيط التطبيق، يمكن للمستخدمين التنقل بسهولة بين الأقسام المختلفة عبر شريط علامات التبويب الموجود في الأسفل أو داخل شريط التطبيق الخاص بالتطبيق.",
                                // Persian
                                "فارسی": "این آموزش ویدیویی بر پیاده‌سازی زبانه‌ها در برنامه Flutter تمرکز دارد و با ایجاد یک ویجت TabsScreen شروع می‌شود که برگه‌ها را برای نمایش دسته‌ها و دستور العمل‌های مورد علاقه مدیریت می‌کند. مربی دو رویکرد را برای افزودن برگه‌ها در برنامه با استفاده از ویجت TabController پیش‌فرض نشان می‌دهد. این آموزش شامل تنظیم TabBar با نمادها و متن برای هر برگه، اتصال آن به TabBarView برای نمایش محتوای مربوطه، تنظیم فهرست برگه پیش‌فرض، و شخصی‌سازی ظاهر و رفتار تب است. با گنجاندن برگه‌ها در طرح‌بندی برنامه، کاربران می‌توانند به راحتی بین بخش‌های مختلف از طریق نوار برگه واقع در پایین یا درون نوار برنامه برنامه حرکت کنند.",
                            },
                        },
                        // 155 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Adding a Bottom TabBar",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter discusses how to implement a bottom navigation bar in a Flutter application, explaining that while a stateless widget suffices initially, a stateful widget becomes necessary when managing tabs at the bottom. The tutorial details the removal of the default tab controller and the addition of a bottom navigation bar widget, highlighting the need for configuration such as setting colors and managing tab items as bottom navigation bar items. The presenter describes how to handle tab selection through an onTap listener, which updates a selected page index and displays the corresponding content from a list of widgets. Additional styling options are explored, including setting colors for selected and unselected items and adjusting the font size for better visibility. The video concludes with a demonstration of dynamically updating the app bar title based on the selected tab, using a list of maps to store both widget references and titles.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Moderator, wie man eine untere Navigationsleiste in einer Flutter-Anwendung implementiert. Dabei wird erklärt, dass zunächst ein zustandsloses Widget ausreicht, bei der Verwaltung von Registerkarten unten jedoch ein zustandsbehaftetes Widget erforderlich wird. Das Tutorial beschreibt detailliert das Entfernen des standardmäßigen Registerkarten-Controllers und das Hinzufügen eines Widgets für die untere Navigationsleiste und hebt die Notwendigkeit der Konfiguration hervor, beispielsweise das Festlegen von Farben und das Verwalten von Registerkartenelementen als Elemente der unteren Navigationsleiste. Der Moderator beschreibt, wie die Registerkartenauswahl über einen onTap-Listener gehandhabt wird, der einen ausgewählten Seitenindex aktualisiert und den entsprechenden Inhalt aus einer Liste von Widgets anzeigt. Zusätzliche Gestaltungsoptionen werden untersucht, darunter das Festlegen von Farben für ausgewählte und nicht ausgewählte Elemente und das Anpassen der Schriftgröße für eine bessere Sichtbarkeit. Das Video endet mit einer Demonstration der dynamischen Aktualisierung des Titels der App-Leiste basierend auf der ausgewählten Registerkarte, wobei eine Liste von Karten zum Speichern von Widget-Referenzen und -Titeln verwendet wird.",
                                // Chinese
                                "中国人": "在本视频中，演示者讨论了如何在 Flutter 应用程序中实现底部导航栏，并解释说，虽然无状态小部件最初就足够了，但在管理底部的选项卡时，有状态小部件就变得必不可少。本教程详细介绍了默认选项卡控制器的删除以及底部导航栏小部件的添加，强调了配置的必要性，例如设置颜色和将选项卡项作为底部导航栏项进行管理。演示者描述了如何通过 onTap 侦听器处理选项卡选择，该侦听器更新选定的页面索引并从小部件列表中显示相应的内容。还探索了其他样式选项，包括设置选定和未选定项目的颜色以及调整字体大小以获得更好的可见性。视频最后演示了如何根据选定的选项卡动态更新应用栏标题，使用地图列表来存储小部件引用和标题。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает, как реализовать нижнюю панель навигации в приложении Flutter, объясняя, что, хотя на начальном этапе достаточно виджета без сохранения состояния, при управлении вкладками внизу становится необходимым виджет с сохранением состояния. В руководстве подробно описывается удаление контроллера вкладок по умолчанию и добавление виджета нижней панели навигации, подчеркивая необходимость настройки, такой как настройка цветов и управление элементами вкладок как элементами нижней панели навигации. Докладчик описывает, как обрабатывать выбор вкладок с помощью прослушивателя onTap, который обновляет выбранный индекс страницы и отображает соответствующий контент из списка виджетов. Изучаются дополнительные параметры стилей, включая настройку цветов для выбранных и невыбранных элементов и настройку размера шрифта для лучшей видимости. Видео завершается демонстрацией динамического обновления заголовка панели приложения на основе выбранной вкладки с использованием списка карт для хранения как ссылок на виджеты, так и заголовков.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur explique comment implémenter une barre de navigation inférieure dans une application Flutter, expliquant que si un widget sans état suffit initialement, un widget avec état devient nécessaire lors de la gestion des onglets en bas. Le didacticiel détaille la suppression du contrôleur d'onglets par défaut et l'ajout d'un widget de barre de navigation inférieure, soulignant la nécessité d'une configuration telle que la définition des couleurs et la gestion des éléments d'onglet en tant qu'éléments de barre de navigation inférieure. Le présentateur décrit comment gérer la sélection d'onglets via un écouteur onTap, qui met à jour un index de page sélectionné et affiche le contenu correspondant à partir d'une liste de widgets. Des options de style supplémentaires sont explorées, notamment la définition des couleurs pour les éléments sélectionnés et non sélectionnés et le réglage de la taille de la police pour une meilleure visibilité. La vidéo se termine par une démonstration de mise à jour dynamique du titre de la barre d'application en fonction de l'onglet sélectionné, à l'aide d'une liste de cartes pour stocker à la fois les références et les titres des widgets.",
                                // Japanese
                                "日本語": "この動画では、プレゼンターが Flutter アプリケーションで下部ナビゲーション バーを実装する方法について説明し、最初はステートレス ウィジェットで十分ですが、下部のタブを管理する場合はステートフル ウィジェットが必要になることを説明します。チュートリアルでは、デフォルトのタブ コントローラーの削除と下部ナビゲーション バー ウィジェットの追加について詳しく説明し、色の設定やタブ項目を下部ナビゲーション バー項目として管理するなどの構成の必要性を強調しています。プレゼンターは、選択されたページ インデックスを更新し、ウィジェットのリストから対応するコンテンツを表示する onTap リスナーを介してタブ選択を処理する方法について説明します。選択された項目と選択されていない項目の色の設定や、視認性を高めるためのフォント サイズの調整など、追加のスタイル設定オプションについても説明します。動画の最後には、ウィジェット参照とタイトルの両方を格納するマップのリストを使用して、選択されたタブに基づいてアプリ バーのタイトルを動的に更新するデモが紹介されます。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 애플리케이션에서 하단 탐색 모음을 구현하는 방법을 논의하며, 처음에는 상태 없는 위젯으로 충분하지만 하단의 탭을 관리할 때는 상태 있는 위젯이 필요하게 된다고 설명합니다. 이 튜토리얼에서는 기본 탭 컨트롤러를 제거하고 하단 탐색 모음 위젯을 추가하는 방법을 자세히 설명하며, 색상 설정 및 탭 항목을 하단 탐색 모음 항목으로 관리하는 것과 같은 구성의 필요성을 강조합니다. 발표자는 onTap 리스너를 통해 탭 선택을 처리하는 방법을 설명합니다. 이 리스너는 선택한 페이지 인덱스를 업데이트하고 위젯 목록에서 해당 콘텐츠를 표시합니다. 선택한 항목과 선택되지 않은 항목에 대한 색상 설정 및 가시성을 높이기 위한 글꼴 크기 조정을 포함한 추가 스타일링 옵션을 살펴봅니다. 이 비디오는 위젯 참조와 제목을 모두 저장하는 맵 목록을 사용하여 선택한 탭에 따라 앱 모음 제목을 동적으로 업데이트하는 방법을 보여주는 것으로 마무리됩니다.",
                                // Spanish
                                "Español": "En este video, el presentador analiza cómo implementar una barra de navegación inferior en una aplicación Flutter y explica que, si bien un widget sin estado es suficiente inicialmente, un widget con estado se vuelve necesario cuando se administran pestañas en la parte inferior. El tutorial detalla la eliminación del controlador de pestañas predeterminado y la incorporación de un widget de barra de navegación inferior, destacando la necesidad de configuración, como la configuración de colores y la administración de elementos de pestañas como elementos de la barra de navegación inferior. El presentador describe cómo manejar la selección de pestañas a través de un detector onTap, que actualiza un índice de página seleccionado y muestra el contenido correspondiente de una lista de widgets. Se exploran opciones de estilo adicionales, que incluyen la configuración de colores para elementos seleccionados y no seleccionados y el ajuste del tamaño de fuente para una mejor visibilidad. El video concluye con una demostración de actualización dinámica del título de la barra de la aplicación en función de la pestaña seleccionada, utilizando una lista de mapas para almacenar referencias y títulos de widgets.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर एप्लिकेशन में बॉटम नेविगेशन बार को लागू करने के तरीके पर चर्चा करता है, यह समझाते हुए कि शुरुआत में स्टेटलेस विजेट पर्याप्त होता है, लेकिन नीचे टैब प्रबंधित करते समय स्टेटफुल विजेट आवश्यक हो जाता है। ट्यूटोरियल डिफ़ॉल्ट टैब कंट्रोलर को हटाने और बॉटम नेविगेशन बार विजेट को जोड़ने का विवरण देता है, जिसमें कॉन्फ़िगरेशन की आवश्यकता पर प्रकाश डाला गया है जैसे कि रंग सेट करना और टैब आइटम को बॉटम नेविगेशन बार आइटम के रूप में प्रबंधित करना। प्रस्तुतकर्ता बताता है कि ऑनटैप श्रोता के माध्यम से टैब चयन को कैसे संभालना है, जो चयनित पेज इंडेक्स को अपडेट करता है और विजेट की सूची से संबंधित सामग्री प्रदर्शित करता है। अतिरिक्त स्टाइलिंग विकल्पों का पता लगाया जाता है, जिसमें चयनित और अचयनित आइटम के लिए रंग सेट करना और बेहतर दृश्यता के लिए फ़ॉन्ट आकार समायोजित करना शामिल है",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador discute como implementar uma barra de navegação inferior numa aplicação Flutter, explicando que embora um widget sem estado seja suficiente inicialmente, um widget com estado torna-se necessário ao gerir separadores na parte inferior. O tutorial detalha a remoção do controlador de separadores padrão e a adição de um widget da barra de navegação inferior, destacando a necessidade de configuração, como a definição de cores e a gestão de itens de separadores como itens da barra de navegação inferior. O apresentador descreve como lidar com a seleção de separadores através de um listener onTap, que atualiza um índice de página selecionado e exibe o conteúdo correspondente de uma lista de widgets. São exploradas opções de estilo adicionais, incluindo a configuração de cores para itens selecionados e não selecionados e o ajuste do tamanho da letra para uma melhor visibilidade. O vídeo termina com uma demonstração de atualização dinâmica do título da barra de aplicações com base no separador selecionado, utilizando uma lista de mapas para armazenar referências e títulos de widgets.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক কীভাবে একটি ফ্লটার অ্যাপ্লিকেশনে একটি নীচের নেভিগেশন বারটি প্রয়োগ করতে হয় তা নিয়ে আলোচনা করেছেন, ব্যাখ্যা করেছেন যে যখন একটি স্টেটলেস উইজেট প্রাথমিকভাবে যথেষ্ট, নীচে ট্যাবগুলি পরিচালনা করার সময় একটি স্টেটফুল উইজেট প্রয়োজনীয় হয়ে ওঠে৷ টিউটোরিয়ালটি ডিফল্ট ট্যাব কন্ট্রোলার অপসারণ এবং নীচের নেভিগেশন বার উইজেট যুক্ত করার বিবরণ দেয়, রঙ সেট করা এবং নীচের নেভিগেশন বার আইটেম হিসাবে ট্যাব আইটেমগুলি পরিচালনা করার মতো কনফিগারেশনের প্রয়োজনীয়তা তুলে ধরে। উপস্থাপক বর্ণনা করেন কিভাবে একটি onTap শ্রোতার মাধ্যমে ট্যাব নির্বাচন পরিচালনা করতে হয়, যা একটি নির্বাচিত পৃষ্ঠা সূচক আপডেট করে এবং উইজেটের একটি তালিকা থেকে সংশ্লিষ্ট বিষয়বস্তু প্রদর্শন করে। নির্বাচিত এবং অনির্বাচিত আইটেমগুলির জন্য রঙ সেট করা এবং আরও ভাল দৃশ্যমানতার জন্য ফন্টের আকার সামঞ্জস্য সহ অতিরিক্ত স্টাইলিং বিকল্পগুলি অন্বেষণ করা হয়েছে। উইজেট রেফারেন্স এবং শিরোনাম উভয় সঞ্চয় করার জন্য মানচিত্রের একটি তালিকা ব্যবহার করে নির্বাচিত ট্যাবের উপর ভিত্তি করে অ্যাপ বার শিরোনামকে গতিশীলভাবে আপডেট করার একটি প্রদর্শনের সাথে ভিডিওটি শেষ হয়েছে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش مقدم العرض كيفية تنفيذ شريط تنقل سفلي في تطبيق Flutter، موضحًا أنه في حين تكفي أداة عديمة الجنسية في البداية، تصبح الأداة ذات الحالة ضرورية عند إدارة علامات التبويب في الأسفل. يوضح البرنامج التعليمي بالتفصيل إزالة وحدة تحكم علامات التبويب الافتراضية وإضافة أداة شريط تنقل سفلي، مع تسليط الضوء على الحاجة إلى التكوين مثل تعيين الألوان وإدارة عناصر علامات التبويب كعناصر شريط تنقل سفلي. يصف مقدم العرض كيفية التعامل مع تحديد علامات التبويب من خلال مستمع onTap، والذي يقوم بتحديث فهرس الصفحة المحددة ويعرض المحتوى المقابل من قائمة الأدوات. يتم استكشاف خيارات التصميم الإضافية، بما في ذلك تعيين الألوان للعناصر المحددة وغير المحددة وضبط حجم الخط لتحسين الرؤية. ويختتم الفيديو بعرض توضيحي لتحديث عنوان شريط التطبيق ديناميكيًا بناءً على علامة التبويب المحددة، باستخدام قائمة من الخرائط لتخزين مراجع وعناوين الأدوات.",
                                // Persian
                                "فارسی": "در این ویدیو، مجری نحوه پیاده‌سازی نوار ناوبری پایین در برنامه فلاتر را مورد بحث قرار می‌دهد و توضیح می‌دهد که در حالی که یک ویجت بدون حالت در ابتدا کافی است، یک ویجت حالت دار هنگام مدیریت برگه‌ها در پایین ضروری می‌شود. این آموزش جزئیات حذف کنترل‌کننده برگه پیش‌فرض و افزودن ویجت نوار ناوبری پایینی را نشان می‌دهد، که نیاز به پیکربندی مانند تنظیم رنگ‌ها و مدیریت موارد برگه به ​​عنوان موارد نوار ناوبری پایین را برجسته می‌کند. ارائه دهنده نحوه مدیریت انتخاب برگه را از طریق شنونده onTap توضیح می دهد که فهرست صفحه انتخاب شده را به روز می کند و محتوای مربوطه را از لیست ویجت ها نمایش می دهد. گزینه های یک ظاهر طراحی اضافی، از جمله تنظیم رنگ برای موارد انتخاب شده و انتخاب نشده و تنظیم اندازه قلم برای دید بهتر، بررسی می شوند. این ویدئو با نمایشی از به‌روزرسانی پویا عنوان نوار برنامه بر اساس برگه انتخاب شده، با استفاده از فهرستی از نقشه‌ها برای ذخیره منابع و عناوین ویجت به پایان می‌رسد.",
                            },
                        },
                        // 156 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Adding a Custom Drawer",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter demonstrates how to add a navigation drawer to a Flutter application, focusing on the TabsScreen. The tutorial begins by explaining the simple process of integrating a drawer widget into the scaffold of the app, which automatically provides a hamburger icon and a backdrop for the drawer. The presenter then creates a custom MainDrawer widget to contain meaningful content, including buttons that link to different pages within the app, specifically the meals section and filters for dietary preferences. The drawer is structured using a column to arrange items vertically, with list tiles representing the buttons. The presenter emphasizes the importance of organizing the code into widgets for better maintainability and reusability. Finally, the tutorial concludes with the integration of the custom drawer into the main app and preparation for implementing functionality for the buttons in future lessons.",
                                // German
                                "Deutsch": "In diesem Video zeigt der Moderator, wie man einer Flutter-Anwendung eine Navigationsleiste hinzufügt, wobei der Schwerpunkt auf dem TabsScreen liegt. Das Tutorial beginnt mit der Erklärung des einfachen Prozesses der Integration eines Schubladen-Widgets in das Gerüst der App, das automatisch ein Hamburger-Symbol und einen Hintergrund für die Schublade bereitstellt. Der Moderator erstellt dann ein benutzerdefiniertes MainDrawer-Widget, das aussagekräftige Inhalte enthält, darunter Schaltflächen, die auf verschiedene Seiten innerhalb der App verweisen, insbesondere auf den Abschnitt „Mahlzeiten“ und Filter für Ernährungspräferenzen. Die Schublade ist mithilfe einer Spalte strukturiert, um Elemente vertikal anzuordnen, wobei Listenkacheln die Schaltflächen darstellen. Der Moderator betont, wie wichtig es ist, den Code in Widgets zu organisieren, um die Wartbarkeit und Wiederverwendbarkeit zu verbessern. Abschließend endet das Tutorial mit der Integration der benutzerdefinierten Schublade in die Haupt-App und der Vorbereitung für die Implementierung der Funktionalität für die Schaltflächen in zukünftigen Lektionen.",
                                // Chinese
                                "中国人": "在本视频中，演示者演示了如何向 Flutter 应用程序添加导航抽屉，重点介绍了 TabsScreen。本教程首先解释了将抽屉小部件集成到应用程序框架中的简单过程，该过程会自动为抽屉提供汉堡图标和背景。然后，演示者创建了一个自定义 MainDrawer 小部件来包含有意义的内容，包括链接到应用程序内不同页面的按钮，特别是膳食部分和饮食偏好过滤器。抽屉的结构是使用列来垂直排列项目，列表图块代表按钮。演示者强调了将代码组织成小部件以提高可维护性和可重用性的重要性。最后，本教程以将自定义抽屉集成到主应用程序中并为在未来的课程中实现按钮功能做准备结束。",
                                // Russian
                                "Русский": "В этом видео ведущий демонстрирует, как добавить навигационный ящик в приложение Flutter, уделяя особое внимание TabsScreen. Учебное пособие начинается с объяснения простого процесса интеграции виджета ящика в каркас приложения, который автоматически предоставляет значок гамбургера и фон для ящика. Затем ведущий создает настраиваемый виджет MainDrawer, содержащий значимый контент, включая кнопки, которые ссылаются на различные страницы в приложении, в частности, на раздел блюд и фильтры для диетических предпочтений. Ящик структурирован с использованием столбца для вертикального расположения элементов, а плитки списка представляют кнопки. Ведущий подчеркивает важность организации кода в виджеты для лучшей поддержки и повторного использования. Наконец, учебное пособие завершается интеграцией настраиваемого ящика в основное приложение и подготовкой к реализации функциональности кнопок в будущих уроках.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur montre comment ajouter un tiroir de navigation à une application Flutter, en se concentrant sur TabsScreen. Le didacticiel commence par expliquer le processus simple d'intégration d'un widget de tiroir dans l'échafaudage de l'application, qui fournit automatiquement une icône de hamburger et un arrière-plan pour le tiroir. Le présentateur crée ensuite un widget MainDrawer personnalisé pour contenir un contenu significatif, y compris des boutons qui renvoient vers différentes pages de l'application, en particulier la section des repas et des filtres pour les préférences alimentaires. Le tiroir est structuré à l'aide d'une colonne pour organiser les éléments verticalement, avec des mosaïques de liste représentant les boutons. Le présentateur souligne l'importance d'organiser le code en widgets pour une meilleure maintenabilité et réutilisabilité. Enfin, le didacticiel se termine par l'intégration du tiroir personnalisé dans l'application principale et la préparation de la mise en œuvre des fonctionnalités des boutons dans les prochaines leçons.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが TabsScreen に焦点を当てて、Flutter アプリケーションにナビゲーション ドロワーを追加する方法を説明します。チュートリアルでは、まず、ドロワー ウィジェットをアプリのスキャフォールドに統合する簡単なプロセスについて説明します。これにより、ドロワーのハンバーガー アイコンと背景が自動的に提供されます。次に、プレゼンターは、アプリ内のさまざまなページ (具体的には食事セクションと食事の好みのフィルター) にリンクするボタンなど、意味のあるコンテンツを含むカスタム MainDrawer ウィジェットを作成します。ドロワーは、アイテムを垂直に配置する列を使用して構造化され、リスト タイルがボタンを表します。プレゼンターは、保守性と再利用性を高めるために、コードをウィジェットに整理することの重要性を強調します。最後に、チュートリアルは、カスタム ドロワーをメイン アプリに統合し、今後のレッスンでボタンの機能を実装するための準備を行うことで終了します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 TabsScreen에 초점을 맞춰 Flutter 애플리케이션에 탐색 서랍을 추가하는 방법을 보여줍니다. 이 튜토리얼은 서랍 위젯을 앱의 스캐폴드에 통합하는 간단한 프로세스를 설명하는 것으로 시작하는데, 이는 자동으로 햄버거 아이콘과 서랍의 배경을 제공합니다. 그런 다음 발표자는 앱 내의 다른 페이지, 특히 식사 섹션과 식단 선호도 필터에 링크되는 버튼을 포함하여 의미 있는 콘텐츠를 포함하는 사용자 지정 MainDrawer 위젯을 만듭니다. 서랍은 항목을 수직으로 배열하는 열을 사용하여 구성되며 목록 타일은 버튼을 나타냅니다. 발표자는 더 나은 유지 관리 및 재사용성을 위해 코드를 위젯으로 구성하는 것의 중요성을 강조합니다. 마지막으로 이 튜토리얼은 사용자 지정 서랍을 기본 앱에 통합하고 향후 수업에서 버튼의 기능을 구현하기 위한 준비로 마무리됩니다.",
                                // Spanish
                                "Español": "En este video, el presentador demuestra cómo agregar un cajón de navegación a una aplicación Flutter, centrándose en TabsScreen. El tutorial comienza explicando el proceso simple de integrar un widget de cajón en el andamiaje de la aplicación, que proporciona automáticamente un ícono de hamburguesa y un fondo para el cajón. Luego, el presentador crea un widget MainDrawer personalizado para contener contenido significativo, incluidos botones que vinculan a diferentes páginas dentro de la aplicación, específicamente la sección de comidas y filtros para preferencias dietéticas. El cajón está estructurado utilizando una columna para organizar los elementos verticalmente, con mosaicos de lista que representan los botones. El presentador enfatiza la importancia de organizar el código en widgets para una mejor capacidad de mantenimiento y reutilización. Finalmente, el tutorial concluye con la integración del cajón personalizado en la aplicación principal y la preparación para implementar la funcionalidad de los botones en lecciones futuras.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर एप्लिकेशन में नेविगेशन ड्रॉअर जोड़ने का तरीका दिखाता है, जिसमें टैब्सस्क्रीन पर ध्यान केंद्रित किया जाता है। ट्यूटोरियल ऐप के स्कैफ़ोल्ड में ड्रॉअर विजेट को एकीकृत करने की सरल प्रक्रिया को समझाते हुए शुरू होता है, जो स्वचालित रूप से ड्रॉअर के लिए एक हैमबर्गर आइकन और एक पृष्ठभूमि प्रदान करता है। प्रस्तुतकर्ता तब सार्थक सामग्री रखने के लिए एक कस्टम MainDrawer विजेट बनाता है, जिसमें ऐप के भीतर विभिन्न पृष्ठों से लिंक करने वाले बटन शामिल हैं, विशेष रूप से भोजन अनुभाग और आहार संबंधी प्राथमिकताओं के लिए फ़िल्टर। आइटम को लंबवत रूप से व्यवस्थित करने के लिए एक कॉलम का उपयोग करके ड्रॉअर को संरचित किया जाता है, जिसमें सूची टाइलें बटन का प्रतिनिधित्व करती हैं। प्रस्तुतकर्ता बेहतर रखरखाव और पुन: प्रयोज्यता के लिए कोड को विजेट में व्यवस्थित करने के महत्व पर जोर देता है। अंत में, ट्यूटोरियल मुख्य ऐप में कस्टम ड्रॉअर के एकीकरण और भविष्य के पाठों में बटनों के लिए कार्यक्षमता को लागू करने की तैयारी के साथ समाप्त होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador demonstra como adicionar uma gaveta de navegação a uma aplicação Flutter, com foco no TabsScreen. O tutorial começa por explicar o processo simples de integração de um widget de gaveta no andaime da aplicação, que fornece automaticamente um ícone de hambúrguer e um fundo para a gaveta. O apresentador cria então um widget MainDrawer personalizado para conter conteúdo significativo, incluindo botões que direcionam para diferentes páginas da aplicação, especificamente a secção de refeições e filtros para as preferências alimentares. A gaveta está estruturada numa coluna para organizar os itens na vertical, com blocos de lista que representam os botões. O apresentador realça a importância de organizar o código em widgets para uma melhor manutenção e reutilização. Por fim, o tutorial termina com a integração da gaveta personalizada na aplicação principal e a preparação para implementar funcionalidades para os botões em lições futuras.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক দেখিয়েছেন কিভাবে একটি ফ্লাটার অ্যাপ্লিকেশনে একটি নেভিগেশন ড্রয়ার যোগ করতে হয়, ট্যাবস্ক্রিনে ফোকাস করে। টিউটোরিয়ালটি অ্যাপের স্ক্যাফোল্ডে একটি ড্রয়ার উইজেট সংহত করার সহজ প্রক্রিয়া ব্যাখ্যা করে শুরু হয়, যা স্বয়ংক্রিয়ভাবে একটি হ্যামবার্গার আইকন এবং ড্রয়ারের জন্য একটি পটভূমি প্রদান করে। উপস্থাপক তারপরে অর্থপূর্ণ বিষয়বস্তু ধারণ করার জন্য একটি কাস্টম মেইনড্রয়ার উইজেট তৈরি করে, যার মধ্যে বোতামগুলি রয়েছে যা অ্যাপের মধ্যে বিভিন্ন পৃষ্ঠার সাথে লিঙ্ক করে, বিশেষত খাবারের বিভাগ এবং খাদ্যতালিকাগত পছন্দগুলির জন্য ফিল্টার। ড্রয়ারটি একটি কলাম ব্যবহার করে আইটেমগুলিকে উল্লম্বভাবে সাজানোর জন্য গঠন করা হয়েছে, তালিকার টাইলগুলি বোতামগুলির প্রতিনিধিত্ব করে। উপস্থাপক আরও ভাল রক্ষণাবেক্ষণযোগ্যতা এবং পুনঃব্যবহারযোগ্যতার জন্য কোডটিকে উইজেটে সংগঠিত করার গুরুত্বের উপর জোর দেন। পরিশেষে, টিউটোরিয়ালটি মূল অ্যাপে কাস্টম ড্রয়ারের একীকরণ এবং ভবিষ্যতের পাঠে বোতামগুলির কার্যকারিতা বাস্তবায়নের প্রস্তুতির সাথে শেষ হয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح مقدم العرض كيفية إضافة درج تنقل إلى تطبيق Flutter، مع التركيز على TabsScreen. يبدأ البرنامج التعليمي بشرح العملية البسيطة المتمثلة في دمج عنصر واجهة مستخدم الدرج في هيكل التطبيق، والذي يوفر تلقائيًا أيقونة همبرغر وخلفية للدرج. ثم يقوم مقدم العرض بإنشاء عنصر واجهة مستخدم MainDrawer مخصص لاحتواء محتوى مفيد، بما في ذلك الأزرار التي ترتبط بصفحات مختلفة داخل التطبيق، وخاصة قسم الوجبات والمرشحات لتفضيلات النظام الغذائي. يتم تنظيم الدرج باستخدام عمود لترتيب العناصر عموديًا، مع وجود بلاطات قائمة تمثل الأزرار. يؤكد مقدم العرض على أهمية تنظيم الكود في عناصر واجهة مستخدم لتحسين إمكانية الصيانة وإعادة الاستخدام. أخيرًا، ينتهي البرنامج التعليمي بدمج الدرج المخصص في التطبيق الرئيسي والتحضير لتنفيذ وظائف الأزرار في الدروس المستقبلية.",
                                // Persian
                                "فارسی": "در این ویدئو، ارائه دهنده نحوه افزودن کشوی ناوبری به برنامه فلاتر را با تمرکز بر TabsScreen نشان می دهد. این آموزش با توضیح فرآیند ساده ادغام ویجت کشو در داربست برنامه آغاز می شود، که به طور خودکار یک نماد همبرگر و یک پس زمینه برای کشو ارائه می دهد. سپس ارائه‌دهنده یک ویجت MainDrawer سفارشی ایجاد می‌کند تا حاوی محتوای معنی‌دار باشد، از جمله دکمه‌هایی که به صفحات مختلف در برنامه پیوند می‌دهند، به‌ویژه بخش وعده‌های غذایی و فیلترهایی برای ترجیحات غذایی. کشو با استفاده از یک ستون برای چیدمان اقلام به صورت عمودی، با کاشی های فهرست نشان دهنده دکمه ها ساخته شده است. ارائه دهنده بر اهمیت سازماندهی کد در ویجت ها برای نگهداری بهتر و قابلیت استفاده مجدد تاکید می کند. در نهایت، آموزش با ادغام کشوی سفارشی در برنامه اصلی و آماده سازی برای اجرای عملکرد دکمه ها در درس های آینده به پایان می رسد.",
                            },
                        },
                        // 157 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Adding Links to the Drawer",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter demonstrates how to implement navigation functionality in a Flutter application using a drawer. Initially, the presenter modifies the MainDrawer by adding a tap handler to the ListTile widgets, allowing users to switch between different pages when tapped. The first ListTile is set to navigate to the TabsScreen, while the second one is configured to lead to a new FiltersScreen. The presenter creates this new screen as a stateless widget and adds a static route name for it. After registering the FiltersScreen in the main route table of the application, the presenter updates the drawer to use named routes for navigation. Finally, the functionality is tested to ensure that tapping on the 'meals' and 'filters' options correctly transitions between the respective screens, confirming that the navigation works as intended.",
                                // German
                                "Deutsch": "In diesem Video zeigt der Moderator, wie man mithilfe einer Schublade Navigationsfunktionen in einer Flutter-Anwendung implementiert. Zunächst ändert der Moderator die MainDrawer, indem er den ListTile-Widgets einen Tap-Handler hinzufügt, sodass Benutzer beim Tippen zwischen verschiedenen Seiten wechseln können. Die erste ListTile ist so eingestellt, dass sie zum TabsScreen navigiert, während die zweite so konfiguriert ist, dass sie zu einem neuen FiltersScreen führt. Der Moderator erstellt diesen neuen Bildschirm als zustandsloses Widget und fügt einen statischen Routennamen dafür hinzu. Nachdem der FiltersScreen in der Hauptroutentabelle der Anwendung registriert wurde, aktualisiert der Moderator die Schublade, um benannte Routen für die Navigation zu verwenden. Abschließend wird die Funktionalität getestet, um sicherzustellen, dass beim Tippen auf die Optionen „Mahlzeiten“ und „Filter“ der Übergang zwischen den jeweiligen Bildschirmen korrekt erfolgt, wodurch bestätigt wird, dass die Navigation wie vorgesehen funktioniert.",
                                // Chinese
                                "中国人": "在此视频中，演示者演示了如何使用抽屉在 Flutter 应用程序中实现导航功能。首先，演示者通过向 ListTile 小部件添加点击处理程序来修改 MainDrawer，允许用户在点击时在不同页面之间切换。第一个 ListTile 设置为导航到 TabsScreen，而第二个 ListTile 被配置为指向新的 FiltersScreen。演示者将这个新屏幕创建为无状态小部件，并为其添加静态路由名称。在应用程序的主路由表中注册 FiltersScreen 后，演示者更新抽屉以使用命名路由进行导航。最后，测试该功能以确保点击“餐点”和“过滤器”选项时可以在相应的屏幕之间正确转换，确认导航按预期工作。",
                                // Russian
                                "Русский": "В этом видео ведущий демонстрирует, как реализовать навигационную функцию в приложении Flutter с помощью drawer. Сначала ведущий изменяет MainDrawer, добавляя обработчик касаний к виджетам ListTile, позволяя пользователям переключаться между разными страницами при касании. Первый ListTile настроен на переход к TabsScreen, а второй настроен на переход к новому FiltersScreen. Ведущий создает этот новый экран как виджет без состояния и добавляет для него статическое имя маршрута. После регистрации FiltersScreen в основной таблице маршрутов приложения ведущий обновляет drawer, чтобы использовать именованные маршруты для навигации. Наконец, функциональность тестируется, чтобы убедиться, что нажатие на опции «еда» и «фильтры» правильно переходит между соответствующими экранами, подтверждая, что навигация работает так, как задумано.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur montre comment implémenter la fonctionnalité de navigation dans une application Flutter à l'aide d'un tiroir. Dans un premier temps, le présentateur modifie le MainDrawer en ajoutant un gestionnaire de tapotement aux widgets ListTile, permettant aux utilisateurs de basculer entre différentes pages lorsqu'ils appuient dessus. Le premier ListTile est configuré pour naviguer vers le TabsScreen, tandis que le second est configuré pour conduire à un nouveau FiltersScreen. Le présentateur crée ce nouvel écran en tant que widget sans état et lui ajoute un nom de route statique. Après avoir enregistré le FiltersScreen dans la table de routage principale de l'application, le présentateur met à jour le tiroir pour utiliser des routes nommées pour la navigation. Enfin, la fonctionnalité est testée pour garantir que le fait d'appuyer sur les options « repas » et « filtres » permet de passer correctement d'un écran à l'autre, confirmant ainsi que la navigation fonctionne comme prévu.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターがドロワーを使用して Flutter アプリケーションにナビゲーション機能を実装する方法を紹介します。最初に、プレゼンターはタップ ハンドラーを ListTile ウィジェットに追加して MainDrawer を変更し、タップするとユーザーがさまざまなページを切り替えることができるようにします。最初の ListTile は TabsScreen に移動するように設定され、2 つ目は新しい FiltersScreen につながるように構成されます。プレゼンターは、この新しい画面をステートレス ウィジェットとして作成し、静的ルート名を追加します。プレゼンターは、FiltersScreen をアプリケーションのメイン ルート テーブルに登録した後、ドロワーを更新して、ナビゲーションに名前付きルートを使用するようにします。最後に、機能がテストされ、「食事」と「フィルター」のオプションをタップすると、それぞれの画面間で正しく遷移し、ナビゲーションが意図したとおりに機能することを確認します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 드로어를 사용하여 Flutter 애플리케이션에서 탐색 기능을 구현하는 방법을 보여줍니다. 처음에 발표자는 ListTile 위젯에 탭 핸들러를 추가하여 MainDrawer를 수정하여 사용자가 탭할 때 다른 페이지 간에 전환할 수 있도록 합니다. 첫 번째 ListTile은 TabsScreen으로 이동하도록 설정되어 있고 두 번째 ListTile은 새 FiltersScreen으로 연결되도록 구성되어 있습니다. 발표자는 이 새 화면을 상태 비저장 위젯으로 만들고 이에 대한 정적 경로 이름을 추가합니다. 발표자는 애플리케이션의 기본 경로 테이블에 FiltersScreen을 등록한 후 드로어를 업데이트하여 탐색에 명명된 경로를 사용합니다. 마지막으로 기능을 테스트하여 'meals' 및 'filters' 옵션을 탭하면 해당 화면 간에 올바르게 전환되는지 확인하고 탐색이 의도한 대로 작동하는지 확인합니다.",
                                // Spanish
                                "Español": "En este video, el presentador demuestra cómo implementar la funcionalidad de navegación en una aplicación Flutter usando un cajón. Inicialmente, el presentador modifica el MainDrawer agregando un controlador de toques a los widgets ListTile, lo que permite a los usuarios cambiar entre diferentes páginas cuando se toca. El primer ListTile está configurado para navegar a TabsScreen, mientras que el segundo está configurado para llevar a un nuevo FiltersScreen. El presentador crea esta nueva pantalla como un widget sin estado y le agrega un nombre de ruta estática. Después de registrar FiltersScreen en la tabla de ruta principal de la aplicación, el presentador actualiza el cajón para usar rutas con nombre para la navegación. Finalmente, se prueba la funcionalidad para garantizar que al tocar las opciones 'comidas' y 'filtros' se realice correctamente la transición entre las pantallas respectivas, lo que confirma que la navegación funciona como se esperaba.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता यह प्रदर्शित करता है कि ड्रॉअर का उपयोग करके फ़्लटर एप्लिकेशन में नेविगेशन कार्यक्षमता को कैसे लागू किया जाए। प्रारंभ में, प्रस्तुतकर्ता ListTile विजेट में टैप हैंडलर जोड़कर MainDrawer को संशोधित करता है, जिससे उपयोगकर्ता टैप किए जाने पर विभिन्न पृष्ठों के बीच स्विच कर सकते हैं। पहला ListTile TabsScreen पर नेविगेट करने के लिए सेट किया गया है, जबकि दूसरा एक नए FiltersScreen पर ले जाने के लिए कॉन्फ़िगर किया गया है। प्रस्तुतकर्ता इस नई स्क्रीन को स्टेटलेस विजेट के रूप में बनाता है और इसके लिए एक स्थिर रूट नाम जोड़ता है। एप्लिकेशन की मुख्य रूट तालिका में FiltersScreen को पंजीकृत करने के बाद, प्रस्तुतकर्ता नेविगेशन के लिए नामित रूट का उपयोग करने के लिए ड्रॉअर को अपडेट करता है। अंत में, कार्यक्षमता का परीक्षण यह सुनिश्चित करने के लिए किया जाता है कि 'भोजन' और 'फ़िल्टर' विकल्पों पर टैप करने से संबंधित स्क्रीन के बीच सही ढंग से संक्रमण होता है, यह पुष्टि करते हुए कि नेविगेशन इच्छित तरीके से काम करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador demonstra como implementar a funcionalidade de navegação numa aplicação Flutter utilizando uma gaveta. Inicialmente, o apresentador modifica o MainDrawer adicionando um manipulador de toque aos widgets ListTile, permitindo aos utilizadores alternar entre páginas diferentes quando tocados. O primeiro ListTile está configurado para navegar até ao TabsScreen, enquanto o segundo está configurado para levar a um novo FiltersScreen. O apresentador cria este novo ecrã como um widget sem estado e adiciona um nome de rota estática para o mesmo. Após o registo do FiltersScreen na tabela de rotas principal da aplicação, o apresentador atualiza a gaveta para utilizar rotas nomeadas para navegação. Por fim, a funcionalidade é testada para garantir que ao tocar nas opções ‘refeições’ e ‘filtros’ transita corretamente entre os respetivos ecrãs, confirmando que a navegação funciona como pretendido.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক একটি ড্রয়ার ব্যবহার করে একটি ফ্লাটার অ্যাপ্লিকেশনে নেভিগেশন কার্যকারিতা কীভাবে প্রয়োগ করতে হয় তা প্রদর্শন করে। প্রাথমিকভাবে, উপস্থাপক ListTile উইজেটগুলিতে একটি ট্যাপ হ্যান্ডলার যোগ করে মেইনড্রয়ারকে পরিবর্তন করে, ব্যবহারকারীদের ট্যাপ করার সময় বিভিন্ন পৃষ্ঠার মধ্যে স্যুইচ করার অনুমতি দেয়। প্রথম লিস্টটাইলটি ট্যাবস্ক্রিনে নেভিগেট করার জন্য সেট করা হয়েছে, যখন দ্বিতীয়টি একটি নতুন ফিল্টারস্ক্রিনে নিয়ে যাওয়ার জন্য কনফিগার করা হয়েছে। উপস্থাপক এই নতুন স্ক্রীনটিকে একটি রাষ্ট্রহীন উইজেট হিসাবে তৈরি করে এবং এর জন্য একটি স্ট্যাটিক রুট নাম যোগ করে। অ্যাপ্লিকেশনটির প্রধান রুট টেবিলে ফিল্টারস্ক্রিন নিবন্ধন করার পরে, উপস্থাপক নেভিগেশনের জন্য নামযুক্ত রুটগুলি ব্যবহার করার জন্য ড্রয়ার আপডেট করে। অবশেষে, 'খাবার' এবং 'ফিল্টার' বিকল্পগুলিতে ট্যাপ করা সঠিকভাবে সংশ্লিষ্ট স্ক্রিনের মধ্যে স্থানান্তরিত হয়েছে তা নিশ্চিত করার জন্য কার্যকারিতা পরীক্ষা করা হয়, নিশ্চিত করে যে নেভিগেশন উদ্দেশ্য অনুযায়ী কাজ করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يوضح مقدم العرض كيفية تنفيذ وظيفة التنقل في تطبيق Flutter باستخدام درج. في البداية، يعدل مقدم العرض MainDrawer عن طريق إضافة معالج النقر إلى عناصر واجهة المستخدم ListTile، مما يسمح للمستخدمين بالتبديل بين الصفحات المختلفة عند النقر عليها. يتم تعيين أول ListTile للانتقال إلى TabsScreen، بينما يتم تكوين الثاني ليؤدي إلى FiltersScreen جديد. ينشئ مقدم العرض هذه الشاشة الجديدة كعنصر واجهة مستخدم بدون حالة ويضيف اسم مسار ثابت لها. بعد تسجيل FiltersScreen في جدول المسار الرئيسي للتطبيق، يقوم مقدم العرض بتحديث الدرج لاستخدام مسارات مسماة للتنقل. أخيرًا، يتم اختبار الوظيفة للتأكد من أن النقر على خياري 'الوجبات' و'المرشحات' ينتقل بشكل صحيح بين الشاشات المعنية، مما يؤكد أن التنقل يعمل كما هو مقصود.",
                                // Persian
                                "فارسی": "در این ویدئو، مجری نحوه پیاده‌سازی عملکرد ناوبری را در یک برنامه فلاتر با استفاده از کشو نشان می‌دهد. در ابتدا، ارائه دهنده با افزودن یک Tap handler به ویجت های ListTile، MainDrawer را تغییر می دهد و به کاربران اجازه می دهد در صورت ضربه زدن بین صفحات مختلف جابجا شوند. ListTile اول برای پیمایش به TabsScreen تنظیم شده است، در حالی که مورد دوم برای هدایت به FiltersScreen جدید پیکربندی شده است. ارائه دهنده این صفحه جدید را به عنوان یک ویجت بدون حالت ایجاد می کند و یک نام مسیر ثابت برای آن اضافه می کند. پس از ثبت FiltersScreen در جدول مسیر اصلی برنامه، ارائه دهنده کشو را به روز می کند تا از مسیرهای نامگذاری شده برای پیمایش استفاده کند. در نهایت، این عملکرد برای اطمینان از اینکه ضربه زدن روی گزینه‌های «غذاها» و «فیلترها» به درستی بین صفحه‌های مربوطه جابه‌جا می‌شود، آزمایش می‌شود و تأیید می‌کند که پیمایش به‌طور مورد نظر کار می‌کند.",
                            },
                        },
                        // 158 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Replacing Pages (Instead of Pushing)",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter enhances the FiltersScreen by adding a scaffold and an appBar displaying 'your filters,' improving its appearance. The presenter discusses the navigation behavior when using the drawer, highlighting an issue with an accumulating stack of pages when navigating back. To resolve this, the presenter suggests using pushReplacementNamed instead of pushNamed to ensure that navigating to a new page replaces the existing page in the navigation stack, thus preventing an ever-growing stack and eliminating the back button. This approach is beneficial in scenarios like user authentication, where users should not navigate back to the login screen after logging in. By implementing this change, the navigation behaves as intended without memory issues associated with a growing stack of pages.",
                                // German
                                "Deutsch": "In diesem Video verbessert der Moderator den FiltersScreen, indem er ein Gerüst und eine AppBar hinzufügt, die „Ihre Filter“ anzeigt, wodurch das Erscheinungsbild verbessert wird. Der Moderator erläutert das Navigationsverhalten bei Verwendung der Schublade und hebt ein Problem mit einem wachsenden Seitenstapel beim Zurücknavigieren hervor. Um dies zu beheben, schlägt der Moderator vor, pushReplacementNamed anstelle von pushNamed zu verwenden, um sicherzustellen, dass beim Navigieren zu einer neuen Seite die vorhandene Seite im Navigationsstapel ersetzt wird. Dadurch wird ein ständig wachsender Stapel verhindert und die Zurück-Schaltfläche eliminiert. Dieser Ansatz ist in Szenarien wie der Benutzerauthentifizierung von Vorteil, bei denen Benutzer nach der Anmeldung nicht zum Anmeldebildschirm zurück navigieren sollten. Durch die Implementierung dieser Änderung verhält sich die Navigation wie vorgesehen, ohne dass Speicherprobleme auftreten, die mit einem wachsenden Seitenstapel verbunden sind.",
                                // Chinese
                                "中国人": "在此视频中，演示者通过添加支架和显示“您的过滤器”的 appBar 来增强 FiltersScreen，从而改善其外观。演示者讨论了使用抽屉时的导航行为，并强调了返回时页面堆栈累积的问题。为了解决这个问题，演示者建议使用 pushReplacementNamed 而不是 pushNamed，以确保导航到新页面会替换导航堆栈中的现有页面，从而防止堆栈不断增长并消除后退按钮。这种方法在用户身份验证等场景中非常有用，在这些场景中，用户登录后不应导航回登录屏幕。通过实施此更改，导航行为将按预期进行，而不会出现与页面堆栈增长相关的内存问题。",
                                // Russian
                                "Русский": "В этом видео ведущий улучшает FiltersScreen, добавляя каркас и appBar, отображающий «ваши фильтры», улучшая его внешний вид. Ведущий обсуждает поведение навигации при использовании ящика, выделяя проблему с накапливающимся стеком страниц при переходе назад. Чтобы решить эту проблему, ведущий предлагает использовать pushReplacementNamed вместо pushNamed, чтобы гарантировать, что переход на новую страницу заменяет существующую страницу в стеке навигации, тем самым предотвращая постоянно растущий стек и устраняя кнопку «Назад». Этот подход полезен в таких сценариях, как аутентификация пользователя, когда пользователи не должны возвращаться на экран входа после входа в систему. Благодаря внедрению этого изменения навигация ведет себя так, как задумано, без проблем с памятью, связанных с растущим стеком страниц.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur améliore l'écran FiltersScreen en ajoutant un échafaudage et une barre d'applications affichant « vos filtres », améliorant ainsi son apparence. Le présentateur discute du comportement de navigation lors de l'utilisation du tiroir, soulignant un problème d'accumulation de pile de pages lors de la navigation en arrière. Pour résoudre ce problème, le présentateur suggère d'utiliser pushReplacementNamed au lieu de pushNamed pour garantir que la navigation vers une nouvelle page remplace la page existante dans la pile de navigation, évitant ainsi une pile toujours croissante et éliminant le bouton de retour. Cette approche est bénéfique dans des scénarios tels que l'authentification des utilisateurs, où les utilisateurs ne doivent pas revenir à l'écran de connexion après s'être connectés. En implémentant ce changement, la navigation se comporte comme prévu sans problèmes de mémoire associés à une pile croissante de pages.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターがスキャフォールドと「フィルター」を表示する appBar を追加して FiltersScreen を拡張し、外観を改善しています。プレゼンターは、ドロワー使用時のナビゲーション動作について説明し、戻るときにページのスタックが蓄積される問題を強調しています。この問題を解決するために、プレゼンターは、pushNamed ではなく pushReplacementNamed を使用して、新しいページに移動するとナビゲーション スタック内の既存のページが置き換えられるようにすることを提案しています。これにより、スタックが大きくなり続けるのを防ぎ、戻るボタンをなくすことができます。このアプローチは、ユーザー認証など、ユーザーがログイン後にログイン画面に戻らないようにするシナリオで役立ちます。この変更を実装することで、ナビゲーションは意図したとおりに動作し、ページのスタックが大きくなることに関連するメモリの問題は発生しません。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 '필터'를 표시하는 스캐폴드와 앱바를 추가하여 FiltersScreen을 개선하고 모양을 개선합니다. 발표자는 서랍을 사용할 때의 탐색 동작을 설명하면서 뒤로 탐색할 때 페이지 스택이 쌓이는 문제를 강조합니다. 이를 해결하기 위해 발표자는 pushNamed 대신 pushReplacementNamed를 사용하여 새 페이지로 이동하면 탐색 스택의 기존 페이지가 대체되도록 하여 스택이 계속 커지는 것을 방지하고 뒤로 가기 버튼을 제거할 것을 제안합니다. 이 방법은 사용자가 로그인 후 로그인 화면으로 돌아가면 안 되는 사용자 인증과 같은 시나리오에서 유용합니다. 이 변경 사항을 구현하면 페이지 스택이 커지는 것과 관련된 메모리 문제 없이 탐색이 의도한 대로 작동합니다.",
                                // Spanish
                                "Español": "En este video, el presentador mejora la pantalla FiltersScreen agregando un andamio y una barra de aplicaciones que muestra 'sus filtros', lo que mejora su apariencia. El presentador analiza el comportamiento de navegación al usar el cajón y destaca un problema con una pila de páginas que se acumula al navegar hacia atrás. Para resolver esto, el presentador sugiere usar pushReplacementNamed en lugar de pushNamed para garantizar que navegar a una nueva página reemplace la página existente en la pila de navegación, lo que evita una pila en constante crecimiento y elimina el botón Atrás. Este enfoque es beneficioso en escenarios como la autenticación de usuarios, donde los usuarios no deben volver a la pantalla de inicio de sesión después de iniciar sesión. Al implementar este cambio, la navegación se comporta como se esperaba sin problemas de memoria asociados con una pila de páginas en crecimiento.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता एक स्कैफोल्ड और एक ऐपबार जोड़कर फ़िल्टर स्क्रीन को बेहतर बनाता है, जो 'आपके फ़िल्टर' प्रदर्शित करता है, जिससे इसकी उपस्थिति में सुधार होता है। प्रस्तुतकर्ता ड्रॉअर का उपयोग करते समय नेविगेशन व्यवहार पर चर्चा करता है, वापस नेविगेट करते समय पृष्ठों के एक संचित स्टैक के साथ एक समस्या को उजागर करता है। इसे हल करने के लिए, प्रस्तुतकर्ता यह सुनिश्चित करने के लिए pushNamed के बजाय pushReplacementNamed का उपयोग करने का सुझाव देता है कि नए पृष्ठ पर नेविगेट करने से नेविगेशन स्टैक में मौजूदा पृष्ठ बदल जाता है, इस प्रकार एक लगातार बढ़ते स्टैक को रोकता है और बैक बटन को समाप्त करता है। यह दृष्टिकोण उपयोगकर्ता प्रमाणीकरण जैसे परिदृश्यों में फायदेमंद है, जहां उपयोगकर्ताओं को लॉग इन करने के बाद लॉगिन स्क्रीन पर वापस नहीं जाना चाहिए। इस परिवर्तन को लागू करने से, नेविगेशन पृष्ठों के बढ़ते स्टैक से जुड़ी मेमोरी समस्याओं के बिना इच्छित तरीके से व्यवहार करता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador melhora o FiltersScreen adicionando um scaffold e uma appBar exibindo 'os seus filtros', melhorando o seu aspeto. O apresentador discute o comportamento de navegação ao utilizar a gaveta, destacando um problema com a acumulação de pilha de páginas ao navegar de volta. Para resolver isto, o apresentador sugere que se utilize pushReplacementNamed em vez de pushNamed para garantir que a navegação para uma nova página substitui a página existente na pilha de navegação, evitando assim uma pilha cada vez maior e eliminando o botão Voltar. Esta abordagem é benéfica em cenários como a autenticação de utilizadores, onde os utilizadores não devem navegar de volta para o ecrã de login após o login. Ao implementar esta alteração, a navegação comporta-se como planeado, sem problemas de memória associados a uma pilha crescente de páginas.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক 'আপনার ফিল্টার' প্রদর্শন করে একটি স্ক্যাফোল্ড এবং একটি অ্যাপবার যোগ করে ফিল্টারস্ক্রিনকে উন্নত করে, এর চেহারা উন্নত করে৷ উপস্থাপক ড্রয়ার ব্যবহার করার সময় নেভিগেশন আচরণ নিয়ে আলোচনা করে, ফিরে নেভিগেট করার সময় পৃষ্ঠাগুলির একটি জমা স্ট্যাকের সাথে একটি সমস্যা হাইলাইট করে। এটি সমাধান করার জন্য, উপস্থাপক একটি নতুন পৃষ্ঠায় নেভিগেট করার জন্য নেভিগেশন স্ট্যাকের বিদ্যমান পৃষ্ঠাটিকে প্রতিস্থাপন করে তা নিশ্চিত করার জন্য pushNamed-এর পরিবর্তে pushReplacementNamed ব্যবহার করার পরামর্শ দেন, এইভাবে একটি ক্রমবর্ধমান স্ট্যাক প্রতিরোধ করে এবং পিছনের বোতামটি বাদ দেয়৷ এই পদ্ধতিটি ব্যবহারকারীর প্রমাণীকরণের মতো পরিস্থিতিতে উপকারী, যেখানে ব্যবহারকারীদের লগ ইন করার পরে লগইন স্ক্রিনে ফিরে যাওয়া উচিত নয়। এই পরিবর্তনটি বাস্তবায়নের মাধ্যমে, নেভিগেশনটি পৃষ্ঠাগুলির ক্রমবর্ধমান স্ট্যাকের সাথে যুক্ত মেমরি সমস্যা ছাড়াই উদ্দেশ্য অনুযায়ী আচরণ করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يقوم مقدم العرض بتحسين شاشة FiltersScreen عن طريق إضافة سقالة وشريط تطبيقات يعرض 'مرشحاتك'، مما يحسن مظهرها. يناقش مقدم العرض سلوك التنقل عند استخدام الدرج، ويسلط الضوء على مشكلة تتعلق بتراكم كومة الصفحات عند التنقل للخلف. لحل هذه المشكلة، يقترح مقدم العرض استخدام pushReplacementNamed بدلاً من pushNamed لضمان استبدال الصفحة الموجودة في كومة التنقل عند التنقل إلى صفحة جديدة، وبالتالي منع كومة الصفحات المتزايدة باستمرار والتخلص من زر الرجوع. هذا النهج مفيد في سيناريوهات مثل مصادقة المستخدم، حيث لا ينبغي للمستخدمين العودة إلى شاشة تسجيل الدخول بعد تسجيل الدخول. من خلال تنفيذ هذا التغيير، يتصرف التنقل كما هو مقصود دون مشاكل الذاكرة المرتبطة بكومة الصفحات المتزايدة.",
                                // Persian
                                "فارسی": "در این ویدئو، ارائه دهنده فیلترهای صفحه را با افزودن یک داربست و یک نوار برنامه که 'فیلترهای شما' را نمایش می دهد، بهبود می بخشد و ظاهر آن را بهبود می بخشد. ارائه‌دهنده رفتار پیمایش را هنگام استفاده از کشو مورد بحث قرار می‌دهد، و در هنگام پیمایش به عقب، مشکلی را که در انباشته شدن صفحات وجود دارد، برجسته می‌کند. برای حل این مشکل، ارائه دهنده پیشنهاد می کند که به جای pushNamed از pushReplacementNamed استفاده کنید تا اطمینان حاصل شود که پیمایش به صفحه جدید جایگزین صفحه موجود در پشته ناوبری می شود، بنابراین از یک پشته همیشه در حال رشد جلوگیری می کند و دکمه برگشت را حذف می کند. این رویکرد در سناریوهایی مانند احراز هویت کاربر، که در آن کاربران نباید پس از ورود به سیستم به صفحه ورود به سیستم برگردند، سودمند است. با اجرای این تغییر، ناوبری بدون مشکلات حافظه مرتبط با افزایش تعداد صفحات، همانطور که در نظر گرفته شده است، رفتار می کند.",
                            },
                        },
                        // 159 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Popping Pages & Passing Data Back",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter discusses how to programmatically navigate back in a Flutter application and pass data back to a previous page, specifically in the context of a recipe detail screen. The presenter implements a floating action button that allows users to 'delete' a recipe temporarily by navigating back and passing the recipe's ID to the previous page. By using the Navigator.pop method, the presenter demonstrates how to remove the current screen from the navigation stack. Additionally, the video covers how to handle the return of data using the Future object from pushNamed and explains the significance of using didChangeDependencies for initialization tasks that require context, since initState cannot be used for this purpose. The presenter also introduces a flag to prevent reloading data unnecessarily when the state updates. Ultimately, the tutorial emphasizes the importance of understanding how to pass data back and manage state transitions effectively in a Flutter app.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Moderator, wie man in einer Flutter-Anwendung programmgesteuert zurücknavigiert und Daten an eine vorherige Seite zurückgibt, insbesondere im Kontext eines Rezeptdetailbildschirms. Der Moderator implementiert eine schwebende Aktionsschaltfläche, mit der Benutzer ein Rezept vorübergehend „löschen“ können, indem sie zurücknavigieren und die ID des Rezepts an die vorherige Seite übergeben. Mithilfe der Methode Navigator.pop zeigt der Moderator, wie der aktuelle Bildschirm aus dem Navigationsstapel entfernt wird. Darüber hinaus behandelt das Video, wie die Rückgabe von Daten mithilfe des Future-Objekts von pushNamed gehandhabt wird, und erklärt die Bedeutung der Verwendung von didChangeDependencies für Initialisierungsaufgaben, die Kontext erfordern, da initState für diesen Zweck nicht verwendet werden kann. Der Moderator führt auch ein Flag ein, um ein unnötiges Neuladen von Daten bei einer Statusaktualisierung zu verhindern. Letztendlich betont das Tutorial, wie wichtig es ist, zu verstehen, wie Daten zurückgegeben und Statusübergänge in einer Flutter-App effektiv verwaltet werden.",
                                // Chinese
                                "中国人": "在本视频中，演示者讨论了如何以编程方式在 Flutter 应用程序中导航回并将数据传回上一页，特别是在食谱详细信息屏幕的上下文中。演示者实现了一个浮动操作按钮，允许用户通过导航回并将食谱的 ID 传递到上一页来暂时“删除”食谱。通过使用 Navigator.pop 方法，演示者演示了如何从导航堆栈中删除当前屏幕。此外，视频还介绍了如何使用 pushNamed 中的 Future 对象处理数据返回，并解释了使用 didChangeDependencies 进行需要上下文的初始化任务的重要性，因为 initState 不能用于此目的。演示者还介绍了一个标志，以防止在状态更新时不必要地重新加载数据。最后，本教程强调了了解如何在 Flutter 应用程序中传回数据和有效管理状态转换的重要性。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает, как программно вернуться назад в приложении Flutter и передать данные обратно на предыдущую страницу, в частности, в контексте экрана с подробностями рецепта. Докладчик реализует плавающую кнопку действия, которая позволяет пользователям временно «удалять» рецепт, возвращаясь назад и передавая идентификатор рецепта на предыдущую страницу. Используя метод Navigator.pop, докладчик демонстрирует, как удалить текущий экран из стека навигации. Кроме того, в видео рассматривается, как обрабатывать возврат данных с помощью объекта Future из pushNamed, и объясняется важность использования didChangeDependencies для задач инициализации, требующих контекста, поскольку initState нельзя использовать для этой цели. Докладчик также представляет флаг, предотвращающий ненужную перезагрузку данных при обновлении состояния. В конечном счете, в руководстве подчеркивается важность понимания того, как передавать данные обратно и эффективно управлять переходами состояний в приложении Flutter.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur explique comment naviguer par programmation dans une application Flutter et renvoyer des données à une page précédente, en particulier dans le contexte d'un écran de détails de recette. Le présentateur implémente un bouton d'action flottant qui permet aux utilisateurs de « supprimer » temporairement une recette en naviguant en arrière et en transmettant l'ID de la recette à la page précédente. En utilisant la méthode Navigator.pop, le présentateur montre comment supprimer l'écran actuel de la pile de navigation. De plus, la vidéo explique comment gérer le retour de données à l'aide de l'objet Future de pushNamed et explique l'importance d'utiliser didChangeDependencies pour les tâches d'initialisation qui nécessitent un contexte, car initState ne peut pas être utilisé à cette fin. Le présentateur présente également un indicateur pour empêcher le rechargement inutile des données lorsque l'état est mis à jour. En fin de compte, le didacticiel souligne l'importance de comprendre comment renvoyer des données et gérer efficacement les transitions d'état dans une application Flutter.",
                                // Japanese
                                "日本語": "この動画では、プレゼンターが Flutter アプリケーションでプログラム的に前のページに戻り、データを前のページに渡す方法について説明します。具体的には、レシピの詳細画面のコンテキストで説明します。プレゼンターは、前のページに戻ってレシピの ID を渡すことで、ユーザーがレシピを一時的に「削除」できるようにするフローティング アクション ボタンを実装します。プレゼンターは、Navigator.pop メソッドを使用して、現在の画面をナビゲーション スタックから削除する方法を示します。さらに、この動画では、pushNamed からの Future オブジェクトを使用してデータの戻りを処理する方法と、initState はこの目的で使用できないため、コンテキストを必要とする初期化タスクに didChangeDependencies を使用することの重要性について説明します。プレゼンターは、状態が更新されたときにデータが不必要に再読み込みされないようにするためのフラグも紹介します。最終的に、このチュートリアルでは、Flutter アプリでデータを戻し、状態遷移を効果的に管理する方法を理解することの重要性を強調しています。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 애플리케이션에서 프로그래밍 방식으로 뒤로 이동하고 이전 페이지로 데이터를 다시 전달하는 방법, 특히 레시피 세부 정보 화면의 컨텍스트에서 논의합니다. 발표자는 사용자가 뒤로 이동하여 레시피의 ID를 이전 페이지로 전달하여 레시피를 일시적으로 '삭제'할 수 있는 플로팅 작업 버튼을 구현합니다. 발표자는 Navigator.pop 메서드를 사용하여 탐색 스택에서 현재 화면을 제거하는 방법을 보여줍니다. 또한 이 비디오에서는 pushNamed에서 Future 객체를 사용하여 데이터 반환을 처리하는 방법을 다루고 컨텍스트가 필요한 초기화 작업에 didChangeDependencies를 사용하는 것의 중요성을 설명합니다. 이 목적으로 initState를 사용할 수 없기 때문입니다. 발표자는 또한 상태가 업데이트될 때 불필요하게 데이터를 다시 로드하는 것을 방지하기 위한 플래그를 소개합니다. 궁극적으로 이 튜토리얼은 Flutter 앱에서 데이터를 다시 전달하고 상태 전환을 효과적으로 관리하는 방법을 이해하는 것의 중요성을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el presentador explica cómo navegar hacia atrás mediante programación en una aplicación Flutter y pasar datos a una página anterior, específicamente en el contexto de una pantalla de detalles de una receta. El presentador implementa un botón de acción flotante que permite a los usuarios 'eliminar' una receta temporalmente navegando hacia atrás y pasando el ID de la receta a la página anterior. Al usar el método Navigator.pop, el presentador demuestra cómo eliminar la pantalla actual de la pila de navegación. Además, el video cubre cómo manejar la devolución de datos usando el objeto Future de pushNamed y explica la importancia de usar didChangeDependencies para tareas de inicialización que requieren contexto, ya que initState no se puede usar para este propósito. El presentador también presenta una bandera para evitar recargar datos innecesariamente cuando se actualiza el estado. Por último, el tutorial enfatiza la importancia de comprender cómo pasar datos de vuelta y administrar las transiciones de estado de manera efectiva en una aplicación Flutter.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर एप्लिकेशन में प्रोग्रामेटिक रूप से नेविगेट करने और डेटा को पिछले पृष्ठ पर वापस भेजने के तरीके पर चर्चा करता है, विशेष रूप से रेसिपी विवरण स्क्रीन के संदर्भ में। प्रस्तुतकर्ता एक फ़्लोटिंग एक्शन बटन लागू करता है जो उपयोगकर्ताओं को पिछले पृष्ठ पर वापस नेविगेट करके और रेसिपी की आईडी को पिछले पृष्ठ पर भेजकर अस्थायी रूप से रेसिपी को 'डिलीट' करने की अनुमति देता है। Navigator.pop विधि का उपयोग करके, प्रस्तुतकर्ता प्रदर्शित करता है कि नेविगेशन स्टैक से वर्तमान स्क्रीन को कैसे हटाया जाए। इसके अतिरिक्त, वीडियो में बताया गया है कि pushNamed से Future ऑब्जेक्ट का उपयोग करके डेटा की वापसी को कैसे हैंडल किया जाए और संदर्भ की आवश्यकता वाले आरंभीकरण कार्यों के लिए didChangeDependencies का उपयोग करने के महत्व को समझाया गया है, क्योंकि इस उद्देश्य के लिए initState का उपयोग नहीं किया जा सकता है। प्रस्तुतकर्ता स्टेट अपडेट होने पर अनावश्यक रूप से डेटा को पुनः लोड होने से रोकने के लिए एक फ़्लैग भी पेश करता है। अंततः, ट्यूटोरियल फ़्लटर ऐप में डेटा को वापस भेजने और स्टेट ट्रांज़िशन को प्रभावी ढंग से प्रबंधित करने के तरीके को समझने के महत्व पर जोर देता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador discute como navegar programaticamente de volta numa aplicação Flutter e passar dados de volta para uma página anterior, especificamente no contexto de um ecrã de detalhes de receitas. O apresentador implementa um botão de ação flutuante que permite aos utilizadores ‘apagar’ uma receita temporariamente navegando de volta e passando o ID da receita para a página anterior. Utilizando o método Navigator. pop, o apresentador demonstra como remover o ecrã atual da pilha de navegação. Além disso, o vídeo aborda como lidar com o retorno de dados utilizando o objeto Future de pushNamed e explica a importância de utilizar didChangeDependencies para tarefas de arranque que requerem contexto, uma vez que initState não pode ser utilizado para este fim. O apresentador também introduz um sinalizador para evitar o recarregamento desnecessário de dados quando o estado é atualizado. Por fim, o tutorial enfatiza a importância de compreender como passar dados e gerir transições de estado de forma eficaz numa aplicação Flutter.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক আলোচনা করেছেন যে কীভাবে প্রোগ্রামেটিকভাবে একটি ফ্লটার অ্যাপ্লিকেশনে নেভিগেট করতে হয় এবং পূর্ববর্তী পৃষ্ঠায় ডেটা পাস করতে হয়, বিশেষ করে একটি রেসিপি বিস্তারিত স্ক্রীনের প্রসঙ্গে। উপস্থাপক একটি ফ্লোটিং অ্যাকশন বোতাম প্রয়োগ করে যা ব্যবহারকারীদের একটি রেসিপিকে সাময়িকভাবে 'মুছে ফেলতে' অনুমতি দেয় পিছনে নেভিগেট করে এবং রেসিপির আইডি পূর্ববর্তী পৃষ্ঠায় দিয়ে। Navigator.pop পদ্ধতি ব্যবহার করে, উপস্থাপক প্রদর্শন করে কিভাবে নেভিগেশন স্ট্যাক থেকে বর্তমান স্ক্রীনটি সরাতে হয়। অতিরিক্তভাবে, ভিডিওটি পুশনামড থেকে ফিউচার অবজেক্ট ব্যবহার করে ডেটার রিটার্ন কীভাবে পরিচালনা করতে হয় তা কভার করে এবং প্রাসঙ্গিকতার প্রয়োজনের জন্য didChangeDependencies ব্যবহার করার তাৎপর্য ব্যাখ্যা করে, যেহেতু initState এই উদ্দেশ্যে ব্যবহার করা যাবে না। উপস্থাপক রাষ্ট্র আপডেট করার সময় অপ্রয়োজনীয়ভাবে ডেটা পুনরায় লোড হওয়া প্রতিরোধ করার জন্য একটি পতাকাও প্রবর্তন করে। শেষ পর্যন্ত, টিউটোরিয়ালটি কীভাবে ডেটা ফেরত দিতে হয় এবং একটি ফ্লাটার অ্যাপে কার্যকরভাবে রাষ্ট্রীয় রূপান্তরগুলি পরিচালনা করতে হয় তা বোঝার গুরুত্বের উপর জোর দেয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش مقدم العرض كيفية التنقل برمجيًا للخلف في تطبيق Flutter وتمرير البيانات مرة أخرى إلى صفحة سابقة، وتحديدًا في سياق شاشة تفاصيل الوصفة. ينفذ مقدم العرض زر إجراء عائمًا يسمح للمستخدمين بحذف وصفة مؤقتًا من خلال التنقل للخلف وتمرير معرف الوصفة إلى الصفحة السابقة. باستخدام طريقة Navigator.pop، يوضح مقدم العرض كيفية إزالة الشاشة الحالية من مكدس التنقل. بالإضافة إلى ذلك، يغطي الفيديو كيفية التعامل مع إرجاع البيانات باستخدام كائن Future من pushNamed ويشرح أهمية استخدام didChangeDependencies لمهام التهيئة التي تتطلب السياق، حيث لا يمكن استخدام initState لهذا الغرض. يقدم مقدم العرض أيضًا علمًا لمنع إعادة تحميل البيانات بشكل غير ضروري عند تحديث الحالة. في النهاية، يؤكد البرنامج التعليمي على أهمية فهم كيفية إرجاع البيانات وإدارة انتقالات الحالة بشكل فعال في تطبيق Flutter.",
                                // Persian
                                "فارسی": "در این ویدیو، مجری در مورد چگونگی پیمایش برنامه‌ای در یک برنامه فلاتر و ارسال داده‌ها به صفحه قبلی، به‌ویژه در زمینه صفحه جزئیات دستور غذا بحث می‌کند. ارائه‌دهنده یک دکمه عمل شناور را پیاده‌سازی می‌کند که به کاربران اجازه می‌دهد با بازگشت به عقب و ارسال شناسه دستور غذا به صفحه قبلی، یک دستور را به طور موقت «حذف» کنند. با استفاده از روش Navigator.pop، ارائه دهنده نحوه حذف صفحه فعلی را از پشته ناوبری نشان می دهد. بعلاوه، این ویدئو نحوه رسیدگی به بازگشت داده ها با استفاده از شی Future از pushNamed را پوشش می دهد و اهمیت استفاده از didChangeDependencies را برای کارهای اولیه که نیاز به زمینه دارند، توضیح می دهد، زیرا initState نمی تواند برای این منظور استفاده شود. ارائه دهنده همچنین پرچمی را برای جلوگیری از بارگذاری مجدد داده ها به صورت غیر ضروری هنگام به روز رسانی وضعیت معرفی می کند. در نهایت، این آموزش بر اهمیت درک نحوه بازگرداندن داده ها و مدیریت موثر انتقال حالت در یک برنامه Flutter تأکید می کند.",
                            },
                        },
                        // 160 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Adding Filter Switches",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter focuses on enhancing the FiltersScreen in a Flutter application by implementing filters that affect the displayed meals on other screens. The FiltersScreen is converted into a stateful widget to manage filter states like gluten-free, vegetarian, vegan, and lactose-free, all initialized to false. The presenter sets up a user interface using a combination of containers and switches, utilizing the SwitchListTile widget to allow users to toggle these filters. The filtering functionality is designed so that when a user selects a filter, it will dynamically update the displayed meals based on the selected criteria. The presenter then introduces a helper method to streamline the creation of the switch tiles for each filter, ensuring clean and maintainable code. Finally, the video emphasizes that the changes made in the filter screen will reflect in the meals displayed, setting the stage for further integration.",
                                // German
                                "Deutsch": "In diesem Video konzentriert sich der Moderator auf die Verbesserung des FiltersScreen in einer Flutter-Anwendung durch die Implementierung von Filtern, die sich auf die angezeigten Mahlzeiten auf anderen Bildschirmen auswirken. Der FiltersScreen wird in ein Stateful-Widget umgewandelt, um Filterzustände wie glutenfrei, vegetarisch, vegan und laktosefrei zu verwalten, die alle auf „false“ initialisiert sind. Der Moderator richtet eine Benutzeroberfläche mit einer Kombination aus Containern und Schaltern ein und verwendet das SwitchListTile-Widget, damit Benutzer diese Filter umschalten können. Die Filterfunktion ist so konzipiert, dass, wenn ein Benutzer einen Filter auswählt, die angezeigten Mahlzeiten basierend auf den ausgewählten Kriterien dynamisch aktualisiert werden. Der Moderator stellt dann eine Hilfsmethode vor, um die Erstellung der Switch-Kacheln für jeden Filter zu optimieren und sauberen und wartbaren Code sicherzustellen. Schließlich betont das Video, dass sich die im Filterbildschirm vorgenommenen Änderungen in den angezeigten Mahlzeiten widerspiegeln und so die Grundlage für eine weitere Integration schaffen.",
                                // Chinese
                                "中国人": "在本视频中，演示者重点介绍了如何通过实现影响其他屏幕上显示的餐点的过滤器来增强 Flutter 应用程序中的 FiltersScreen。FiltersScreen 被转换为状态小部件，用于管理无麸质、素食、纯素食和无乳糖等过滤器状态，这些状态均初始化为 false。演示者使用容器和开关的组合设置用户界面，并利用 SwitchListTile 小部件允许用户切换这些过滤器。过滤功能的设计使得当用户选择过滤器时，它将根据所选条件动态更新显示的餐点。然后，演示者介绍了一种辅助方法来简化每个过滤器的开关图块的创建，确保代码干净且易于维护。最后，视频强调，在过滤器屏幕中所做的更改将反映在显示的餐点中，为进一步集成奠定了基础。",
                                // Russian
                                "Русский": "В этом видео ведущий фокусируется на улучшении FiltersScreen в приложении Flutter путем внедрения фильтров, которые влияют на отображаемые блюда на других экранах. FiltersScreen преобразуется в виджет с отслеживанием состояния для управления состояниями фильтров, такими как «без глютена», «вегетарианское», «веганское» и «без лактозы», все из которых инициализируются значением «ложь». Ведущий настраивает пользовательский интерфейс с помощью комбинации контейнеров и переключателей, используя виджет SwitchListTile, чтобы пользователи могли переключать эти фильтры. Функциональность фильтрации разработана таким образом, что когда пользователь выбирает фильтр, он динамически обновляет отображаемые блюда на основе выбранных критериев. Затем ведущий представляет вспомогательный метод для упрощения создания плиток переключателей для каждого фильтра, обеспечивая чистый и поддерживаемый код. Наконец, в видео подчеркивается, что изменения, внесенные в экран фильтра, будут отражаться в отображаемых блюдах, подготавливая почву для дальнейшей интеграции.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur se concentre sur l'amélioration de l'écran FiltersScreen dans une application Flutter en implémentant des filtres qui affectent les repas affichés sur d'autres écrans. L'écran FiltersScreen est converti en un widget avec état pour gérer les états de filtre tels que sans gluten, végétarien, végétalien et sans lactose, tous initialisés sur false. Le présentateur met en place une interface utilisateur à l'aide d'une combinaison de conteneurs et de commutateurs, en utilisant le widget SwitchListTile pour permettre aux utilisateurs de basculer entre ces filtres. La fonctionnalité de filtrage est conçue de telle sorte que lorsqu'un utilisateur sélectionne un filtre, il met à jour dynamiquement les repas affichés en fonction des critères sélectionnés. Le présentateur présente ensuite une méthode d'aide pour rationaliser la création des tuiles de commutation pour chaque filtre, garantissant un code propre et maintenable. Enfin, la vidéo souligne que les modifications apportées à l'écran de filtrage se refléteront dans les repas affichés, ouvrant la voie à une intégration plus poussée.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターは、他の画面に表示される食事に影響を与えるフィルターを実装することで、Flutter アプリケーションの FiltersScreen を強化することに焦点を当てています。FiltersScreen は、グルテンフリー、ベジタリアン、ビーガン、ラクトースフリーなどのフィルター状態を管理するステートフル ウィジェットに変換され、すべて false に初期化されます。プレゼンターは、コンテナーとスイッチの組み合わせを使用してユーザー インターフェイスを設定し、SwitchListTile ウィジェットを使用してユーザーがこれらのフィルターを切り替えられるようにします。フィルタリング機能は、ユーザーがフィルターを選択すると、選択した基準に基づいて表示される食事が動的に更新されるように設計されています。プレゼンターは次に、各フィルターのスイッチ タイルの作成を合理化し、クリーンかつ保守しやすいコードを保証するヘルパー メソッドを紹介します。最後に、ビデオでは、フィルター画面で行われた変更が表示される食事に反映されることを強調し、さらなる統合の準備を整えます。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 다른 화면에 표시되는 식사에 영향을 미치는 필터를 구현하여 Flutter 애플리케이션에서 FiltersScreen을 향상시키는 데 중점을 둡니다. FiltersScreen은 글루텐 없음, 채식주의, 비건, 락토오스 없음과 같은 필터 상태를 관리하는 상태 저장 위젯으로 변환되며, 모두 false로 초기화됩니다. 발표자는 컨테이너와 스위치의 조합을 사용하여 사용자 인터페이스를 설정하고 SwitchListTile 위젯을 사용하여 사용자가 이러한 필터를 토글할 수 있도록 합니다. 필터링 기능은 사용자가 필터를 선택하면 선택한 기준에 따라 표시되는 식사를 동적으로 업데이트하도록 설계되었습니다. 그런 다음 발표자는 각 필터에 대한 스위치 타일 생성을 간소화하여 깔끔하고 유지 관리 가능한 코드를 보장하는 도우미 메서드를 소개합니다. 마지막으로 이 비디오는 필터 화면에서 변경한 내용이 표시되는 식사에 반영되어 추가 통합을 위한 무대를 마련한다는 점을 강조합니다.",
                                // Spanish
                                "Español": "En este video, el presentador se centra en mejorar la pantalla FiltersScreen en una aplicación Flutter mediante la implementación de filtros que afectan las comidas que se muestran en otras pantallas. La pantalla FiltersScreen se convierte en un widget con estado para administrar los estados de los filtros, como sin gluten, vegetariano, vegano y sin lactosa, todos inicializados en falso. El presentador configura una interfaz de usuario utilizando una combinación de contenedores e interruptores, utilizando el widget SwitchListTile para permitir que los usuarios alternen estos filtros. La funcionalidad de filtrado está diseñada para que cuando un usuario seleccione un filtro, se actualicen dinámicamente las comidas que se muestran en función de los criterios seleccionados. Luego, el presentador presenta un método auxiliar para agilizar la creación de los mosaicos de interruptores para cada filtro, lo que garantiza un código limpio y fácil de mantener. Finalmente, el video enfatiza que los cambios realizados en la pantalla de filtro se reflejarán en las comidas que se muestran, lo que prepara el escenario para una mayor integración.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर एप्लिकेशन में फ़िल्टर लागू करके फ़िल्टर स्क्रीन को बेहतर बनाने पर ध्यान केंद्रित करता है जो अन्य स्क्रीन पर प्रदर्शित भोजन को प्रभावित करता है। फ़िल्टर स्क्रीन को ग्लूटेन-मुक्त, शाकाहारी, शाकाहारी और लैक्टोज-मुक्त जैसे फ़िल्टर राज्यों को प्रबंधित करने के लिए एक स्टेटफुल विजेट में परिवर्तित किया जाता है, सभी को गलत तरीके से आरंभ किया जाता है। प्रस्तुतकर्ता कंटेनर और स्विच के संयोजन का उपयोग करके एक उपयोगकर्ता इंटरफ़ेस सेट करता है, जो उपयोगकर्ताओं को इन फ़िल्टर को टॉगल करने की अनुमति देने के लिए स्विचलिस्टटाइल विजेट का उपयोग करता है। फ़िल्टरिंग कार्यक्षमता को इस तरह से डिज़ाइन किया गया है कि जब कोई उपयोगकर्ता फ़िल्टर का चयन करता है, तो यह चयनित मानदंडों के आधार पर प्रदर्शित भोजन को गतिशील रूप से अपडेट करेगा। प्रस्तुतकर्ता तब प्रत्येक फ़िल्टर के लिए स्विच टाइल के निर्माण को सुव्यवस्थित करने के लिए एक सहायक विधि पेश करता है, जो साफ और रखरखाव योग्य कोड सुनिश्चित करता है। अंत में, वीडियो इस बात पर जोर देता है कि फ़िल्टर स्क्रीन में किए गए परिवर्तन प्रदर्शित भोजन में दिखाई देंगे, जो आगे के एकीकरण के लिए मंच तैयार करेगा।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador foca-se em melhorar o FiltersScreen numa aplicação Flutter implementando filtros que afetam as refeições exibidas noutros ecrãs. O FiltersScreen é convertido num widget com estado para gerir estados de filtro como sem glúten, vegetariano, vegan e sem lactose, todos inicializados como falsos. O apresentador configura uma interface de utilizador utilizando uma combinação de contentores e opções, utilizando o widget SwitchListTile para permitir que os utilizadores alternem estes filtros. A funcionalidade de filtragem foi concebida para que, quando um utilizador seleciona um filtro, atualize dinamicamente as refeições apresentadas com base nos critérios selecionados. O apresentador apresenta, de seguida, um método auxiliar para agilizar a criação de blocos de comutação para cada filtro, garantindo um código limpo e de fácil manutenção. Por fim, o vídeo realça que as alterações efetuadas no ecrã do filtro irão refletir-se nas refeições exibidas, preparando o terreno para uma maior integração.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক অন্যান্য স্ক্রিনে প্রদর্শিত খাবারকে প্রভাবিত করে এমন ফিল্টারগুলি প্রয়োগ করে একটি ফ্লাটার অ্যাপ্লিকেশনে ফিল্টারস্ক্রিন উন্নত করার উপর ফোকাস করে৷ ফিল্টারস্ক্রিনকে একটি স্টেটফুল উইজেটে রূপান্তরিত করা হয়েছে ফিল্টার অবস্থা যেমন গ্লুটেন-মুক্ত, নিরামিষাশী, নিরামিষাশী, এবং ল্যাকটোজ-মুক্ত, সবকিছুই মিথ্যাতে শুরু করা হয়েছে। উপস্থাপক কনটেইনার এবং সুইচগুলির সংমিশ্রণ ব্যবহার করে একটি ব্যবহারকারী ইন্টারফেস সেট আপ করে, ব্যবহারকারীদের এই ফিল্টারগুলিকে টগল করার অনুমতি দেওয়ার জন্য SwitchListTile উইজেট ব্যবহার করে৷ ফিল্টারিং কার্যকারিতা ডিজাইন করা হয়েছে যাতে একজন ব্যবহারকারী যখন একটি ফিল্টার নির্বাচন করেন, তখন এটি নির্বাচিত মানদণ্ডের উপর ভিত্তি করে প্রদর্শিত খাবারগুলি গতিশীলভাবে আপডেট করবে। উপস্থাপক তারপর পরিষ্কার এবং রক্ষণাবেক্ষণযোগ্য কোড নিশ্চিত করে, প্রতিটি ফিল্টারের জন্য সুইচ টাইলস তৈরিকে প্রবাহিত করার জন্য একটি সহায়ক পদ্ধতি প্রবর্তন করে। অবশেষে, ভিডিওতে জোর দেওয়া হয়েছে যে ফিল্টার স্ক্রিনে করা পরিবর্তনগুলি প্রদর্শিত খাবারে প্রতিফলিত হবে, আরও একীকরণের জন্য মঞ্চ নির্ধারণ করবে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يركز مقدم العرض على تحسين شاشة FiltersScreen في تطبيق Flutter من خلال تنفيذ مرشحات تؤثر على الوجبات المعروضة على شاشات أخرى. يتم تحويل شاشة FiltersScreen إلى عنصر واجهة مستخدم لإدارة حالات المرشح مثل خالٍ من الجلوتين ونباتي وخالي من اللاكتوز، وكلها مهيأة على القيمة false. يقوم مقدم العرض بإعداد واجهة مستخدم باستخدام مجموعة من الحاويات والمفاتيح، باستخدام عنصر واجهة المستخدم SwitchListTile للسماح للمستخدمين بتبديل هذه المرشحات. تم تصميم وظيفة التصفية بحيث عندما يختار المستخدم مرشحًا، سيتم تحديث الوجبات المعروضة ديناميكيًا بناءً على المعايير المحددة. ثم يقدم مقدم العرض طريقة مساعدة لتبسيط إنشاء مربعات التبديل لكل مرشح، مما يضمن كودًا نظيفًا وقابلًا للصيانة. أخيرًا، يؤكد الفيديو على أن التغييرات التي تم إجراؤها في شاشة المرشح ستنعكس في الوجبات المعروضة، مما يمهد الطريق لمزيد من التكامل.",
                                // Persian
                                "فارسی": "در این ویدئو، ارائه دهنده بر روی افزایش FiltersScreen در یک برنامه Flutter با پیاده سازی فیلترهایی تمرکز می کند که بر روی غذاهای نمایش داده شده در سایر صفحه ها تأثیر می گذارد. FiltersScreen به یک ویجت حالت دار برای مدیریت حالت های فیلتر مانند بدون گلوتن، گیاهخواری، گیاهخواری و بدون لاکتوز تبدیل می شود که همگی به غلط اولیه می شوند. ارائه‌دهنده با استفاده از ترکیبی از کانتینرها و سوئیچ‌ها، با استفاده از ویجت SwitchListTile، یک رابط کاربری تنظیم می‌کند تا به کاربران اجازه دهد این فیلترها را تغییر دهند. عملکرد فیلتر به گونه ای طراحی شده است که وقتی کاربر فیلتری را انتخاب می کند، به صورت پویا غذاهای نمایش داده شده را بر اساس معیارهای انتخاب شده به روز می کند. سپس ارائه‌دهنده یک روش کمکی را برای ساده‌سازی ایجاد تایل‌های سوئیچ برای هر فیلتر معرفی می‌کند و از کد تمیز و قابل نگهداری اطمینان می‌دهد. در نهایت، ویدئو تاکید می کند که تغییرات ایجاد شده در صفحه فیلتر در وعده های غذایی نمایش داده شده منعکس می شود و زمینه را برای یکپارچگی بیشتر فراهم می کند.",
                            },
                        },
                        // 161 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Adding Filtering Logic",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter discusses the implementation of a filtering system in a Flutter application, focusing on how to manage filters globally within the main.dart file. The approach involves converting the main widget into a stateful widget to maintain a map of filter settings, initialized with default values. The presenter creates a method to update these filters when a user clicks a save button on the FiltersScreen, ensuring that the updates occur only upon user confirmation rather than immediately. The filters are then passed to the CategoryMealsScreen to dynamically change the displayed meals based on the selected criteria. The presenter demonstrates how to use logical conditions to filter meals based on gluten-free, lactose-free, vegetarian, and vegan preferences, updating the meal list accordingly. Finally, the implementation allows the filter settings to persist when returning to the FiltersScreen, ensuring a seamless user experience.",
                                // German
                                "Deutsch": "In diesem Video erläutert der Moderator die Implementierung eines Filtersystems in einer Flutter-Anwendung und konzentriert sich dabei auf die globale Verwaltung von Filtern in der Datei main.dart. Der Ansatz umfasst die Konvertierung des Haupt-Widgets in ein Stateful-Widget, um eine Karte der Filtereinstellungen beizubehalten, die mit Standardwerten initialisiert ist. Der Moderator erstellt eine Methode zum Aktualisieren dieser Filter, wenn ein Benutzer auf dem FiltersScreen auf eine Schaltfläche zum Speichern klickt, und stellt so sicher, dass die Aktualisierungen nur nach Bestätigung durch den Benutzer und nicht sofort erfolgen. Die Filter werden dann an den CategoryMealsScreen übergeben, um die angezeigten Mahlzeiten basierend auf den ausgewählten Kriterien dynamisch zu ändern. Der Moderator demonstriert, wie man logische Bedingungen verwendet, um Mahlzeiten basierend auf glutenfreien, laktosefreien, vegetarischen und veganen Vorlieben zu filtern und die Mahlzeitenliste entsprechend zu aktualisieren. Schließlich ermöglicht die Implementierung, dass die Filtereinstellungen beim Zurückkehren zum FiltersScreen erhalten bleiben, was ein nahtloses Benutzererlebnis gewährleistet.",
                                // Chinese
                                "中国人": "在本视频中，演示者讨论了 Flutter 应用程序中过滤系统的实现，重点介绍了如何在 main.dart 文件中全局管理过滤器。该方法涉及将主窗口小部件转换为有状态窗口小部件，以维护使用默认值初始化的过滤器设置映射。演示者创建了一个方法，当用户单击 FiltersScreen 上的保存按钮时更新这些过滤器，确保更新仅在用户确认后发生，而不是立即发生。然后将过滤器传递给 CategoryMealsScreen，以根据所选标准动态更改显示的餐点。演示者演示了如何使用逻辑条件根据无麸质、无乳糖、素食和纯素食偏好过滤餐点，并相应地更新餐点列表。最后，该实现允许过滤器设置在返回 FiltersScreen 时保持不变，从而确保无缝的用户体验。",
                                // Russian
                                "Русский": "В этом видео докладчик обсуждает реализацию системы фильтрации в приложении Flutter, уделяя особое внимание тому, как управлять фильтрами глобально в файле main.dart. Подход включает преобразование основного виджета в виджет с отслеживанием состояния для поддержания карты настроек фильтров, инициализированных значениями по умолчанию. Докладчик создает метод для обновления этих фильтров, когда пользователь нажимает кнопку сохранения на FiltersScreen, гарантируя, что обновления происходят только после подтверждения пользователя, а не немедленно. Затем фильтры передаются на CategoryMealsScreen для динамического изменения отображаемых блюд на основе выбранных критериев. Докладчик демонстрирует, как использовать логические условия для фильтрации блюд на основе безглютеновых, безлактозных, вегетарианских и веганских предпочтений, обновляя список блюд соответствующим образом. Наконец, реализация позволяет сохранять настройки фильтра при возврате на FiltersScreen, обеспечивая бесперебойный пользовательский интерфейс.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur explique comment mettre en œuvre un système de filtrage dans une application Flutter, en se concentrant sur la gestion globale des filtres dans le fichier main.dart. L'approche consiste à convertir le widget principal en un widget avec état pour conserver une carte des paramètres de filtre, initialisée avec des valeurs par défaut. Le présentateur crée une méthode pour mettre à jour ces filtres lorsqu'un utilisateur clique sur un bouton d'enregistrement sur l'écran FiltersScreen, garantissant que les mises à jour ne se produisent qu'après confirmation de l'utilisateur plutôt qu'immédiatement. Les filtres sont ensuite transmis à l'écran CategoryMealsScreen pour modifier dynamiquement les repas affichés en fonction des critères sélectionnés. Le présentateur montre comment utiliser des conditions logiques pour filtrer les repas en fonction des préférences sans gluten, sans lactose, végétariennes et végétaliennes, en mettant à jour la liste des repas en conséquence. Enfin, l'implémentation permet aux paramètres de filtre de persister lors du retour à l'écran FiltersScreen, garantissant une expérience utilisateur transparente.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが Flutter アプリケーションでのフィルタリング システムの実装について説明し、main.dart ファイル内でフィルタをグローバルに管理する方法に焦点を当てています。このアプローチでは、メイン ウィジェットをステートフル ウィジェットに変換して、デフォルト値で初期化されたフィルタ設定のマップを維持します。プレゼンターは、ユーザーが FiltersScreen の保存ボタンをクリックしたときにこれらのフィルタを更新するメソッドを作成し、更新がすぐに行われるのではなく、ユーザーの確認があった場合にのみ行われるようにします。次に、フィルタは CategoryMealsScreen に渡され、選択された基準に基づいて表示される食事が動的に変更されます。プレゼンターは、論理条件を使用してグルテンフリー、ラクトースフリー、ベジタリアン、ビーガンの好みに基づいて食事をフィルタリングし、それに応じて食事リストを更新する方法を示します。最後に、実装により、FiltersScreen に戻ったときにフィルタ設定が保持され、シームレスなユーザー エクスペリエンスが保証されます。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 애플리케이션에서 필터링 시스템을 구현하는 방법을 설명하며, main.dart 파일 내에서 필터를 전역적으로 관리하는 방법에 초점을 맞춥니다. 이 접근 방식은 기본 위젯을 상태 저장 위젯으로 변환하여 기본값으로 초기화된 필터 설정 맵을 유지하는 것을 포함합니다. 발표자는 사용자가 FiltersScreen에서 저장 버튼을 클릭할 때 이러한 필터를 업데이트하는 메서드를 만들어 업데이트가 즉시가 아니라 사용자 확인 시에만 수행되도록 합니다. 그런 다음 필터가 CategoryMealsScreen에 전달되어 선택한 기준에 따라 표시되는 식사를 동적으로 변경합니다. 발표자는 논리적 조건을 사용하여 글루텐 무함유, 락토오스 무함유, 채식주의, 비건 선호도에 따라 식사를 필터링하고 그에 따라 식사 목록을 업데이트하는 방법을 보여줍니다. 마지막으로 이 구현을 통해 FiltersScreen으로 돌아갈 때 필터 설정이 유지되어 원활한 사용자 경험이 보장됩니다.",
                                // Spanish
                                "Español": "En este video, el presentador analiza la implementación de un sistema de filtrado en una aplicación Flutter, centrándose en cómo administrar filtros de forma global dentro del archivo main.dart. El enfoque implica convertir el widget principal en un widget con estado para mantener un mapa de configuraciones de filtros, inicializado con valores predeterminados. El presentador crea un método para actualizar estos filtros cuando un usuario hace clic en un botón de guardar en FiltersScreen, lo que garantiza que las actualizaciones se produzcan solo tras la confirmación del usuario en lugar de inmediatamente. Luego, los filtros se pasan a CategoryMealsScreen para cambiar dinámicamente las comidas mostradas en función de los criterios seleccionados. El presentador demuestra cómo usar condiciones lógicas para filtrar comidas en función de las preferencias sin gluten, sin lactosa, vegetarianas y veganas, actualizando la lista de comidas en consecuencia. Finalmente, la implementación permite que las configuraciones de filtros persistan al regresar a FiltersScreen, lo que garantiza una experiencia de usuario perfecta.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर एप्लिकेशन में फ़िल्टरिंग सिस्टम के कार्यान्वयन पर चर्चा करता है, जो main.dart फ़ाइल के भीतर वैश्विक रूप से फ़िल्टर प्रबंधित करने के तरीके पर ध्यान केंद्रित करता है। इस दृष्टिकोण में मुख्य विजेट को स्टेटफुल विजेट में परिवर्तित करना शामिल है, ताकि डिफ़ॉल्ट मानों के साथ आरंभ किए गए फ़िल्टर सेटिंग्स का मानचित्र बनाए रखा जा सके। प्रस्तुतकर्ता इन फ़िल्टर को अपडेट करने के लिए एक विधि बनाता है जब कोई उपयोगकर्ता FiltersScreen पर सेव बटन पर क्लिक करता है, यह सुनिश्चित करता है कि अपडेट तुरंत होने के बजाय केवल उपयोगकर्ता की पुष्टि पर होते हैं। फिर फ़िल्टर को CategoryMealsScreen में भेजा जाता है ताकि चयनित मानदंडों के आधार पर प्रदर्शित भोजन को गतिशील रूप से बदला जा सके। प्रस्तुतकर्ता प्रदर्शित करता है कि ग्लूटेन-मुक्त, लैक्टोज-मुक्त, शाकाहारी और शाकाहारी वरीयताओं के आधार पर भोजन को फ़िल्टर करने के लिए तार्किक स्थितियों का उपयोग कैसे करें, तदनुसार भोजन सूची को अपडेट करें। अंत में, कार्यान्वयन FiltersScreen पर लौटने पर फ़िल्टर सेटिंग्स को बनाए रखने की अनुमति देता है, जिससे एक सहज उपयोगकर्ता अनुभव सुनिश्चित होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador aborda a implementação de um sistema de filtragem numa aplicação Flutter, com foco na forma de gerir filtros globalmente dentro do ficheiro main.dart. A abordagem envolve a conversão do widget principal num widget com estado para manter um mapa de definições de filtro, inicializado com valores padrão. O apresentador cria um método para atualizar estes filtros quando um utilizador clica num botão de guardar no Ecrã de Filtros, garantindo que as atualizações ocorrem apenas após a confirmação do utilizador e não imediatamente. Os filtros são então passados ​​para o CategoryMealsScreen para alterar dinamicamente as refeições apresentadas com base nos critérios selecionados. O apresentador demonstra como utilizar condições lógicas para filtrar as refeições com base nas preferências sem glúten, sem lactose, vegetarianas e veganas, atualizando a lista de refeições em conformidade. Por fim, a implementação permite que as definições de filtro persistam ao regressar ao FiltersScreen, garantindo uma experiência de utilizador perfeita.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক একটি ফ্লটার অ্যাপ্লিকেশনে একটি ফিল্টারিং সিস্টেমের বাস্তবায়ন নিয়ে আলোচনা করেছেন, কিভাবে main.dart ফাইলের মধ্যে বিশ্বব্যাপী ফিল্টারগুলি পরিচালনা করা যায় তার উপর ফোকাস করে৷ পদ্ধতির মধ্যে প্রধান উইজেটটিকে একটি স্টেটফুল উইজেটে রূপান্তরিত করা জড়িত থাকে যাতে ফিল্টার সেটিংসের একটি মানচিত্র বজায় থাকে, যা ডিফল্ট মানগুলির সাথে শুরু হয়। উপস্থাপক এই ফিল্টারগুলিকে আপডেট করার একটি পদ্ধতি তৈরি করে যখন একজন ব্যবহারকারী ফিল্টারস্ক্রিনে একটি সংরক্ষণ বোতামে ক্লিক করেন, এটি নিশ্চিত করে যে আপডেটগুলি অবিলম্বে না হয়ে শুধুমাত্র ব্যবহারকারীর নিশ্চিতকরণের মাধ্যমে ঘটে। ফিল্টারগুলি তারপরে নির্বাচিত মানদণ্ডের উপর ভিত্তি করে প্রদর্শিত খাবারগুলিকে গতিশীলভাবে পরিবর্তন করতে CategoryMealsScreen-এ পাঠানো হয়। উপস্থাপক দেখান কিভাবে আঠালো-মুক্ত, ল্যাকটোজ-মুক্ত, নিরামিষ, এবং নিরামিষ পছন্দের উপর ভিত্তি করে খাবার ফিল্টার করতে যৌক্তিক অবস্থার ব্যবহার করতে হয়, সেই অনুযায়ী খাবারের তালিকা আপডেট করে। অবশেষে, বাস্তবায়ন ফিল্টারস্ক্রিনে ফিরে আসার সময় ফিল্টার সেটিংসকে টিকে থাকার অনুমতি দেয়, একটি নির্বিঘ্ন ব্যবহারকারীর অভিজ্ঞতা নিশ্চিত করে।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يناقش مقدم العرض تنفيذ نظام تصفية في تطبيق Flutter، مع التركيز على كيفية إدارة المرشحات عالميًا داخل ملف main.dart. يتضمن النهج تحويل الأداة الرئيسية إلى أداة بحالة للحفاظ على خريطة لإعدادات المرشح، مع تهيئتها بقيم افتراضية. ينشئ مقدم العرض طريقة لتحديث هذه المرشحات عندما ينقر المستخدم على زر الحفظ على شاشة المرشحات، مما يضمن حدوث التحديثات فقط عند تأكيد المستخدم وليس على الفور. ثم يتم تمرير المرشحات إلى شاشة CategoryMeals لتغيير الوجبات المعروضة ديناميكيًا بناءً على المعايير المحددة. يوضح مقدم العرض كيفية استخدام الشروط المنطقية لتصفية الوجبات بناءً على تفضيلات خالية من الغلوتين وخالية من اللاكتوز والنباتية والنباتية الصرفة، وتحديث قائمة الوجبات وفقًا لذلك. أخيرًا، يسمح التنفيذ بإعدادات المرشح بالاستمرار عند العودة إلى شاشة المرشحات، مما يضمن تجربة مستخدم سلسة.",
                                // Persian
                                "فارسی": "در این ویدیو، مجری در مورد پیاده سازی یک سیستم فیلترینگ در یک برنامه فلاتر با تمرکز بر نحوه مدیریت فیلترها به صورت سراسری در فایل main.dart بحث می کند. این رویکرد شامل تبدیل ویجت اصلی به ویجت حالت دار برای حفظ نقشه تنظیمات فیلتر است که با مقادیر پیش فرض مقداردهی اولیه شده است. هنگامی که کاربر روی دکمه ذخیره در FiltersScreen کلیک می کند، ارائه دهنده روشی برای به روز رسانی این فیلترها ایجاد می کند و اطمینان حاصل می کند که به روز رسانی ها فقط پس از تأیید کاربر و نه بلافاصله انجام می شود. سپس فیلترها به CategoryMealsScreen منتقل می شوند تا به صورت پویا غذاهای نمایش داده شده را بر اساس معیارهای انتخاب شده تغییر دهند. مجری نحوه استفاده از شرایط منطقی برای فیلتر کردن وعده‌های غذایی بر اساس ترجیحات بدون گلوتن، لاکتوز، گیاه‌خواری و وگان را نشان می‌دهد و فهرست وعده‌های غذایی را بر این اساس به‌روزرسانی می‌کند. در نهایت، پیاده‌سازی به تنظیمات فیلتر اجازه می‌دهد هنگام بازگشت به FiltersScreen باقی بمانند و تجربه کاربری یکپارچه را تضمین کنند.",
                            },
                        },
                        // 162 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Adding a _Mark as Favorite_ Feature",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter focuses on implementing a favorites feature in a Flutter application. The initial step involves enhancing the FavoritesScreen to display meaningful text when no favorites are saved and to allow users to view their favorite meals. Instead of adding a isFavorite field to the meal model, which could lead to data inconsistency across users, the presenter opts to manage a separate list of favorite meals in main.dart. This list is then passed through the TabsScreen to the FavoritesScreen. The presenter creates a toggleFavorite function in MyAppState to add or remove meals from the favorites list based on user interaction. The video demonstrates how to check if a meal is already a favorite and update the UI accordingly, using a floating action button in the MealDetailScreen to toggle favorites. Additionally, the presenter tackles minor errors and ensures that the favorites reflect the user's selections effectively, providing a functional favorites feature in the app.",
                                // German
                                "Deutsch": "In diesem Video konzentriert sich der Moderator auf die Implementierung einer Favoritenfunktion in einer Flutter-Anwendung. Der erste Schritt besteht darin, den Favoritenbildschirm zu verbessern, um aussagekräftigen Text anzuzeigen, wenn keine Favoriten gespeichert sind, und Benutzern die Anzeige ihrer Lieblingsgerichte zu ermöglichen. Anstatt dem Mahlzeitenmodell ein Feld „isFavorite“ hinzuzufügen, was zu Dateninkonsistenzen zwischen Benutzern führen könnte, entscheidet sich der Moderator dafür, eine separate Liste der Lieblingsgerichte in main.dart zu verwalten. Diese Liste wird dann über den TabsScreen an den Favoritenbildschirm übergeben. Der Moderator erstellt eine Funktion „toggleFavorite“ in MyAppState, um Mahlzeiten basierend auf der Benutzerinteraktion zur Favoritenliste hinzuzufügen oder daraus zu entfernen. Das Video zeigt, wie man überprüft, ob eine Mahlzeit bereits ein Favorit ist, und die Benutzeroberfläche entsprechend aktualisiert, indem man eine schwebende Aktionsschaltfläche im MealDetailScreen verwendet, um Favoriten umzuschalten. Darüber hinaus behebt der Moderator kleinere Fehler und stellt sicher, dass die Favoriten die Auswahl des Benutzers effektiv widerspiegeln, wodurch eine funktionale Favoritenfunktion in der App bereitgestellt wird.",
                                // Chinese
                                "中国人": "在本视频中，演示者重点介绍了如何在 Flutter 应用中实现收藏夹功能。第一步是增强 FavoritesScreen，以便在未保存任何收藏夹时显示有意义的文本，并允许用户查看他们最喜欢的餐点。演示者没有向餐点模型添加 isFavorite 字段（这可能会导致用户之间的数据不一致），而是选择在 main.dart 中管理单独的收藏夹餐点列表。然后，此列表通过 TabsScreen 传递到 FavoritesScreen。演示者在 MyAppState 中创建 toggleFavorite 函数，以根据用户交互在收藏夹列表中添加或删除餐点。该视频演示了如何检查餐点是否已是收藏夹并相应地更新 UI，使用 MealDetailScreen 中的浮动操作按钮切换收藏夹。此外，演示者还解决了小错误并确保收藏夹有效反映用户的选择，从而在应用中提供实用的收藏夹功能。",
                                // Russian
                                "Русский": "В этом видео ведущий фокусируется на реализации функции избранного в приложении Flutter. Первоначальный шаг включает в себя улучшение FavoritesScreen для отображения осмысленного текста, когда нет сохраненных избранных блюд, и для предоставления пользователям возможности просматривать свои любимые блюда. Вместо добавления поля isFavorite в модель приема пищи, что может привести к несогласованности данных между пользователями, ведущий решает управлять отдельным списком любимых блюд в main.dart. Затем этот список передается через TabsScreen в FavoritesScreen. Ведущий создает функцию toggleFavorite в MyAppState для добавления или удаления блюд из списка избранного на основе взаимодействия с пользователем. Видео демонстрирует, как проверить, является ли блюдо уже избранным, и соответствующим образом обновить пользовательский интерфейс, используя плавающую кнопку действия на MealDetailScreen для переключения избранного. Кроме того, ведущий устраняет мелкие ошибки и обеспечивает эффективное отражение избранного в избранном, предоставляя функциональную функцию избранного в приложении.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur se concentre sur la mise en œuvre d'une fonctionnalité de favoris dans une application Flutter. La première étape consiste à améliorer l'écran FavoritesScreen pour afficher un texte significatif lorsqu'aucun favori n'est enregistré et pour permettre aux utilisateurs de visualiser leurs plats préférés. Au lieu d'ajouter un champ isFavorite au modèle de repas, ce qui pourrait entraîner une incohérence des données entre les utilisateurs, le présentateur choisit de gérer une liste distincte de plats favoris dans main.dart. Cette liste est ensuite transmise via l'écran TabsScreen à l'écran FavoritesScreen. Le présentateur crée une fonction toggleFavorite dans MyAppState pour ajouter ou supprimer des repas de la liste des favoris en fonction de l'interaction de l'utilisateur. La vidéo montre comment vérifier si un repas est déjà un favori et mettre à jour l'interface utilisateur en conséquence, à l'aide d'un bouton d'action flottant dans l'écran MealDetailScreen pour basculer entre les favoris. De plus, le présentateur s'attaque aux erreurs mineures et s'assure que les favoris reflètent efficacement les sélections de l'utilisateur, offrant ainsi une fonction de favoris fonctionnelle dans l'application.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターは Flutter アプリケーションにお気に入り機能を実装することに焦点を当てています。最初のステップでは、お気に入りが保存されていない場合に意味のあるテキストを表示し、ユーザーがお気に入りの食事を表示できるように FavoritesScreen を強化します。食事モデルに isFavorite フィールドを追加するとユーザー間でデータの不一致が生じる可能性があるため、プレゼンターは main.dart で別のお気に入りの食事リストを管理することを選択しました。次に、このリストは TabsScreen を介して FavoritesScreen に渡されます。プレゼンターは、ユーザーの操作に基づいてお気に入りリストから食事を追加または削除するための、MyAppState に toogleFavorite 関数を作成します。ビデオでは、食事がすでにお気に入りになっているかどうかを確認し、それに応じて UI を更新して、MealDetailScreen のフローティング アクション ボタンを使用してお気に入りを切り替える方法を示します。さらに、プレゼンターは小さなエラーに対処し、お気に入りがユーザーの選択を効果的に反映するようにして、アプリで機能的なお気に入り機能を提供します。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 Flutter 애플리케이션에서 즐겨찾기 기능을 구현하는 데 중점을 둡니다. 첫 번째 단계는 즐겨찾기가 저장되지 않은 경우 의미 있는 텍스트를 표시하고 사용자가 좋아하는 식사를 볼 수 있도록 FavoritesScreen을 개선하는 것입니다. 사용자 간에 데이터 불일치로 이어질 수 있는 isFavorite 필드를 식사 모델에 추가하는 대신 발표자는 main.dart에서 별도의 좋아하는 식사 목록을 관리하기로 선택합니다. 그런 다음 이 목록은 TabsScreen을 통해 FavoritesScreen으로 전달됩니다. 발표자는 MyAppState에서 사용자 상호 작용에 따라 즐겨찾기 목록에서 식사를 추가하거나 제거하는 토글Favorite 함수를 만듭니다. 이 비디오는 MealDetailScreen에서 플로팅 작업 버튼을 사용하여 식사가 이미 즐겨찾기인지 확인하고 그에 따라 UI를 업데이트하는 방법을 보여줍니다. 또한 발표자는 사소한 오류를 해결하고 즐겨찾기가 사용자의 선택을 효과적으로 반영하도록 하여 앱에서 기능적인 즐겨찾기 기능을 제공합니다.",
                                // Spanish
                                "Español": "En este video, el presentador se centra en la implementación de una función de favoritos en una aplicación Flutter. El paso inicial implica mejorar la FavoritesScreen para mostrar texto significativo cuando no se guardan favoritos y permitir que los usuarios vean sus comidas favoritas. En lugar de agregar un campo isFavorite al modelo de comida, lo que podría generar inconsistencias en los datos entre los usuarios, el presentador opta por administrar una lista separada de comidas favoritas en main.dart. Luego, esta lista se pasa a través de TabsScreen a FavoritesScreen. El presentador crea una función toggleFavorite en MyAppState para agregar o eliminar comidas de la lista de favoritos según la interacción del usuario. El video demuestra cómo verificar si una comida ya es favorita y actualizar la interfaz de usuario en consecuencia, utilizando un botón de acción flotante en MealDetailScreen para alternar los favoritos. Además, el presentador aborda errores menores y se asegura de que los favoritos reflejen las selecciones del usuario de manera efectiva, lo que proporciona una función de favoritos funcional en la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर एप्लिकेशन में पसंदीदा सुविधा को लागू करने पर ध्यान केंद्रित करता है। प्रारंभिक चरण में पसंदीदा स्क्रीन को बेहतर बनाना शामिल है, ताकि जब कोई पसंदीदा सहेजा न जाए तो सार्थक टेक्स्ट प्रदर्शित हो और उपयोगकर्ता अपने पसंदीदा भोजन देख सकें। भोजन मॉडल में isFavorite फ़ील्ड जोड़ने के बजाय, जो उपयोगकर्ताओं के बीच डेटा असंगतता का कारण बन सकता है, प्रस्तुतकर्ता main.dart में पसंदीदा भोजन की एक अलग सूची प्रबंधित करने का विकल्प चुनता है। फिर इस सूची को TabsScreen के माध्यम से FavoritesScreen में भेजा जाता है। प्रस्तुतकर्ता उपयोगकर्ता इंटरैक्शन के आधार पर पसंदीदा सूची से भोजन जोड़ने या हटाने के लिए MyAppState में एक toggleFavorite फ़ंक्शन बनाता है। वीडियो यह प्रदर्शित करता है कि कैसे जाँच करें कि कोई भोजन पहले से ही पसंदीदा है और पसंदीदा को टॉगल करने के लिए MealDetailScreen में फ़्लोटिंग एक्शन बटन का उपयोग करके UI को तदनुसार अपडेट करें। इसके अतिरिक्त, प्रस्तुतकर्ता छोटी-मोटी त्रुटियों से निपटता है और सुनिश्चित करता है कि पसंदीदा उपयोगकर्ता के चयन को प्रभावी ढंग से दर्शाता है, जिससे ऐप में एक कार्यात्मक पसंदीदा सुविधा प्रदान होती है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador foca-se na implementação de uma funcionalidade de favoritos numa aplicação Flutter. A etapa inicial envolve melhorar o Ecrã de Favoritos para exibir um texto significativo quando nenhum favorito é guardado e para permitir que os utilizadores visualizem as suas refeições favoritas. Em vez de adicionar um campo isFavorite ao modelo de refeição, o que poderia levar à inconsistência de dados entre utilizadores, o apresentador opta por gerir uma lista separada de refeições favoritas em main.dart. Essa lista é depois passada da TabsScreen para a FavoritesScreen. O apresentador cria uma função toggleFavorite em MyAppState para adicionar ou remover refeições da lista de favoritos com base na interação do utilizador. O vídeo demonstra como verificar se uma refeição já é favorita e atualizar a IU em conformidade, utilizando um botão de ação flutuante no MealDetailScreen para alternar os favoritos. Além disso, o apresentador corrige pequenos erros e garante que os favoritos refletem as seleções do utilizador de forma eficaz, fornecendo uma funcionalidade funcional de favoritos na aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক একটি Flutter অ্যাপ্লিকেশনে একটি পছন্দসই বৈশিষ্ট্য বাস্তবায়নের উপর ফোকাস করেছেন৷ প্রারম্ভিক ধাপে অর্থপূর্ণ পাঠ্য প্রদর্শনের জন্য প্রিয় স্ক্রীন বাড়ানো জড়িত যখন কোনো পছন্দসই সংরক্ষণ করা হয় না এবং ব্যবহারকারীদের তাদের পছন্দের খাবার দেখতে দেয়। খাবারের মডেলে একটি isFavorite ক্ষেত্র যোগ করার পরিবর্তে, যা ব্যবহারকারীদের মধ্যে ডেটা অসঙ্গতি সৃষ্টি করতে পারে, উপস্থাপক main.dart-এ পছন্দের খাবারের একটি পৃথক তালিকা পরিচালনা করতে বেছে নেয়। এই তালিকাটি তারপর TabsScreen এর মাধ্যমে FavoritesScreen এ পাঠানো হয়। উপস্থাপক ব্যবহারকারীর ইন্টারঅ্যাকশনের উপর ভিত্তি করে পছন্দের তালিকা থেকে খাবার যোগ করতে বা অপসারণ করতে MyAppState-এ একটি টগল ফেভারিট ফাংশন তৈরি করে। ভিডিওটি দেখায় যে কীভাবে একটি খাবার ইতিমধ্যেই পছন্দের কিনা তা পরীক্ষা করতে হবে এবং সেই অনুযায়ী UI আপডেট করতে হবে, পছন্দগুলি টগল করতে MealDetailScreen-এ একটি ফ্লোটিং অ্যাকশন বোতাম ব্যবহার করে৷ উপরন্তু, উপস্থাপক ছোটখাটো ত্রুটিগুলি মোকাবেলা করে এবং নিশ্চিত করে যে পছন্দগুলি ব্যবহারকারীর নির্বাচনগুলিকে কার্যকরভাবে প্রতিফলিত করে, অ্যাপটিতে একটি কার্যকরী পছন্দের বৈশিষ্ট্য প্রদান করে৷",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يركز مقدم العرض على تنفيذ ميزة المفضلة في تطبيق Flutter. تتضمن الخطوة الأولية تحسين شاشة المفضلة لعرض نص ذي معنى عندما لا يتم حفظ أي مفضلات والسماح للمستخدمين بعرض وجباتهم المفضلة. بدلاً من إضافة حقل isFavorite إلى نموذج الوجبة، والذي قد يؤدي إلى عدم تناسق البيانات بين المستخدمين، يختار مقدم العرض إدارة قائمة منفصلة من الوجبات المفضلة في main.dart. ثم يتم تمرير هذه القائمة عبر TabsScreen إلى شاشة المفضلة. ينشئ مقدم العرض وظيفة تبديل المفضلة في MyAppState لإضافة أو إزالة الوجبات من قائمة المفضلة بناءً على تفاعل المستخدم. يوضح الفيديو كيفية التحقق مما إذا كانت الوجبة مفضلة بالفعل وتحديث واجهة المستخدم وفقًا لذلك، باستخدام زر إجراء عائم في MealDetailScreen لتبديل المفضلات. بالإضافة إلى ذلك، يعالج مقدم العرض الأخطاء البسيطة ويضمن أن تعكس المفضلات اختيارات المستخدم بشكل فعال، مما يوفر ميزة مفضلات وظيفية في التطبيق.",
                                // Persian
                                "فارسی": "در این ویدئو، مجری بر روی پیاده‌سازی ویژگی علاقه مندی‌ها در یک اپلیکیشن فلاتر تمرکز می‌کند. مرحله اولیه شامل افزایش FavoritesScreen برای نمایش متن معنی دار در زمانی که هیچ مورد دلخواه ذخیره نمی شود و به کاربران اجازه می دهد تا غذاهای مورد علاقه خود را مشاهده کنند. به جای افزودن یک قسمت isFavorite به مدل غذا، که می‌تواند منجر به تناقض داده‌ها در بین کاربران شود، ارائه‌دهنده تصمیم می‌گیرد فهرست جداگانه‌ای از وعده‌های غذایی مورد علاقه را در main.dart مدیریت کند. این لیست سپس از طریق TabsScreen به FavoritesScreen منتقل می شود. ارائه دهنده یک تابع toggleFavorite در MyAppState ایجاد می کند تا براساس تعامل کاربر، غذاها را از لیست علاقه مندی ها اضافه یا حذف کند. این ویدئو نشان می‌دهد که چگونه می‌توان بررسی کرد که آیا یک وعده غذایی از قبل مورد علاقه است یا نه و رابط کاربری را متناسب با آن به‌روزرسانی کنید، با استفاده از یک دکمه عمل شناور در MealDetailScreen برای تغییر موارد دلخواه. به‌علاوه، ارائه‌دهنده خطاهای جزئی را برطرف می‌کند و اطمینان می‌دهد که موارد دلخواه انتخاب‌های کاربر را به طور مؤثر منعکس می‌کنند، و یک ویژگی کاربردی مورد علاقه در برنامه ارائه می‌دهد.",
                            },
                        },
                        // 163 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "A Problem!",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this video, the presenter addresses an issue with outdated data appearing on the FavoritesScreen in a Flutter application when a user unchecks an item as a favorite on the detail page. The root cause is that navigating back to the favorites page often displays a cached version rather than updating based on the latest state. The presenter acknowledges that while there are temporary fixes, such as converting the FavoritesScreen into a stateful widget and forcing an update through state management methods, these are not ideal solutions. Instead, the presenter emphasizes the importance of learning more advanced state management techniques that will provide a cleaner and more efficient way to manage global data and avoid such issues in the future. The section concludes by summarizing the skills learned regarding navigation and data handling within the app.",
                                // German
                                "Deutsch": "In diesem Video spricht der Moderator ein Problem mit veralteten Daten an, die auf dem Favoritenbildschirm einer Flutter-Anwendung erscheinen, wenn ein Benutzer ein Element auf der Detailseite als Favorit abwählt. Die Grundursache ist, dass beim Zurücknavigieren zur Favoritenseite häufig eine zwischengespeicherte Version angezeigt wird, anstatt basierend auf dem neuesten Status aktualisiert zu werden. Der Moderator räumt ein, dass es zwar vorübergehende Lösungen gibt, wie z. B. die Konvertierung des Favoritenbildschirms in ein statusbehaftetes Widget und das Erzwingen einer Aktualisierung durch Statusverwaltungsmethoden, dies jedoch keine idealen Lösungen sind. Stattdessen betont der Moderator, wie wichtig es ist, fortgeschrittenere Statusverwaltungstechniken zu erlernen, die eine sauberere und effizientere Möglichkeit bieten, globale Daten zu verwalten und solche Probleme in Zukunft zu vermeiden. Der Abschnitt schließt mit einer Zusammenfassung der erlernten Fähigkeiten in Bezug auf Navigation und Datenverarbeitung innerhalb der App.",
                                // Chinese
                                "中国人": "在本视频中，演示者解决了当用户在详细信息页面上取消选中某项收藏时，Flutter 应用程序中的 FavoritesScreen 上会出现过时数据的问题。根本原因是导航回收藏夹页面通常会显示缓存版本，而不是根据最新状态进行更新。演示者承认，虽然有一些临时修复方法，例如将 FavoritesScreen 转换为有状态的小部件并通过状态管理方法强制更新，但这些都不是理想的解决方案。相反，演示者强调了学习更高级的状态管理技术的重要性，这些技术将提供更清晰、更有效的方式来管理全局数据并避免将来出现此类问题。本节最后总结了在应用程序内导航和数据处理方面学到的技能。",
                                // Russian
                                "Русский": "В этом видео докладчик рассматривает проблему с устаревшими данными, появляющимися на экране избранного в приложении Flutter, когда пользователь снимает отметку с элемента как избранного на странице сведений. Основная причина заключается в том, что при возврате на страницу избранного часто отображается кэшированная версия, а не обновление на основе последнего состояния. Докладчик признает, что, хотя есть временные исправления, такие как преобразование экрана избранного в виджет с отслеживанием состояния и принудительное обновление с помощью методов управления состоянием, это не идеальные решения. Вместо этого докладчик подчеркивает важность изучения более продвинутых методов управления состоянием, которые обеспечат более чистый и эффективный способ управления глобальными данными и позволят избежать подобных проблем в будущем. Раздел завершается обобщением полученных навыков в отношении навигации и обработки данных в приложении.",
                                // French
                                "Français": "Dans cette vidéo, le présentateur aborde un problème lié aux données obsolètes apparaissant sur l'écran des favoris dans une application Flutter lorsqu'un utilisateur décoche un élément en tant que favori sur la page de détails. La cause principale est que la navigation vers la page des favoris affiche souvent une version en cache plutôt qu'une mise à jour en fonction de l'état le plus récent. Le présentateur reconnaît que même s'il existe des correctifs temporaires, tels que la conversion de l'écran des favoris en un widget avec état et le forçage d'une mise à jour via des méthodes de gestion d'état, ce ne sont pas des solutions idéales. Au lieu de cela, le présentateur souligne l'importance d'apprendre des techniques de gestion d'état plus avancées qui fourniront un moyen plus propre et plus efficace de gérer les données globales et d'éviter de tels problèmes à l'avenir. La section se termine en résumant les compétences acquises en matière de navigation et de gestion des données au sein de l'application.",
                                // Japanese
                                "日本語": "このビデオでは、プレゼンターが、ユーザーが詳細ページでアイテムをお気に入りとしてチェック解除したときに、Flutter アプリケーションの FavoritesScreen に古いデータが表示される問題について説明します。根本的な原因は、お気に入りページに戻ると、最新の状態に基づいて更新されるのではなく、キャッシュされたバージョンが表示されることが多いことです。プレゼンターは、FavoritesScreen をステートフル ウィジェットに変換し、状態管理メソッドを通じて強制的に更新するなどの一時的な修正はあるものの、これらは理想的な解決策ではないことを認めています。代わりに、プレゼンターは、よりクリーンで効率的なグローバル データを管理し、将来的にこのような問題を回避する方法を提供する、より高度な状態管理手法を習得することの重要性を強調しています。このセクションの最後には、アプリ内でのナビゲーションとデータ処理に関して習得したスキルをまとめます。",
                                // Korean
                                "한국인": "이 비디오에서 발표자는 사용자가 세부 정보 페이지에서 항목을 즐겨찾기에서 선택 취소할 때 Flutter 애플리케이션의 FavoritesScreen에 오래된 데이터가 표시되는 문제를 다룹니다. 근본 원인은 즐겨찾기 페이지로 돌아가면 최신 상태를 기반으로 업데이트하는 대신 캐시된 버전이 표시되는 경우가 많기 때문입니다. 발표자는 FavoritesScreen을 상태 저장 위젯으로 변환하고 상태 관리 방법을 통해 업데이트를 강제하는 것과 같은 일시적인 수정 사항이 있지만 이상적인 솔루션은 아니라는 것을 인정합니다. 대신 발표자는 글로벌 데이터를 관리하고 앞으로 이러한 문제를 피하는 더 깔끔하고 효율적인 방법을 제공하는 보다 고급 상태 관리 기술을 배우는 것의 중요성을 강조합니다. 이 섹션은 앱 내에서 탐색 및 데이터 처리와 관련하여 배운 기술을 요약하여 마무리합니다.",
                                // Spanish
                                "Español": "En este video, el presentador aborda un problema con datos desactualizados que aparecen en la pantalla de favoritos de una aplicación Flutter cuando un usuario desmarca un elemento como favorito en la página de detalles. La causa principal es que al volver a navegar a la página de favoritos, a menudo se muestra una versión en caché en lugar de actualizarse según el estado más reciente. El presentador reconoce que, si bien existen soluciones temporales, como convertir la pantalla de favoritos en un widget con estado y forzar una actualización a través de métodos de administración de estado, estas no son soluciones ideales. En cambio, el presentador enfatiza la importancia de aprender técnicas de administración de estado más avanzadas que brindarán una forma más clara y eficiente de administrar datos globales y evitar este tipo de problemas en el futuro. La sección concluye resumiendo las habilidades aprendidas con respecto a la navegación y el manejo de datos dentro de la aplicación.",
                                // Hindi
                                "हिंदी": "इस वीडियो में, प्रस्तुतकर्ता फ़्लटर एप्लिकेशन में FavoritesScreen पर दिखाई देने वाले पुराने डेटा के साथ एक समस्या को संबोधित करता है जब कोई उपयोगकर्ता विवरण पृष्ठ पर पसंदीदा के रूप में किसी आइटम को अनचेक करता है। मूल कारण यह है कि पसंदीदा पृष्ठ पर वापस नेविगेट करने पर अक्सर नवीनतम स्थिति के आधार पर अपडेट करने के बजाय कैश्ड संस्करण प्रदर्शित होता है। प्रस्तुतकर्ता स्वीकार करता है कि हालांकि अस्थायी समाधान हैं, जैसे कि FavoritesScreen को स्टेटफुल विजेट में बदलना और स्टेट मैनेजमेंट विधियों के माध्यम से अपडेट को मजबूर करना, ये आदर्श समाधान नहीं हैं। इसके बजाय, प्रस्तुतकर्ता अधिक उन्नत स्टेट मैनेजमेंट तकनीकों को सीखने के महत्व पर जोर देता है जो वैश्विक डेटा को प्रबंधित करने और भविष्य में ऐसी समस्याओं से बचने का एक साफ और अधिक कुशल तरीका प्रदान करेगा। अनुभाग ऐप के भीतर नेविगेशन और डेटा हैंडलिंग के बारे में सीखे गए कौशल को सारांशित करके समाप्त होता है।",
                                // Portuguese
                                "Português": "Neste vídeo, o apresentador aborda um problema com dados desatualizados que aparecem no ecrã Favorites numa aplicação Flutter quando um utilizador desmarca um item como favorito na página de detalhes. A causa raiz é que a navegação de volta para a página de favoritos geralmente exibe uma versão em cache em vez de atualizar com base no estado mais recente. O apresentador reconhece que embora existam soluções temporárias, como converter o FavoritesScreen num widget com estado e forçar uma atualização através de métodos de gestão de estado, estas não são soluções ideais. Em vez disso, o apresentador sublinha a importância de aprender técnicas de gestão de estado mais avançadas que proporcionarão uma forma mais limpa e eficiente de gerir dados globais e evitar tais problemas no futuro. A secção termina resumindo as competências aprendidas em relação à navegação e manipulação de dados na aplicação.",
                                // Bengali
                                "বাংলা": "এই ভিডিওতে, উপস্থাপক একটি ফ্লাটার অ্যাপ্লিকেশনে ফেভারিট স্ক্রীনে পুরানো ডেটা প্রদর্শিত হওয়ার সাথে একটি সমস্যার সমাধান করেছেন যখন একজন ব্যবহারকারী বিশদ পৃষ্ঠায় পছন্দসই হিসাবে একটি আইটেম আনচেক করে। মূল কারণ হল যে প্রিয় পৃষ্ঠায় ফিরে নেভিগেট করা প্রায়ই সর্বশেষ অবস্থার উপর ভিত্তি করে আপডেট করার পরিবর্তে একটি ক্যাশে সংস্করণ প্রদর্শন করে। উপস্থাপক স্বীকার করেছেন যে যখন অস্থায়ী সমাধান রয়েছে, যেমন ফেভারিটস্ক্রিনকে একটি রাষ্ট্রীয় উইজেটে রূপান্তর করা এবং রাষ্ট্র পরিচালনার পদ্ধতির মাধ্যমে একটি আপডেট বাধ্যতামূলক করা, এগুলো আদর্শ সমাধান নয়। পরিবর্তে, উপস্থাপক আরও উন্নত রাষ্ট্র পরিচালনার কৌশল শেখার গুরুত্বের উপর জোর দেন যা বিশ্বব্যাপী ডেটা পরিচালনা করার এবং ভবিষ্যতে এই জাতীয় সমস্যাগুলি এড়াতে একটি পরিষ্কার এবং আরও কার্যকর উপায় প্রদান করবে। অ্যাপের মধ্যে নেভিগেশন এবং ডেটা পরিচালনার বিষয়ে শেখা দক্ষতার সংক্ষিপ্তসারের মাধ্যমে বিভাগটি শেষ হয়।",
                                // Arabic
                                "عَرَبِيّ": "في هذا الفيديو، يتناول مقدم العرض مشكلة تتعلق بظهور بيانات قديمة على شاشة المفضلة في تطبيق Flutter عندما يقوم المستخدم بإلغاء تحديد عنصر كمفضل في صفحة التفاصيل. والسبب الجذري هو أن العودة إلى صفحة المفضلة غالبًا ما تعرض إصدارًا مخزنًا مؤقتًا بدلاً من التحديث بناءً على أحدث حالة. ويقر مقدم العرض بأنه على الرغم من وجود إصلاحات مؤقتة، مثل تحويل شاشة المفضلة إلى عنصر واجهة مستخدم يعتمد على الحالة وفرض التحديث من خلال أساليب إدارة الحالة، إلا أن هذه ليست حلولاً مثالية. وبدلاً من ذلك، يؤكد مقدم العرض على أهمية تعلم تقنيات إدارة الحالة الأكثر تقدمًا والتي ستوفر طريقة أنظف وأكثر كفاءة لإدارة البيانات العالمية وتجنب مثل هذه المشكلات في المستقبل. ويختتم القسم بتلخيص المهارات المكتسبة فيما يتعلق بالتنقل ومعالجة البيانات داخل التطبيق.",
                                // Persian
                                "فارسی": "در این ویدئو، ارائه دهنده به مشکلی که در مورد نمایش داده های قدیمی در صفحه FavoritesScreen در یک برنامه Flutter زمانی که کاربر علامت موردی را به عنوان مورد دلخواه در صفحه جزئیات بردارید، می پردازد. علت اصلی این است که بازگشت به صفحه علاقه مندی ها اغلب یک نسخه کش شده را به جای به روز رسانی بر اساس آخرین وضعیت نمایش می دهد. ارائه دهنده تصدیق می کند که اگرچه اصلاحات موقتی وجود دارد، مانند تبدیل FavoritesScreen به یک ویجت حالت دار و به روز رسانی اجباری از طریق روش های مدیریت وضعیت، این راه حل های ایده آل نیستند. در عوض، مجری بر اهمیت یادگیری تکنیک‌های پیشرفته‌تر مدیریت دولتی تأکید می‌کند که روشی تمیزتر و کارآمدتر برای مدیریت داده‌های جهانی و اجتناب از چنین مسائلی در آینده ارائه می‌کند. این بخش با خلاصه کردن مهارت های آموخته شده در مورد ناوبری و مدیریت داده ها در برنامه به پایان می رسد.",
                            },
                        },
                        // 164 [Video Number]
                        {
                            "SectionName": "Navigation & Multiple Screens [MEALS APP]",
                            "VideoName": "Wrap Up",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "In this concluding video of the module, the presenter reflects on the comprehensive learning experience regarding Flutter, highlighting the development of an entire app and the various widgets and features explored. Key topics covered include navigation between screens (or routes), passing data using both named and unnamed routes, and the importance of managing state. The presenter discusses the use of tabs and drawers for navigation, the functionality of the Flutter navigator for pushing and popping pages, and the handling of dialogs and modal bottom sheets. The video emphasizes the importance of these navigation concepts while setting the stage for the next module, which will delve into state management, addressing challenges that arise in larger applications.",
                                // German
                                "Deutsch": "In diesem Abschlussvideo des Moduls reflektiert der Moderator über die umfassende Lernerfahrung in Bezug auf Flutter und hebt die Entwicklung einer gesamten App und die verschiedenen erkundeten Widgets und Funktionen hervor. Zu den wichtigsten behandelten Themen gehören die Navigation zwischen Bildschirmen (oder Routen), die Datenübertragung über benannte und unbenannte Routen und die Bedeutung der Statusverwaltung. Der Moderator erörtert die Verwendung von Registerkarten und Schubladen zur Navigation, die Funktionalität des Flutter-Navigators zum Pushen und Popup von Seiten sowie die Handhabung von Dialogen und modalen Fußzeilen. Das Video betont die Bedeutung dieser Navigationskonzepte und bereitet gleichzeitig die Bühne für das nächste Modul, das sich mit der Statusverwaltung befasst und Herausforderungen behandelt, die bei größeren Anwendungen auftreten.",
                                // Chinese
                                "中国人": "在本模块的最后视频中，演示者回顾了有关 Flutter 的全面学习体验，重点介绍了整个应用程序的开发以及探索的各种小部件和功能。涵盖的关键主题包括屏幕（或路由）之间的导航、使用命名和未命名路由传递数据以及管理状态的重要性。演示者讨论了使用标签和抽屉进行导航、Flutter 导航器推送和弹出页面的功能以及对话框和模态底部表单的处理。该视频强调了这些导航概念的重要性，同时为下一个模块奠定了基础，该模块将深入研究状态管理，解决大型应用程序中出现的挑战。",
                                // Russian
                                "Русский": "В этом заключительном видео модуля докладчик размышляет о всестороннем опыте обучения Flutter, выделяя разработку целого приложения и различные изученные виджеты и функции. Основные затронутые темы включают навигацию между экранами (или маршрутами), передачу данных с использованием как именованных, так и неименованных маршрутов и важность управления состоянием. Докладчик обсуждает использование вкладок и ящиков для навигации, функциональность навигатора Flutter для выталкивания и выталкивания страниц, а также обработку диалогов и модальных нижних листов. Видео подчеркивает важность этих концепций навигации, одновременно подготавливая почву для следующего модуля, который углубится в управление состоянием, решая проблемы, возникающие в более крупных приложениях.",
                                // French
                                "Français": "Dans cette vidéo de conclusion du module, le présentateur revient sur l'expérience d'apprentissage complète concernant Flutter, en soulignant le développement d'une application entière et les différents widgets et fonctionnalités explorés. Les principaux sujets abordés incluent la navigation entre les écrans (ou itinéraires), la transmission de données à l'aide d'itinéraires nommés et non nommés et l'importance de la gestion de l'état. Le présentateur discute de l'utilisation des onglets et des tiroirs pour la navigation, de la fonctionnalité du navigateur Flutter pour pousser et faire apparaître des pages, et de la gestion des boîtes de dialogue et des feuilles de fond modales. La vidéo souligne l'importance de ces concepts de navigation tout en préparant le terrain pour le prochain module, qui se penchera sur la gestion de l'état, en abordant les défis qui se posent dans les applications plus vastes.",
                                // Japanese
                                "日本語": "このモジュールの最後のビデオでは、プレゼンターが Flutter に関する包括的な学習体験を振り返り、アプリ全体の開発と、検討したさまざまなウィジェットや機能に焦点を当てています。取り上げる主なトピックには、画面 (またはルート) 間のナビゲーション、名前付きルートと名前なしルートの両方を使用したデータの受け渡し、状態管理の重要性などがあります。プレゼンターは、ナビゲーションでのタブとドロワーの使用、ページのプッシュとポップのための Flutter ナビゲーターの機能、ダイアログとモーダル ボトム シートの処理について説明します。このビデオでは、これらのナビゲーション コンセプトの重要性を強調しながら、次のモジュールの準備を整えます。次のモジュールでは、状態管理について詳しく掘り下げ、より大規模なアプリケーションで発生する課題に対処します。",
                                // Korean
                                "한국인": "이 모듈의 마지막 영상에서 발표자는 Flutter에 대한 포괄적인 학습 경험을 되돌아보며 전체 앱의 개발과 탐색한 다양한 위젯과 기능을 강조합니다. 다루는 주요 주제로는 화면(또는 경로) 간 탐색, 명명된 경로와 명명되지 않은 경로를 모두 사용하여 데이터 전달, 상태 관리의 중요성이 있습니다. 발표자는 탐색을 위한 탭과 서랍의 사용, 페이지를 푸시하고 팝하기 위한 Flutter 탐색기의 기능, 대화 상자와 모달 바텀 시트의 처리에 대해 설명합니다. 이 영상은 이러한 탐색 개념의 중요성을 강조하는 동시에 다음 모듈의 무대를 마련하는데, 다음 모듈에서는 상태 관리를 탐구하고 대규모 애플리케이션에서 발생하는 과제를 다룹니다.",
                                // Spanish
                                "Español": "En este video final del módulo, el presentador reflexiona sobre la experiencia de aprendizaje integral con respecto a Flutter, destacando el desarrollo de una aplicación completa y los diversos widgets y funciones explorados. Los temas clave que se tratan incluyen la navegación entre pantallas (o rutas), el paso de datos mediante rutas con nombre y sin nombre, y la importancia de administrar el estado. El presentador analiza el uso de pestañas y cajones para la navegación, la funcionalidad del navegador de Flutter para insertar y extraer páginas, y el manejo de cuadros de diálogo y hojas inferiores modales. El video enfatiza la importancia de estos conceptos de navegación al tiempo que prepara el terreno para el siguiente módulo, que profundizará en la administración del estado y abordará los desafíos que surgen en aplicaciones más grandes.",
                                // Hindi
                                "हिंदी": "मॉड्यूल के इस समापन वीडियो में, प्रस्तुतकर्ता फ़्लटर के बारे में व्यापक शिक्षण अनुभव पर विचार करता है, एक संपूर्ण ऐप के विकास और खोजे गए विभिन्न विजेट और सुविधाओं पर प्रकाश डालता है। कवर किए गए प्रमुख विषयों में स्क्रीन (या रूट) के बीच नेविगेशन, नामित और अनाम दोनों रूट का उपयोग करके डेटा पास करना और स्टेट को प्रबंधित करने का महत्व शामिल है। प्रस्तुतकर्ता नेविगेशन के लिए टैब और ड्रॉअर के उपयोग, पेजों को पुश करने और पॉप करने के लिए फ़्लटर नेविगेटर की कार्यक्षमता और डायलॉग्स और मोडल बॉटम शीट्स को संभालने के बारे में चर्चा करता है। वीडियो अगले मॉड्यूल के लिए मंच तैयार करते हुए इन नेविगेशन अवधारणाओं के महत्व पर जोर देता है, जो स्टेट मैनेजमेंट में गहराई से जाएगा, बड़े अनुप्रयोगों में उत्पन्न होने वाली चुनौतियों का समाधान करेगा।",
                                // Portuguese
                                "Português": "Neste vídeo de conclusão do módulo, o apresentador reflete sobre a experiência de aprendizagem abrangente em relação ao Flutter, destacando o desenvolvimento de uma aplicação completa e os vários widgets e funcionalidades explorados. Os principais tópicos abordados incluem a navegação entre ecrãs (ou rotas), a passagem de dados utilizando rotas nomeadas e não nomeadas e a importância da gestão do estado. O apresentador discute a utilização de separadores e gavetas para navegação, a funcionalidade do navegador Flutter para empurrar e abrir páginas e a manipulação de caixas de diálogo e folhas inferiores modais. O vídeo enfatiza a importância destes conceitos de navegação ao mesmo tempo que prepara o terreno para o próximo módulo, que irá aprofundar a gestão do estado, abordando desafios que surgem em aplicações de maior dimensão.",
                                // Bengali
                                "বাংলা": "মডিউলটির এই সমাপ্তি ভিডিওতে, উপস্থাপক ফ্লটার সম্পর্কিত ব্যাপক শিক্ষার অভিজ্ঞতার প্রতিফলন করে, একটি সম্পূর্ণ অ্যাপের বিকাশ এবং বিভিন্ন উইজেট এবং বৈশিষ্ট্যগুলিকে অন্বেষণ করা হাইলাইট করে। আচ্ছাদিত মূল বিষয়গুলির মধ্যে রয়েছে স্ক্রীন (বা রুট) এর মধ্যে নেভিগেশন, নাম ও নামহীন উভয় রুট ব্যবহার করে ডেটা পাস করা এবং রাষ্ট্র পরিচালনার গুরুত্ব। উপস্থাপক নেভিগেশনের জন্য ট্যাব এবং ড্রয়ারের ব্যবহার, পৃষ্ঠাগুলি ঠেলে ও পপ করার জন্য ফ্লটার নেভিগেটরের কার্যকারিতা এবং ডায়ালগ এবং মডেল নীচের শীটগুলি পরিচালনার বিষয়ে আলোচনা করেন। ভিডিওটি পরবর্তী মডিউলের জন্য পর্যায় সেট করার সময় এই নেভিগেশন ধারণাগুলির গুরুত্বের উপর জোর দেয়, যা রাষ্ট্র পরিচালনার বিষয়ে গভীর মনোযোগ দেবে, বৃহত্তর অ্যাপ্লিকেশনগুলিতে উদ্ভূত চ্যালেঞ্জগুলিকে মোকাবেলা করবে।",
                                // Arabic
                                "عَرَبِيّ": "في مقطع الفيديو الختامي للوحدة، يتأمل مقدم العرض تجربة التعلم الشاملة فيما يتعلق بـ Flutter، مسلطًا الضوء على تطوير تطبيق كامل والأدوات والميزات المتنوعة التي تم استكشافها. تشمل الموضوعات الرئيسية التي تمت تغطيتها التنقل بين الشاشات (أو المسارات)، وتمرير البيانات باستخدام المسارات المسماة وغير المسماة، وأهمية إدارة الحالة. يناقش مقدم العرض استخدام علامات التبويب والأدراج للتنقل، ووظيفة متصفح Flutter لدفع الصفحات وإظهارها، والتعامل مع الحوارات والصفحات السفلية النموذجية. يؤكد الفيديو على أهمية مفاهيم التنقل هذه مع إعداد المسرح للوحدة التالية، والتي ستتعمق في إدارة الحالة، ومعالجة التحديات التي تنشأ في التطبيقات الأكبر.",
                                // Persian
                                "فارسی": "در این ویدیوی پایانی از ماژول، ارائه دهنده تجربه یادگیری جامع در مورد فلاتر را منعکس می کند و توسعه یک برنامه کامل و ویجت ها و ویژگی های مختلف بررسی شده را برجسته می کند. موضوعات کلیدی تحت پوشش عبارتند از ناوبری بین صفحه‌ها (یا مسیرها)، انتقال داده‌ها با استفاده از مسیرهای نام‌گذاری شده و بدون نام، و اهمیت مدیریت وضعیت. مجری در مورد استفاده از زبانه ها و کشوها برای پیمایش، عملکرد ناوبر فلاتر برای فشار دادن و باز کردن صفحات، و مدیریت دیالوگ ها و ورق های پایینی مدال بحث می کند. این ویدئو بر اهمیت این مفاهیم ناوبری تاکید می کند، در حالی که زمینه را برای ماژول بعدی فراهم می کند، که به مدیریت دولت می پردازد و به چالش هایی که در برنامه های کاربردی بزرگتر ایجاد می شود، می پردازد.",
                            },
                        },
                    ],
                },
                // Section 8 : State Management [SHOP APP]
                {
                    "SectionName": "State Management [SHOP APP]",
                    "Videos": [
                        // 165 [Video Number]
                        {
                            "SectionName": "State Management [SHOP APP]",
                            "VideoName": "Module Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "",
                                // German
                                "Deutsch": "",
                                // Chinese
                                "中国人": "",
                                // Russian
                                "Русский": "",
                                // French
                                "Français": "",
                                // Japanese
                                "日本語": "",
                                // Korean
                                "한국인": "",
                                // Spanish
                                "Español": "",
                                // Hindi
                                "हिंदी": "",
                                // Portuguese
                                "Português": "",
                                // Bengali
                                "বাংলা": "",
                                // Arabic
                                "عَرَبِيّ": "",
                                // Persian
                                "فارسی": "",
                            },
                        },
                        // - [Video Number]
                        {
                            "SectionName": "State Management [SHOP APP]",
                            "VideoName": "Module Introduction",
                            "ShortDescriptionAboutChapter": {
                                // English
                                "English": "",
                                // German
                                "Deutsch": "",
                                // Chinese
                                "中国人": "",
                                // Russian
                                "Русский": "",
                                // French
                                "Français": "",
                                // Japanese
                                "日本語": "",
                                // Korean
                                "한국인": "",
                                // Spanish
                                "Español": "",
                                // Hindi
                                "हिंदी": "",
                                // Portuguese
                                "Português": "",
                                // Bengali
                                "বাংলা": "",
                                // Arabic
                                "عَرَبِيّ": "",
                                // Persian
                                "فارسی": "",
                            },
                        },
                    ],
                },
            ],
            "TotalDescriptionAboutTheBook": [
                // Paragraph 1
                {
                    // English
                    "English": "Flutter Complete Reference 2.0 is a comprehensive and practical book that covers all aspects of Dart and Flutter development. It is written by Alberto Miola, a professional Flutter developer and instructor. The book is suitable for beginners and experienced developers alike, as it provides clear explanations, examples, and tips for each topic.",
                    // German
                    "Deutsch": "Flutter Complete Reference 2.0 ist ein umfassendes und praktisches Buch, das alle Aspekte der Dart- und Flutter-Entwicklung abdeckt. Es wurde von Alberto Miola geschrieben, einem professionellen Flutter-Entwickler und -Lehrer. Das Buch ist sowohl für Anfänger als auch für erfahrene Entwickler geeignet, da es klare Erklärungen, Beispiele und Tipps zu jedem Thema bietet.",
                    // Chinese
                    "中国人": "Flutter Complete Reference 2.0 是一本全面实用的书，涵盖了 Dart 和 Flutter 开发的各个方面。它由专业的 Flutter 开发人员和讲师 Alberto Miola 撰写。这本书适合初学者和经验丰富的开发人员，因为它为每个主题提供了清晰的解释、示例和提示。",
                    // Russian
                    "Русский": "Flutter Complete Reference 2.0 — это всеобъемлющая и практическая книга, охватывающая все аспекты разработки Dart и Flutter. Он написан Альберто Миолой, профессиональным разработчиком и инструктором Flutter. Книга подойдет как новичкам, так и опытным разработчикам, поскольку содержит понятные объяснения, примеры и советы по каждой теме.",
                    // French
                    "Français": "Flutter Complete Reference 2.0 est un livre complet et pratique qui couvre tous les aspects du développement de Dart et Flutter. Il est écrit par Alberto Miola, développeur et instructeur professionnel Flutter. Le livre convient aussi bien aux développeurs débutants qu'aux développeurs expérimentés, car il fournit des explications claires, des exemples et des conseils pour chaque sujet.",
                    // Japanese
                    "日本語": "Flutter Complete Reference 2.0 は、Dart および Flutter 開発のあらゆる側面を網羅した包括的かつ実用的な書籍です。プロの Flutter 開発者兼インストラクターである Alberto Miola によって執筆されています。各トピックについて明確な説明、例、ヒントを提供しているため、初心者にも経験豊富な開発者にも適した書籍です。",
                    // Korean
                    "한국인": "Flutter Complete Reference 2.0은 Dart 및 Flutter 개발의 모든 측면을 다루는 포괄적이고 실용적인 책입니다. Flutter 전문 개발자이자 강사인 Alberto Miola가 작성했습니다. 이 책은 각 주제에 대한 명확한 설명, 예제, 팁을 제공하므로 초보자와 숙련된 개발자 모두에게 적합합니다.",
                    // Spanish
                    "Español": "Flutter Complete Reference 2.0 es un libro completo y práctico que cubre todos los aspectos del desarrollo de Dart y Flutter. Está escrito por Alberto Miola, un desarrollador e instructor profesional de Flutter. El libro es adecuado tanto para principiantes como para desarrolladores experimentados, ya que proporciona explicaciones claras, ejemplos y consejos para cada tema.",
                    // Hindi
                    "हिंदी": "फ़्लटर कम्प्लीट रेफरेंस 2.0 एक व्यापक और व्यावहारिक पुस्तक है जो डार्ट और फ़्लटर विकास के सभी पहलुओं को कवर करती है। यह अल्बर्टो मिओला द्वारा लिखी गई है, जो एक पेशेवर फ़्लटर डेवलपर और प्रशिक्षक हैं। यह पुस्तक शुरुआती और अनुभवी डेवलपर्स दोनों के लिए उपयुक्त है, क्योंकि यह प्रत्येक विषय के लिए स्पष्ट स्पष्टीकरण, उदाहरण और सुझाव प्रदान करती है।",
                    // Portuguese
                    "Português": "Flutter Complete Reference 2.0 é um livro abrangente e prático que cobre todos os aspectos do desenvolvimento do Dart e do Flutter. Foi escrito por Alberto Miola, desenvolvedor e instrutor profissional de Flutter. O livro é adequado tanto para iniciantes quanto para desenvolvedores experientes, pois fornece explicações claras, exemplos e dicas para cada tópico.",
                    // Bengali
                    "বাংলা": "ফ্লাটার কমপ্লিট রেফারেন্স 2.0 হল একটি ব্যাপক এবং ব্যবহারিক বই যা ডার্ট এবং ফ্লাটার ডেভেলপমেন্টের সমস্ত দিক কভার করে। এটি আলবার্তো মিওলা লিখেছেন, একজন পেশাদার ফ্লাটার বিকাশকারী এবং প্রশিক্ষক৷ বইটি নতুনদের এবং অভিজ্ঞ বিকাশকারীদের জন্য একইভাবে উপযুক্ত, কারণ এটি প্রতিটি বিষয়ের জন্য স্পষ্ট ব্যাখ্যা, উদাহরণ এবং টিপস প্রদান করে।",
                    // Arabic
                    "عَرَبِيّ": "Flutter Complete Reference 2.0 هو كتاب شامل وعملي يغطي جميع جوانب تطوير Dart وFlutter. تمت كتابته بواسطة ألبرتو ميولا، وهو مطور ومدرب Flutter محترف. الكتاب مناسب للمبتدئين والمطورين ذوي الخبرة على حد سواء، حيث يقدم شروحات وأمثلة ونصائح واضحة لكل موضوع.",
                    // Persian
                    "فارسی": "Flutter Complete Reference 2.0 یک کتاب جامع و کاربردی است که تمام جنبه های توسعه دارت و فلاتر را پوشش می دهد. این توسط Alberto Miola، توسعه دهنده و مربی حرفه ای Flutter نوشته شده است. این کتاب برای مبتدیان و توسعه دهندگان با تجربه به طور یکسان مناسب است، زیرا توضیحات، مثال ها و نکات روشنی را برای هر موضوع ارائه می دهد.",
                },
                // Paragraph 2
                {
                    // English
                    "English": "By reading this book, you will learn how to use Flutter to create beautiful, fast, and native apps for any device. You will also master the Dart language and its features, such as generics, collections, async, streams, and isolates. You will explore the Flutter framework and its widgets, state management solutions, animations, navigation, localization, accessibility, and more. You will also learn how to test, deploy, and monetize your Flutter apps, as well as how to interact with platforms, servers, and low-level HTML.",
                    // German
                    "Deutsch": "In diesem Buch lernen Sie, wie Sie mit Flutter schöne, schnelle und native Apps für jedes Gerät erstellen. Sie beherrschen auch die Sprache Dart und ihre Funktionen wie Generika, Sammlungen, Asynchronität, Streams und Isolate. Sie erkunden das Flutter-Framework und seine Widgets, Lösungen zur Zustandsverwaltung, Animationen, Navigation, Lokalisierung, Zugänglichkeit und mehr. Sie lernen auch, wie Sie Ihre Flutter-Apps testen, bereitstellen und monetarisieren sowie wie Sie mit Plattformen, Servern und Low-Level-HTML interagieren.",
                    // Chinese
                    "中国人": "通过阅读本书，您将学习如何使用 Flutter 为任何设备创建美观、快速且原生的应用。您还将掌握 Dart 语言及其功能，例如泛型、集合、异步、流和隔离。您将探索 Flutter 框架及其小部件、状态管理解决方案、动画、导航、本地化、可访问性等。您还将学习如何测试、部署和货币化您的 Flutter 应用，以及如何与平台、服务器和低级 HTML 交互。",
                    // Russian
                    "Русский": "Прочитав эту книгу, вы узнаете, как использовать Flutter для создания красивых, быстрых и нативных приложений для любого устройства. Вы также освоите язык Dart и его функции, такие как дженерики, коллекции, асинхронность, потоки и изоляты. Вы изучите инфраструктуру Flutter и ее виджеты, решения для управления состоянием, анимацию, навигацию, локализацию, специальные возможности и многое другое. Вы также узнаете, как тестировать, развертывать и монетизировать свои приложения Flutter, а также как взаимодействовать с платформами, серверами и низкоуровневым HTML.",
                    // French
                    "Français": "En lisant ce livre, vous apprendrez à utiliser Flutter pour créer des applications belles, rapides et natives pour n'importe quel appareil. Vous maîtriserez également le langage Dart et ses fonctionnalités, telles que les génériques, les collections, l'async, les flux et les isolats. Vous explorerez le framework Flutter et ses widgets, ses solutions de gestion d'état, ses animations, sa navigation, sa localisation, son accessibilité, etc. Vous apprendrez également comment tester, déployer et monétiser vos applications Flutter, ainsi que comment interagir avec les plates-formes, les serveurs et le HTML de bas niveau.",
                    // Japanese
                    "日本語": "この本を読むことで、Flutter を使用して、あらゆるデバイス向けの美しく高速なネイティブ アプリを作成する方法を学ぶことができます。また、ジェネリック、コレクション、非同期、ストリーム、分離などの Dart 言語とその機能を習得できます。Flutter フレームワークとそのウィジェット、状態管理ソリューション、アニメーション、ナビゲーション、ローカリゼーション、アクセシビリティなどについて学習します。さらに、Flutter アプリをテスト、展開、収益化する方法、およびプラットフォーム、サーバー、低レベル HTML を操作する方法についても学習します。",
                    // Korean
                    "한국인": "이 책을 읽으면 Flutter를 사용하여 모든 기기에서 사용할 수 있는 아름답고 빠른 기본 앱을 만드는 방법을 배우게 됩니다. 또한 Dart 언어와 제네릭, 컬렉션, 비동기, 스트림 및 격리와 같은 기능을 익히게 됩니다. Flutter 프레임워크와 해당 위젯, 상태 관리 솔루션, 애니메이션, 탐색, 현지화, 접근성 등을 살펴보겠습니다. 또한 Flutter 앱을 테스트, 배포 및 수익화하는 방법은 물론 플랫폼, 서버 및 하위 수준 HTML과 상호 작용하는 방법도 배우게 됩니다.",
                    // Spanish
                    "Español": "Al leer este libro, aprenderá cómo usar Flutter para crear aplicaciones hermosas, rápidas y nativas para cualquier dispositivo. También dominará el lenguaje Dart y sus características, como genéricos, colecciones, asíncronos, transmisiones y aislamientos. Explorará el marco Flutter y sus widgets, soluciones de administración de estado, animaciones, navegación, localización, accesibilidad y más. También aprenderá cómo probar, implementar y monetizar sus aplicaciones Flutter, así como también cómo interactuar con plataformas, servidores y HTML de bajo nivel.",
                    // Hindi
                    "हिंदी": "इस पुस्तक को पढ़कर, आप सीखेंगे कि किसी भी डिवाइस के लिए सुंदर, तेज़ और मूल ऐप बनाने के लिए फ़्लटर का उपयोग कैसे करें। आप डार्ट भाषा और इसकी विशेषताओं, जैसे कि जेनरिक, संग्रह, एसिंक्रोनस, स्ट्रीम और आइसोलेट्स में भी महारत हासिल करेंगे। आप फ़्लटर फ्रेमवर्क और इसके विजेट, स्टेट मैनेजमेंट सॉल्यूशन, एनिमेशन, नेविगेशन, लोकलाइज़ेशन, एक्सेसिबिलिटी और बहुत कुछ का पता लगाएंगे। आप यह भी सीखेंगे कि अपने फ़्लटर ऐप का परीक्षण, परिनियोजन और मुद्रीकरण कैसे करें, साथ ही प्लेटफ़ॉर्म, सर्वर और निम्न-स्तरीय HTML के साथ कैसे इंटरैक्ट करें।",
                    // Portuguese
                    "Português": "Ao ler este livro, você aprenderá como usar o Flutter para criar aplicativos bonitos, rápidos e nativos para qualquer dispositivo. Você também dominará a linguagem Dart e seus recursos, como genéricos, coleções, assíncronos, fluxos e isolados. Você explorará a estrutura Flutter e seus widgets, soluções de gerenciamento de estado, animações, navegação, localização, acessibilidade e muito mais. Você também aprenderá como testar, implantar e monetizar seus aplicativos Flutter, bem como interagir com plataformas, servidores e HTML de baixo nível.",
                    // Bengali
                    "বাংলা": "এই বইটি পড়ার মাধ্যমে, আপনি শিখবেন কিভাবে যেকোন ডিভাইসের জন্য সুন্দর, দ্রুত এবং নেটিভ অ্যাপ তৈরি করতে Flutter ব্যবহার করতে হয়। এছাড়াও আপনি ডার্ট ভাষা এবং এর বৈশিষ্ট্যগুলি যেমন জেনেরিক, সংগ্রহ, অ্যাসিঙ্ক, স্ট্রিম এবং আইসোলেটগুলি আয়ত্ত করতে পারবেন। আপনি ফ্লটার ফ্রেমওয়ার্ক এবং এর উইজেট, স্টেট ম্যানেজমেন্ট সলিউশন, অ্যানিমেশন, নেভিগেশন, স্থানীয়করণ, অ্যাক্সেসযোগ্যতা এবং আরও অনেক কিছু অন্বেষণ করবেন। আপনি কীভাবে আপনার ফ্লাটার অ্যাপগুলি পরীক্ষা, স্থাপন এবং নগদীকরণ করবেন, সেইসাথে প্ল্যাটফর্ম, সার্ভার এবং নিম্ন-স্তরের HTML এর সাথে কীভাবে ইন্টারঅ্যাক্ট করবেন তাও শিখবেন।",
                    // Arabic
                    "عَرَبِيّ": "من خلال قراءة هذا الكتاب، ستتعلم كيفية استخدام Flutter لإنشاء تطبيقات جميلة وسريعة ومبتكرة لأي جهاز. ستتقن أيضًا لغة Dart وميزاتها، مثل الأدوية العامة والمجموعات وغير المتزامنة والتدفقات والعزلات. سوف تستكشف إطار عمل Flutter وعناصر واجهة المستخدم الخاصة به وحلول إدارة الحالة والرسوم المتحركة والتنقل والترجمة وإمكانية الوصول والمزيد. ستتعلم أيضًا كيفية اختبار تطبيقات Flutter ونشرها وتحقيق الدخل منها، بالإضافة إلى كيفية التفاعل مع الأنظمة الأساسية والخوادم ولغة HTML ذات المستوى المنخفض.",
                    // Persian
                    "فارسی": "با خواندن این کتاب، یاد خواهید گرفت که چگونه از فلاتر برای ایجاد اپلیکیشن های زیبا، سریع و بومی برای هر دستگاهی استفاده کنید. شما همچنین به زبان دارت و ویژگی‌های آن مانند ژنریک، مجموعه‌ها، همگام‌سازی، جریان‌ها و ایزوله‌ها تسلط خواهید داشت. شما چارچوب Flutter و ویجت‌های آن، راه‌حل‌های مدیریت حالت، انیمیشن‌ها، ناوبری، محلی‌سازی، دسترسی و موارد دیگر را بررسی خواهید کرد. همچنین یاد خواهید گرفت که چگونه برنامه های Flutter خود را آزمایش، استقرار و کسب درآمد کنید و همچنین نحوه تعامل با پلتفرم ها، سرورها و HTML سطح پایین را خواهید آموخت.",
                },
                // Paragraph 3
                {
                    // English
                    "English": "This book will help you gain a solid understanding of Flutter and its best practices. You will also discover the benefits of using Flutter, such as faster development, native performance, hot reload and hot restart, and a vibrant community. Whether you are new to Flutter or have some experience with it, this book will help you master the skills and knowledge you need to become a successful Flutter developer.",
                    // German
                    "Deutsch": "Dieses Buch vermittelt Ihnen ein solides Verständnis von Flutter und seinen Best Practices. Sie werden auch die Vorteile von Flutter entdecken, wie schnellere Entwicklung, native Leistung, Hot Reload und Hot Restart sowie eine lebendige Community. Egal, ob Sie neu bei Flutter sind oder bereits Erfahrung damit haben, dieses Buch hilft Ihnen dabei, die Fähigkeiten und Kenntnisse zu erlernen, die Sie benötigen, um ein erfolgreicher Flutter-Entwickler zu werden.",
                    // Chinese
                    "中国人": "本书将帮助您深入了解 Flutter 及其最佳实践。您还将发现使用 Flutter 的好处，例如更快的开发、原生性能、热重载和热重启以及充满活力的社区。无论您是 Flutter 新手还是有一定使用经验，本书都将帮助您掌握成为成功的 Flutter 开发人员所需的技能和知识。",
                    // Russian
                    "Русский": "Эта книга поможет вам получить четкое представление о Flutter и его лучших практиках. Вы также откроете для себя преимущества использования Flutter, такие как более быстрая разработка, собственная производительность, горячая перезагрузка и горячий перезапуск, а также активное сообщество. Независимо от того, являетесь ли вы новичком во Flutter или имеете некоторый опыт работы с ним, эта книга поможет вам овладеть навыками и знаниями, необходимыми для того, чтобы стать успешным разработчиком Flutter.",
                    // French
                    "Français": "Ce livre vous aidera à acquérir une solide compréhension de Flutter et de ses meilleures pratiques. Vous découvrirez également les avantages de l'utilisation de Flutter, tels qu'un développement plus rapide, des performances natives, un rechargement et un redémarrage à chaud, ainsi qu'une communauté dynamique. Que vous soyez nouveau sur Flutter ou que vous en ayez une certaine expérience, ce livre vous aidera à maîtriser les compétences et les connaissances dont vous avez besoin pour devenir un développeur Flutter à succès.",
                    // Japanese
                    "日本語": "この本は、Flutter とそのベスト プラクティスをしっかりと理解するのに役立ちます。また、開発の高速化、ネイティブ パフォーマンス、ホット リロードとホット リスタート、活気のあるコミュニティなど、Flutter を使用する利点も発見できます。Flutter を初めて使用する場合でも、ある程度の経験がある場合でも、この本は、成功する Flutter 開発者になるために必要なスキルと知識を習得するのに役立ちます。",
                    // Korean
                    "한국인": "이 책은 Flutter와 Flutter의 모범 사례를 확실하게 이해하는 데 도움이 될 것입니다. 또한 더 빠른 개발, 기본 성능, 핫 리로드 및 핫 리스타트, 활발한 커뮤니티 등 Flutter 사용의 이점을 발견하게 될 것입니다. Flutter를 처음 접하는 사람이든 경험이 있는 사람이든 이 책은 성공적인 Flutter 개발자가 되기 위해 필요한 기술과 지식을 익히는 데 도움이 될 것입니다.",
                    // Spanish
                    "Español": "Este libro lo ayudará a obtener una comprensión sólida de Flutter y sus mejores prácticas. También descubrirá los beneficios de usar Flutter, como un desarrollo más rápido, rendimiento nativo, recarga y reinicio en caliente y una comunidad vibrante. Ya sea que sea nuevo en Flutter o tenga algo de experiencia con él, este libro lo ayudará a dominar las habilidades y el conocimiento que necesita para convertirse en un desarrollador exitoso de Flutter.",
                    // Hindi
                    "हिंदी": "यह पुस्तक आपको फ़्लटर और इसके सर्वोत्तम अभ्यासों की ठोस समझ हासिल करने में मदद करेगी। आप फ़्लटर का उपयोग करने के लाभों की भी खोज करेंगे, जैसे तेज़ विकास, मूल प्रदर्शन, हॉट रीलोड और हॉट रीस्टार्ट, और एक जीवंत समुदाय। चाहे आप फ़्लटर के लिए नए हों या इसके साथ कुछ अनुभव रखते हों, यह पुस्तक आपको फ़्लटर डेवलपर बनने के लिए आवश्यक कौशल और ज्ञान में महारत हासिल करने में मदद करेगी।",
                    // Portuguese
                    "Português": "Este livro o ajudará a obter uma compreensão sólida do Flutter e de suas práticas recomendadas. Você também descobrirá os benefícios de usar o Flutter, como desenvolvimento mais rápido, desempenho nativo, recarga e reinicialização a quente e uma comunidade vibrante. Quer você seja novo no Flutter ou tenha alguma experiência com ele, este livro o ajudará a dominar as habilidades e o conhecimento necessários para se tornar um desenvolvedor Flutter de sucesso.",
                    // Bengali
                    "বাংলা": "এই বইটি আপনাকে ফ্লটার এবং এর সর্বোত্তম অনুশীলন সম্পর্কে একটি দৃঢ় উপলব্ধি অর্জন করতে সহায়তা করবে। আপনি ফ্লটার ব্যবহারের সুবিধাগুলিও আবিষ্কার করবেন, যেমন দ্রুত বিকাশ, নেটিভ পারফরম্যান্স, হট রিলোড এবং হট রিস্টার্ট এবং একটি প্রাণবন্ত সম্প্রদায়। আপনি ফ্লটারে নতুন হোন বা এর সাথে কিছু অভিজ্ঞতা থাকুক না কেন, এই বইটি আপনাকে একজন সফল ফ্লটার ডেভেলপার হওয়ার জন্য আপনার প্রয়োজনীয় দক্ষতা এবং জ্ঞান আয়ত্ত করতে সাহায্য করবে।",
                    // Arabic
                    "عَرَبِيّ": "سيساعدك هذا الكتاب على اكتساب فهم قوي لـ Flutter وأفضل ممارساتها. ستكتشف أيضًا فوائد استخدام Flutter، مثل التطوير الأسرع والأداء الأصلي وإعادة التحميل السريع وإعادة التشغيل السريع ومجتمع نابض بالحياة. سواء كنت جديدًا في استخدام Flutter أو لديك بعض الخبرة فيه، سيساعدك هذا الكتاب على إتقان المهارات والمعرفة التي تحتاجها لتصبح مطور Flutter ناجحًا.",
                    // Persian
                    "فارسی": "این کتاب به شما کمک می کند تا درک کاملی از فلاتر و بهترین شیوه های آن به دست آورید. همچنین مزایای استفاده از Flutter مانند توسعه سریعتر، عملکرد بومی، بارگذاری مجدد داغ و راه اندازی مجدد داغ و یک جامعه پر جنب و جوش را خواهید دید. چه در فلاتر تازه کار باشید و چه تجربه ای در این زمینه داشته باشید، این کتاب به شما کمک می کند تا مهارت ها و دانش لازم برای تبدیل شدن به یک توسعه دهنده موفق فلاتر را به دست آورید.",
                },
            ],
            "CourseCoverImagePath": "../assets/img/Courses Covers/Flutter Development/Flutter & Dart [Complete Guide] Maximillian.jpg",
            "shortDescriptionsForCourseReviewing": {
                // English
                "English": "Flutter & Dart - The Complete Guide is a comprehensive online course led by expert instructor Maximilian Schwarzmüller. This course is designed for beginners and experienced developers alike who want to learn how to build mobile applications using Flutter and Dart. With over 30 hours of video content, students will master the fundamentals of Flutter, understand Dart programming language, and create real-world projects from scratch. From building user interfaces to handling state management and integrating third-party libraries, students will gain a solid foundation in Flutter development through hands-on coding exercises and practical projects. By the end of this course, students will have the knowledge and skills needed to confidently create cross-platform mobile applications with Flutter.",
                // German
                "Deutsch": "Flutter & Dart – The Complete Guide ist ein umfassender Onlinekurs unter der Leitung des erfahrenen Dozenten Maximilian Schwarzmüller. Dieser Kurs richtet sich sowohl an Anfänger als auch an erfahrene Entwickler, die lernen möchten, wie man mit Flutter und Dart mobile Anwendungen erstellt. Mit über 30 Stunden Videoinhalt beherrschen die Teilnehmer die Grundlagen von Flutter, verstehen die Programmiersprache Dart und erstellen reale Projekte von Grund auf. Vom Erstellen von Benutzeroberflächen über die Handhabung der Statusverwaltung bis hin zur Integration von Bibliotheken von Drittanbietern erhalten die Teilnehmer durch praktische Programmierübungen und praktische Projekte eine solide Grundlage in der Flutter-Entwicklung. Am Ende dieses Kurses verfügen die Teilnehmer über das erforderliche Wissen und die erforderlichen Fähigkeiten, um plattformübergreifende mobile Anwendungen mit Flutter sicher zu erstellen.",
                // Chinese
                "中国人": "Flutter & Dart - 完整指南是一门综合性的在线课程，由专家讲师 Maximilian Schwarzmüller 讲授。本课程专为初学者和经验丰富的开发人员设计，他们希望学习如何使用 Flutter 和 Dart 构建移动应用程序。通过超过 30 小时的视频内容，学生将掌握 Flutter 的基础知识，了解 Dart 编程语言，并从头开始创建真实项目。从构建用户界面到处理状态管理和集成第三方库，学生将通过动手编码练习和实际项目获得 Flutter 开发的坚实基础。在本课程结束时，学生将掌握使用 Flutter 自信地创建跨平台移动应用程序所需的知识和技能。",
                // Russian
                "Русский": "Flutter & Dart - The Complete Guide - это комплексный онлайн-курс под руководством опытного инструктора Максимилиана Шварцмюллера. Этот курс предназначен как для новичков, так и для опытных разработчиков, которые хотят научиться создавать мобильные приложения с использованием Flutter и Dart. С более чем 30 часами видеоконтента студенты освоят основы Flutter, поймут язык программирования Dart и создадут реальные проекты с нуля. От создания пользовательских интерфейсов до управления состоянием и интеграции сторонних библиотек студенты получат прочную основу в разработке Flutter с помощью практических упражнений по кодированию и проектов. К концу этого курса студенты будут обладать знаниями и навыками, необходимыми для уверенного создания кроссплатформенных мобильных приложений с использованием Flutter.",
                // French
                "Français": "Flutter & Dart - The Complete Guide est un cours en ligne complet dirigé par l'instructeur expert Maximilian Schwarzmüller. Ce cours est conçu pour les développeurs débutants et expérimentés qui souhaitent apprendre à créer des applications mobiles à l'aide de Flutter et de Dart. Avec plus de 30 heures de contenu vidéo, les étudiants maîtriseront les principes fondamentaux de Flutter, comprendront le langage de programmation Dart et créeront des projets concrets à partir de zéro. De la création d'interfaces utilisateur à la gestion de l'état et à l'intégration de bibliothèques tierces, les étudiants acquerront une base solide dans le développement Flutter grâce à des exercices de codage pratiques et à des projets pratiques. À la fin de ce cours, les étudiants auront les connaissances et les compétences nécessaires pour créer en toute confiance des applications mobiles multiplateformes avec Flutter.",
                // Japanese
                "日本語": "Flutter & Dart - 完全ガイドは、専門講師の Maximilian Schwarzmüller が指導する総合的なオンライン コースです。このコースは、Flutter と Dart を使用してモバイル アプリケーションを構築する方法を学びたい初心者と経験豊富な開発者の両方を対象としています。30 時間を超えるビデオ コンテンツを通じて、受講者は Flutter の基礎を習得し、Dart プログラミング言語を理解し、実際のプロジェクトをゼロから作成します。ユーザー インターフェイスの構築から状態管理の処理、サードパーティ ライブラリの統合まで、受講者は実践的なコーディング演習と実用的なプロジェクトを通じて、Flutter 開発の強固な基礎を身に付けます。このコースを修了すると、受講者は Flutter を使用してクロスプラットフォーム モバイル アプリケーションを自信を持って作成するために必要な知識とスキルを身に付けます。",
                // Korean
                "한국인": "Flutter & Dart - The Complete Guide는 전문 강사 Maximilian Schwarzmüller가 진행하는 포괄적인 온라인 과정입니다. 이 과정은 Flutter와 Dart를 사용하여 모바일 애플리케이션을 만드는 방법을 배우고자 하는 초보자와 숙련된 개발자를 위해 설계되었습니다. 30시간 이상의 비디오 콘텐츠를 통해 학생들은 Flutter의 기본을 익히고 Dart 프로그래밍 언어를 이해하고 처음부터 실제 프로젝트를 만들 수 있습니다. 사용자 인터페이스 구축에서 상태 관리 처리 및 타사 라이브러리 통합에 이르기까지 학생들은 실습 코딩 연습과 실용적인 프로젝트를 통해 Flutter 개발에 대한 탄탄한 기초를 쌓을 것입니다. 이 과정을 마치면 학생들은 Flutter로 크로스 플랫폼 모바일 애플리케이션을 자신 있게 만드는 데 필요한 지식과 기술을 갖추게 됩니다.",
                // Spanish
                "Español": "Flutter & Dart - The Complete Guide es un curso en línea integral dirigido por el instructor experto Maximilian Schwarzmüller. Este curso está diseñado tanto para principiantes como para desarrolladores experimentados que quieran aprender a crear aplicaciones móviles con Flutter y Dart. Con más de 30 horas de contenido en video, los estudiantes dominarán los conceptos básicos de Flutter, comprenderán el lenguaje de programación Dart y crearán proyectos reales desde cero. Desde la creación de interfaces de usuario hasta el manejo de la gestión de estados y la integración de bibliotecas de terceros, los estudiantes obtendrán una base sólida en el desarrollo de Flutter a través de ejercicios prácticos de codificación y proyectos prácticos. Al final de este curso, los estudiantes tendrán el conocimiento y las habilidades necesarias para crear con confianza aplicaciones móviles multiplataforma con Flutter.",
                // Hindi
                "हिंदी": "फ़्लटर और डार्ट - द कम्प्लीट गाइड एक व्यापक ऑनलाइन कोर्स है जिसका नेतृत्व विशेषज्ञ प्रशिक्षक मैक्सिमिलियन श्वार्ज़मुलर कर रहे हैं। यह कोर्स शुरुआती और अनुभवी डेवलपर्स दोनों के लिए डिज़ाइन किया गया है जो फ़्लटर और डार्ट का उपयोग करके मोबाइल एप्लिकेशन बनाना सीखना चाहते हैं। 30 घंटे से ज़्यादा की वीडियो सामग्री के साथ, छात्र फ़्लटर की बुनियादी बातों में महारत हासिल करेंगे, डार्ट प्रोग्रामिंग भाषा को समझेंगे और स्क्रैच से वास्तविक दुनिया की परियोजनाएँ बनाएंगे। उपयोगकर्ता इंटरफ़ेस बनाने से लेकर स्टेट मैनेजमेंट को संभालने और थर्ड-पार्टी लाइब्रेरी को एकीकृत करने तक, छात्र व्यावहारिक कोडिंग अभ्यास और व्यावहारिक परियोजनाओं के माध्यम से फ़्लटर विकास में एक ठोस आधार प्राप्त करेंगे। इस कोर्स के अंत तक, छात्रों के पास फ़्लटर के साथ आत्मविश्वास से क्रॉस-प्लेटफ़ॉर्म मोबाइल एप्लिकेशन बनाने के लिए आवश्यक ज्ञान और कौशल होंगे।",
                // Portuguese
                "Português": "Flutter & Dart - The Complete Guide é um curso online abrangente, ministrado pelo instrutor especialista Maximilian Schwarzmüller. Este curso foi desenvolvido para programadores iniciantes e experientes que desejam aprender a construir aplicações móveis utilizando Flutter e Dart. Com mais de 30 horas de conteúdo de vídeo, os alunos dominarão os conceitos básicos do Flutter, compreenderão a linguagem de programação Dart e criarão projetos do mundo real a partir do zero. Desde a construção de interfaces de utilizador até à gestão de estado e à integração de bibliotecas de terceiros, os alunos obterão uma base sólida no desenvolvimento do Flutter através de exercícios práticos de codificação e projetos práticos. No final deste curso, os alunos terão os conhecimentos e as competências necessárias para criar com confiança aplicações móveis multiplataforma com Flutter.",
                // Bengali
                "বাংলা": "ফ্লাটার অ্যান্ড ডার্ট - সম্পূর্ণ গাইড হল বিশেষজ্ঞ প্রশিক্ষক ম্যাক্সিমিলিয়ান শোয়ার্জমুলারের নেতৃত্বে একটি ব্যাপক অনলাইন কোর্স। এই কোর্সটি নতুন এবং অভিজ্ঞ ডেভেলপারদের জন্য ডিজাইন করা হয়েছে যারা ফ্লটার এবং ডার্ট ব্যবহার করে মোবাইল অ্যাপ্লিকেশন তৈরি করতে শিখতে চান। 30 ঘন্টার বেশি ভিডিও সামগ্রী সহ, শিক্ষার্থীরা ফ্লটারের মৌলিক বিষয়গুলি আয়ত্ত করবে, ডার্ট প্রোগ্রামিং ভাষা বুঝতে পারবে এবং স্ক্র্যাচ থেকে বাস্তব-বিশ্বের প্রকল্পগুলি তৈরি করবে৷ ইউজার ইন্টারফেস তৈরি করা থেকে শুরু করে স্টেট ম্যানেজমেন্ট পরিচালনা এবং থার্ড-পার্টি লাইব্রেরিগুলোকে একীভূত করা, হ্যান্ডস-অন কোডিং ব্যায়াম এবং ব্যবহারিক প্রকল্পের মাধ্যমে শিক্ষার্থীরা ফ্লটার ডেভেলপমেন্টে একটি শক্ত ভিত্তি অর্জন করবে। এই কোর্সের শেষ নাগাদ, ছাত্রদের কাছে ফ্লটার সহ ক্রস-প্ল্যাটফর্ম মোবাইল অ্যাপ্লিকেশনগুলি আত্মবিশ্বাসের সাথে তৈরি করার জন্য প্রয়োজনীয় জ্ঞান এবং দক্ষতা থাকবে।",
                // Arabic
                "عَرَبِيّ": "Flutter & Dart - The Complete Guide هي دورة تدريبية شاملة عبر الإنترنت يقودها المدرب الخبير Maximilian Schwarzmüller. تم تصميم هذه الدورة التدريبية للمبتدئين والمطورين ذوي الخبرة على حد سواء الذين يرغبون في تعلم كيفية إنشاء تطبيقات جوال باستخدام Flutter وDart. مع أكثر من 30 ساعة من محتوى الفيديو، سيتمكن الطلاب من إتقان أساسيات Flutter وفهم لغة برمجة Dart وإنشاء مشاريع واقعية من الصفر. من بناء واجهات المستخدم إلى التعامل مع إدارة الحالة ودمج مكتبات الطرف الثالث، سيكتسب الطلاب أساسًا قويًا في تطوير Flutter من خلال تمارين الترميز العملية والمشاريع العملية. بحلول نهاية هذه الدورة التدريبية، سيكون لدى الطلاب المعرفة والمهارات اللازمة لإنشاء تطبيقات جوال متعددة الأنظمة بثقة باستخدام Flutter.",
                // Persian
                "فارسی": "Flutter & Dart - The Complete Guide یک دوره آنلاین جامع است که توسط مربی متخصص ماکسیمیلیان شوارتزمولر هدایت می شود. این دوره برای مبتدیان و توسعه دهندگان با تجربه طراحی شده است که می خواهند یاد بگیرند که چگونه با استفاده از فلاتر و دارت برنامه های موبایل بسازند. با بیش از 30 ساعت محتوای ویدیویی، دانش‌آموزان بر اصول فلاتر تسلط پیدا می‌کنند، زبان برنامه‌نویسی دارت را می‌فهمند و پروژه‌های دنیای واقعی را از ابتدا ایجاد می‌کنند. از ساخت رابط های کاربر گرفته تا مدیریت دولتی و ادغام کتابخانه های شخص ثالث، دانش آموزان از طریق تمرین های کدنویسی عملی و پروژه های عملی، پایه محکمی در توسعه Flutter به دست خواهند آورد. در پایان این دوره، دانش‌آموزان دانش و مهارت‌های مورد نیاز برای ایجاد مطمئن برنامه‌های موبایلی چند پلتفرمی با Flutter را خواهند داشت.",
            },
            "DetailPageScreenToShowEachBookDetails": "CRs/Flutter Developing/1 - Flutter & Dart - The Complete Guide/1 - Flutter & Dart - The Complete Guide.html",
        },
    ],
    // Full Stack Developer
    "Full Stack Developer": [
        // Django for Everybody
        {
            "CourseName": "Complete Django Course",
            "InstructorName": "Dennis Ivy",
            "Gender": "M", // F: Female, M: Male
            "CourseTime": {
                "English": "18 hours, 21 minutes",
                "Deutsch": "18 Stunden, 21 Minuten",
                "中国人": "18 小时 21 分钟",
                "Русский": "18 часов, 21 минута",
                "Français": "18 heures, 21 minutes",
                "日本語": "18時間21分",
                "한국인": "18시간 21분",
                "Español": "18 horas, 21 minutos",
                "हिंदी": "18 घंटे, 21 मिनट",
                "Português": "18 horas e 21 minutos",
                "বাংলা": "18 ঘন্টা, 21 মিনিট",
                "عَرَبِيّ": "١٨ ساعة و ٢١ دقيقة",
                "فارسی": "١٨ ساعت و ٢١ دقیقه",
            },
            "PlatformName": "Udemy",
            "Ratings": "4.5",
            "YearNumber": "2021",
            "ProgrammingLanguages": "Python and Django",
            "TableOfContents": [],
            "TotalDescriptionAboutTheBook": [
                // Paragraph 1
                {
                    // English
                    "English": "Dennis Ivy's Complete Django Course offers a comprehensive and engaging introduction to the powerful Python web framework. Whether you're a beginner or have some programming experience, Ivy's clear explanations and hands-on approach make learning Django a rewarding journey. The course covers essential topics such as project setup, models, views, templates, and databases, providing a solid foundation for building dynamic web applications.",
                    // German
                    "Deutsch": "Dennis Ivys kompletter Django-Kurs bietet eine umfassende und spannende Einführung in das leistungsstarke Python-Webframework. Egal, ob Sie Anfänger sind oder bereits Programmiererfahrung haben, Ivys klare Erklärungen und sein praktischer Ansatz machen das Erlernen von Django zu einer lohnenden Reise. Der Kurs behandelt wichtige Themen wie Projekteinrichtung, Modelle, Ansichten, Vorlagen und Datenbanken und bietet eine solide Grundlage für die Erstellung dynamischer Webanwendungen.",
                    // Chinese
                    "中国人": "Dennis Ivy 的完整 Django 课程全面而有趣地介绍了强大的 Python Web 框架。无论您是初学者还是有一定编程经验，Ivy 清晰的讲解和实践方法都会让学习 Django 成为一次有益的旅程。该课程涵盖了项目设置、模型、视图、模板和数据库等基本主题，为构建动态 Web 应用程序奠定了坚实的基础。",
                    // Russian
                    "Русский": "Полный курс Django Денниса Айви предлагает всестороннее и увлекательное введение в мощный веб-фреймворк Python. Независимо от того, новичок вы или имеете некоторый опыт программирования, понятные объяснения и практический подход Айви делают изучение Django полезным путешествием. Курс охватывает такие важные темы, как настройка проекта, модели, представления, шаблоны и базы данных, обеспечивая прочную основу для создания динамических веб-приложений.",
                    // French
                    "Français": "Le cours complet Django de Dennis Ivy propose une introduction complète et attrayante au puissant framework Web Python. Que vous soyez débutant ou que vous ayez une certaine expérience en programmation, les explications claires et l'approche pratique d'Ivy font de l'apprentissage de Django un parcours enrichissant. Le cours couvre des sujets essentiels tels que la configuration de projet, les modèles, les vues, les modèles et les bases de données, offrant une base solide pour la création d'applications Web dynamiques.",
                    // Japanese
                    "日本語": "Dennis Ivy の Complete Django コースでは、強力な Python Web フレームワークを包括的かつ魅力的に紹介します。初心者でも、プログラミング経験者でも、Ivy のわかりやすい説明と実践的なアプローチにより、Django の学習はやりがいのある旅になります。このコースでは、プロジェクトのセットアップ、モデル、ビュー、テンプレート、データベースなどの重要なトピックを取り上げ、動的な Web アプリケーションを構築するための強固な基盤を提供します。",
                    // Korean
                    "한국인": "데니스 아이비의 Django Complete Course는 강력한 Python 웹 프레임워크에 대한 포괄적이고 매력적인 소개를 제공합니다. 초보자이든 프로그래밍 경험이 있든 아이비의 명확한 설명과 실습적 접근 방식은 Django를 배우는 것을 보람 있는 여정으로 만듭니다. 이 과정은 프로젝트 설정, 모델, 뷰, 템플릿, 데이터베이스와 같은 필수 주제를 다루며 동적 웹 애플리케이션을 구축하기 위한 견고한 기반을 제공합니다.",
                    // Spanish
                    "Español": "El curso completo de Django de Dennis Ivy ofrece una introducción completa y atractiva al potente marco web Python. Tanto si eres principiante como si tienes algo de experiencia en programación, las explicaciones claras y el enfoque práctico de Ivy hacen que aprender Django sea una experiencia gratificante. El curso cubre temas esenciales como la configuración de proyectos, modelos, vistas, plantillas y bases de datos, lo que proporciona una base sólida para crear aplicaciones web dinámicas.",
                    // Hindi
                    "हिंदी": "डेनिस आइवी का संपूर्ण Django कोर्स शक्तिशाली पायथन वेब फ्रेमवर्क के लिए एक व्यापक और आकर्षक परिचय प्रदान करता है। चाहे आप शुरुआती हों या आपको प्रोग्रामिंग का कुछ अनुभव हो, आइवी की स्पष्ट व्याख्याएँ और व्यावहारिक दृष्टिकोण Django को सीखना एक पुरस्कृत यात्रा बनाते हैं। पाठ्यक्रम में प्रोजेक्ट सेटअप, मॉडल, दृश्य, टेम्प्लेट और डेटाबेस जैसे आवश्यक विषयों को शामिल किया गया है, जो गतिशील वेब एप्लिकेशन बनाने के लिए एक ठोस आधार प्रदान करता है।",
                    // Portuguese
                    "Português": "O curso completo de Django de Dennis Ivy oferece uma introdução abrangente e envolvente à poderosa framework web Python. Quer seja principiante ou tenha alguma experiência em programação, as explicações claras e a abordagem prática de Ivy tornam a aprendizagem do Django numa viagem gratificante. O curso abrange tópicos essenciais como a configuração de projetos, modelos, visualizações, modelos e bases de dados, fornecendo uma base sólida para a construção de aplicações web dinâmicas.",
                    // Bengali
                    "বাংলা": "ডেনিস আইভির সম্পূর্ণ জ্যাঙ্গো কোর্স শক্তিশালী পাইথন ওয়েব ফ্রেমওয়ার্কের একটি ব্যাপক এবং আকর্ষক ভূমিকা প্রদান করে। আপনি একজন শিক্ষানবিস হোন বা কিছু প্রোগ্রামিং অভিজ্ঞতা থাকুক না কেন, আইভির স্পষ্ট ব্যাখ্যা এবং হাতে-কলমে পদ্ধতি জ্যাঙ্গো শেখাকে একটি ফলপ্রসূ যাত্রা করে তোলে। এই কোর্সে প্রজেক্ট সেটআপ, মডেল, ভিউ, টেমপ্লেট এবং ডাটাবেসের মতো প্রয়োজনীয় বিষয়গুলিকে কভার করে, যা গতিশীল ওয়েব অ্যাপ্লিকেশন তৈরির জন্য একটি শক্ত ভিত্তি প্রদান করে।",
                    // Arabic
                    "عَرَبِيّ": "تقدم دورة Django الكاملة التي يقدمها دينيس آيفي مقدمة شاملة وجذابة لإطار عمل الويب القوي Python. سواء كنت مبتدئًا أو لديك بعض الخبرة في البرمجة، فإن تفسيرات آيفي الواضحة ونهجه العملي يجعلان تعلم Django رحلة مجزية. تغطي الدورة مواضيع أساسية مثل إعداد المشروع والنماذج والعروض والقوالب وقواعد البيانات، مما يوفر أساسًا قويًا لبناء تطبيقات الويب الديناميكية.",
                    // Persian
                    "فارسی": "دوره کامل جنگو دنیس آیوی مقدمه ای جامع و جذاب برای چارچوب وب قدرتمند پایتون ارائه می دهد. چه مبتدی باشید و چه تجربه برنامه نویسی داشته باشید، توضیحات واضح و رویکرد عملی آیوی، یادگیری جنگو را به یک سفر مفید تبدیل می کند. این دوره موضوعات ضروری مانند راه اندازی پروژه، مدل ها، نماها، قالب ها و پایگاه های داده را پوشش می دهد و پایه ای محکم برای ساخت برنامه های کاربردی وب پویا فراهم می کند.",
                },
                // Paragraph 2
                {
                    // English
                    "English": "One of the standout features of this course is its focus on real-world applications. Ivy guides learners through the process of creating a fully functional social media platform, demonstrating how Django can be used to build complex and interactive websites. This practical approach not only reinforces the concepts learned but also inspires students to explore their own creative projects.",
                    // German
                    "Deutsch": "Eines der herausragenden Merkmale dieses Kurses ist sein Fokus auf reale Anwendungen. Ivy führt die Lernenden durch den Prozess der Erstellung einer voll funktionsfähigen Social-Media-Plattform und zeigt, wie mit Django komplexe und interaktive Websites erstellt werden können. Dieser praktische Ansatz festigt nicht nur die erlernten Konzepte, sondern inspiriert die Schüler auch dazu, ihre eigenen kreativen Projekte zu erkunden.",
                    // Chinese
                    "中国人": "本课程的一大特色是注重实际应用。Ivy 指导学习者完成创建功能齐全的社交媒体平台的过程，展示如何使用 Django 构建复杂且交互式的网站。这种实用的方法不仅可以巩固所学的概念，还可以激励学生探索自己的创意项目。",
                    // Russian
                    "Русский": "Одной из выдающихся особенностей этого курса является его фокус на реальных приложениях. Айви проводит учащихся через процесс создания полностью функциональной платформы социальных сетей, демонстрируя, как Django может использоваться для создания сложных и интерактивных веб-сайтов. Этот практический подход не только закрепляет изученные концепции, но и вдохновляет учащихся на исследование собственных творческих проектов.",
                    // French
                    "Français": "L'une des caractéristiques marquantes de ce cours est l'accent mis sur les applications concrètes. Ivy guide les apprenants tout au long du processus de création d'une plateforme de médias sociaux entièrement fonctionnelle, en leur montrant comment Django peut être utilisé pour créer des sites Web complexes et interactifs. Cette approche pratique renforce non seulement les concepts appris, mais incite également les étudiants à explorer leurs propres projets créatifs.",
                    // Japanese
                    "日本語": "このコースの際立った特徴の 1 つは、実際のアプリケーションに重点を置いていることです。Ivy は、学習者を完全な機能を備えたソーシャル メディア プラットフォームの作成プロセスに導き、Django を使用して複雑でインタラクティブな Web サイトを構築する方法を示します。この実践的なアプローチは、学習した概念を強化するだけでなく、学生が独自のクリエイティブ プロジェクトを探求する意欲を刺激します。",
                    // Korean
                    "한국인": "이 과정의 두드러진 특징 중 하나는 실제 세계 응용 프로그램에 초점을 맞춘다는 것입니다. Ivy는 학습자에게 완벽하게 기능하는 소셜 미디어 플랫폼을 만드는 과정을 안내하여 Django를 사용하여 복잡하고 상호 작용적인 웹사이트를 구축하는 방법을 보여줍니다. 이러한 실용적인 접근 방식은 학습한 개념을 강화할 뿐만 아니라 학생들이 자신의 창의적인 프로젝트를 탐구하도록 영감을 줍니다.",
                    // Spanish
                    "Español": "Una de las características más destacadas de este curso es su enfoque en aplicaciones del mundo real. Ivy guía a los estudiantes a través del proceso de creación de una plataforma de redes sociales completamente funcional, demostrando cómo se puede utilizar Django para crear sitios web complejos e interactivos. Este enfoque práctico no solo refuerza los conceptos aprendidos, sino que también inspira a los estudiantes a explorar sus propios proyectos creativos.",
                    // Hindi
                    "हिंदी": "इस कोर्स की एक खास विशेषता यह है कि इसका फोकस वास्तविक दुनिया के अनुप्रयोगों पर है। आइवी पूरी तरह कार्यात्मक सोशल मीडिया प्लेटफॉर्म बनाने की प्रक्रिया के माध्यम से शिक्षार्थियों का मार्गदर्शन करता है, यह दर्शाता है कि जटिल और इंटरैक्टिव वेबसाइट बनाने के लिए Django का उपयोग कैसे किया जा सकता है। यह व्यावहारिक दृष्टिकोण न केवल सीखी गई अवधारणाओं को पुष्ट करता है बल्कि छात्रों को अपनी खुद की रचनात्मक परियोजनाओं का पता लगाने के लिए भी प्रेरित करता है।",
                    // Portuguese
                    "Português": "Uma das características de destaque deste curso é o foco nas aplicações do mundo real. Ivy orienta os alunos no processo de criação de uma plataforma de redes sociais totalmente funcional, demonstrando como o Django pode ser utilizado para construir sites complexos e interativos. Esta abordagem prática não só reforça os conceitos aprendidos, como também inspira os alunos a explorar os seus próprios projetos criativos.",
                    // Bengali
                    "বাংলা": "এই কোর্সের স্ট্যান্ডআউট বৈশিষ্ট্যগুলির মধ্যে একটি হল বাস্তব-বিশ্বের অ্যাপ্লিকেশনগুলিতে এর ফোকাস। Ivy একটি সম্পূর্ণ কার্যকরী সোশ্যাল মিডিয়া প্ল্যাটফর্ম তৈরি করার প্রক্রিয়ার মাধ্যমে শিক্ষার্থীদের গাইড করে, কীভাবে জ্যাঙ্গোকে জটিল এবং ইন্টারেক্টিভ ওয়েবসাইট তৈরি করতে ব্যবহার করা যেতে পারে তা প্রদর্শন করে। এই ব্যবহারিক পদ্ধতিটি শুধুমাত্র শেখা ধারণাগুলিকে শক্তিশালী করে না বরং শিক্ষার্থীদের তাদের নিজস্ব সৃজনশীল প্রকল্পগুলি অন্বেষণ করতে অনুপ্রাণিত করে।",
                    // Arabic
                    "عَرَبِيّ": "من بين السمات البارزة لهذه الدورة التدريبية التركيز على التطبيقات في العالم الحقيقي. حيث ترشد آيفي المتعلمين خلال عملية إنشاء منصة وسائط اجتماعية وظيفية بالكامل، وتوضح كيف يمكن استخدام Django لبناء مواقع ويب معقدة وتفاعلية. ولا يعمل هذا النهج العملي على تعزيز المفاهيم التي تعلموها فحسب، بل يلهم الطلاب أيضًا لاستكشاف مشاريعهم الإبداعية الخاصة.",
                    // Persian
                    "فارسی": "یکی از ویژگی های برجسته این دوره، تمرکز آن بر برنامه های کاربردی در دنیای واقعی است. Ivy فراگیران را از طریق فرآیند ایجاد یک پلتفرم رسانه اجتماعی کاملاً کاربردی راهنمایی می کند و نشان می دهد که چگونه می توان از جنگو برای ساخت وب سایت های پیچیده و تعاملی استفاده کرد. این رویکرد عملی نه تنها مفاهیم آموخته شده را تقویت می کند، بلکه دانش آموزان را برای کشف پروژه های خلاقانه خود ترغیب می کند.",
                },
                // Paragraph 3
                {
                    // English
                    "English": "In addition to the core curriculum, the course includes valuable supplementary materials, such as downloadable code examples and project templates. These resources allow learners to practice and experiment with Django concepts at their own pace. Furthermore, Ivy's commitment to providing ongoing support and updates ensures that students have access to the latest information and best practices in the Django ecosystem.",
                    // German
                    "Deutsch": "Zusätzlich zum Kernlehrplan enthält der Kurs wertvolle Zusatzmaterialien wie herunterladbare Codebeispiele und Projektvorlagen. Diese Ressourcen ermöglichen es den Lernenden, Django-Konzepte in ihrem eigenen Tempo zu üben und damit zu experimentieren. Darüber hinaus stellt Ivys Engagement für kontinuierliche Unterstützung und Updates sicher, dass die Studierenden Zugriff auf die neuesten Informationen und Best Practices im Django-Ökosystem haben.",
                    // Chinese
                    "中国人": "除了核心课程外，该课程还包括有价值的补充材料，例如可下载的代码示例和项目模板。这些资源允许学习者按照自己的节奏练习和试验 Django 概念。此外，Ivy 致力于提供持续的支持和更新，确保学生能够获得 Django 生态系统中的最新信息和最佳实践。",
                    // Russian
                    "Русский": "В дополнение к основной программе курс включает ценные дополнительные материалы, такие как загружаемые примеры кода и шаблоны проектов. Эти ресурсы позволяют учащимся практиковаться и экспериментировать с концепциями Django в своем собственном темпе. Кроме того, приверженность Ivy предоставлению постоянной поддержки и обновлений гарантирует, что учащиеся будут иметь доступ к последней информации и лучшим практикам в экосистеме Django.",
                    // French
                    "Français": "En plus du programme de base, le cours comprend des ressources complémentaires utiles, telles que des exemples de code téléchargeables et des modèles de projets. Ces ressources permettent aux apprenants de pratiquer et d'expérimenter les concepts de Django à leur propre rythme. De plus, l'engagement d'Ivy à fournir un soutien et des mises à jour continus garantit aux étudiants l'accès aux dernières informations et aux meilleures pratiques de l'écosystème Django.",
                    // Japanese
                    "日本語": "コースには、コアカリキュラムに加えて、ダウンロード可能なコード例やプロジェクト テンプレートなどの貴重な補足資料が含まれています。これらのリソースにより、学習者は自分のペースで Django の概念を実践し、実験することができます。さらに、Ivy は継続的なサポートと更新を提供するという約束をしているため、学生は Django エコシステムの最新情報とベスト プラクティスにアクセスできます。",
                    // Korean
                    "한국인": "핵심 커리큘럼 외에도 이 과정에는 다운로드 가능한 코드 예제 및 프로젝트 템플릿과 같은 귀중한 보충 자료가 포함되어 있습니다. 이러한 리소스를 통해 학습자는 자신의 속도에 맞춰 Django 개념을 연습하고 실험할 수 있습니다. 또한 Ivy는 지속적인 지원과 업데이트를 제공함으로써 학생들이 Django 생태계의 최신 정보와 모범 사례에 액세스할 수 있도록 보장합니다.",
                    // Spanish
                    "Español": "Además del plan de estudios básico, el curso incluye valiosos materiales complementarios, como ejemplos de código descargables y plantillas de proyectos. Estos recursos permiten a los alumnos practicar y experimentar con los conceptos de Django a su propio ritmo. Además, el compromiso de Ivy de brindar soporte y actualizaciones constantes garantiza que los estudiantes tengan acceso a la información más reciente y las mejores prácticas en el ecosistema de Django.",
                    // Hindi
                    "हिंदी": "मुख्य पाठ्यक्रम के अलावा, पाठ्यक्रम में मूल्यवान पूरक सामग्री शामिल है, जैसे डाउनलोड करने योग्य कोड उदाहरण और प्रोजेक्ट टेम्पलेट। ये संसाधन शिक्षार्थियों को अपनी गति से Django अवधारणाओं का अभ्यास और प्रयोग करने की अनुमति देते हैं। इसके अलावा, निरंतर समर्थन और अपडेट प्रदान करने के लिए आइवी की प्रतिबद्धता यह सुनिश्चित करती है कि छात्रों को Django पारिस्थितिकी तंत्र में नवीनतम जानकारी और सर्वोत्तम प्रथाओं तक पहुँच प्राप्त हो।",
                    // Portuguese
                    "Português": "Além do currículo básico, o curso inclui materiais complementares valiosos, como exemplos de código para download e modelos de projetos. Estas características permitem que os alunos pratiquem e experimentem os conceitos do Django ao seu próprio ritmo. Além disso, o compromisso da Ivy em fornecer apoio e atualizações contínuas garante que os alunos têm acesso às informações mais recentes e às melhores práticas no ecossistema Django.",
                    // Bengali
                    "বাংলা": "মূল পাঠ্যক্রমের পাশাপাশি, কোর্সে মূল্যবান সম্পূরক উপকরণ রয়েছে, যেমন ডাউনলোডযোগ্য কোড উদাহরণ এবং প্রকল্প টেমপ্লেট। এই সংস্থানগুলি শিক্ষার্থীদের তাদের নিজস্ব গতিতে জ্যাঙ্গো ধারণাগুলি অনুশীলন এবং পরীক্ষা করার অনুমতি দেয়। তদুপরি, চলমান সহায়তা এবং আপডেটগুলি প্রদানের জন্য আইভির প্রতিশ্রুতি নিশ্চিত করে যে ছাত্রদের জ্যাঙ্গো ইকোসিস্টেমের সর্বশেষ তথ্য এবং সর্বোত্তম অনুশীলনগুলিতে অ্যাক্সেস রয়েছে।",
                    // Arabic
                    "عَرَبِيّ": "بالإضافة إلى المنهج الأساسي، تتضمن الدورة مواد تكميلية قيمة، مثل أمثلة التعليمات البرمجية القابلة للتنزيل وقوالب المشروع. تتيح هذه الموارد للمتعلمين ممارسة مفاهيم Django وتجربتها بالسرعة التي تناسبهم. علاوة على ذلك، يضمن التزام Ivy بتقديم الدعم المستمر والتحديثات حصول الطلاب على أحدث المعلومات وأفضل الممارسات في نظام Django البيئي.",
                    // Persian
                    "فارسی": "علاوه بر برنامه درسی اصلی، این دوره شامل مواد تکمیلی ارزشمندی مانند نمونه های کد قابل دانلود و قالب های پروژه است. این منابع به زبان آموزان اجازه می دهد تا مفاهیم جنگو را با سرعت خود تمرین و آزمایش کنند. علاوه بر این، تعهد آیوی به ارائه پشتیبانی و به روز رسانی مداوم تضمین می کند که دانش آموزان به آخرین اطلاعات و بهترین شیوه ها در اکوسیستم جنگو دسترسی دارند.",
                },
            ],
            "CourseCoverImagePath": "../assets/img/Courses Covers/Full Stack Development/3 - Django Complete Course.webp",
            "shortDescriptionsForCourseReviewing": {
                // English
                "English": "Dennis Ivy's Complete Django Course offers a comprehensive and engaging introduction to the powerful Python web framework. Ivy's clear explanations and hands-on approach make learning Django a rewarding journey, covering essential topics such as project setup, models, views, templates, and databases. The course culminates in the creation of a real-world social media platform, demonstrating how Django can be used to build dynamic and interactive web applications.",
                // German
                "Deutsch": "Dennis Ivys kompletter Django-Kurs bietet eine umfassende und spannende Einführung in das leistungsstarke Python-Webframework. Ivys klare Erklärungen und sein praktischer Ansatz machen das Erlernen von Django zu einer lohnenden Reise und behandeln wichtige Themen wie Projekteinrichtung, Modelle, Ansichten, Vorlagen und Datenbanken. Der Kurs gipfelt in der Erstellung einer realen Social-Media-Plattform und zeigt, wie Django zum Erstellen dynamischer und interaktiver Webanwendungen verwendet werden kann.",
                // Chinese
                "中国人": "Dennis Ivy 的完整 Django 课程全面而引人入胜地介绍了强大的 Python Web 框架。Ivy 清晰的讲解和实践方法使学习 Django 成为一次有益的旅程，涵盖了项目设置、模型、视图、模板和数据库等基本主题。该课程最终创建了一个真实的社交媒体平台，展示了如何使用 Django 构建动态和交互式 Web 应用程序。",
                // Russian
                "Русский": "Полный курс Django Денниса Айви предлагает всестороннее и увлекательное введение в мощный веб-фреймворк Python. Четкие объяснения Айви и практический подход делают изучение Django полезным путешествием, охватывающим такие важные темы, как настройка проекта, модели, представления, шаблоны и базы данных. Курс завершается созданием реальной платформы социальных сетей, демонстрируя, как Django можно использовать для создания динамических и интерактивных веб-приложений.",
                // French
                "Français": "Le cours complet Django de Dennis Ivy propose une introduction complète et attrayante au puissant framework Web Python. Les explications claires et l'approche pratique d'Ivy font de l'apprentissage de Django un voyage enrichissant, couvrant des sujets essentiels tels que la configuration de projet, les modèles, les vues, les modèles et les bases de données. Le cours se termine par la création d'une plate-forme de médias sociaux réelle, démontrant comment Django peut être utilisé pour créer des applications Web dynamiques et interactives.",
                // Japanese
                "日本語": "Dennis Ivy の Complete Django コースでは、強力な Python Web フレームワークを包括的かつ魅力的に紹介します。Ivy のわかりやすい説明と実践的なアプローチにより、プロジェクトのセットアップ、モデル、ビュー、テンプレート、データベースなどの重要なトピックを網羅し、Django の学習がやりがいのあるものになります。このコースの最後は、実際のソーシャル メディア プラットフォームの作成で、Django を使用して動的でインタラクティブな Web アプリケーションを構築する方法を説明します。",
                // Korean
                "한국인": "데니스 아이비의 Django Complete Course는 강력한 Python 웹 프레임워크에 대한 포괄적이고 매력적인 소개를 제공합니다. 아이비의 명확한 설명과 실습적인 접근 방식은 Django를 배우는 것을 보람 있는 여정으로 만들어 프로젝트 설정, 모델, 뷰, 템플릿, 데이터베이스와 같은 필수 주제를 다룹니다. 이 과정은 실제 소셜 미디어 플랫폼을 만드는 것으로 마무리되며, Django를 사용하여 동적이고 대화형 웹 애플리케이션을 구축하는 방법을 보여줍니다.",
                // Spanish
                "Español": "El curso completo de Django de Dennis Ivy ofrece una introducción completa y atractiva al potente marco web Python. Las explicaciones claras de Ivy y su enfoque práctico hacen que aprender Django sea una experiencia gratificante, que abarca temas esenciales como la configuración de proyectos, modelos, vistas, plantillas y bases de datos. El curso culmina con la creación de una plataforma de redes sociales del mundo real, que demuestra cómo se puede utilizar Django para crear aplicaciones web dinámicas e interactivas.",
                // Hindi
                "हिंदी": "डेनिस आइवी का संपूर्ण Django कोर्स शक्तिशाली पायथन वेब फ्रेमवर्क के लिए एक व्यापक और आकर्षक परिचय प्रदान करता है। आइवी के स्पष्ट स्पष्टीकरण और व्यावहारिक दृष्टिकोण Django को सीखना एक पुरस्कृत यात्रा बनाते हैं, जिसमें प्रोजेक्ट सेटअप, मॉडल, दृश्य, टेम्पलेट और डेटाबेस जैसे आवश्यक विषय शामिल हैं। पाठ्यक्रम वास्तविक दुनिया के सोशल मीडिया प्लेटफ़ॉर्म के निर्माण में परिणत होता है, जो दर्शाता है कि गतिशील और इंटरैक्टिव वेब एप्लिकेशन बनाने के लिए Django का उपयोग कैसे किया जा सकता है।",
                // Portuguese
                "Português": "O curso completo de Django de Dennis Ivy oferece uma introdução abrangente e envolvente à poderosa framework web Python. As explicações claras e a abordagem prática de Ivy tornam a aprendizagem do Django numa viagem gratificante, abrangendo tópicos essenciais como a configuração de projetos, modelos, visualizações, modelos e bases de dados. O curso culmina na criação de uma plataforma de redes sociais do mundo real, demonstrando como o Django pode ser utilizado para construir aplicações web dinâmicas e interativas.",
                // Bengali
                "বাংলা": "ডেনিস আইভির সম্পূর্ণ জ্যাঙ্গো কোর্স শক্তিশালী পাইথন ওয়েব ফ্রেমওয়ার্কের একটি ব্যাপক এবং আকর্ষক ভূমিকা প্রদান করে। আইভির স্পষ্ট ব্যাখ্যা এবং হ্যান্ডস-অন পদ্ধতি জ্যাঙ্গো শেখাকে একটি পুরস্কৃত যাত্রা করে তোলে, প্রকল্প সেটআপ, মডেল, দৃশ্য, টেমপ্লেট এবং ডেটাবেসের মতো প্রয়োজনীয় বিষয়গুলিকে কভার করে৷ কোর্সটি একটি বাস্তব-বিশ্ব সোশ্যাল মিডিয়া প্ল্যাটফর্ম তৈরিতে সমাপ্ত হয়, এটি প্রদর্শন করে যে কীভাবে গতিশীল এবং ইন্টারেক্টিভ ওয়েব অ্যাপ্লিকেশন তৈরি করতে জ্যাঙ্গো ব্যবহার করা যেতে পারে।",
                // Arabic
                "عَرَبِيّ": "تقدم دورة Django الكاملة التي يقدمها دينيس آيفي مقدمة شاملة وجذابة لإطار عمل الويب القوي Python. تجعل تفسيرات آيفي الواضحة ونهجه العملي من تعلم Django رحلة مجزية، حيث تغطي مواضيع أساسية مثل إعداد المشروع والنماذج والعروض والقوالب وقواعد البيانات. تتوج الدورة بإنشاء منصة وسائط اجتماعية في العالم الحقيقي، مما يوضح كيف يمكن استخدام Django لبناء تطبيقات ويب ديناميكية وتفاعلية.",
                // Persian
                "فارسی": "دوره کامل جنگو دنیس آیوی مقدمه ای جامع و جذاب برای چارچوب وب قدرتمند پایتون ارائه می دهد. توضیحات واضح و رویکرد عملی آیوی، یادگیری جنگو را به سفری پرارزش تبدیل می‌کند و موضوعات ضروری مانند راه‌اندازی پروژه، مدل‌ها، نماها، قالب‌ها و پایگاه‌های داده را پوشش می‌دهد. این دوره با ایجاد یک پلتفرم رسانه اجتماعی در دنیای واقعی به اوج خود می رسد و نشان می دهد که چگونه می توان از جنگو برای ساخت برنامه های کاربردی وب پویا و تعاملی استفاده کرد.",
            },
            "DetailPageScreenToShowEachBookDetails": "CRs/Full Stack Development/3 - Django Complete Course/3 - Django Complete Course.html",
        },
        // Django for Everybody
        {
            "CourseName": "Django for Everybody",
            "InstructorName": "Charles Russell Severance",
            "Gender": "M", // F: Female, M: Male
            "CourseTime": {
                "English": "60 hours",
                "Deutsch": "60 Stunden",
                "中国人": "60 小时",
                "Русский": "60 часов",
                "Français": "60 heures",
                "日本語": "60時間",
                "한국인": "60시간",
                "Español": "60 horas",
                "हिंदी": "60 घंटे",
                "Português": "60 horas",
                "বাংলা": "60 ঘন্টা",
                "عَرَبِيّ": "٦٠ ساعة",
                "فارسی": "٦٠ ساعت",
            },
            "PlatformName": "Coursera",
            "Ratings": "4.7",
            "YearNumber": "2023",
            "ProgrammingLanguages": "Python and Django",
            "TableOfContents": [],
            "TotalDescriptionAboutTheBook": [
                // Paragraph 1
                {
                    // English
                    "English": "Django for Everybody is a popular online course created and taught by Dr. Charles Russell Severance, commonly known as Dr. Chuck, through the University of Michigan on the Coursera platform. The course is designed to cater to individuals of all levels of expertise, from beginners to experienced programmers, who are interested in learning how to develop web applications using Django, a widely-used web framework built on Python. Dr. Chuck's teaching approach is highly engaging and accessible, making even complex concepts easy to grasp for learners with varying backgrounds in programming. By the end of the course, participants will have a solid understanding of Django and be able to create interactive, database-driven web applications.",
                    // German
                    "Deutsch": "„Django für alle“ ist ein beliebter Onlinekurs, der von Dr. Charles Russell Severance, besser bekannt als Dr. Chuck, an der University of Michigan auf der Coursera-Plattform entwickelt und unterrichtet wird. Der Kurs richtet sich an Personen aller Erfahrungsstufen, vom Anfänger bis zum erfahrenen Programmierer, die lernen möchten, wie man Webanwendungen mit Django entwickelt, einem weit verbreiteten Webframework auf Basis von Python. Dr. Chucks Lehransatz ist sehr ansprechend und zugänglich, sodass selbst komplexe Konzepte für Lernende mit unterschiedlichem Programmierhintergrund leicht verständlich sind. Am Ende des Kurses verfügen die Teilnehmer über ein solides Verständnis von Django und können interaktive, datenbankgesteuerte Webanwendungen erstellen.",
                    // Chinese
                    "中国人": "Django for Everybody 是一门流行的在线课程，由 Charles Russell Severance 博士（通常被称为 Chuck 博士）通过密歇根大学 Coursera 平台创建和教授。该课程旨在满足从初学者到经验丰富的程序员等各个专业水平的个人的需求，他们有兴趣学习如何使用 Django（一种基于 Python 构建的广泛使用的 Web 框架）开发 Web 应用程序。Chuck 博士的教学方法极具吸引力且易于理解，即使是复杂的概念，对于具有不同编程背景的学习者来说也很容易掌握。在课程结束时，参与者将对 Django 有扎实的理解，并能够创建交互式的、数据库驱动的 Web 应用程序。",
                    // Russian
                    "Русский": "Django for Everybody — популярный онлайн-курс, созданный и преподаваемый доктором Чарльзом Расселом Северансом, широко известным как доктор Чак, в Мичиганском университете на платформе Coursera. Курс рассчитан на людей с любым уровнем подготовки, от новичков до опытных программистов, желающих научиться разрабатывать веб-приложения с использованием Django, широко используемого веб-фреймворка, созданного на основе Python. Подход доктора Чака к обучению очень интересен и доступен, что делает даже сложные концепции простыми для понимания для учащихся с различным опытом программирования. К концу курса участники будут иметь прочное понимание Django и смогут создавать интерактивные веб-приложения, управляемые базами данных.",
                    // French
                    "Français": "Django for Everybody est un cours en ligne populaire créé et enseigné par le Dr Charles Russell Severance, communément appelé Dr Chuck, par l'intermédiaire de l'Université du Michigan sur la plateforme Coursera. Le cours est conçu pour répondre aux besoins des personnes de tous niveaux d'expertise, des débutants aux programmeurs expérimentés, qui souhaitent apprendre à développer des applications Web à l'aide de Django, un framework Web largement utilisé basé sur Python. L'approche pédagogique du Dr Chuck est très engageante et accessible, ce qui rend même les concepts complexes faciles à comprendre pour les apprenants ayant des antécédents variés en programmation. À la fin du cours, les participants auront une solide compréhension de Django et seront capables de créer des applications Web interactives basées sur des bases de données.",
                    // Japanese
                    "日本語": "Django for Everybody は、ミシガン大学の Coursera プラットフォームで、通称 Dr. Chuck として知られる Charles Russell Severance 博士が作成し、指導する人気のオンライン コースです。このコースは、Python で構築された広く使用されている Web フレームワークである Django を使用して Web アプリケーションを開発する方法を学習したい初心者から経験豊富なプログラマーまで、あらゆるレベルの専門知識を持つ個人に対応できるように設計されています。Dr. Chuck の指導方法は非常に魅力的でわかりやすく、プログラミングのさまざまなバックグラウンドを持つ学習者でも複雑な概念を簡単に理解できます。コースの終了までに、参加者は Django をしっかりと理解し、インタラクティブなデータベース駆動型 Web アプリケーションを作成できるようになります。",
                    // Korean
                    "한국인": "Django for Everybody는 Dr. Charles Russell Severance, 흔히 Dr. Chuck으로 알려진 사람이 Coursera 플랫폼에서 Michigan 대학을 통해 만들고 가르치는 인기 있는 온라인 과정입니다. 이 과정은 Python을 기반으로 하는 널리 사용되는 웹 프레임워크인 Django를 사용하여 웹 애플리케이션을 개발하는 방법을 배우고자 하는 초보자부터 숙련된 프로그래머까지 모든 수준의 전문성을 가진 개인을 대상으로 설계되었습니다. Dr. Chuck의 교육 방식은 매우 매력적이고 접근하기 쉬워 프로그래밍에 대한 배경이 다양한 학습자가 복잡한 개념도 쉽게 이해할 수 있습니다. 과정을 마치면 참가자는 Django에 대한 확실한 이해를 얻고 대화형 데이터베이스 기반 웹 애플리케이션을 만들 수 있게 됩니다.",
                    // Spanish
                    "Español": "Django para todos es un popular curso en línea creado y dictado por el Dr. Charles Russell Severance, más conocido como Dr. Chuck, a través de la Universidad de Michigan en la plataforma Coursera. El curso está diseñado para personas de todos los niveles de experiencia, desde principiantes hasta programadores experimentados, que estén interesados ​​en aprender a desarrollar aplicaciones web utilizando Django, un marco web ampliamente utilizado creado en Python. El enfoque de enseñanza del Dr. Chuck es muy atractivo y accesible, lo que hace que incluso los conceptos complejos sean fáciles de comprender para los estudiantes con diferentes antecedentes en programación. Al final del curso, los participantes tendrán una sólida comprensión de Django y podrán crear aplicaciones web interactivas basadas en bases de datos.",
                    // Hindi
                    "हिंदी": "Django for Everyone एक लोकप्रिय ऑनलाइन कोर्स है जिसे डॉ. चार्ल्स रसेल सेवरेंस ने बनाया और पढ़ाया है, जिन्हें आमतौर पर डॉ. चक के नाम से जाना जाता है, उन्होंने मिशिगन विश्वविद्यालय के माध्यम से कोर्सेरा प्लेटफ़ॉर्म पर पढ़ाया है। यह कोर्स सभी स्तरों की विशेषज्ञता वाले व्यक्तियों को ध्यान में रखकर बनाया गया है, शुरुआती से लेकर अनुभवी प्रोग्रामर तक, जो Django का उपयोग करके वेब एप्लिकेशन विकसित करना सीखने में रुचि रखते हैं, जो कि Python पर निर्मित एक व्यापक रूप से उपयोग किया जाने वाला वेब फ्रेमवर्क है। डॉ. चक का शिक्षण दृष्टिकोण अत्यधिक आकर्षक और सुलभ है, जो प्रोग्रामिंग में अलग-अलग पृष्ठभूमि वाले शिक्षार्थियों के लिए जटिल अवधारणाओं को भी समझना आसान बनाता है। कोर्स के अंत तक, प्रतिभागियों को Django की ठोस समझ हो जाएगी और वे इंटरैक्टिव, डेटाबेस-संचालित वेब एप्लिकेशन बनाने में सक्षम होंगे।",
                    // Portuguese
                    "Português": "Django for Everybody é um curso online popular criado e ministrado pelo Dr. Charles Russell Severance, vulgarmente conhecido como Dr. Chuck, pela Universidade de Michigan na plataforma Coursera. O curso foi desenvolvido para atender indivíduos de todos os níveis de especialização, desde iniciantes a programadores experientes, que estejam interessados ​​em aprender a desenvolver aplicações web utilizando Django, um framework web amplamente utilizado construído em Python. A abordagem de ensino do Dr. Chuck é altamente envolvente e acessível, tornando até mesmo conceitos complexos fáceis de compreender para estudantes com experiências variadas em programação. No final do curso, os participantes terão um conhecimento sólido de Django e serão capazes de criar aplicações web interativas e baseadas em base de dados.",
                    // Bengali
                    "বাংলা": "জ্যাঙ্গো ফর এভরিবডি একটি জনপ্রিয় অনলাইন কোর্স যা কোর্সেরা প্ল্যাটফর্মে মিশিগান বিশ্ববিদ্যালয়ের মাধ্যমে ড. চার্লস রাসেল সেভারেন্স, সাধারণত ড. চাক নামে পরিচিত, দ্বারা তৈরি এবং শেখানো হয়। কোর্সটি ডিজাইন করা হয়েছে সকল স্তরের দক্ষতার ব্যক্তিদের, নতুনদের থেকে অভিজ্ঞ প্রোগ্রামারদের জন্য, যারা পাইথনে নির্মিত একটি বহুল-ব্যবহৃত ওয়েব ফ্রেমওয়ার্ক জ্যাঙ্গো ব্যবহার করে কীভাবে ওয়েব অ্যাপ্লিকেশন তৈরি করতে হয় তা শিখতে আগ্রহী। ডঃ চাকের শিক্ষার পদ্ধতি অত্যন্ত আকর্ষক এবং অ্যাক্সেসযোগ্য, এমনকি জটিল ধারণাগুলিকে প্রোগ্রামিং-এর বিভিন্ন ব্যাকগ্রাউন্ড সহ শিক্ষার্থীদের জন্য উপলব্ধি করা সহজ করে তোলে। কোর্সের শেষ নাগাদ, অংশগ্রহণকারীদের জ্যাঙ্গো সম্পর্কে একটি দৃঢ় ধারণা থাকবে এবং তারা ইন্টারেক্টিভ, ডাটাবেস-চালিত ওয়েব অ্যাপ্লিকেশন তৈরি করতে সক্ষম হবে।",
                    // Arabic
                    "عَرَبِيّ": "Django for Everybody هي دورة تدريبية شهيرة عبر الإنترنت أنشأها وقام بتدريسها الدكتور تشارلز راسل سيفيرانس، المعروف باسم الدكتور تشاك، من خلال جامعة ميشيغان على منصة كورسيرا. تم تصميم الدورة التدريبية لتلبية احتياجات الأفراد من جميع مستويات الخبرة، من المبتدئين إلى المبرمجين ذوي الخبرة، المهتمين بتعلم كيفية تطوير تطبيقات الويب باستخدام Django، وهو إطار عمل ويب واسع الاستخدام مبني على Python. إن أسلوب التدريس للدكتور تشاك جذاب للغاية وسهل الفهم، مما يجعل حتى المفاهيم المعقدة سهلة الفهم للمتعلمين من خلفيات مختلفة في البرمجة. بحلول نهاية الدورة التدريبية، سيكون لدى المشاركين فهم قوي لـ Django وسيكونون قادرين على إنشاء تطبيقات ويب تفاعلية تعتمد على قواعد البيانات.",
                    // Persian
                    "فارسی": "جنگو برای همه یک دوره آنلاین محبوب است که توسط دکتر چارلز راسل سورنس، که معمولاً به نام دکتر چاک شناخته می شود، از طریق دانشگاه میشیگان در پلتفرم Coursera ایجاد و تدریس می شود. این دوره برای پاسخگویی به افراد در تمام سطوح تخصص، از مبتدی تا برنامه نویس باتجربه، که علاقه مند به یادگیری نحوه توسعه برنامه های کاربردی وب با استفاده از جنگو، یک چارچوب وب پرکاربرد ساخته شده بر روی پایتون هستند، طراحی شده است. رویکرد تدریس دکتر چاک بسیار جذاب و قابل دسترس است، و درک مفاهیم پیچیده را برای زبان آموزان با پیشینه های مختلف در برنامه نویسی آسان می کند. در پایان دوره، شرکت کنندگان درک کاملی از جنگو خواهند داشت و قادر به ایجاد برنامه های کاربردی وب تعاملی مبتنی بر پایگاه داده خواهند بود.",
                },
                // Paragraph 2
                {
                    // English
                    "English": "Throughout the Django for Everybody course, Dr. Chuck covers a comprehensive range of topics, including setting up a Django development environment, creating database models, designing user interfaces with views and templates, implementing user authentication, and deploying Django applications to web servers. The lectures are accompanied by practical exercises, quizzes, and assignments that provide hands-on experience with Django development. Additionally, Dr. Chuck emphasizes real-world applications of Django, enabling students to build practical projects that demonstrate their mastery of Django's core features and functionalities.",
                    // German
                    "Deutsch": "Im Kurs „Django für alle“ behandelt Dr. Chuck ein umfassendes Themenspektrum, darunter das Einrichten einer Django-Entwicklungsumgebung, das Erstellen von Datenbankmodellen, das Entwerfen von Benutzeroberflächen mit Ansichten und Vorlagen, das Implementieren der Benutzerauthentifizierung und das Bereitstellen von Django-Anwendungen auf Webservern. Die Vorlesungen werden von praktischen Übungen, Tests und Aufgaben begleitet, die praktische Erfahrung mit der Django-Entwicklung vermitteln. Darüber hinaus legt Dr. Chuck Wert auf reale Anwendungen von Django, sodass die Studenten praktische Projekte erstellen können, die ihre Beherrschung der Kernfunktionen und -funktionen von Django demonstrieren.",
                    // Chinese
                    "中国人": "在整个 Django for Everybody 课程中，Chuck 博士涵盖了广泛的主题，包括设置 Django 开发环境、创建数据库模型、使用视图和模板设计用户界面、实施用户身份验证以及将 Django 应用程序部署到 Web 服务器。讲座配有实践练习、测验和作业，提供 Django 开发的实践经验。此外，Chuck 博士强调 Django 的实际应用，使学生能够构建实际项目，展示他们对 Django 核心特性和功能的掌握。",
                    // Russian
                    "Русский": "На протяжении всего курса Django for Everybody доктор Чак охватывает широкий спектр тем, включая настройку среды разработки Django, создание моделей баз данных, проектирование пользовательских интерфейсов с представлениями и шаблонами, реализацию аутентификации пользователей и развертывание приложений Django на веб-серверах. Лекции сопровождаются практическими упражнениями, тестами и заданиями, которые дают практический опыт разработки Django. Кроме того, доктор Чак делает акцент на реальных приложениях Django, позволяя студентам создавать практические проекты, демонстрирующие их мастерство в основных функциях и возможностях Django.",
                    // French
                    "Français": "Tout au long du cours Django for Everybody, le Dr Chuck couvre un large éventail de sujets, notamment la configuration d'un environnement de développement Django, la création de modèles de base de données, la conception d'interfaces utilisateur avec des vues et des modèles, la mise en œuvre de l'authentification des utilisateurs et le déploiement d'applications Django sur des serveurs Web. Les cours sont accompagnés d'exercices pratiques, de questionnaires et de devoirs qui offrent une expérience concrète du développement Django. De plus, le Dr Chuck met l'accent sur les applications concrètes de Django, permettant aux étudiants de créer des projets pratiques qui démontrent leur maîtrise des principales fonctionnalités de Django.",
                    // Japanese
                    "日本語": "Django for Everybody コース全体を通じて、Django 開発環境の設定、データベース モデルの作成、ビューとテンプレートを使用したユーザー インターフェイスの設計、ユーザー認証の実装、Django アプリケーションの Web サーバーへの展開など、幅広いトピックを Chuck 博士が取り上げます。講義には、Django 開発の実践的な経験を提供する実践的な演習、クイズ、課題が伴います。さらに、Django の実際のアプリケーションに重点を置き、学生が Django のコア機能の習得を示す実用的なプロジェクトを構築できるようにします。",
                    // Korean
                    "한국인": "Django for Everybody 과정 전반에 걸쳐 Chuck 박사는 Django 개발 환경 설정, 데이터베이스 모델 생성, 뷰와 템플릿을 사용한 사용자 인터페이스 설계, 사용자 인증 구현, Django 애플리케이션 웹 서버 배포를 포함한 포괄적인 주제를 다룹니다. 강의에는 Django 개발에 대한 실무 경험을 제공하는 실습 연습, 퀴즈 및 과제가 함께 제공됩니다. 또한 Chuck 박사는 Django의 실제 적용을 강조하여 학생들이 Django의 핵심 기능과 기능에 대한 숙달을 입증하는 실무 프로젝트를 구축할 수 있도록 합니다.",
                    // Spanish
                    "Español": "A lo largo del curso Django para todos, el Dr. Chuck cubre una amplia gama de temas, que incluyen la configuración de un entorno de desarrollo de Django, la creación de modelos de bases de datos, el diseño de interfaces de usuario con vistas y plantillas, la implementación de la autenticación de usuarios y la implementación de aplicaciones de Django en servidores web. Las clases están acompañadas de ejercicios prácticos, exámenes y tareas que brindan experiencia práctica con el desarrollo de Django. Además, el Dr. Chuck enfatiza las aplicaciones del mundo real de Django, lo que permite a los estudiantes crear proyectos prácticos que demuestren su dominio de las características y funcionalidades principales de Django.",
                    // Hindi
                    "हिंदी": "Django for Everyone पाठ्यक्रम के दौरान, डॉ. चक ने Django विकास वातावरण की स्थापना, डेटाबेस मॉडल बनाना, व्यू और टेम्प्लेट के साथ उपयोगकर्ता इंटरफ़ेस डिज़ाइन करना, उपयोगकर्ता प्रमाणीकरण लागू करना और वेब सर्वर पर Django एप्लिकेशन तैनात करना सहित विषयों की एक विस्तृत श्रृंखला को कवर किया। व्याख्यानों के साथ व्यावहारिक अभ्यास, प्रश्नोत्तरी और असाइनमेंट होते हैं जो Django विकास के साथ व्यावहारिक अनुभव प्रदान करते हैं। इसके अतिरिक्त, डॉ. चक Django के वास्तविक दुनिया के अनुप्रयोगों पर जोर देते हैं, जिससे छात्र व्यावहारिक प्रोजेक्ट बनाने में सक्षम होते हैं जो Django की मुख्य विशेषताओं और कार्यात्मकताओं में उनकी महारत को प्रदर्शित करते हैं।",
                    // Portuguese
                    "Português": "Ao longo do curso Django para Todos, o Dr. Chuck cobre uma vasta gama de tópicos, incluindo a configuração de um ambiente de desenvolvimento Django, a criação de modelos de base de dados, o design de interfaces de utilizador com visualizações e modelos, a implementação de autenticação de utilizador e implementação de aplicações Django em servidores web. As palestras são acompanhadas de exercícios práticos, questionários e tarefas que proporcionam experiência prática com o desenvolvimento em Django. Além disso, o Dr. Chuck enfatiza as aplicações reais do Django, permitindo aos alunos construir projetos práticos que demonstrem o seu domínio das principais características e funcionalidades do Django.",
                    // Bengali
                    "বাংলা": "জ্যাঙ্গো ফর এভরিবডি কোর্স জুড়ে, ডাঃ চাক একটি জ্যাঙ্গো ডেভেলপমেন্ট এনভায়রনমেন্ট সেট আপ করা, ডাটাবেস মডেল তৈরি করা, ভিউ এবং টেমপ্লেট সহ ইউজার ইন্টারফেস ডিজাইন করা, ইউজার অথেন্টিকেশন বাস্তবায়ন করা এবং ওয়েব সার্ভারে জ্যাঙ্গো অ্যাপ্লিকেশান স্থাপন করা সহ বিষয়গুলির একটি বিস্তৃত পরিসর কভার করেছেন। বক্তৃতাগুলির সাথে ব্যবহারিক অনুশীলন, কুইজ এবং অ্যাসাইনমেন্ট রয়েছে যা জ্যাঙ্গো বিকাশের সাথে অভিজ্ঞতা প্রদান করে। অতিরিক্তভাবে, ডাঃ চাক জ্যাঙ্গোর বাস্তব-বিশ্বের অ্যাপ্লিকেশনের উপর জোর দেন, যা শিক্ষার্থীদের এমন বাস্তব প্রকল্প তৈরি করতে সক্ষম করে যা জ্যাঙ্গোর মূল বৈশিষ্ট্য এবং কার্যকারিতাগুলির উপর তাদের দক্ষতা প্রদর্শন করে।",
                    // Arabic
                    "عَرَبِيّ": "يغطي الدكتور تشاك خلال دورة Django for Everybody مجموعة شاملة من المواضيع، بما في ذلك إعداد بيئة تطوير Django، وإنشاء نماذج قواعد البيانات، وتصميم واجهات المستخدم مع العروض والقوالب، وتنفيذ مصادقة المستخدم، ونشر تطبيقات Django على خوادم الويب. وتصاحب المحاضرات تمارين عملية واختبارات وواجبات توفر خبرة عملية في تطوير Django. بالإضافة إلى ذلك، يؤكد الدكتور تشاك على التطبيقات الواقعية لـ Django، مما يمكن الطلاب من بناء مشاريع عملية توضح إتقانهم للميزات والوظائف الأساسية لـ Django.",
                    // Persian
                    "فارسی": "در طول دوره جنگو برای همه، دکتر چاک طیف گسترده ای از موضوعات را پوشش می دهد، از جمله راه اندازی یک محیط توسعه جنگو، ایجاد مدل های پایگاه داده، طراحی رابط های کاربری با نماها و قالب ها، پیاده سازی احراز هویت کاربر، و استقرار برنامه های جنگو در سرورهای وب. این سخنرانی‌ها با تمرین‌های عملی، آزمون‌ها و تکالیفی همراه است که تجربه عملی را با توسعه جنگو فراهم می‌کند. علاوه بر این، دکتر چاک بر کاربردهای دنیای واقعی جنگو تأکید می‌کند و دانش‌آموزان را قادر می‌سازد تا پروژه‌های عملی بسازند که تسلط خود را بر ویژگی‌ها و عملکردهای اصلی جنگو نشان دهد.",
                },
                // Paragraph 3
                {
                    // English
                    "English": "One of the key highlights of Django for Everybody is Dr. Chuck's extensive experience in the field of web development and his passion for teaching. As a renowned educator and technologist, Dr. Chuck brings a wealth of knowledge and practical insights to the course, making it an invaluable resource for anyone looking to enhance their skills in Django development. Whether you are a beginner seeking to enter the world of web programming or a seasoned professional looking to expand your expertise, Django for Everybody offers a comprehensive and engaging learning experience that can empower you to create dynamic and responsive web applications using Django.",
                    // German
                    "Deutsch": "Eines der wichtigsten Highlights von „Django für alle“ ist Dr. Chucks umfangreiche Erfahrung im Bereich der Webentwicklung und seine Leidenschaft für das Unterrichten. Als renommierter Pädagoge und Techniker bringt Dr. Chuck eine Fülle von Wissen und praktischen Erkenntnissen in den Kurs ein, was ihn zu einer unschätzbaren Ressource für alle macht, die ihre Fähigkeiten in der Django-Entwicklung verbessern möchten. Egal, ob Sie ein Anfänger sind, der in die Welt der Webprogrammierung einsteigen möchte, oder ein erfahrener Profi, der sein Fachwissen erweitern möchte, „Django für alle“ bietet eine umfassende und spannende Lernerfahrung, die Sie in die Lage versetzt, dynamische und reaktionsschnelle Webanwendungen mit Django zu erstellen.",
                    // Chinese
                    "中国人": "Django for Everybody 的一大亮点是 Chuck 博士在 Web 开发领域的丰富经验和对教学的热情。作为知名教育家和技术专家，Chuck 博士为该课程带来了丰富的知识和实用见解，使其成为任何希望提高 Django 开发技能的人的宝贵资源。无论您是想要进入 Web 编程世界的初学者，还是想要扩展专业知识的经验丰富的专业人士，Django for Everybody 都提供全面而引人入胜的学习体验，使您能够使用 Django 创建动态且响应迅速的 Web 应用程序。",
                    // Russian
                    "Русский": "Одной из главных особенностей Django for Everybody является обширный опыт доктора Чака в области веб-разработки и его страсть к преподаванию. Как известный педагог и технолог, доктор Чак привносит в курс богатство знаний и практических идей, делая его бесценным ресурсом для тех, кто хочет улучшить свои навыки в разработке Django. Независимо от того, являетесь ли вы новичком, желающим войти в мир веб-программирования, или опытным профессионалом, желающим расширить свои знания, Django for Everybody предлагает всеобъемлющий и увлекательный опыт обучения, который может дать вам возможность создавать динамичные и адаптивные веб-приложения с использованием Django.",
                    // French
                    "Français": "L'un des points forts de Django for Everybody est la vaste expérience du Dr Chuck dans le domaine du développement Web et sa passion pour l'enseignement. En tant qu'éducateur et technologue renommé, le Dr Chuck apporte une richesse de connaissances et d'idées pratiques au cours, ce qui en fait une ressource inestimable pour quiconque cherche à améliorer ses compétences en développement Django. Que vous soyez un débutant cherchant à entrer dans le monde de la programmation Web ou un professionnel chevronné cherchant à élargir son expertise, Django for Everybody offre une expérience d'apprentissage complète et engageante qui peut vous permettre de créer des applications Web dynamiques et réactives à l'aide de Django.",
                    // Japanese
                    "日本語": "Django for Everybody の重要な特徴の 1 つは、Web 開発分野における Chuck 博士の豊富な経験と、教育に対する情熱です。著名な教育者であり技術者でもある Chuck 博士は、豊富な知識と実践的な洞察をこのコースに持ち込み、Django 開発のスキルを向上させたいと考えている人にとって貴重なリソースとなっています。Web プログラミングの世界に足を踏み入れようとしている初心者でも、専門知識を広げたいと考えている熟練したプロフェッショナルでも、Django for Everybody は、Django を使用して動的で応答性の高い Web アプリケーションを作成できるようになる包括的で魅力的な学習体験を提供します。",
                    // Korean
                    "한국인": "Django for Everybody의 주요 하이라이트 중 하나는 웹 개발 분야에서의 Chuck 박사의 광범위한 경험과 교육에 대한 열정입니다. 유명한 교육자이자 기술자인 Chuck 박사는 이 과정에 풍부한 지식과 실질적인 통찰력을 제공하여 Django 개발 기술을 향상시키고자 하는 모든 사람에게 귀중한 리소스가 됩니다. 웹 프로그래밍 세계에 진입하려는 초보자이든 전문 지식을 확장하려는 노련한 전문가이든 Django for Everybody는 Django를 사용하여 동적이고 반응성 있는 웹 애플리케이션을 만들 수 있는 포괄적이고 매력적인 학습 경험을 제공합니다.",
                    // Spanish
                    "Español": "Uno de los aspectos más destacados de Django for Everybody es la amplia experiencia del Dr. Chuck en el campo del desarrollo web y su pasión por la enseñanza. Como reconocido educador y tecnólogo, el Dr. Chuck aporta una gran cantidad de conocimientos y perspectivas prácticas al curso, lo que lo convierte en un recurso invaluable para cualquier persona que desee mejorar sus habilidades en el desarrollo de Django. Ya sea que sea un principiante que busca ingresar al mundo de la programación web o un profesional experimentado que busca expandir su experiencia, Django for Everybody ofrece una experiencia de aprendizaje integral y atractiva que puede capacitarlo para crear aplicaciones web dinámicas y responsivas utilizando Django.",
                    // Hindi
                    "हिंदी": "Django for Everyone की एक मुख्य विशेषता यह है कि डॉ. चक का वेब डेवलपमेंट के क्षेत्र में व्यापक अनुभव और शिक्षण के प्रति उनका जुनून है। एक प्रसिद्ध शिक्षक और प्रौद्योगिकीविद् के रूप में, डॉ. चक इस कोर्स में ज्ञान और व्यावहारिक अंतर्दृष्टि का खजाना लेकर आते हैं, जो इसे Django डेवलपमेंट में अपने कौशल को बढ़ाने की चाह रखने वाले किसी भी व्यक्ति के लिए एक अमूल्य संसाधन बनाता है। चाहे आप वेब प्रोग्रामिंग की दुनिया में प्रवेश करने वाले शुरुआती हों या अपनी विशेषज्ञता का विस्तार करने के इच्छुक अनुभवी पेशेवर हों, Django for Everyone एक व्यापक और आकर्षक शिक्षण अनुभव प्रदान करता है जो आपको Django का उपयोग करके गतिशील और उत्तरदायी वेब एप्लिकेशन बनाने में सक्षम बना सकता है।",
                    // Portuguese
                    "Português": "Um dos principais destaques do Django for Everybody é a vasta experiência do Dr. Chuck na área do desenvolvimento web e a sua paixão pelo ensino. Como educador e tecnólogo de renome, o Dr. Chuck traz uma riqueza de conhecimentos e insights práticos para o curso, tornando-o um recurso inestimável para quem procura melhorar as suas capacidades no desenvolvimento do Django. Quer seja um principiante que procura entrar no mundo da programação web ou um profissional experiente que procura expandir os seus conhecimentos, o Django for Everybody oferece uma experiência de aprendizagem abrangente e envolvente que o pode capacitar para criar aplicações web dinâmicas e responsivas utilizando Django.",
                    // Bengali
                    "বাংলা": "জ্যাঙ্গো ফর এভরিবডির অন্যতম প্রধান আকর্ষণ হল ওয়েব ডেভেলপমেন্টের ক্ষেত্রে ডঃ চাকের ব্যাপক অভিজ্ঞতা এবং শিক্ষাদানের প্রতি তার আবেগ। একজন প্রখ্যাত শিক্ষাবিদ এবং প্রযুক্তিবিদ হিসাবে, ড. চাক কোর্সটিতে প্রচুর জ্ঞান এবং বাস্তব অন্তর্দৃষ্টি নিয়ে এসেছেন, যা জ্যাঙ্গো বিকাশে তাদের দক্ষতা বাড়াতে চাইছেন এমন প্রত্যেকের জন্য এটিকে একটি অমূল্য সম্পদ করে তুলেছে। আপনি ওয়েব প্রোগ্রামিং-এর জগতে প্রবেশ করতে চাওয়া একজন শিক্ষানবিস বা একজন অভিজ্ঞ পেশাদার যা আপনার দক্ষতা বাড়াতে চাইছেন না কেন, জ্যাঙ্গো ফর এভরিবডি একটি ব্যাপক এবং আকর্ষক শেখার অভিজ্ঞতা অফার করে যা আপনাকে জ্যাঙ্গো ব্যবহার করে গতিশীল এবং প্রতিক্রিয়াশীল ওয়েব অ্যাপ্লিকেশন তৈরি করতে সক্ষম করে।",
                    // Arabic
                    "عَرَبِيّ": "من أهم مميزات دورة Django for Everybody هي الخبرة الواسعة التي يتمتع بها الدكتور تشاك في مجال تطوير الويب وشغفه بالتدريس. بصفته معلمًا وخبيرًا في التكنولوجيا، يجلب الدكتور تشاك ثروة من المعرفة والرؤى العملية إلى الدورة، مما يجعلها موردًا لا يقدر بثمن لأي شخص يتطلع إلى تعزيز مهاراته في تطوير Django. سواء كنت مبتدئًا تسعى إلى دخول عالم برمجة الويب أو محترفًا متمرسًا يتطلع إلى توسيع خبرته، فإن دورة Django for Everybody تقدم تجربة تعليمية شاملة وجذابة يمكنها تمكينك من إنشاء تطبيقات ويب ديناميكية ومستجيبة باستخدام Django.",
                    // Persian
                    "فارسی": "یکی از مهمترین نکات برجسته جنگو برای همه، تجربه گسترده دکتر چاک در زمینه توسعه وب و اشتیاق او به تدریس است. دکتر چاک به‌عنوان یک مربی و فن‌شناس مشهور، دانش و بینش‌های عملی فراوانی را در این دوره به ارمغان می‌آورد و آن را به منبعی ارزشمند برای هر کسی که به دنبال افزایش مهارت‌های خود در توسعه جنگو است تبدیل می‌کند. چه مبتدی باشید که به دنبال ورود به دنیای برنامه نویسی وب هستید و چه یک حرفه ای باتجربه که به دنبال گسترش تخصص خود هستید، جنگو برای همه یک تجربه یادگیری جامع و جذاب را ارائه می دهد که می تواند به شما قدرت ایجاد برنامه های وب پویا و پاسخگو با استفاده از جنگو را بدهد.",
                },
            ],
            "CourseCoverImagePath": "../assets/img/Courses Covers/Full Stack Development/2 - Django For Everybody.webp",
            "shortDescriptionsForCourseReviewing": {
                // English
                "English": "Django for Everybody by Dr. Charles Russell Serverance, known as Dr. Chuck, is a highly acclaimed online course offered through Coursera and the University of Michigan. This comprehensive course aims to equips learners with the essential knowledge and skills needed to develop web applications using Django, a powerful Python-based web framework. Dr. Chuck's engaging teaching style, practical hands-on assignments, and real-world applications of Django make this course a valuable resource for individuals of all levels of programming proficiency looking to master the fundamentals of Django development. By the end of the course, participants will have the expertise to create database-driven web applications, design user interfaces, implement user authentication features, and deploy Django projects to web servers, setting them on the path to becoming proficient Django developers.",
                // German
                "Deutsch": "„Django für alle“ von Dr. Charles Russell Serverance, auch bekannt als Dr. Chuck, ist ein hochgelobter Onlinekurs, der über Coursera und die University of Michigan angeboten wird. Dieser umfassende Kurs vermittelt den Kursteilnehmern die grundlegenden Kenntnisse und Fähigkeiten, die sie benötigen, um Webanwendungen mit Django, einem leistungsstarken Python-basierten Webframework, zu entwickeln. Dr. Chucks ansprechender Unterrichtsstil, praktische Aufgaben und reale Anwendungen von Django machen diesen Kurs zu einer wertvollen Ressource für Personen aller Programmierkenntnisse, die die Grundlagen der Django-Entwicklung erlernen möchten. Am Ende des Kurses verfügen die Teilnehmer über das Fachwissen, um datenbankgestützte Webanwendungen zu erstellen, Benutzeroberflächen zu entwerfen, Benutzerauthentifizierungsfunktionen zu implementieren und Django-Projekte auf Webservern bereitzustellen, was sie auf den Weg bringt, kompetente Django-Entwickler zu werden.",
                // Chinese
                "中国人": "由 Charles Russell Serverance 博士（又名 Chuck 博士）编写的《Django for Everybody》是 Coursera 和密歇根大学提供的一门备受赞誉的在线课程。这门综合课程旨在让学习者掌握使用 Django（一个强大的基于 Python 的 Web 框架）开发 Web 应用程序所需的基本知识和技能。Chuck 博士引人入胜的教学风格、实用的动手作业和 Django 的实际应用使这门课程成为希望掌握 Django 开发基础知识的各个编程水平的个人的宝贵资源。在课程结束时，参与者将具备创建数据库驱动的 Web 应用程序、设计用户界面、实现用户身份验证功能以及将 Django 项目部署到 Web 服务器的专业知识，从而踏上成为熟练的 Django 开发人员的道路。",
                // Russian
                "Русский": "Django for Everybody доктора Чарльза Рассела Серверанса, известного как доктор Чак, — это высоко оцененный онлайн-курс, предлагаемый Coursera и Мичиганским университетом. Этот всеобъемлющий курс направлен на то, чтобы вооружить учащихся основными знаниями и навыками, необходимыми для разработки веб-приложений с использованием Django, мощного веб-фреймворка на основе Python. Увлекательный стиль преподавания доктора Чака, практические задания и реальные приложения Django делают этот курс ценным ресурсом для людей с любым уровнем владения программированием, желающих освоить основы разработки Django. К концу курса участники будут обладать опытом создания веб-приложений, управляемых базами данных, проектирования пользовательских интерфейсов, внедрения функций аутентификации пользователей и развертывания проектов Django на веб-серверах, что позволит им стать опытными разработчиками Django.",
                // French
                "Français": "Django for Everybody du Dr Charles Russell Serverance, connu sous le nom de Dr Chuck, est un cours en ligne très apprécié proposé par Coursera et l'Université du Michigan. Ce cours complet vise à doter les apprenants des connaissances et des compétences essentielles nécessaires pour développer des applications Web à l'aide de Django, un puissant framework Web basé sur Python. Le style d'enseignement engageant du Dr Chuck, ses travaux pratiques et ses applications concrètes de Django font de ce cours une ressource précieuse pour les personnes de tous niveaux de compétence en programmation qui cherchent à maîtriser les fondamentaux du développement Django. À la fin du cours, les participants auront l'expertise nécessaire pour créer des applications Web pilotées par base de données, concevoir des interfaces utilisateur, implémenter des fonctionnalités d'authentification des utilisateurs et déployer des projets Django sur des serveurs Web, les mettant ainsi sur la voie de devenir des développeurs Django compétents.",
                // Japanese
                "日本語": "チャールズ・ラッセル・サーバンス博士 (通称チャック博士) による Django for Everybody は、Coursera とミシガン大学で提供される、高く評価されているオンライン コースです。この総合的なコースは、強力な Python ベースの Web フレームワークである Django を使用して Web アプリケーションを開発するために必要な基本的な知識とスキルを学習者に身につけさせることを目標としています。チャック博士の魅力的な指導スタイル、実践的なハンズオン課題、および Django の実際のアプリケーションにより、このコースは、Django 開発の基礎を習得したいあらゆるレベルのプログラミング能力を持つ個人にとって貴重なリソースとなっています。コース終了時には、参加者はデータベース駆動型 Web アプリケーションの作成、ユーザー インターフェイスの設計、ユーザー認証機能の実装、および Django プロジェクトの Web サーバーへの展開に関する専門知識を習得し、熟練した Django 開発者への道を歩むことになります。",
                // Korean
                "한국인": "Django for Everybody by Dr. Charles Russell Serverance, 일명 Dr. Chuck은 Coursera와 University of Michigan에서 제공하는 매우 호평을 받는 온라인 과정입니다. 이 포괄적인 과정은 학습자에게 강력한 Python 기반 웹 프레임워크인 Django를 사용하여 웹 애플리케이션을 개발하는 데 필요한 필수 지식과 기술을 제공하는 것을 목표로 합니다. Chuck 박사의 매력적인 교육 스타일, 실용적인 실습 과제, Django의 실제 적용은 이 과정을 Django 개발의 기본을 마스터하려는 모든 수준의 프로그래밍 능숙도의 개인에게 귀중한 리소스로 만듭니다. 과정을 마치면 참가자는 데이터베이스 기반 웹 애플리케이션을 만들고, 사용자 인터페이스를 디자인하고, 사용자 인증 기능을 구현하고, Django 프로젝트를 웹 서버에 배포하는 전문 지식을 갖게 되어 능숙한 Django 개발자가 되는 길로 나아갈 수 있습니다.",
                // Spanish
                "Español": "Django para todos, del Dr. Charles Russell Serverance, conocido como Dr. Chuck, es un curso en línea muy aclamado que se ofrece a través de Coursera y la Universidad de Michigan. Este curso integral tiene como objetivo dotar a los alumnos de los conocimientos y las habilidades esenciales necesarios para desarrollar aplicaciones web utilizando Django, un potente marco de trabajo web basado en Python. El atractivo estilo de enseñanza del Dr. Chuck, las tareas prácticas y las aplicaciones reales de Django hacen de este curso un recurso valioso para personas de todos los niveles de competencia en programación que deseen dominar los fundamentos del desarrollo de Django. Al finalizar el curso, los participantes tendrán la experiencia necesaria para crear aplicaciones web basadas en bases de datos, diseñar interfaces de usuario, implementar funciones de autenticación de usuarios e implementar proyectos de Django en servidores web, lo que los encaminará a convertirse en desarrolladores competentes de Django.",
                // Hindi
                "हिंदी": "डॉ. चार्ल्स रसेल सर्वरेंस, जिन्हें डॉ. चक के नाम से जाना जाता है, द्वारा लिखित Django for Everyone कोर्सेरा और मिशिगन विश्वविद्यालय द्वारा प्रस्तुत एक अत्यधिक प्रशंसित ऑनलाइन पाठ्यक्रम है। इस व्यापक पाठ्यक्रम का उद्देश्य शिक्षार्थियों को Django, एक शक्तिशाली पायथन-आधारित वेब फ्रेमवर्क का उपयोग करके वेब एप्लिकेशन विकसित करने के लिए आवश्यक आवश्यक ज्ञान और कौशल से लैस करना है। डॉ. चक की आकर्षक शिक्षण शैली, व्यावहारिक हाथों से किए जाने वाले कार्य और Django के वास्तविक-विश्व अनुप्रयोग इस पाठ्यक्रम को प्रोग्रामिंग दक्षता के सभी स्तरों के व्यक्तियों के लिए एक मूल्यवान संसाधन बनाते हैं जो Django विकास के मूल सिद्धांतों में महारत हासिल करना चाहते हैं। पाठ्यक्रम के अंत तक, प्रतिभागियों के पास डेटाबेस-संचालित वेब एप्लिकेशन बनाने, उपयोगकर्ता इंटरफ़ेस डिज़ाइन करने, उपयोगकर्ता प्रमाणीकरण सुविधाओं को लागू करने और Django प्रोजेक्ट को वेब सर्वर पर तैनात करने की विशेषज्ञता होगी, जो उन्हें कुशल Django डेवलपर बनने के मार्ग पर ले जाएगा।",
                // Portuguese
                "Português": "Django for All, do Dr. Charles Russell Serverance, conhecido como Dr. Chuck, é um curso online muito aclamado, oferecido pela Coursera e pela Universidade de Michigan. Este curso abrangente tem como objetivo capacitar os alunos com o conhecimento e as competências essenciais necessárias para desenvolver aplicações web utilizando Django, uma poderosa framework web baseada em Python. O estilo de ensino envolvente do Dr. Chuck, as tarefas práticas e as aplicações do Django no mundo real fazem deste curso um recurso valioso para indivíduos de todos os níveis de proficiência em programação que desejam dominar os fundamentos do desenvolvimento do Django. No final do curso, os participantes terão experiência para criar aplicações web orientadas para bases de dados, conceber interfaces de utilizador, implementar capacidades de autenticação de utilizadores e implementar projetos Django em servidores web, colocando-os no caminho para se tornarem programadores Django proficientes.",
                // Bengali
                "বাংলা": "ডাঃ চার্লস রাসেল সার্ভারেন্সের জ্যাঙ্গো ফর এভরিবডি, যা ডাঃ চাক নামে পরিচিত, একটি অত্যন্ত প্রশংসিত অনলাইন কোর্স যা Coursera এবং মিশিগান বিশ্ববিদ্যালয়ের মাধ্যমে দেওয়া হয়। এই বিস্তৃত কোর্সটির লক্ষ্য হল জ্যাঙ্গো, একটি শক্তিশালী পাইথন-ভিত্তিক ওয়েব ফ্রেমওয়ার্ক ব্যবহার করে ওয়েব অ্যাপ্লিকেশন বিকাশের জন্য প্রয়োজনীয় জ্ঞান এবং দক্ষতার সাথে শিক্ষার্থীদের সজ্জিত করা। ডাঃ চাকের আকর্ষক শিক্ষণ শৈলী, ব্যবহারিক হ্যান্ডস-অন অ্যাসাইনমেন্ট, এবং জ্যাঙ্গোর বাস্তব-বিশ্বের অ্যাপ্লিকেশন এই কোর্সটিকে সমস্ত স্তরের প্রোগ্রামিং দক্ষতার ব্যক্তিদের জন্য একটি মূল্যবান সম্পদ করে তোলে যারা জ্যাঙ্গো বিকাশের মৌলিক বিষয়গুলি আয়ত্ত করতে চায়। কোর্সের শেষ নাগাদ, অংশগ্রহণকারীদের ডাটাবেস-চালিত ওয়েব অ্যাপ্লিকেশন তৈরি করা, ব্যবহারকারীর ইন্টারফেস ডিজাইন করা, ব্যবহারকারীর প্রমাণীকরণ বৈশিষ্ট্যগুলি বাস্তবায়ন করা এবং জ্যাঙ্গো প্রকল্পগুলিকে ওয়েব সার্ভারে স্থাপন করার দক্ষতা থাকবে, তাদের দক্ষ জ্যাঙ্গো বিকাশকারী হওয়ার পথে সেট করা হবে।",
                // Arabic
                "عَرَبِيّ": "Django for Everybody للدكتور تشارلز راسل سيرفرانس، المعروف باسم الدكتور تشاك، هو دورة تدريبية عبر الإنترنت تحظى بتقدير كبير وتقدم من خلال كورسيرا وجامعة ميشيغان. تهدف هذه الدورة التدريبية الشاملة إلى تزويد المتعلمين بالمعرفة والمهارات الأساسية اللازمة لتطوير تطبيقات الويب باستخدام Django، وهو إطار عمل قوي للويب قائم على Python. إن أسلوب التدريس الجذاب للدكتور تشاك، والمهام العملية العملية، والتطبيقات الواقعية لـ Django تجعل هذه الدورة موردًا قيمًا للأفراد من جميع مستويات كفاءة البرمجة الذين يتطلعون إلى إتقان أساسيات تطوير Django. بحلول نهاية الدورة التدريبية، سيكون لدى المشاركين الخبرة اللازمة لإنشاء تطبيقات ويب تعتمد على قاعدة بيانات، وتصميم واجهات المستخدم، وتنفيذ ميزات مصادقة المستخدم، ونشر مشاريع Django على خوادم الويب، مما يضعهم على الطريق ليصبحوا مطوري Django مهرة.",
                // Persian
                "فارسی": "جنگو برای همه توسط دکتر چارلز راسل سرورنس، معروف به دکتر چاک، یک دوره آنلاین بسیار تحسین شده است که از طریق Coursera و دانشگاه میشیگان ارائه می شود. این دوره جامع با هدف تجهیز دانش آموزان به دانش و مهارت های ضروری مورد نیاز برای توسعه برنامه های کاربردی وب با استفاده از جنگو، یک چارچوب وب قدرتمند مبتنی بر پایتون، می باشد. سبک تدریس جذاب دکتر چاک، تکالیف عملی عملی و کاربردهای جنگو در دنیای واقعی، این دوره را به منبعی با ارزش برای افراد با تمام سطوح مهارت برنامه نویسی تبدیل کرده است که به دنبال تسلط بر اصول توسعه جنگو هستند. در پایان دوره، شرکت‌کنندگان در ایجاد برنامه‌های کاربردی وب مبتنی بر پایگاه داده، طراحی رابط‌های کاربری، پیاده‌سازی ویژگی‌های احراز هویت کاربر، و استقرار پروژه‌های جنگو بر روی سرورهای وب، تخصص خواهند داشت و آنها را در مسیر تبدیل شدن به توسعه‌دهندگان حرفه‌ای جنگو قرار می‌دهند.",
            },
            "DetailPageScreenToShowEachBookDetails": "CRs/Full Stack Development/2 - Django For Everybody/2 - Django For Everybody.html",
        },
        // Python Django: Build an E-commerce Store - 2024
        {
            "CourseName": "Python Django: Build an E-commerce Store",
            "InstructorName": "Arno Pretorius",
            "Gender": "M", // F: Female, M: Male
            "CourseTime": {
                "English": "19 hours, 21 minutes",
                "Deutsch": "19 Stunden, 21 Minuten",
                "中国人": "19 小时 21 分钟",
                "Русский": "19 часов, 21 минута",
                "Français": "19 heures, 21 minutes",
                "日本語": "19時間21分",
                "한국인": "19시간 21분",
                "Español": "19 horas, 21 minutos",
                "हिंदी": "19 घंटे, 21 मिनट",
                "Português": "19 horas e 21 minutos",
                "বাংলা": "19 ঘন্টা, 21 মিনিট",
                "عَرَبِيّ": "١٩ ساعة و ٢١ دقيقة",
                "فارسی": "١٩ ساعت و ٢١ دقیقه",
            },
            "PlatformName": "Udemy",
            "Ratings": "4.8",
            "YearNumber": "2024",
            "ProgrammingLanguages": "Python and Django",
            "TableOfContents": [],
            "TotalDescriptionAboutTheBook": [
                // Paragraph 1
                {
                    // English
                    "English": "Python Django: Build an E-commerce Store by Arno Pretorius on Udemy is a comprehensive course designed to guide learners through the process of creating a fully functional e-commerce website using the Django framework. This course is ideal for both beginners and intermediate developers who are interested in enhancing their skills in web development and Python programming. Arno Pretorius, a seasoned software engineer, provides step-by-step instructions, ensuring that students grasp the fundamental concepts of Django while also learning how to implement real-world features like product listings, shopping carts, and checkout systems.",
                    // German
                    "Deutsch": "Python Django: Erstellen Sie einen E-Commerce-Shop von Arno Pretorius auf Udemy ist ein umfassender Kurs, der Lernende durch den Prozess der Erstellung einer voll funktionsfähigen E-Commerce-Website mithilfe des Django-Frameworks führt. Dieser Kurs ist ideal für Anfänger und fortgeschrittene Entwickler, die ihre Fähigkeiten in Webentwicklung und Python-Programmierung verbessern möchten. Arno Pretorius, ein erfahrener Softwareentwickler, bietet Schritt-für-Schritt-Anleitungen, um sicherzustellen, dass die Schüler die grundlegenden Konzepte von Django verstehen und gleichzeitig lernen, wie sie reale Funktionen wie Produktlisten, Einkaufswagen und Kassensysteme implementieren.",
                    // Chinese
                    "中国人": "Python Django：Arno Pretorius 在 Udemy 上开设的电子商务商店是一门综合课程，旨在指导学习者使用 Django 框架创建功能齐全的电子商务网站。本课程非常适合想要提高 Web 开发和 Python 编程技能的初学者和中级开发人员。经验丰富的软件工程师 Arno Pretorius 提供分步说明，确保学生掌握 Django 的基本概念，同时学习如何实现产品列表、购物车和结账系统等实际功能。",
                    // Russian
                    "Русский": "Python Django: Build an E-commerce Store Арно Преториус на Udemy — это комплексный курс, разработанный для того, чтобы провести учащихся через процесс создания полнофункционального веб-сайта электронной коммерции с использованием фреймворка Django. Этот курс идеально подходит как для начинающих, так и для разработчиков среднего уровня, которые хотят улучшить свои навыки в веб-разработке и программировании на Python. Арно Преториус, опытный инженер-программист, предоставляет пошаговые инструкции, гарантируя, что студенты поймут основные концепции Django, а также научатся реализовывать реальные функции, такие как списки продуктов, корзины покупок и системы оформления заказов.",
                    // French
                    "Français": "Python Django : Créer une boutique en ligne par Arno Pretorius sur Udemy est un cours complet conçu pour guider les apprenants dans le processus de création d'un site Web de commerce électronique entièrement fonctionnel à l'aide du framework Django. Ce cours est idéal pour les développeurs débutants et intermédiaires qui souhaitent améliorer leurs compétences en développement Web et en programmation Python. Arno Pretorius, un ingénieur logiciel chevronné, fournit des instructions étape par étape, garantissant que les étudiants saisissent les concepts fondamentaux de Django tout en apprenant à mettre en œuvre des fonctionnalités concrètes telles que les listes de produits, les paniers d'achat et les systèmes de paiement.",
                    // Japanese
                    "日本語": "Udemy の Arno Pretorius による Python Django: E コマース ストアの構築は、Django フレームワークを使用して完全に機能する E コマース Web サイトを作成するプロセスを学習者に指導するように設計された包括的なコースです。このコースは、Web 開発と Python プログラミングのスキルを向上させたい初心者と中級開発者の両方に最適です。熟練したソフトウェア エンジニアである Arno Pretorius がステップ バイ ステップの手順を提供し、学生が Django の基本概念を理解できるようにしながら、製品リスト、ショッピング カート、チェックアウト システムなどの実際の機能を実装する方法も学習します。",
                    // Korean
                    "한국인": "Arno Pretorius가 Udemy에서 쓴 Python Django: Build an E-commerce Store는 학습자가 Django 프레임워크를 사용하여 완벽하게 기능하는 전자상거래 웹사이트를 만드는 과정을 안내하도록 설계된 포괄적인 과정입니다. 이 과정은 웹 개발과 Python 프로그래밍 기술을 향상시키고자 하는 초보자와 중급 개발자 모두에게 이상적입니다. 노련한 소프트웨어 엔지니어인 Arno Pretorius는 단계별 지침을 제공하여 학생들이 Django의 기본 개념을 파악하는 동시에 제품 목록, 쇼핑 카트, 체크아웃 시스템과 같은 실제 기능을 구현하는 방법을 배울 수 있도록 합니다.",
                    // Spanish
                    "Español": "Python Django: Build an E-commerce Store de Arno Pretorius en Udemy es un curso integral diseñado para guiar a los estudiantes a través del proceso de creación de un sitio web de comercio electrónico completamente funcional utilizando el marco de trabajo Django. Este curso es ideal tanto para principiantes como para desarrolladores intermedios que estén interesados ​​en mejorar sus habilidades en desarrollo web y programación Python. Arno Pretorius, un experimentado ingeniero de software, brinda instrucciones paso a paso, lo que garantiza que los estudiantes comprendan los conceptos fundamentales de Django y, al mismo tiempo, aprendan a implementar funciones del mundo real como listados de productos, carritos de compras y sistemas de pago.",
                    // Hindi
                    "हिंदी": "उडेमी पर अर्नो प्रीटोरियस द्वारा लिखित पायथन Django: एक ई-कॉमर्स स्टोर बनाएँ एक व्यापक पाठ्यक्रम है जिसे Django फ्रेमवर्क का उपयोग करके एक पूरी तरह कार्यात्मक ई-कॉमर्स वेबसाइट बनाने की प्रक्रिया के माध्यम से शिक्षार्थियों का मार्गदर्शन करने के लिए डिज़ाइन किया गया है। यह पाठ्यक्रम शुरुआती और मध्यवर्ती डेवलपर्स दोनों के लिए आदर्श है जो वेब डेवलपमेंट और पायथन प्रोग्रामिंग में अपने कौशल को बढ़ाने में रुचि रखते हैं। अर्नो प्रीटोरियस, एक अनुभवी सॉफ्टवेयर इंजीनियर, चरण-दर-चरण निर्देश प्रदान करता है, यह सुनिश्चित करते हुए कि छात्र Django की मूलभूत अवधारणाओं को समझें और साथ ही उत्पाद लिस्टिंग, शॉपिंग कार्ट और चेकआउट सिस्टम जैसी वास्तविक दुनिया की सुविधाओं को लागू करना सीखें।",
                    // Portuguese
                    "Português": "Python Django: Construa uma loja de comércio eletrónico de Arno Pretorius na Udemy é um curso abrangente desenvolvido para orientar os alunos no processo de criação de um site de comércio eletrónico totalmente funcional utilizando a estrutura Django. Este curso é ideal para programadores iniciantes e intermédios que estejam interessados ​​em melhorar as suas competências em desenvolvimento web e programação Python. Arno Pretorius, um engenheiro de software experiente, fornece instruções passo a passo, garantindo que os alunos compreendem os conceitos fundamentais do Django enquanto aprendem como implementar funcionalidades do mundo real, como listas de produtos, carrinhos de compras e sistemas de checkout.",
                    // Bengali
                    "বাংলা": "Python Django: Udemy-এ Arno Pretorius-এর দ্বারা একটি ই-কমার্স স্টোর তৈরি করা হল Django ফ্রেমওয়ার্ক ব্যবহার করে একটি সম্পূর্ণ কার্যকরী ই-কমার্স ওয়েবসাইট তৈরির প্রক্রিয়ার মাধ্যমে শিক্ষার্থীদের গাইড করার জন্য ডিজাইন করা একটি ব্যাপক কোর্স। এই কোর্সটি নতুন এবং মধ্যবর্তী বিকাশকারী উভয়ের জন্যই আদর্শ যারা ওয়েব ডেভেলপমেন্ট এবং পাইথন প্রোগ্রামিংয়ে তাদের দক্ষতা বাড়াতে আগ্রহী। আর্নো প্রিটোরিয়াস, একজন অভিজ্ঞ সফ্টওয়্যার প্রকৌশলী, ধাপে ধাপে নির্দেশনা প্রদান করে, যা নিশ্চিত করে যে শিক্ষার্থীরা জ্যাঙ্গোর মৌলিক ধারণাগুলি উপলব্ধি করতে পারে এবং সেইসঙ্গে পণ্য তালিকা, শপিং কার্ট এবং চেকআউট সিস্টেমের মতো বাস্তব-বিশ্বের বৈশিষ্ট্যগুলি কীভাবে প্রয়োগ করতে হয় তাও শেখে।",
                    // Arabic
                    "عَرَبِيّ": "Python Django: Build an E-commerce Store بواسطة Arno Pretorius على Udemy هي دورة شاملة مصممة لتوجيه المتعلمين خلال عملية إنشاء موقع ويب للتجارة الإلكترونية يعمل بكامل طاقته باستخدام إطار عمل Django. هذه الدورة مثالية للمبتدئين والمطورين المتوسطين المهتمين بتعزيز مهاراتهم في تطوير الويب وبرمجة Python. يقدم Arno Pretorius، وهو مهندس برمجيات متمرس، تعليمات خطوة بخطوة، مما يضمن أن الطلاب يدركون المفاهيم الأساسية لـ Django بينما يتعلمون أيضًا كيفية تنفيذ ميزات العالم الحقيقي مثل قوائم المنتجات وعربات التسوق وأنظمة الدفع.",
                    // Persian
                    "فارسی": "Python Django: Build an E-commerce Store توسط Arno Pretorius در Udemy یک دوره آموزشی جامع است که برای راهنمایی زبان آموزان در فرآیند ایجاد یک وب سایت تجارت الکترونیک کاملاً کاربردی با استفاده از چارچوب جنگو طراحی شده است. این دوره برای توسعه دهندگان مبتدی و متوسط ​​که علاقه مند به افزایش مهارت های خود در توسعه وب و برنامه نویسی پایتون هستند ایده آل است. آرنو پرتوریوس، یک مهندس نرم‌افزار باتجربه، دستورالعمل‌های گام به گام را ارائه می‌کند و تضمین می‌کند که دانش‌آموزان مفاهیم اساسی جنگو را درک می‌کنند و همچنین یاد می‌گیرند که چگونه ویژگی‌های دنیای واقعی مانند فهرست‌های محصولات، سبد خرید و سیستم‌های پرداخت را پیاده‌سازی کنند.",
                },
                // Paragraph 2
                {
                    // English
                    "English": "Throughout the course, learners dive deep into the core functionalities of Django, including models, views, templates, and forms. Arno also covers essential aspects of building an e-commerce platform, such as managing user authentication, handling payments, and integrating third-party services. The course emphasizes hands-on practice, allowing students to follow along with the coding exercises and build their e-commerce store from scratch. By the end of the course, students will have a solid understanding of Django and will be able to create complex web applications with confidence.",
                    // German
                    "Deutsch": "Während des Kurses tauchen die Teilnehmer tief in die Kernfunktionen von Django ein, darunter Modelle, Ansichten, Vorlagen und Formulare. Arno behandelt auch wesentliche Aspekte beim Aufbau einer E-Commerce-Plattform, wie die Verwaltung der Benutzerauthentifizierung, die Abwicklung von Zahlungen und die Integration von Diensten Dritter. Der Kurs legt den Schwerpunkt auf praktische Übungen, sodass die Teilnehmer die Programmierübungen mitmachen und ihren E-Commerce-Shop von Grund auf aufbauen können. Am Ende des Kurses verfügen die Teilnehmer über ein solides Verständnis von Django und können komplexe Webanwendungen sicher erstellen.",
                    // Chinese
                    "中国人": "在整个课程中，学习者将深入了解 Django 的核心功能，包括模型、视图、模板和表单。Arno 还涵盖了构建电子商务平台的基本方面，例如管理用户身份验证、处理付款和集成第三方服务。该课程强调动手实践，让学生跟随编码练习并从头开始构建他们的电子商务商店。在课程结束时，学生将对 Django 有扎实的了解，并能够自信地创建复杂的 Web 应用程序。",
                    // Russian
                    "Русский": "На протяжении всего курса учащиеся глубоко погружаются в основные функции Django, включая модели, представления, шаблоны и формы. Арно также охватывает основные аспекты создания платформы электронной коммерции, такие как управление аутентификацией пользователей, обработка платежей и интеграция сторонних сервисов. Курс делает акцент на практической практике, позволяя учащимся следовать упражнениям по кодированию и создавать свой магазин электронной коммерции с нуля. К концу курса учащиеся будут иметь прочное понимание Django и смогут уверенно создавать сложные веб-приложения.",
                    // French
                    "Français": "Tout au long du cours, les apprenants se plongent dans les fonctionnalités de base de Django, notamment les modèles, les vues, les modèles et les formulaires. Arno couvre également les aspects essentiels de la création d'une plateforme de commerce électronique, tels que la gestion de l'authentification des utilisateurs, la gestion des paiements et l'intégration de services tiers. Le cours met l'accent sur la pratique, permettant aux étudiants de suivre les exercices de codage et de créer leur boutique de commerce électronique à partir de zéro. À la fin du cours, les étudiants auront une solide compréhension de Django et seront capables de créer des applications Web complexes en toute confiance.",
                    // Japanese
                    "日本語": "コース全体を通して、学習者はモデル、ビュー、テンプレート、フォームなど、Django のコア機能を深く理解します。また、Arno は、ユーザー認証の管理、支払いの処理、サードパーティ サービスの統合など、e コマース プラットフォームの構築に不可欠な側面についても説明します。このコースでは実践的な練習を重視しており、学習者はコーディング演習に沿って e コマース ストアをゼロから構築できます。コース終了時には、学習者は Django をしっかりと理解し、自信を持って複雑な Web アプリケーションを作成できるようになります。",
                    // Korean
                    "한국인": "과정 전반에 걸쳐 학습자는 모델, 뷰, 템플릿, 폼을 포함한 Django의 핵심 기능을 깊이 파고듭니다. Arno는 또한 사용자 인증 관리, 결제 처리, 타사 서비스 통합과 같은 전자상거래 플랫폼 구축의 필수적인 측면을 다룹니다. 이 과정은 실습을 강조하여 학생들이 코딩 연습을 따라가고 처음부터 전자상거래 매장을 구축할 수 있도록 합니다. 과정을 마치면 학생들은 Django에 대한 확실한 이해를 갖게 되고 자신 있게 복잡한 웹 애플리케이션을 만들 수 있게 됩니다.",
                    // Spanish
                    "Español": "A lo largo del curso, los alumnos profundizan en las funcionalidades básicas de Django, incluidos los modelos, las vistas, las plantillas y los formularios. Arno también cubre aspectos esenciales de la creación de una plataforma de comercio electrónico, como la gestión de la autenticación de usuarios, la gestión de pagos y la integración de servicios de terceros. El curso hace hincapié en la práctica, lo que permite a los estudiantes seguir los ejercicios de codificación y crear su tienda de comercio electrónico desde cero. Al final del curso, los estudiantes tendrán una sólida comprensión de Django y podrán crear aplicaciones web complejas con confianza.",
                    // Hindi
                    "हिंदी": "पूरे कोर्स के दौरान, शिक्षार्थी मॉडल, व्यू, टेम्प्लेट और फॉर्म सहित Django की मुख्य कार्यक्षमताओं में गहराई से उतरते हैं। अर्नो ई-कॉमर्स प्लेटफ़ॉर्म बनाने के आवश्यक पहलुओं को भी कवर करता है, जैसे कि उपयोगकर्ता प्रमाणीकरण का प्रबंधन करना, भुगतान संभालना और तृतीय-पक्ष सेवाओं को एकीकृत करना। पाठ्यक्रम व्यावहारिक अभ्यास पर जोर देता है, जिससे छात्रों को कोडिंग अभ्यासों का पालन करने और स्क्रैच से अपना ई-कॉमर्स स्टोर बनाने की अनुमति मिलती है। पाठ्यक्रम के अंत तक, छात्रों को Django की ठोस समझ होगी और वे आत्मविश्वास के साथ जटिल वेब एप्लिकेशन बनाने में सक्षम होंगे।",
                    // Portuguese
                    "Português": "Ao longo do curso, os alunos aprofundam as principais funcionalidades do Django, incluindo modelos, visualizações, modelos e formulários. O Arno também aborda aspetos essenciais da construção de uma plataforma de comércio eletrónico, como a gestão da autenticação de utilizadores, o tratamento de pagamentos e a integração de serviços de terceiros. O curso enfatiza a prática, permitindo aos alunos acompanhar os exercícios de codificação e construir a sua loja de comércio eletrónico a partir do zero. No final do curso, os alunos terão um conhecimento sólido de Django e serão capazes de criar aplicações web complexas com confiança.",
                    // Bengali
                    "বাংলা": "পুরো কোর্স জুড়ে, শিক্ষার্থীরা জ্যাঙ্গোর মূল কার্যকারিতা, মডেল, দৃশ্য, টেমপ্লেট এবং ফর্ম সহ গভীরভাবে ডুব দেয়। আরনো একটি ই-কমার্স প্ল্যাটফর্ম তৈরির প্রয়োজনীয় দিকগুলিও কভার করে, যেমন ব্যবহারকারীর প্রমাণীকরণ পরিচালনা, অর্থপ্রদান পরিচালনা এবং তৃতীয় পক্ষের পরিষেবাগুলিকে একীভূত করা। কোর্সটি হাতে-কলমে অনুশীলনের উপর জোর দেয়, যা শিক্ষার্থীদের কোডিং অনুশীলনের সাথে অনুসরণ করতে এবং স্ক্র্যাচ থেকে তাদের ই-কমার্স স্টোর তৈরি করতে দেয়। কোর্সের শেষ নাগাদ, ছাত্ররা জ্যাঙ্গো সম্বন্ধে দৃঢ় ধারণা পাবে এবং আত্মবিশ্বাসের সাথে জটিল ওয়েব অ্যাপ্লিকেশন তৈরি করতে সক্ষম হবে।",
                    // Arabic
                    "عَرَبِيّ": "خلال الدورة، يتعمق المتعلمون في الوظائف الأساسية لـ Django، بما في ذلك النماذج والعروض والقوالب والنماذج. كما يغطي أرنو أيضًا الجوانب الأساسية لبناء منصة للتجارة الإلكترونية، مثل إدارة مصادقة المستخدم ومعالجة المدفوعات ودمج خدمات الطرف الثالث. وتؤكد الدورة على الممارسة العملية، مما يسمح للطلاب بمتابعة تمارين الترميز وبناء متجر التجارة الإلكترونية الخاص بهم من الصفر. بحلول نهاية الدورة، سيكون لدى الطلاب فهم قوي لـ Django وسيكونون قادرين على إنشاء تطبيقات ويب معقدة بثقة.",
                    // Persian
                    "فارسی": "در طول دوره، زبان آموزان عمیقاً به عملکردهای اصلی جنگو، از جمله مدل ها، نماها، قالب ها و فرم ها می پردازند. آرنو همچنین جنبه‌های ضروری ساخت یک پلتفرم تجارت الکترونیک، مانند مدیریت احراز هویت کاربر، رسیدگی به پرداخت‌ها و یکپارچه‌سازی خدمات شخص ثالث را پوشش می‌دهد. این دوره بر تمرین عملی تأکید دارد و به دانش‌آموزان اجازه می‌دهد تا تمرین‌های کدنویسی را دنبال کنند و فروشگاه تجارت الکترونیک خود را از ابتدا بسازند. در پایان دوره، دانش‌آموزان درک کاملی از جنگو خواهند داشت و می‌توانند برنامه‌های پیچیده وب را با اطمینان ایجاد کنند.",
                },
                // Paragraph 3
                {
                    // English
                    "English": "In addition to the technical skills, the course also touches on important topics like deploying Django projects to production, optimizing performance, and ensuring security. Arno Pretorius leverages his industry experience to provide valuable insights and best practices that are crucial for any developer aiming to succeed in the field of web development. Whether you're looking to start a new career in web development or enhance your existing skills, this course offers a thorough and practical approach to mastering Django and building dynamic e-commerce applications.",
                    // German
                    "Deutsch": "Neben den technischen Fähigkeiten werden im Kurs auch wichtige Themen wie die Bereitstellung von Django-Projekten für die Produktion, die Optimierung der Leistung und die Gewährleistung der Sicherheit behandelt. Arno Pretorius nutzt seine Branchenerfahrung, um wertvolle Einblicke und bewährte Methoden bereitzustellen, die für jeden Entwickler von entscheidender Bedeutung sind, der im Bereich der Webentwicklung erfolgreich sein möchte. Egal, ob Sie eine neue Karriere in der Webentwicklung starten oder Ihre vorhandenen Fähigkeiten verbessern möchten, dieser Kurs bietet einen gründlichen und praktischen Ansatz zur Beherrschung von Django und zum Erstellen dynamischer E-Commerce-Anwendungen.",
                    // Chinese
                    "中国人": "除了技术技能外，本课程还涉及重要主题，例如将 Django 项目部署到生产环境、优化性能和确保安全性。Arno Pretorius 利用他的行业经验提供宝贵的见解和最佳实践，这些见解和最佳实践对于任何想要在 Web 开发领域取得成功的开发人员来说都至关重要。无论您是想开始新的 Web 开发职业生涯还是增强现有技能，本课程都提供了一种全面而实用的方法来掌握 Django 并构建动态电子商务应用程序。",
                    // Russian
                    "Русский": "Помимо технических навыков, курс также затрагивает такие важные темы, как развертывание проектов Django в производстве, оптимизация производительности и обеспечение безопасности. Арно Преториус использует свой отраслевой опыт, чтобы предоставить ценные идеи и лучшие практики, которые имеют решающее значение для любого разработчика, стремящегося добиться успеха в области веб-разработки. Независимо от того, хотите ли вы начать новую карьеру в веб-разработке или улучшить свои существующие навыки, этот курс предлагает основательный и практический подход к освоению Django и созданию динамических приложений электронной коммерции.",
                    // French
                    "Français": "En plus des compétences techniques, le cours aborde également des sujets importants tels que le déploiement de projets Django en production, l'optimisation des performances et la garantie de la sécurité. Arno Pretorius s'appuie sur son expérience du secteur pour fournir des informations précieuses et des bonnes pratiques qui sont cruciales pour tout développeur souhaitant réussir dans le domaine du développement Web. Que vous cherchiez à démarrer une nouvelle carrière dans le développement Web ou à améliorer vos compétences existantes, ce cours offre une approche approfondie et pratique pour maîtriser Django et créer des applications de commerce électronique dynamiques.",
                    // Japanese
                    "日本語": "このコースでは、技術的なスキルに加えて、Django プロジェクトを本番環境にデプロイする、パフォーマンスを最適化する、セキュリティを確保するといった重要なトピックについても取り上げます。Arno Pretorius は、業界での経験を活かして、Web 開発の分野で成功を目指す開発者にとって重要な、貴重な洞察とベスト プラクティスを提供します。Web 開発で新しいキャリアを始めたい場合でも、既存のスキルを強化したい場合でも、このコースは、Django を習得し、動的な e コマース アプリケーションを構築するための徹底的かつ実践的なアプローチを提供します。",
                    // Korean
                    "한국인": "기술적 기술 외에도 이 과정은 Django 프로젝트를 프로덕션에 배포하고, 성능을 최적화하고, 보안을 보장하는 것과 같은 중요한 주제에 대해서도 다룹니다. Arno Pretorius는 업계 경험을 활용하여 웹 개발 분야에서 성공하려는 모든 개발자에게 중요한 귀중한 통찰력과 모범 사례를 제공합니다. 웹 개발 분야에서 새로운 경력을 시작하거나 기존 기술을 향상시키려는 경우 이 과정은 Django를 마스터하고 동적 전자 상거래 애플리케이션을 구축하는 데 철저하고 실용적인 접근 방식을 제공합니다.",
                    // Spanish
                    "Español": "Además de las habilidades técnicas, el curso también aborda temas importantes como la implementación de proyectos de Django en producción, la optimización del rendimiento y la garantía de la seguridad. Arno Pretorius aprovecha su experiencia en la industria para brindar información valiosa y las mejores prácticas que son cruciales para cualquier desarrollador que desee tener éxito en el campo del desarrollo web. Ya sea que desee comenzar una nueva carrera en el desarrollo web o mejorar sus habilidades existentes, este curso ofrece un enfoque exhaustivo y práctico para dominar Django y crear aplicaciones de comercio electrónico dinámicas.",
                    // Hindi
                    "हिंदी": "तकनीकी कौशल के अलावा, यह पाठ्यक्रम Django परियोजनाओं को उत्पादन में तैनात करने, प्रदर्शन को अनुकूलित करने और सुरक्षा सुनिश्चित करने जैसे महत्वपूर्ण विषयों को भी छूता है। अर्नो प्रीटोरियस अपने उद्योग के अनुभव का लाभ उठाकर मूल्यवान अंतर्दृष्टि और सर्वोत्तम अभ्यास प्रदान करते हैं जो वेब विकास के क्षेत्र में सफल होने के लक्ष्य वाले किसी भी डेवलपर के लिए महत्वपूर्ण हैं। चाहे आप वेब डेवलपमेंट में एक नया करियर शुरू करना चाहते हों या अपने मौजूदा कौशल को बढ़ाना चाहते हों, यह कोर्स Django में महारत हासिल करने और गतिशील ई-कॉमर्स एप्लिकेशन बनाने के लिए एक संपूर्ण और व्यावहारिक दृष्टिकोण प्रदान करता है।",
                    // Portuguese
                    "Português": "Para além das competências técnicas, o curso aborda também temas importantes como a implementação de projetos Django em produção, a otimização de desempenho e a garantia de segurança. Arno Pretorius aproveita a sua experiência no setor para fornecer insights valiosos e melhores práticas que são cruciais para qualquer programador que pretenda ter sucesso na área de desenvolvimento web. Quer esteja à procura de iniciar uma nova carreira em desenvolvimento web ou de melhorar as suas competências existentes, este curso oferece uma abordagem completa e prática para dominar o Django e construir aplicações dinâmicas de comércio eletrónico.",
                    // Bengali
                    "বাংলা": "প্রযুক্তিগত দক্ষতার পাশাপাশি, কোর্সটি জ্যাঙ্গো প্রকল্পগুলিকে উৎপাদনে স্থাপন, কর্মক্ষমতা অপ্টিমাইজ করা এবং নিরাপত্তা নিশ্চিত করার মতো গুরুত্বপূর্ণ বিষয়গুলিকেও স্পর্শ করে৷ আর্নো প্রিটোরিয়াস মূল্যবান অন্তর্দৃষ্টি এবং সর্বোত্তম অনুশীলনগুলি প্রদান করতে তার শিল্পের অভিজ্ঞতা লাভ করে যা ওয়েব বিকাশের ক্ষেত্রে সফল হওয়ার লক্ষ্যে যে কোনও বিকাশকারীর জন্য অত্যন্ত গুরুত্বপূর্ণ। আপনি ওয়েব ডেভেলপমেন্টে একটি নতুন কর্মজীবন শুরু করতে চাইছেন বা আপনার বিদ্যমান দক্ষতা বাড়াতে চাইছেন না কেন, এই কোর্সটি জ্যাঙ্গোকে আয়ত্ত করতে এবং গতিশীল ই-কমার্স অ্যাপ্লিকেশন তৈরি করার জন্য একটি পুঙ্খানুপুঙ্খ এবং ব্যবহারিক পদ্ধতির প্রস্তাব দেয়।",
                    // Arabic
                    "عَرَبِيّ": "بالإضافة إلى المهارات الفنية، تتناول الدورة أيضًا مواضيع مهمة مثل نشر مشاريع Django في الإنتاج، وتحسين الأداء، وضمان الأمان. يستفيد أرنو بريتوريوس من خبرته في الصناعة لتقديم رؤى قيمة وأفضل الممارسات التي تعد بالغة الأهمية لأي مطور يهدف إلى النجاح في مجال تطوير الويب. سواء كنت تتطلع إلى بدء مهنة جديدة في تطوير الويب أو تحسين مهاراتك الحالية، تقدم هذه الدورة نهجًا شاملاً وعمليًا لإتقان Django وبناء تطبيقات التجارة الإلكترونية الديناميكية.",
                    // Persian
                    "فارسی": "علاوه بر مهارت های فنی، این دوره همچنین موضوعات مهمی مانند استقرار پروژه های جنگو در تولید، بهینه سازی عملکرد و تضمین امنیت را مورد بررسی قرار می دهد. آرنو پرتوریوس از تجربه صنعت خود استفاده می‌کند تا بینش‌های ارزشمند و بهترین شیوه‌ها را ارائه دهد که برای هر توسعه‌دهنده‌ای که هدفش موفقیت در زمینه توسعه وب است، حیاتی است. چه به دنبال شروع یک حرفه جدید در توسعه وب یا ارتقای مهارت های موجود خود باشید، این دوره یک رویکرد کامل و عملی برای تسلط بر جنگو و ایجاد برنامه های کاربردی تجارت الکترونیک پویا ارائه می دهد.",
                },
            ],
            "CourseCoverImagePath": "../assets/img/Courses Covers/Full Stack Development/1 - Build an E-commerce Store.webp",
            "shortDescriptionsForCourseReviewing": {
                // English
                "English": "Python Django: Build an E-commerce Store by Arno Pretorius is a detailed Udemy course designed to teach learners how to create a full-featured e-commerce website using the Django framework. This course is suitable for those who are new to Django as well as developers looking to expand their web development skills. Arno guides students through every step of the process, covering essential topics like setting up Django models, views, and templates, as well as implementing key e-commerce functionalities such as product listings, shopping carts, and payment integration. By the end of the course, students will have the knowledge and confidence to build and deploy their own e-commerce web applications using Django.",
                // German
                "Deutsch": "Python Django: Erstellen Sie einen E-Commerce-Shop von Arno Pretorius ist ein ausführlicher Udemy-Kurs, der den Lernenden beibringt, wie sie mit dem Django-Framework eine voll funktionsfähige E-Commerce-Website erstellen. Dieser Kurs eignet sich sowohl für Django-Neulinge als auch für Entwickler, die ihre Webentwicklungskenntnisse erweitern möchten. Arno führt die Schüler durch jeden Schritt des Prozesses und behandelt wichtige Themen wie das Einrichten von Django-Modellen, -Ansichten und -Vorlagen sowie die Implementierung wichtiger E-Commerce-Funktionen wie Produktlisten, Einkaufswagen und Zahlungsintegration. Am Ende des Kurses verfügen die Schüler über das Wissen und die Sicherheit, ihre eigenen E-Commerce-Webanwendungen mit Django zu erstellen und bereitzustellen.",
                // Chinese
                "中国人": "Python Django：Arno Pretorius 的“构建电子商务商店”是一门详细的 Udemy 课程，旨在教学习者如何使用 Django 框架创建功能齐全的电子商务网站。本课程适合 Django 新手以及希望扩展其 Web 开发技能的开发人员。Arno 指导学生完成该过程的每个步骤，涵盖设置 Django 模型、视图和模板等基本主题，以及实现关键的电子商务功能，例如产品列表、购物车和支付集成。在课程结束时，学生将具备使用 Django 构建和部署自己的电子商务 Web 应用程序的知识和信心。",
                // Russian
                "Русский": "Python Django: Build an E-commerce Store Арно Преториуса — это подробный курс Udemy, разработанный для обучения студентов созданию полнофункционального веб-сайта электронной коммерции с использованием фреймворка Django. Этот курс подходит как для новичков в Django, так и для разработчиков, желающих расширить свои навыки веб-разработки. Арно проводит студентов через каждый шаг процесса, охватывая такие важные темы, как настройка моделей, представлений и шаблонов Django, а также внедрение ключевых функций электронной коммерции, таких как списки продуктов, корзины покупок и интеграция платежей. К концу курса студенты будут обладать знаниями и уверенностью для создания и развертывания собственных веб-приложений электронной коммерции с использованием Django.",
                // French
                "Français": "Python Django : Build an E-commerce Store d'Arno Pretorius est un cours Udemy détaillé conçu pour enseigner aux apprenants comment créer un site Web de commerce électronique complet à l'aide du framework Django. Ce cours convient à ceux qui débutent avec Django ainsi qu'aux développeurs qui cherchent à étendre leurs compétences en développement Web. Arno guide les étudiants à chaque étape du processus, couvrant des sujets essentiels comme la configuration des modèles, des vues et des modèles Django, ainsi que la mise en œuvre de fonctionnalités clés du commerce électronique telles que les listes de produits, les paniers d'achat et l'intégration des paiements. À la fin du cours, les étudiants auront les connaissances et la confiance nécessaires pour créer et déployer leurs propres applications Web de commerce électronique à l'aide de Django.",
                // Japanese
                "日本語": "Python Django: Eコマースストアの構築は、Arno Pretorius による詳細な Udemy コースで、Django フレームワークを使用してフル機能の Eコマース Web サイトを作成する方法を学習者に教えるように設計されています。このコースは、Django を初めて使用する人や、Web 開発スキルを拡張したい開発者に適しています。Arno は、Django モデル、ビュー、テンプレートの設定などの重要なトピックをカバーし、製品リスト、ショッピング カート、支払い統合などの主要な E コマース機能を実装しながら、プロセスのすべてのステップを学生にガイドします。コースの終了までに、学生は Django を使用して独自の E コマース Web アプリケーションを構築および展開するための知識と自信を身に付けます。",
                // Korean
                "한국인": "Arno Pretorius의 Python Django: Build an E-commerce Store는 학습자에게 Django 프레임워크를 사용하여 모든 기능을 갖춘 전자상거래 웹사이트를 만드는 방법을 가르치기 위해 설계된 자세한 Udemy 과정입니다. 이 과정은 Django를 처음 사용하는 사람과 웹 개발 기술을 확장하려는 개발자에게 적합합니다. Arno는 Django 모델, 뷰 및 템플릿 설정과 같은 필수 주제를 다루고 제품 목록, 쇼핑 카트 및 결제 통합과 같은 주요 전자상거래 기능을 구현하는 과정의 모든 단계를 안내합니다. 과정을 마치면 학생들은 Django를 사용하여 자신의 전자상거래 웹 애플리케이션을 빌드하고 배포할 수 있는 지식과 자신감을 갖게 됩니다.",
                // Spanish
                "Español": "Python Django: Build an E-commerce Store de Arno Pretorius es un curso detallado de Udemy diseñado para enseñar a los alumnos a crear un sitio web de comercio electrónico con todas las funciones utilizando el marco de trabajo Django. Este curso es adecuado para aquellos que son nuevos en Django, así como para desarrolladores que buscan ampliar sus habilidades de desarrollo web. Arno guía a los estudiantes a través de cada paso del proceso, cubriendo temas esenciales como la configuración de modelos, vistas y plantillas de Django, así como la implementación de funcionalidades clave de comercio electrónico como listados de productos, carritos de compra e integración de pagos. Al final del curso, los estudiantes tendrán el conocimiento y la confianza para crear e implementar sus propias aplicaciones web de comercio electrónico utilizando Django.",
                // Hindi
                "हिंदी": "अर्नो प्रीटोरियस द्वारा पायथन Django: बिल्ड एन ई-कॉमर्स स्टोर एक विस्तृत Udemy कोर्स है जिसे शिक्षार्थियों को Django फ्रेमवर्क का उपयोग करके एक पूर्ण-विशेषताओं वाली ई-कॉमर्स वेबसाइट बनाने का तरीका सिखाने के लिए डिज़ाइन किया गया है। यह कोर्स उन लोगों के लिए उपयुक्त है जो Django के लिए नए हैं और साथ ही ऐसे डेवलपर्स के लिए जो अपने वेब डेवलपमेंट कौशल का विस्तार करना चाहते हैं। अर्नो छात्रों को प्रक्रिया के हर चरण में मार्गदर्शन करते हैं, जिसमें Django मॉडल, दृश्य और टेम्पलेट सेट अप करने जैसे आवश्यक विषयों को शामिल किया गया है, साथ ही उत्पाद लिस्टिंग, शॉपिंग कार्ट और भुगतान एकीकरण जैसी प्रमुख ई-कॉमर्स कार्यक्षमताओं को लागू किया गया है। पाठ्यक्रम के अंत तक, छात्रों के पास Django का उपयोग करके अपने स्वयं के ई-कॉमर्स वेब एप्लिकेशन बनाने और तैनात करने का ज्ञान और आत्मविश्वास होगा।",
                // Portuguese
                "Português": "Python Django: Construa uma loja de comércio eletrónico de Arno Pretorius é um curso detalhado da Udemy, concebido para ensinar os alunos a criar um site de comércio eletrónico completo utilizando a estrutura Django. Este curso é adequado para aqueles que são novos no Django, bem como para programadores que procuram expandir as suas competências de desenvolvimento web. Arno orienta os alunos em todas as etapas do processo, cobrindo tópicos essenciais como a configuração de modelos, visualizações e modelos do Django, além de implementar funcionalidades importantes de comércio eletrónico, como listas de produtos, carrinhos de compras e integração de pagamentos. No final do curso, os alunos terão conhecimento e confiança para construir e implementar as suas próprias aplicações web de comércio eletrónico utilizando Django.",
                // Bengali
                "বাংলা": "পাইথন জ্যাঙ্গো: আর্নো প্রিটোরিয়াসের দ্বারা একটি ই-কমার্স স্টোর তৈরি করুন একটি বিশদ Udemy কোর্স যা শিক্ষার্থীদের শেখানোর জন্য ডিজাইন করা হয়েছে কীভাবে জ্যাঙ্গো ফ্রেমওয়ার্ক ব্যবহার করে একটি সম্পূর্ণ বৈশিষ্ট্যযুক্ত ই-কমার্স ওয়েবসাইট তৈরি করা যায়। এই কোর্সটি তাদের জন্য উপযুক্ত যারা জ্যাঙ্গোতে নতুন এবং সেইসাথে ডেভেলপাররা তাদের ওয়েব ডেভেলপমেন্ট দক্ষতা বাড়াতে চান। জ্যাঙ্গো মডেল, ভিউ এবং টেমপ্লেট সেট আপ করার পাশাপাশি পণ্য তালিকা, শপিং কার্ট এবং পেমেন্ট ইন্টিগ্রেশনের মতো গুরুত্বপূর্ণ ই-কমার্স কার্যকারিতা বাস্তবায়নের মতো প্রয়োজনীয় বিষয়গুলিকে কভার করে আর্নো প্রক্রিয়ার প্রতিটি ধাপে শিক্ষার্থীদের গাইড করে। কোর্সের শেষে, ছাত্ররা জ্যাঙ্গো ব্যবহার করে তাদের নিজস্ব ই-কমার্স ওয়েব অ্যাপ্লিকেশন তৈরি এবং স্থাপন করার জ্ঞান এবং আত্মবিশ্বাস পাবে।",
                // Arabic
                "عَرَبِيّ": "Python Django: Build an E-commerce Store بواسطة Arno Pretorius هي دورة Udemy مفصلة مصممة لتعليم المتعلمين كيفية إنشاء موقع ويب للتجارة الإلكترونية كامل الميزات باستخدام إطار عمل Django. هذه الدورة مناسبة لأولئك الذين هم جدد على Django وكذلك المطورين الذين يتطلعون إلى توسيع مهارات تطوير الويب الخاصة بهم. يرشد Arno الطلاب خلال كل خطوة من خطوات العملية، ويغطي مواضيع أساسية مثل إعداد نماذج Django والعروض والقوالب، بالإضافة إلى تنفيذ وظائف التجارة الإلكترونية الرئيسية مثل قوائم المنتجات وعربات التسوق وتكامل الدفع. بحلول نهاية الدورة، سيكون لدى الطلاب المعرفة والثقة لبناء ونشر تطبيقات الويب للتجارة الإلكترونية الخاصة بهم باستخدام Django.",
                // Persian
                "فارسی": "Python Django: Build an E-commerce Store by Arno Pretorius یک دوره آموزشی مفصل Udemy است که برای آموزش به زبان‌آموزان طراحی شده است که چگونه با استفاده از چارچوب جنگو یک وب‌سایت تجارت الکترونیک با امکانات کامل ایجاد کنند. این دوره برای کسانی که تازه وارد جنگو شده اند و همچنین توسعه دهندگانی که به دنبال گسترش مهارت های توسعه وب خود هستند مناسب است. Arno دانش‌آموزان را در هر مرحله از فرآیند راهنمایی می‌کند و موضوعات ضروری مانند راه‌اندازی مدل‌ها، نماها و قالب‌های جنگو را پوشش می‌دهد و همچنین قابلیت‌های کلیدی تجارت الکترونیک مانند فهرست‌های محصولات، سبد خرید و یکپارچه‌سازی پرداخت را اجرا می‌کند. در پایان دوره، دانش‌آموزان دانش و اعتماد به نفس لازم برای ساخت و استقرار برنامه‌های کاربردی وب تجارت الکترونیک خود را با استفاده از جنگو خواهند داشت.",
            },
            "DetailPageScreenToShowEachBookDetails": "CRs/Full Stack Development/1 - Build an E-commerce Store/1 - Build an E-commerce Store.html",
        },
    ],
    // Android Developer
    "Android Developer": [

    ],
    // AI Engineer
    "AI Engineer": [

    ],
    // Industrial Designer
    "Industrial Designer": [

    ],
    // Self-Driving Automobile Engineer
    "Self-Driving Automobile Engineer": [
        // Simulink Onramp
        {
            "CourseName": "Simulink Onramp",
            "InstructorName": "Alisha Schor",
            "Gender": "M", // F: Female, M: Male
            "CourseTime": {
                "English": "2 hours",
                "Deutsch": "2 Stunden",
                "中国人": "2小时",
                "Русский": "2 часа",
                "Français": "2 heures",
                "日本語": "2時間",
                "한국인": "2시간",
                "Español": "2 horas",
                "हिंदी": "2 ঘন্টা",
                "Português": "2 horas",
                "বাংলা": "2 ঘন্টা",
                "عَرَبِيّ": "ساعاتين",
                "فارسی": "٢ ساعت",
            },
            "PlatformName": "Udemy",
            "Ratings": "0.0",
            "YearNumber": "2024",
            "ProgrammingLanguages": "MATLAB and Simulink",
            "TableOfContents": [],
            "TotalDescriptionAboutTheBook": [
                // Paragraph 1
                {
                    // English
                    "English": "MathWorks' Simulink courses offer a comprehensive and interactive learning experience for individuals seeking to master the powerful simulation software. These courses, designed by experts in the field, provide a solid foundation in Simulink's graphical environment, enabling users to model and simulate dynamic systems efficiently.",
                    // German
                    "Deutsch": "Die Simulink-Kurse von MathWorks bieten eine umfassende und interaktive Lernerfahrung für Personen, die die leistungsstarke Simulationssoftware beherrschen möchten. Diese von Experten auf diesem Gebiet entwickelten Kurse bieten eine solide Grundlage für die grafische Umgebung von Simulink und ermöglichen Benutzern die effiziente Modellierung und Simulation dynamischer Systeme.",
                    // Chinese
                    "中国人": "MathWorks 的 Simulink 课程为希望掌握功能强大的仿真软件的个人提供全面而互动的学习体验。这些课程由该领域的专家设计，为 Simulink 的图形环境提供了坚实的基础，使用户能够高效地建模和仿真动态系统。",
                    // Russian
                    "Русский": "Курсы MathWorks Simulink предлагают комплексный и интерактивный опыт обучения для тех, кто стремится освоить мощное программное обеспечение для моделирования. Эти курсы, разработанные экспертами в этой области, обеспечивают прочную основу в графической среде Simulink, позволяя пользователям эффективно моделировать и имитировать динамические системы.",
                    // French
                    "Français": "Les cours Simulink de MathWorks offrent une expérience d'apprentissage complète et interactive aux personnes souhaitant maîtriser ce puissant logiciel de simulation. Ces cours, conçus par des experts du domaine, offrent une base solide dans l'environnement graphique de Simulink, permettant aux utilisateurs de modéliser et de simuler efficacement des systèmes dynamiques.",
                    // Japanese
                    "日本語": "MathWorks の Simulink コースは、強力なシミュレーション ソフトウェアを習得したい方のために、包括的でインタラクティブな学習体験を提供します。この分野の専門家によって設計されたこれらのコースは、Simulink のグラフィカル環境の強固な基礎を提供し、ユーザーが動的システムを効率的にモデル化およびシミュレーションできるようにします。",
                    // Korean
                    "한국인": "MathWorks의 Simulink 과정은 강력한 시뮬레이션 소프트웨어를 마스터하려는 개인에게 포괄적이고 대화형 학습 경험을 제공합니다. 이 분야의 전문가가 설계한 이 과정은 Simulink의 그래픽 환경에 대한 견고한 기초를 제공하여 사용자가 동적 시스템을 효율적으로 모델링하고 시뮬레이션할 수 있도록 합니다.",
                    // Spanish
                    "Español": "Los cursos de Simulink de MathWorks ofrecen una experiencia de aprendizaje completa e interactiva para aquellas personas que deseen dominar el potente software de simulación. Estos cursos, diseñados por expertos en el campo, proporcionan una base sólida en el entorno gráfico de Simulink, lo que permite a los usuarios modelar y simular sistemas dinámicos de manera eficiente.",
                    // Hindi
                    "हिंदी": "मैथवर्क्स के सिमुलिंक पाठ्यक्रम शक्तिशाली सिमुलेशन सॉफ़्टवेयर में महारत हासिल करने के इच्छुक व्यक्तियों के लिए एक व्यापक और इंटरैक्टिव सीखने का अनुभव प्रदान करते हैं। क्षेत्र के विशेषज्ञों द्वारा डिज़ाइन किए गए ये पाठ्यक्रम सिमुलिंक के ग्राफ़िकल वातावरण में एक ठोस आधार प्रदान करते हैं, जिससे उपयोगकर्ता गतिशील प्रणालियों को कुशलतापूर्वक मॉडल और सिम्युलेट कर सकते हैं।",
                    // Portuguese
                    "Português": "Os cursos Simulink da MathWorks oferecem uma experiência de aprendizagem abrangente e interativa para indivíduos que procuram dominar o poderoso software de simulação. Estes cursos, elaborados por especialistas na área, fornecem uma base sólida no ambiente gráfico do Simulink, permitindo aos utilizadores modelar e simular sistemas dinâmicos de forma eficiente.",
                    // Bengali
                    "বাংলা": "ম্যাথওয়ার্কসের সিমুলিঙ্ক কোর্সগুলি শক্তিশালী সিমুলেশন সফ্টওয়্যার আয়ত্ত করতে চাওয়া ব্যক্তিদের জন্য একটি ব্যাপক এবং ইন্টারেক্টিভ শেখার অভিজ্ঞতা প্রদান করে। এই ক্ষেত্রের বিশেষজ্ঞদের দ্বারা ডিজাইন করা এই কোর্সগুলি, সিমুলিংকের গ্রাফিকাল পরিবেশে একটি দৃঢ় ভিত্তি প্রদান করে, যা ব্যবহারকারীদের দক্ষতার সাথে গতিশীল সিস্টেমের মডেল এবং অনুকরণ করতে সক্ষম করে।",
                    // Arabic
                    "عَرَبِيّ": "توفر دورات Simulink من MathWorks تجربة تعليمية شاملة وتفاعلية للأفراد الذين يسعون إلى إتقان برنامج المحاكاة القوي. توفر هذه الدورات، التي صممها خبراء في هذا المجال، أساسًا قويًا في البيئة الرسومية لبرنامج Simulink، مما يتيح للمستخدمين نمذجة ومحاكاة الأنظمة الديناميكية بكفاءة.",
                    // Persian
                    "فارسی": "دوره های Simulink MathWorks یک تجربه یادگیری جامع و تعاملی را برای افرادی که به دنبال تسلط بر نرم افزار قدرتمند شبیه سازی هستند ارائه می دهد. این دوره‌ها که توسط متخصصان این حوزه طراحی شده‌اند، پایه‌ای محکم در محیط گرافیکی Simulink فراهم می‌کنند و کاربران را قادر می‌سازند تا سیستم‌های پویا را به‌طور کارآمد مدل‌سازی و شبیه‌سازی کنند.",
                },
                // Paragraph 2
                {
                    // English
                    "English": "One of the standout features of these courses is their hands-on approach. Participants are encouraged to experiment with various Simulink blocks and components, building and testing their own models. This practical experience not only reinforces theoretical concepts but also fosters creativity and problem-solving skills. Additionally, the courses cover a wide range of applications, from control systems engineering to signal processing, ensuring that learners can apply their knowledge to real-world scenarios.",
                    // German
                    "Deutsch": "Eines der herausragenden Merkmale dieser Kurse ist ihr praktischer Ansatz. Die Teilnehmer werden ermutigt, mit verschiedenen Simulink-Blöcken und -Komponenten zu experimentieren und ihre eigenen Modelle zu erstellen und zu testen. Diese praktische Erfahrung stärkt nicht nur theoretische Konzepte, sondern fördert auch Kreativität und Problemlösungsfähigkeiten. Darüber hinaus decken die Kurse ein breites Anwendungsspektrum ab, von der Steuerungs- und Regelungstechnik bis zur Signalverarbeitung, sodass die Lernenden ihr Wissen auf reale Szenarien anwenden können.",
                    // Chinese
                    "中国人": "这些课程的一大特色是实践教学。我们鼓励学员尝试各种 Simulink 模块和组件，构建和测试自己的模型。这种实践经验不仅可以巩固理论概念，还可以培养创造力和解决问题的能力。此外，这些课程涵盖了从控制系统工程到信号处理的广泛应用，确保学员能够将所学知识应用于实际场景。",
                    // Russian
                    "Русский": "Одной из отличительных особенностей этих курсов является их практический подход. Участникам предлагается экспериментировать с различными блоками и компонентами Simulink, создавая и тестируя собственные модели. Этот практический опыт не только закрепляет теоретические концепции, но и способствует развитию творческих способностей и навыков решения проблем. Кроме того, курсы охватывают широкий спектр приложений, от проектирования систем управления до обработки сигналов, гарантируя, что учащиеся смогут применять свои знания в реальных сценариях.",
                    // French
                    "Français": "L'une des caractéristiques les plus remarquables de ces cours est leur approche pratique. Les participants sont encouragés à expérimenter différents blocs et composants Simulink, en construisant et en testant leurs propres modèles. Cette expérience pratique renforce non seulement les concepts théoriques, mais favorise également la créativité et les compétences en résolution de problèmes. De plus, les cours couvrent un large éventail d'applications, de l'ingénierie des systèmes de contrôle au traitement du signal, garantissant ainsi que les apprenants peuvent appliquer leurs connaissances à des scénarios réels.",
                    // Japanese
                    "日本語": "これらのコースの際立った特徴の 1 つは、実践的なアプローチです。参加者は、さまざまな Simulink ブロックとコンポーネントを試し、独自のモデルを構築してテストすることが推奨されます。この実践的な経験は、理論的な概念を強化するだけでなく、創造性と問題解決スキルを養います。さらに、コースでは、制御システム エンジニアリングから信号処理まで、幅広いアプリケーションをカバーしているため、学習者は知識を実際のシナリオに適用できます。",
                    // Korean
                    "한국인": "이러한 과정의 두드러진 특징 중 하나는 실습적 접근 방식입니다. 참가자는 다양한 Simulink 블록과 구성 요소를 실험하고, 자신의 모델을 구축하고 테스트하도록 권장됩니다. 이러한 실무 경험은 이론적 개념을 강화할 뿐만 아니라 창의성과 문제 해결 기술을 육성합니다. 또한, 이 과정은 제어 시스템 엔지니어링에서 신호 처리에 이르기까지 광범위한 응용 프로그램을 다루므로 학습자는 지식을 실제 상황에 적용할 수 있습니다.",
                    // Spanish
                    "Español": "Una de las características más destacadas de estos cursos es su enfoque práctico. Se anima a los participantes a experimentar con diversos bloques y componentes de Simulink, construyendo y probando sus propios modelos. Esta experiencia práctica no solo refuerza los conceptos teóricos, sino que también fomenta la creatividad y las habilidades para la resolución de problemas. Además, los cursos cubren una amplia gama de aplicaciones, desde la ingeniería de sistemas de control hasta el procesamiento de señales, lo que garantiza que los alumnos puedan aplicar sus conocimientos a situaciones del mundo real.",
                    // Hindi
                    "हिंदी": "इन पाठ्यक्रमों की एक खास विशेषता उनका व्यावहारिक दृष्टिकोण है। प्रतिभागियों को विभिन्न सिमुलिंक ब्लॉक और घटकों के साथ प्रयोग करने, अपने स्वयं के मॉडल बनाने और उनका परीक्षण करने के लिए प्रोत्साहित किया जाता है। यह व्यावहारिक अनुभव न केवल सैद्धांतिक अवधारणाओं को पुष्ट करता है बल्कि रचनात्मकता और समस्या-समाधान कौशल को भी बढ़ावा देता है। इसके अतिरिक्त, पाठ्यक्रम नियंत्रण प्रणाली इंजीनियरिंग से लेकर सिग्नल प्रोसेसिंग तक अनुप्रयोगों की एक विस्तृत श्रृंखला को कवर करते हैं, यह सुनिश्चित करते हुए कि शिक्षार्थी अपने ज्ञान को वास्तविक दुनिया के परिदृश्यों में लागू कर सकते हैं।",
                    // Portuguese
                    "Português": "Uma das características de destaque destes cursos é a sua abordagem prática. Os participantes são encorajados a experimentar vários blocos e componentes do Simulink, construindo e testando os seus próprios modelos. Esta experiência prática não só reforça conceitos teóricos, como também estimula a criatividade e a capacidade de resolução de problemas. Além disso, os cursos abrangem uma vasta gama de aplicações, desde a engenharia de sistemas de controlo ao processamento de sinais, garantindo que os alunos podem aplicar os seus conhecimentos em cenários do mundo real.",
                    // Bengali
                    "বাংলা": "এই কোর্সগুলির স্ট্যান্ডআউট বৈশিষ্ট্যগুলির মধ্যে একটি হল তাদের হাতে-কলমে পদ্ধতি। অংশগ্রহণকারীদের বিভিন্ন সিমুলিঙ্ক ব্লক এবং উপাদানগুলির সাথে পরীক্ষা করার জন্য, তাদের নিজস্ব মডেল তৈরি এবং পরীক্ষা করার জন্য উত্সাহিত করা হয়। এই ব্যবহারিক অভিজ্ঞতা শুধুমাত্র তাত্ত্বিক ধারণাকে শক্তিশালী করে না বরং সৃজনশীলতা এবং সমস্যা সমাধানের দক্ষতাও বৃদ্ধি করে। উপরন্তু, কোর্সগুলি কন্ট্রোল সিস্টেম ইঞ্জিনিয়ারিং থেকে শুরু করে সিগন্যাল প্রসেসিং পর্যন্ত বিস্তৃত অ্যাপ্লিকেশানগুলিকে কভার করে, যা নিশ্চিত করে যে শিক্ষার্থীরা তাদের জ্ঞান বাস্তব-বিশ্বের পরিস্থিতিতে প্রয়োগ করতে পারে।",
                    // Arabic
                    "عَرَبِيّ": "من بين السمات البارزة لهذه الدورات التدريبية هو نهجها العملي. يتم تشجيع المشاركين على تجربة العديد من كتل ومكونات Simulink، وبناء واختبار نماذجهم الخاصة. لا تعمل هذه التجربة العملية على تعزيز المفاهيم النظرية فحسب، بل تعزز أيضًا الإبداع ومهارات حل المشكلات. بالإضافة إلى ذلك، تغطي الدورات التدريبية مجموعة واسعة من التطبيقات، من هندسة أنظمة التحكم إلى معالجة الإشارات، مما يضمن قدرة المتعلمين على تطبيق معرفتهم على سيناريوهات العالم الحقيقي.",
                    // Persian
                    "فارسی": "یکی از ویژگی های برجسته این دوره ها رویکرد عملی آنهاست. شرکت کنندگان تشویق می شوند تا با بلوک ها و اجزای مختلف Simulink آزمایش کنند و مدل های خود را بسازند و آزمایش کنند. این تجربه عملی نه تنها مفاهیم نظری را تقویت می کند، بلکه خلاقیت و مهارت های حل مسئله را نیز تقویت می کند. علاوه بر این، دوره‌ها طیف گسترده‌ای از برنامه‌ها، از مهندسی سیستم‌های کنترل گرفته تا پردازش سیگنال را پوشش می‌دهند و تضمین می‌کنند که فراگیران می‌توانند دانش خود را در سناریوهای دنیای واقعی به کار ببرند.",
                },
                // Paragraph 3
                {
                    // English
                    "English": "Beyond the core curriculum, MathWorks offers supplementary resources, such as online forums and documentation, to support learners in their journey. These additional materials provide valuable insights, troubleshooting tips, and opportunities to connect with a community of fellow Simulink users. By combining expert instruction, practical exercises, and comprehensive support, MathWorks' Simulink courses empower individuals to become proficient in this essential tool for engineers and scientists.",
                    // German
                    "Deutsch": "Über den Kernlehrplan hinaus bietet MathWorks ergänzende Ressourcen wie Online-Foren und Dokumentationen, um Lernende auf ihrem Weg zu unterstützen. Diese zusätzlichen Materialien bieten wertvolle Einblicke, Tipps zur Fehlerbehebung und Möglichkeiten, sich mit einer Community anderer Simulink-Benutzer zu vernetzen. Durch die Kombination von fachkundiger Anleitung, praktischen Übungen und umfassender Unterstützung versetzen die Simulink-Kurse von MathWorks Lernende in die Lage, sich dieses für Ingenieure und Wissenschaftler unverzichtbare Werkzeug zu eigen zu machen.",
                    // Chinese
                    "中国人": "除了核心课程外，MathWorks 还提供补充资源，例如在线论坛和文档，以支持学习者的学习。这些附加材料提供了宝贵的见解、故障排除技巧以及与其他 Simulink 用户社区建立联系的机会。通过结合专家指导、实践练习和全面支持，MathWorks 的 Simulink 课程使个人能够熟练掌握工程师和科学家的这一必备工具。",
                    // Russian
                    "Русский": "Помимо основной учебной программы, MathWorks предлагает дополнительные ресурсы, такие как онлайн-форумы и документация, чтобы поддержать учащихся в их путешествии. Эти дополнительные материалы предоставляют ценные идеи, советы по устранению неполадок и возможности для общения с сообществом других пользователей Simulink. Объединяя экспертные инструкции, практические упражнения и всестороннюю поддержку, курсы Simulink от MathWorks позволяют людям стать профессионалами в этом важном инструменте для инженеров и ученых.",
                    // French
                    "Français": "Au-delà du programme de base, MathWorks propose des ressources supplémentaires, telles que des forums en ligne et de la documentation, pour accompagner les apprenants dans leur parcours. Ces supports complémentaires fournissent des informations précieuses, des conseils de dépannage et des opportunités de connexion avec une communauté d'autres utilisateurs de Simulink. En combinant des instructions d'experts, des exercices pratiques et une assistance complète, les cours Simulink de MathWorks permettent aux individus de devenir compétents dans cet outil essentiel pour les ingénieurs et les scientifiques.",
                    // Japanese
                    "日本語": "MathWorks は、コアカリキュラム以外にも、オンライン フォーラムやドキュメントなどの補足リソースを提供して、学習者の学習をサポートします。これらの追加資料は、貴重な洞察、トラブルシューティングのヒント、Simulink ユーザーのコミュニティとつながる機会を提供します。専門家による指導、実践的な演習、包括的なサポートを組み合わせることで、MathWorks の Simulink コースは、エンジニアや科学者にとって不可欠なこのツールを個人が習得できるようにします。",
                    // Korean
                    "한국인": "핵심 커리큘럼을 넘어 MathWorks는 온라인 포럼 및 설명서와 같은 보충 리소스를 제공하여 학습자의 여정을 지원합니다. 이러한 추가 자료는 귀중한 통찰력, 문제 해결 팁 및 Simulink 사용자 커뮤니티와 연결할 수 있는 기회를 제공합니다. MathWorks의 Simulink 과정은 전문가 교육, 실습 및 포괄적인 지원을 결합하여 개인이 엔지니어와 과학자를 위한 이 필수 도구를 능숙하게 사용할 수 있도록 지원합니다.",
                    // Spanish
                    "Español": "Además del plan de estudios básico, MathWorks ofrece recursos complementarios, como foros en línea y documentación, para ayudar a los estudiantes en su recorrido. Estos materiales adicionales brindan información valiosa, sugerencias para la resolución de problemas y oportunidades para conectarse con una comunidad de usuarios de Simulink. Al combinar instrucción experta, ejercicios prácticos y soporte integral, los cursos de Simulink de MathWorks permiten a las personas dominar esta herramienta esencial para ingenieros y científicos.",
                    // Hindi
                    "हिंदी": "मुख्य पाठ्यक्रम से परे, मैथवर्क्स पूरक संसाधन प्रदान करता है, जैसे ऑनलाइन फ़ोरम और दस्तावेज़ीकरण, जो शिक्षार्थियों को उनकी यात्रा में सहायता करते हैं। ये अतिरिक्त सामग्रियाँ मूल्यवान अंतर्दृष्टि, समस्या निवारण युक्तियाँ और साथी सिमुलिंक उपयोगकर्ताओं के समुदाय से जुड़ने के अवसर प्रदान करती हैं। विशेषज्ञ निर्देश, व्यावहारिक अभ्यास और व्यापक सहायता को मिलाकर, मैथवर्क्स के सिमुलिंक पाठ्यक्रम व्यक्तियों को इंजीनियरों और वैज्ञानिकों के लिए इस आवश्यक उपकरण में कुशल बनने के लिए सशक्त बनाते हैं।",
                    // Portuguese
                    "Português": "Além do currículo básico, o MathWorks oferece recursos complementares, como fóruns online e documentação, para apoiar os alunos na sua jornada. Estes materiais adicionais fornecem informações valiosas, dicas para a resolução de problemas e oportunidades para se ligar a uma comunidade de outros utilizadores do Simulink. Ao combinar instrução especializada, exercícios práticos e apoio abrangente, os cursos Simulink da MathWorks capacitam os indivíduos para se tornarem proficientes nesta ferramenta essencial para engenheiros e cientistas.",
                    // Bengali
                    "বাংলা": "মূল পাঠ্যক্রমের বাইরে, MathWorks তাদের যাত্রায় শিক্ষার্থীদের সহায়তা করার জন্য অনলাইন ফোরাম এবং ডকুমেন্টেশনের মতো সম্পূরক সংস্থান সরবরাহ করে। এই অতিরিক্ত উপকরণগুলি মূল্যবান অন্তর্দৃষ্টি, সমস্যা সমাধানের টিপস এবং সহকর্মী Simulink ব্যবহারকারীদের সম্প্রদায়ের সাথে সংযোগ করার সুযোগ প্রদান করে। বিশেষজ্ঞের নির্দেশনা, ব্যবহারিক অনুশীলন এবং ব্যাপক সহায়তার সমন্বয়ের মাধ্যমে, ম্যাথওয়ার্কসের সিমুলিঙ্ক কোর্স ব্যক্তিদের প্রকৌশলী এবং বিজ্ঞানীদের জন্য এই অপরিহার্য সরঞ্জামটিতে দক্ষ হয়ে উঠতে সক্ষম করে।",
                    // Arabic
                    "عَرَبِيّ": "بالإضافة إلى المنهج الأساسي، تقدم MathWorks موارد تكميلية، مثل المنتديات والوثائق عبر الإنترنت، لدعم المتعلمين في رحلتهم. توفر هذه المواد الإضافية رؤى قيمة ونصائح لاستكشاف الأخطاء وإصلاحها وفرصًا للتواصل مع مجتمع من مستخدمي Simulink. من خلال الجمع بين التعليمات المتخصصة والتمارين العملية والدعم الشامل، تعمل دورات Simulink من MathWorks على تمكين الأفراد من إتقان هذه الأداة الأساسية للمهندسين والعلماء.",
                    // Persian
                    "فارسی": "فراتر از برنامه درسی اصلی، MathWorks منابع تکمیلی، مانند انجمن‌های آنلاین و مستندات را برای حمایت از زبان‌آموزان در سفرشان ارائه می‌دهد. این مطالب اضافی، بینش‌های ارزشمند، نکات عیب‌یابی و فرصت‌هایی را برای ارتباط با جامعه‌ای از کاربران دیگر سیمولینک ارائه می‌کنند. دوره‌های Simulink MathWorks با ترکیب آموزش‌های تخصصی، تمرین‌های عملی و پشتیبانی جامع، افراد را قادر می‌سازد تا در این ابزار ضروری برای مهندسان و دانشمندان مهارت پیدا کنند.",
                },
            ],
            "CourseCoverImagePath": "../assets/img/Courses Covers/SDA Engineering/1 - MATLAB Simulink Onramp.webp",
            "shortDescriptionsForCourseReviewing": {
                // English
                "English": "MathWorks' Simulink courses offer a comprehensive and interactive learning experience for individuals seeking to master the powerful simulation software. These courses, designed by experts in the field, provide a solid foundation in Simulink's graphical environment, enabling users to model and simulate dynamic systems efficiently.",
                // German
                "Deutsch": "Die Simulink-Kurse von MathWorks bieten eine umfassende und interaktive Lernerfahrung für Personen, die die leistungsstarke Simulationssoftware beherrschen möchten. Diese von Experten auf diesem Gebiet entwickelten Kurse bieten eine solide Grundlage für die grafische Umgebung von Simulink und ermöglichen Benutzern die effiziente Modellierung und Simulation dynamischer Systeme.",
                // Chinese
                "中国人": "MathWorks 的 Simulink 课程为希望掌握功能强大的仿真软件的个人提供全面而互动的学习体验。这些课程由该领域的专家设计，为 Simulink 的图形环境提供了坚实的基础，使用户能够高效地建模和仿真动态系统。",
                // Russian
                "Русский": "Курсы MathWorks Simulink предлагают комплексный и интерактивный опыт обучения для тех, кто стремится освоить мощное программное обеспечение для моделирования. Эти курсы, разработанные экспертами в этой области, обеспечивают прочную основу в графической среде Simulink, позволяя пользователям эффективно моделировать и имитировать динамические системы.",
                // French
                "Français": "Les cours Simulink de MathWorks offrent une expérience d'apprentissage complète et interactive aux personnes souhaitant maîtriser ce puissant logiciel de simulation. Ces cours, conçus par des experts du domaine, offrent une base solide dans l'environnement graphique de Simulink, permettant aux utilisateurs de modéliser et de simuler efficacement des systèmes dynamiques.",
                // Japanese
                "日本語": "MathWorks の Simulink コースは、強力なシミュレーション ソフトウェアを習得したい方のために、包括的でインタラクティブな学習体験を提供します。この分野の専門家によって設計されたこれらのコースは、Simulink のグラフィカル環境の強固な基礎を提供し、ユーザーが動的システムを効率的にモデル化およびシミュレーションできるようにします。",
                // Korean
                "한국인": "MathWorks의 Simulink 과정은 강력한 시뮬레이션 소프트웨어를 마스터하려는 개인에게 포괄적이고 대화형 학습 경험을 제공합니다. 이 분야의 전문가가 설계한 이 과정은 Simulink의 그래픽 환경에 대한 견고한 기초를 제공하여 사용자가 동적 시스템을 효율적으로 모델링하고 시뮬레이션할 수 있도록 합니다.",
                // Spanish
                "Español": "Los cursos de Simulink de MathWorks ofrecen una experiencia de aprendizaje completa e interactiva para aquellas personas que deseen dominar el potente software de simulación. Estos cursos, diseñados por expertos en el campo, proporcionan una base sólida en el entorno gráfico de Simulink, lo que permite a los usuarios modelar y simular sistemas dinámicos de manera eficiente.",
                // Hindi
                "हिंदी": "मैथवर्क्स के सिमुलिंक पाठ्यक्रम शक्तिशाली सिमुलेशन सॉफ़्टवेयर में महारत हासिल करने के इच्छुक व्यक्तियों के लिए एक व्यापक और इंटरैक्टिव सीखने का अनुभव प्रदान करते हैं। क्षेत्र के विशेषज्ञों द्वारा डिज़ाइन किए गए ये पाठ्यक्रम सिमुलिंक के ग्राफ़िकल वातावरण में एक ठोस आधार प्रदान करते हैं, जिससे उपयोगकर्ता गतिशील प्रणालियों को कुशलतापूर्वक मॉडल और सिम्युलेट कर सकते हैं।",
                // Portuguese
                "Português": "Os cursos Simulink da MathWorks oferecem uma experiência de aprendizagem abrangente e interativa para indivíduos que procuram dominar o poderoso software de simulação. Estes cursos, elaborados por especialistas na área, fornecem uma base sólida no ambiente gráfico do Simulink, permitindo aos utilizadores modelar e simular sistemas dinâmicos de forma eficiente.",
                // Bengali
                "বাংলা": "ম্যাথওয়ার্কসের সিমুলিঙ্ক কোর্সগুলি শক্তিশালী সিমুলেশন সফ্টওয়্যার আয়ত্ত করতে চাওয়া ব্যক্তিদের জন্য একটি ব্যাপক এবং ইন্টারেক্টিভ শেখার অভিজ্ঞতা প্রদান করে। এই ক্ষেত্রের বিশেষজ্ঞদের দ্বারা ডিজাইন করা এই কোর্সগুলি, সিমুলিংকের গ্রাফিকাল পরিবেশে একটি দৃঢ় ভিত্তি প্রদান করে, যা ব্যবহারকারীদের দক্ষতার সাথে গতিশীল সিস্টেমের মডেল এবং অনুকরণ করতে সক্ষম করে।",
                // Arabic
                "عَرَبِيّ": "توفر دورات Simulink من MathWorks تجربة تعليمية شاملة وتفاعلية للأفراد الذين يسعون إلى إتقان برنامج المحاكاة القوي. توفر هذه الدورات، التي صممها خبراء في هذا المجال، أساسًا قويًا في البيئة الرسومية لبرنامج Simulink، مما يتيح للمستخدمين نمذجة ومحاكاة الأنظمة الديناميكية بكفاءة.",
                // Persian
                "فارسی": "دوره های Simulink MathWorks یک تجربه یادگیری جامع و تعاملی را برای افرادی که به دنبال تسلط بر نرم افزار قدرتمند شبیه سازی هستند ارائه می دهد. این دوره‌ها که توسط متخصصان این حوزه طراحی شده‌اند، پایه‌ای محکم در محیط گرافیکی Simulink فراهم می‌کنند و کاربران را قادر می‌سازند تا سیستم‌های پویا را به‌طور کارآمد مدل‌سازی و شبیه‌سازی کنند.",
            },
            "DetailPageScreenToShowEachBookDetails": "CRs/SDA Engineering/1 - MATLAB Simulink Onramp/1 - MATLAB Simulink Onramp.html",
        },
    ],
    // Mechanical Engineer
    "Mechanical Engineer": [

    ],
};

// Documentation
// This variable will be used for translation fonts
var longTextParagraphsIntros = {
    // English
    'English': {
        'fontFamily': "'Roboto Condensed', sans-serif",
    },
    // German
    'Deutsch': {
        'fontFamily': "'Roboto Condensed', sans-serif",
    },
    // Chinese
    '中国人': {
        'fontFamily': "'Ma Shan Zheng', serif",
    },
    // Russian
    'Русский': {
        'fontFamily': "'Roboto Condensed', sans-serif",
    },
    // French
    'Français': {
        'fontFamily': "'Roboto Condensed', sans-serif",
    },
    // Japanese
    '日本語': {
        'fontFamily': "'Hina Mincho', serif",
    },
    // Korean
    '한국인': {
        'fontFamily': "'Gowun Batang', serif",
    },
    // Spanish
    'Español': {
        'fontFamily': "'Roboto Condensed', sans-serif",
    },
    // Hindi
    'हिंदी': {
        'fontFamily': "'Roboto Condensed', sans-serif",
    },
    // Portuguese
    'Português': {
        'fontFamily': "'Roboto Condensed', sans-serif",
    },
    // Bengali
    'বাংলা': {
        'fontFamily': "'Noto Serif Bengali', serif",
    },
    // Arabic
    'عَرَبِيّ': {
        'fontFamily': "Amiri, serif",
    },
    // Persian
    'فارسی': {
        'fontFamily': "'B Nazanin'",
    },
};

// Documentation
// This variable will be used for h1 font styles
var downloadMyResumeTranslations = {
    'English': {
        'fontFamily': "'Lilita One', serif",
    },
    'Deutsch': {
        'fontFamily': "'Lilita One', serif",
    },
    '中国人': {
        'fontFamily': "'Ma Shan Zheng', serif",
    },
    'Русский': {
        'fontFamily': "'Lilita One', serif",
    },
    'Français': {
        'fontFamily': "'Lilita One', serif",
    },
    '日本語': {
        'fontFamily': "'Dela Gothic One', serif",
    },
    '한국인': {
        'fontFamily': "'Black Han Sans'",
    },
    'Español': {
        'fontFamily': "'Lilita One', serif",
    },
    'हिंदी': {
        'fontFamily': "'Lilita One', serif",
    },
    'Português': {
        'fontFamily': "'Lilita One', serif",
    },
    'বাংলা': {
        'fontFamily': "'Galada', serif",
    },
    'عَرَبِيّ': {
        'fontFamily': "'Lalezar', serif",
    },
    'فارسی': {
        'fontFamily': "'Lalezar', serif",
    },
};

// Documentation
// This condition will control to execute a function just once
var nextButtonClicked = false;

// Documentation
// This condition will control to execute a function just once
var previousButtonClicked = false;

// --------------------- ↑ Static Informations for Individual Skills Page ↑ ---------------------

// ---------------------------------------- ↓ Functions ↓ ----------------------------------------

// Documentation
// This function will be used to make the page responsive
function ResponsiveAdaptive() {
    if (window.innerWidth >= 1300) {

        // First View
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "1";
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.paddingBottom = "5vw";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "3vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "3vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "45vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "30vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "3vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "15vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }

        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "1.5vw";
        document.getElementById("first-view-intro-short-description-text-paragraph").style.marginBottom = "3vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginBottom = "3vw";
        // - > Row of Image and Skill Title
        document.getElementById("First-view-title-skill-short-intro-text-staff").style.width = "40%";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.width = "40%";
        document.getElementById("First-Row-of-introduction-showingtheSkills").className = "d-xxl-flex justify-content-xxl-center";

        // Second View
        // - > Pagination Row
        document.getElementById("pagination-section-to-show-other-books").style.paddingBottom = "3vw";

        // Contact Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 100vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '2vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = (window.innerWidth * 0.02) + 'px';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

        // First View
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "1";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "10vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "4vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "90vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "30vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "3vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "3vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }
        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "2vw";
        document.getElementById("first-view-intro-short-description-text-paragraph").style.marginBottom = "3vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginBottom = "3vw";

        // Contact Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 100vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '2vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '3vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

        // First View
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "1";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "13vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "5vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "90vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "40vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "4vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "3vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }
        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "3vw";
        document.getElementById("first-view-intro-short-description-text-paragraph").style.marginBottom = "3vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginBottom = "3vw";


        // Contact Section Information
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 100vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '2vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '3vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

        // First View
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "1";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "13vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "5vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "90vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "40vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "4vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "3.5vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }
        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "3vw";
        document.getElementById("first-view-intro-short-description-text-paragraph").style.marginBottom = "3vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginBottom = "3vw";


        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 100vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '2vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '3vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

        // First View
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "0";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "15vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "8vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "90vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "40vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "4vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "3vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }
        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "3vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";

        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 100vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '2vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '3vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

        // First View
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "0";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "15vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "8vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "90vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "40vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "4vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "3vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }
        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "3vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";

        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 100vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '2vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '3vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

        // Top Navigation Bar
        // > Class Name
        document.getElementById('top-navigation-bar-individual-bar').className = "navbar navbar-expand-md bg-body shadow-lg py-3";
        // - > Home Button
        document.getElementById('navigation-top-bar-home-link-to-go-to-the-home-page').style.marginLeft = "-15vw";
        // - > language Drop Down
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.marginLeft = "-15vw";
        document.getElementById('languagesssss-drop-down-menu-items').style.width = "5vw";
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.height = "6vw";
        // - > Skill Drop Down
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.marginLeft = "-15vw";
        document.getElementById('skillssss-drop-down-opened-to-style').style.width = "50vw";
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.height = "6vw";
        // - > Download the resume
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginLeft = "-15vw";
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginBottom = "2vw";
        // - > Contact me Button
        document.getElementById('contact-me-nav-bar').style.marginLeft = "-15vw";
        document.getElementById('contact-me-nav-bar').style.marginBottom = "1.5vw";

        // First View
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "0";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "8vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "90vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "50vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "5vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "3vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }
        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "3vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";
        // document.getElementById("first-view-div-element-for-short-description-just").style.paddingBottom = "2vw";

        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 100vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '2vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '3vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

        // Top Navigation Bar
        // > Class Name
        document.getElementById('top-navigation-bar-individual-bar').className = "navbar navbar-expand-md bg-body shadow-lg py-3";
        // - > Home Button
        document.getElementById('navigation-top-bar-home-link-to-go-to-the-home-page').style.marginLeft = "-15vw";
        // - > language Drop Down
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.marginLeft = "-15vw";
        document.getElementById('languagesssss-drop-down-menu-items').style.width = "5vw";
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.height = "8vw";
        // - > Skill Drop Down
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.marginLeft = "-15vw";
        document.getElementById('skillssss-drop-down-opened-to-style').style.width = "50vw";
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.height = "8vw";
        // - > Download the resume
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginLeft = "-15vw";
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginBottom = "2vw";
        // - > Contact me Button
        document.getElementById('contact-me-nav-bar').style.marginLeft = "-15vw";
        document.getElementById('contact-me-nav-bar').style.marginBottom = "1.5vw";

        // First View
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "0";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "8vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "90vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "50vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "5vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "3vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }
        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "3vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";


        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 100vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '2vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '3vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

        // Top Navigation Bar
        // > Class Name
        document.getElementById('top-navigation-bar-individual-bar').className = "navbar navbar-expand-md bg-body shadow-lg py-3";
        // - > Home Button
        document.getElementById('navigation-top-bar-home-link-to-go-to-the-home-page').style.marginLeft = "-15vw";
        // - > language Drop Down
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.marginLeft = "-15vw";
        document.getElementById('languagesssss-drop-down-menu-items').style.width = "5vw";
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.height = "10vw";
        // - > Skill Drop Down
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.marginLeft = "-15vw";
        document.getElementById('skillssss-drop-down-opened-to-style').style.width = "50vw";
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.height = "10vw";
        // - > Download the resume
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginLeft = "-15vw";
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginBottom = "2vw";
        // - > Contact me Button
        document.getElementById('contact-me-nav-bar').style.marginLeft = "-15vw";
        document.getElementById('contact-me-nav-bar').style.marginBottom = "1.5vw";

        // First View
        // - > Image column
        document.getElementById('column-of-image-first-view-container-of-skill-card-image').style.width = "100vw";
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "0";
        // - > Top Location Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "8vw";
        // - > Text Staff Column
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.paddingLeft = "-30vw";
        document.getElementById('First-view-title-skill-short-intro-text-staff').style.marginLeft = "0px";
        // - > Skill Title Indicator
        document.getElementById('first-view-skill-name-heading-introduction').style.fontSize = "10vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.width = "90vw";
        // - > Skill Image
        document.getElementById("first-view-card-image-intro-skill-book-page").style.width = "60vw";
        document.getElementById("first-view-card-image-intro-skill-book-page").style.height = "auto";
        document.getElementById("column-of-image-first-view-container-of-skill-card-image").style.paddingBottom = "3vw";
        // - > Skill Title
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "7vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "3vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "10vw";
        }
        // - > Skill first Intro short paragraph
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "4vw";
        // - > Skill first Intro short paragraph - > Padding
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.paddingRight = "10vw";



        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 140vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '4vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '5vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

        // Top Navigation Bar
        // > Class Name
        document.getElementById('top-navigation-bar-individual-bar').className = "navbar navbar-expand-md bg-body shadow-lg py-3";
        // - > Home Button
        document.getElementById('navigation-top-bar-home-link-to-go-to-the-home-page').style.marginLeft = "-20vw";
        // - > language Drop Down
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.marginLeft = "-20vw";
        document.getElementById('languagesssss-drop-down-menu-items').style.width = "5vw";
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.height = "10vw";
        // - > Skill Drop Down
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.marginLeft = "-20vw";
        document.getElementById('skillssss-drop-down-opened-to-style').style.width = "50vw";
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.height = "10vw";
        // - > Download the resume
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginLeft = "-20vw";
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginBottom = "2vw";
        // - > Contact me Button
        document.getElementById('contact-me-nav-bar').style.marginLeft = "-20vw";
        document.getElementById('contact-me-nav-bar').style.marginBottom = "1.5vw";

        // First View
        // - > Top Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.height = "auto";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "5vw";
        document.getElementById("Books-top-navigation-just-for-containingg").style.fontSize = "4vw";
        document.getElementById("right-arrow-book-navigation-bar-icon").style.fontSize = "4vw";
        document.getElementById("link-button-to-go-the-individual-skill-page-top-indicatotor").style.fontSize = "4vw";
        // - > Skill Image
        document.getElementById('column-of-image-first-view-container-of-skill-card-image').style.align = "center";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.width = "70vw";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.borderRadius = "40px";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.marginTop = "5vw";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.marginBottom = "10vw";
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "0";
        // - > Skill Heading
        document.getElementById('first-view-skill-name-heading-introduction').style.marginLeft = "5vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.marginRight = "5vw";
        // - > Short Description Paragraph
        document.getElementById('first-view-div-element-for-short-description-just').style.marginLeft = "5vw";
        document.getElementById('first-view-div-element-for-short-description-just').style.marginRight = "5vw";
        // Skill Introduction First View
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "7vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "5vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "5vw";
        }
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "5vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginRight = "10vw";



        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 140vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '5vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '6vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

        // Top Navigation Bar
        // > Class Name
        document.getElementById('top-navigation-bar-individual-bar').className = "navbar navbar-expand-md bg-body shadow-lg py-3";
        // - > Home Button
        document.getElementById('navigation-top-bar-home-link-to-go-to-the-home-page').style.marginLeft = "-20vw";
        // - > language Drop Down
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.marginLeft = "-20vw";
        document.getElementById('languagesssss-drop-down-menu-items').style.width = "5vw";
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.height = "13vw";
        // - > Skill Drop Down
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.marginLeft = "-20vw";
        document.getElementById('skillssss-drop-down-opened-to-style').style.width = "70vw";
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.height = "13vw";
        // - > Download the resume
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginLeft = "-20vw";
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginBottom = "3vw";
        // - > Contact me Button
        document.getElementById('contact-me-nav-bar').style.marginLeft = "-20vw";
        document.getElementById('contact-me-nav-bar').style.marginBottom = "1.5vw";

        // First View
        // - > Top Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.height = "auto";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "5vw";
        // - > Skill Image
        document.getElementById('column-of-image-first-view-container-of-skill-card-image').style.align = "center";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.width = "70vw";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.borderRadius = "40px";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.marginTop = "5vw";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.marginBottom = "10vw";
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "0";
        // - > Skill Heading
        document.getElementById('first-view-skill-name-heading-introduction').style.marginLeft = "5vw";
        document.getElementById('first-view-skill-name-heading-introduction').style.marginRight = "5vw";
        // - > Short Description Paragraph
        document.getElementById('first-view-div-element-for-short-description-just').style.marginLeft = "5vw";
        document.getElementById('first-view-div-element-for-short-description-just').style.marginRight = "5vw";
        // Skill Introduction First View
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "8vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "5vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "5vw";
        }
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "6vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginLeft = "10vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginRight = "10vw";

        // Second View
        // Planning the responsive of second or book list view

        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 140vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '5vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '6vw';
            item.style.width = '75vw';
        });

    } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

        // Top Navigation Bar
        // - > Navigation Width
        document.getElementById('top-navigation-bar-individual-bar').style.width = "100%";
        // > Class Name
        document.getElementById('top-navigation-bar-individual-bar').className = "navbar navbar-expand-md bg-body shadow-lg py-3";
        // - > Home Button
        document.getElementById('navigation-top-bar-home-link-to-go-to-the-home-page').style.marginLeft = "-40vw";
        // - > language Drop Down
        document.getElementById('Main-Intro-language-individual-skills-drop-down-change-languages').style.marginLeft = "-40vw";
        document.getElementById('languagesssss-drop-down-menu-items').style.width = "5vw";
        // - > Skill Drop Down
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.marginLeft = "-40vw";
        document.getElementById('skillssss-drop-down-opened-to-style').style.width = "87vw";
        // - > Download the resume
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginLeft = "-40vw";
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.marginBottom = "3vw";
        // - > Contact me Button
        document.getElementById('contact-me-nav-bar').style.marginLeft = "-40vw";

        // First View
        // - > Top Indicator
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.height = "auto";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingTop = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingBottom = "8vw";
        document.getElementById('top-indicatotor-div-to-show-which-skill-is-selected').style.paddingLeft = "5vw";
        // - > Skill Image
        document.getElementById('column-of-image-first-view-container-of-skill-card-image').style.align = "center";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.width = "70vw";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.borderRadius = "20px";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.marginTop = "10vw";
        document.getElementById('first-view-card-image-intro-skill-book-page').style.marginBottom = "10vw";
        // - > Mouse Scroll Indicator
        document.getElementById('Column-of-mouse-indicator-to-scrolling').style.opacity = "0";
        // Skill Introduction First View
        document.getElementById("first-view-skill-name-heading-introduction").style.fontSize = "8vw";
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "0vw";
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingRight = "5vw";
        } else {
            document.getElementById("first-view-skill-name-heading-introduction").style.paddingLeft = "5vw";
        }
        document.getElementById("first-view-intro-short-description-text-paragraph").style.fontSize = "6vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginLeft = "5vw";
        document.getElementById("first-view-div-element-for-short-description-just").style.marginRight = "5vw";


        // Contact Information Section
        // Fourth View
        // - > Background
        document.getElementById('all-rights-reserved-copy-right-symbol').style.background = "url('../../assets/img/End Main Page - BC.svg') -2vw bottom / 140vw no-repeat, linear-gradient(black, #000000)";
        // - > Reserved rights
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.fontSize = '5vw';
        document.getElementById('all-rights-reserved-copy-right-symbol-paragraph-muhammad-husain-aboutalebi-all-right-reserved').style.width = '75vw';
        // - > Contact information buttons
        document.querySelectorAll('#fourth-view-talk-to-me-button-contact-informations').forEach(function (item) {
            item.style.fontSize = '6vw';
            item.style.width = '75vw';
        });

    } else {

    }
}

// Documentation
// This function will create the book cover row list
function BookListRowCreator(SkillName, Language, StartIndex, EndIndex) {
    // Creating the book records which has more than 3 books
    // Creating the book records which has one or two books
    for (var index = StartIndex; index < EndIndex; ++index) {

        // Row
        var parent = document.getElementById("secon-d-section-of-book-list-to-show");
        var rowBook = document.createElement("div");
        rowBook.id = "Book-record-for-styling";
        rowBook.className = "row";
        // - > Styling
        if (window.innerWidth >= 1300) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "1vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "1vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "1vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "1vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "1vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "1vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            rowBook.style.paddingBottom = "1vw";
            rowBook.style.paddingTop = "5vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "5vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "5vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "5vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "5vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "5vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        } else {

            rowBook.style.paddingBottom = "5vw";
            rowBook.style.paddingTop = "5vw";
            rowBook.style.background = "linear-gradient(rgba(0, 102, 255, 0), #0066ff00)";
            rowBook.style.width = "100%";
            rowBook.style.marginRight = "0px";
            rowBook.style.marginLeft = "0px";

        }
        parent.appendChild(rowBook);

        // Image Column
        var parent = document.getElementById("secon-d-section-of-book-list-to-show");
        var ImageColumn = document.createElement("div");
        ImageColumn.id = "Book-image-second-view-column";
        ImageColumn.className = "col-xxl-2 d-flex d-xl-flex d-xxl-flex justify-content-center align-items-center justify-content-xl-center justify-content-xxl-center align-items-xxl-center";
        // Image Column - > Styling
        if (window.innerWidth >= 1300) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.width = "40vw";
            ImageColumn.style.paddingTop = "3vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "3vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "3vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "3vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "3vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "3vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "3vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "5vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "5vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "5vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            ImageColumn.style.height = "120vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            ImageColumn.style.height = "auto";
            ImageColumn.style.paddingTop = "5vw";
            ImageColumn.style.paddingBottom = "5vw";

        } else {

            ImageColumn.style.height = "100vh";

        }
        var Image_column = document.createElement("img");
        Image_column.id = "Book-image-second-view";
        Image_column.className = "img-fluid";
        Image_column.src = PassedCoursesForEachSkillStaticContainer[SkillName][index]["CourseCoverImagePath"];
        // - > Styling
        if (window.innerWidth >= 1300) {

            Image_column.style.borderRadius = "40px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "30vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "50vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "50vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "50vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "50vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "50vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "60vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "60vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            Image_column.style.borderRadius = "40px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "75vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            Image_column.style.borderRadius = "35px";
            Image_column.style.boxShadow = "rgba(0, 0, 0, 0.2) 0px 0px 20px 10px";
            Image_column.style.height = "auto";
            Image_column.style.width = "75vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "rgba(0, 0, 0, 0.2) 0px 0px 15px 5px";
            Image_column.style.height = "auto";
            Image_column.style.width = "75vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            Image_column.style.borderRadius = "20px";
            Image_column.style.boxShadow = "rgba(0, 0, 0, 0.2) 0px 0px 15px 5px";
            Image_column.style.height = "auto";
            Image_column.style.width = "75vw";

        } else {

            Image_column.style.borderRadius = "30px";
            Image_column.style.boxShadow = "0px 0px 40px 30px rgba(0, 0, 0, 0.15)";
            Image_column.style.height = "auto";
            Image_column.style.width = "75vw";

        }
        ImageColumn.appendChild(Image_column);
        parent.appendChild(ImageColumn);

        // Book Short Information Row
        var parent = document.getElementById("secon-d-section-of-book-list-to-show");
        var ShortInformationRow = document.createElement("div");
        ShortInformationRow.id = "short-information-couloumn-all-text-staffs";
        ShortInformationRow.className = "col d-flex d-xxl-flex flex-column align-items-xxl-start";
        // - > Styling
        if (window.innerWidth >= 1300) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.width = "40vw";
            ShortInformationRow.style.marginLeft = "2vw";
            ShortInformationRow.style.marginRight = "2vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "10vw";
            ShortInformationRow.style.marginRight = "10vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "10vw";
            ShortInformationRow.style.marginRight = "10vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "10vw";
            ShortInformationRow.style.marginRight = "10vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "10vw";
            ShortInformationRow.style.marginRight = "10vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "10vw";
            ShortInformationRow.style.marginRight = "10vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "10vw";
            ShortInformationRow.style.marginRight = "10vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "10vw";
            ShortInformationRow.style.marginRight = "10vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "10vw";
            ShortInformationRow.style.marginRight = "10vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "5vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "5vw";

        } else {

            ShortInformationRow.style.height = "auto";
            ShortInformationRow.style.marginLeft = "5vw";

        }
        // - > - > Book Name Title
        var BookNameTitle = document.createElement("h1");
        BookNameTitle.id = "Book-name";
        BookNameTitle.className = "flex-shrink-0";
        // - > - > Book Name Title - > Styling
        if (window.innerWidth >= 1300) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "2vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "4vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "4vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "4vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "4vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "5vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "5vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "5vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "7vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "7vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "9vw";
            BookNameTitle.style.marginTop = "20px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "9vw";
            BookNameTitle.style.marginTop = "20px";

        } else {

            BookNameTitle.style.fontFamily = "'Lilita One', serif";
            BookNameTitle.style.color = "rgb(252, 163, 17)";
            BookNameTitle.style.fontSize = "auto";
            BookNameTitle.style.marginTop = "20px";

        }
        BookNameTitle.textContent = PassedCoursesForEachSkillStaticContainer[SkillName][index]["CourseName"];
        ShortInformationRow.appendChild(BookNameTitle);

        // - > - > Instructor Tag Row
        var AuthorNameRow = document.createElement("div");
        if ((Language == "فارسی") || (Language == "عَرَبِيّ")) {
            AuthorNameRow.dir = "rtl";
        } else {
            AuthorNameRow.dir = "ltr";
        }
        AuthorNameRow.id = "text-staff-container-jsut-AuthorRowTag";
        AuthorNameRow.className = "container-fluid d-inline-flex d-xxl-flex align-items-center align-items-xxl-center";
        // - > - > Instructor Tag Row - > Styling
        if (window.innerWidth >= 1300) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "auto";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "5px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "5px";

        } else {

            AuthorNameRow.style.paddingLeft = "0px";
            AuthorNameRow.style.marginTop = "10px";
            AuthorNameRow.style.marginBottom = "auto";

        }
        // - > - > Instructor Tag Row - > Span
        var AuthorNameTagSpan = document.createElement("span");
        AuthorNameTagSpan.id = "tag-name-that-means-what-is-this-property";
        AuthorNameTagSpan.className = "d-flex flex-shrink-0 align-items-start";
        AuthorNameTagSpan.style.fontFamily = "Roboto, sans-serif";
        // - > - > Instructor Tag Row - > Span - > Styling
        if (window.innerWidth >= 1300) {

            AuthorNameTagSpan.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            AuthorNameTagSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            AuthorNameTagSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            AuthorNameTagSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            AuthorNameTagSpan.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            AuthorNameTagSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            AuthorNameTagSpan.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            AuthorNameTagSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            AuthorNameTagSpan.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            AuthorNameTagSpan.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            AuthorNameTagSpan.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            AuthorNameTagSpan.style.fontSize = "6vw";

        } else {

            AuthorNameTagSpan.style.fontSize = "6vw";

        }

        if (PassedCoursesForEachSkillStaticContainer[SkillName][index]['Gender'] == "F") {
            AuthorNameTagSpan.textContent = boorRecordsShortInformationTags["AuthorTagName"][Language]["Female"];
        } else {
            AuthorNameTagSpan.textContent = boorRecordsShortInformationTags["AuthorTagName"][Language]["Male"];
        }
        AuthorNameTagSpan.style.fontFamily = longTextParagraphsIntros[Language]["fontFamily"];
        AuthorNameRow.appendChild(AuthorNameTagSpan);
        // - > - > Instructor Tag Row - > h5
        var AuthorNameTagH5 = document.createElement("h5");
        AuthorNameTagH5.id = "author-name-that-should-be-replaced";
        AuthorNameTagH5.className = "d-flex align-items-start";
        AuthorNameTagH5.style.fontFamily = "'Lilita One', serif";
        // - > - > Instructor Tag Row - > h5 - > Styling
        if (window.innerWidth >= 1300) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            AuthorNameTagH5.style.marginBottom = "0px";
            AuthorNameTagH5.style.fontSize = "6vw";

        } else {

            AuthorNameTagH5.style.marginBottom = "0px";

        }
        AuthorNameTagH5.textContent = PassedCoursesForEachSkillStaticContainer[SkillName][index]['InstructorName'];
        AuthorNameRow.appendChild(AuthorNameTagH5);
        ShortInformationRow.appendChild(AuthorNameRow);

        // - > - > Course Time
        var EditionNumberRow = document.createElement("div");
        if ((Language == "فارسی") || (Language == "عَرَبِيّ")) {
            EditionNumberRow.dir = "rtl";
        } else {
            EditionNumberRow.dir = "ltr";
        }
        EditionNumberRow.id = "text-staff-container-jsut-EditionRowTag";
        EditionNumberRow.className = "container-fluid d-inline-flex d-xxl-flex align-items-center align-items-xxl-center";
        // - > - > Course Time - > Styling
        if (window.innerWidth >= 1300) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "5px";
            EditionNumberRow.style.marginBottom = "5px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "5px";
            EditionNumberRow.style.marginBottom = "5px";

        } else {

            EditionNumberRow.style.paddingLeft = "0px";
            EditionNumberRow.style.marginTop = "10px";
            EditionNumberRow.style.marginBottom = "auto";

        }
        // - > - > Course Time Span
        var EditionNumberRowSpan = document.createElement("span");
        EditionNumberRowSpan.id = "tag-name-that-means-what-is-this-property-EditionNumberSpan";
        EditionNumberRowSpan.className = "d-flex flex-shrink-0 align-items-start";
        EditionNumberRowSpan.style.fontFamily = "Roboto, sans-serif";
        // - > - > Course Time Span - > Styling
        if (window.innerWidth >= 1300) {

            EditionNumberRowSpan.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            EditionNumberRowSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            EditionNumberRowSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            EditionNumberRowSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            EditionNumberRowSpan.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            EditionNumberRowSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            EditionNumberRowSpan.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            EditionNumberRowSpan.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            EditionNumberRowSpan.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            EditionNumberRowSpan.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            EditionNumberRowSpan.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            EditionNumberRowSpan.style.fontSize = "6vw";

        } else {

            EditionNumberRowSpan.style.fontSize = "6vw";

        }
        EditionNumberRowSpan.textContent = boorRecordsShortInformationTags["EditionNumberTag"][Language];
        EditionNumberRowSpan.style.fontFamily = longTextParagraphsIntros[Language]["fontFamily"];
        EditionNumberRow.appendChild(EditionNumberRowSpan);

        // - > - > Course Time h5
        var EditionNumberRowH5 = document.createElement("h5");
        EditionNumberRowH5.id = "edition-number-name-that-should-be-replaced-Editionh5";
        EditionNumberRowH5.className = "d-flex align-items-start";
        EditionNumberRowH5.style.fontFamily = BoldFirstHeireachyFont[neededProperties.Currrent_Language_Selected]["fontFamily"];
        // - > - > Course Time h5 - > Styling
        if (window.innerWidth >= 1300) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            EditionNumberRowH5.style.marginBottom = "0px";
            EditionNumberRowH5.style.fontSize = "6vw";

        } else {

            EditionNumberRowH5.style.marginBottom = "0px";

        }
        EditionNumberRowH5.textContent = PassedCoursesForEachSkillStaticContainer[SkillName][index]['CourseTime'][neededProperties.Currrent_Language_Selected];
        EditionNumberRow.appendChild(EditionNumberRowH5);
        ShortInformationRow.appendChild(EditionNumberRow);

        // - > - > Platform Row
        var PublisherRow = document.createElement("div");
        if ((Language == "فارسی") || (Language == "عَرَبِيّ")) {
            PublisherRow.dir = "rtl";
        } else {
            PublisherRow.dir = "ltr";
        }
        PublisherRow.id = "text-staff-container-jsut";
        PublisherRow.className = "container-fluid d-inline-flex d-xxl-flex align-items-center align-items-xxl-center";
        // - > - > Platform Row - > Styling
        if (window.innerWidth >= 1300) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "auto";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "5px";
            PublisherRow.style.marginBottom = "5px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "5px";
            PublisherRow.style.marginBottom = "5px";

        } else {

            PublisherRow.style.paddingLeft = "0px";
            PublisherRow.style.marginTop = "10px";
            PublisherRow.style.marginBottom = "auto";

        }
        // - > - > Platform - > Span
        var PublisherRow_Span = document.createElement("span");
        PublisherRow_Span.id = "tag-name-that-means-what-is-this-property";
        PublisherRow_Span.className = "d-flex flex-shrink-0 align-items-start";
        PublisherRow_Span.style.fontFamily = "Roboto, sans-serif";
        // - > - > Platform - > Span - > styling
        if (window.innerWidth >= 1300) {

            PublisherRow_Span.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            PublisherRow_Span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            PublisherRow_Span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            PublisherRow_Span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            PublisherRow_Span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            PublisherRow_Span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            PublisherRow_Span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            PublisherRow_Span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            PublisherRow_Span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            PublisherRow_Span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            PublisherRow_Span.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            PublisherRow_Span.style.fontSize = "6vw";

        } else {

            PublisherRow_Span.style.fontSize = "6vw";

        }
        PublisherRow_Span.textContent = boorRecordsShortInformationTags["PlatformNameTag"][Language];
        PublisherRow_Span.style.fontFamily = longTextParagraphsIntros[Language]["fontFamily"];
        PublisherRow.appendChild(PublisherRow_Span);

        // - > - > Platform - > h5
        var PublisherRow_h5 = document.createElement("h5");
        PublisherRow_h5.id = "publisher-name-that-should-be-replaced";
        PublisherRow_h5.className = "d-flex align-items-start";
        PublisherRow_h5.style.fontFamily = "'Lilita One', serif";
        // - > - > Platform - > h5 - > Styling
        if (window.innerWidth >= 1300) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            PublisherRow_h5.style.marginBottom = "0px";
            PublisherRow_h5.style.fontSize = "6vw";

        } else {

            PublisherRow_h5.style.marginBottom = "0px";

        }
        PublisherRow_h5.textContent = PassedCoursesForEachSkillStaticContainer[SkillName][index]["PlatformName"];
        PublisherRow.appendChild(PublisherRow_h5);
        ShortInformationRow.appendChild(PublisherRow);

        // - > - > Ratings
        var ISBNRow = document.createElement("div");
        if ((Language == "فارسی") || (Language == "عَرَبِيّ")) {
            ISBNRow.dir = "rtl";
        } else {
            ISBNRow.dir = "ltr";
        }
        ISBNRow.id = "text-staff-container-jsut";
        ISBNRow.className = "container-fluid d-inline-flex d-xxl-flex align-items-center align-items-xxl-center";
        // - > - > Ratings - > Styling
        if (window.innerWidth >= 1300) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "auto";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "5px";
            ISBNRow.style.marginBottom = "5px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "5px";
            ISBNRow.style.marginBottom = "5px";

        } else {

            ISBNRow.style.paddingLeft = "0px";
            ISBNRow.style.marginTop = "10px";
            ISBNRow.style.marginBottom = "auto";

        }
        // - > - > Ratings - > span
        var ISBNRow_span = document.createElement("span");
        ISBNRow_span.id = "tag-name-that-means-what-is-this-property";
        ISBNRow_span.className = "d-flex flex-shrink-0 align-items-start";
        ISBNRow_span.style.fontFamily = "Roboto, sans-serif";
        // - > - > Ratings - > span - > Styling
        if (window.innerWidth >= 1300) {

            ISBNRow_span.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            ISBNRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            ISBNRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            ISBNRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            ISBNRow_span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            ISBNRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            ISBNRow_span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            ISBNRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            ISBNRow_span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            ISBNRow_span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            ISBNRow_span.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            ISBNRow_span.style.fontSize = "6vw";

        } else {

            ISBNRow_span.style.fontSize = "6vw";

        }
        ISBNRow_span.textContent = "Ratings : ";
        ISBNRow.appendChild(ISBNRow_span);

        // - > - > Ratings - > h5
        var ISBNRow_h5 = document.createElement("h5");
        ISBNRow_h5.id = "isbn-number-name-that-should-be-replaced";
        ISBNRow_h5.className = "d-flex align-items-start";
        ISBNRow_h5.style.fontFamily = "'Lilita One', serif";
        // - > - > Ratings - > h5 - > Styling
        if (window.innerWidth >= 1300) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            ISBNRow_h5.style.marginBottom = "0px";
            ISBNRow_h5.style.fontSize = "6vw";

        } else {

            ISBNRow_h5.style.marginBottom = "0px";

        }
        ISBNRow_h5.textContent = PassedCoursesForEachSkillStaticContainer[SkillName][index]["Ratings"];
        ISBNRow.appendChild(ISBNRow_h5);
        ShortInformationRow.appendChild(ISBNRow);

        // - > - > Year
        var YearNumberRow = document.createElement("div");
        if ((Language == "فارسی") || (Language == "عَرَبِيّ")) {
            YearNumberRow.dir = "rtl";
        } else {
            YearNumberRow.dir = "ltr";
        }
        YearNumberRow.id = "text-staff-container-jsut";
        YearNumberRow.className = "container-fluid d-inline-flex d-xxl-flex align-items-center align-items-xxl-center";
        // - > - > Year - > Styling
        if (window.innerWidth >= 1300) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "auto";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "5px";
            YearNumberRow.style.marginBottom = "5px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "5px";
            YearNumberRow.style.marginBottom = "5px";

        } else {

            YearNumberRow.style.paddingLeft = "0px";
            YearNumberRow.style.marginTop = "10px";
            YearNumberRow.style.marginBottom = "auto";

        }
        // - > - > Year - > span
        var YearNumberRow_span = document.createElement("span");
        YearNumberRow_span.id = "tag-name-that-means-what-is-this-property";
        YearNumberRow_span.className = "d-flex flex-shrink-0 align-items-start";
        YearNumberRow_span.style.fontFamily = "Roboto, sans-serif";
        // - > - > Year - > span - > styling
        if (window.innerWidth >= 1300) {

            YearNumberRow_span.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            YearNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            YearNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            YearNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            YearNumberRow_span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            YearNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            YearNumberRow_span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            YearNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            YearNumberRow_span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            YearNumberRow_span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            YearNumberRow_span.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            YearNumberRow_span.style.fontSize = "6vw";

        } else {

            YearNumberRow_span.style.fontSize = "6vw";

        }

        YearNumberRow_span.textContent = boorRecordsShortInformationTags["YearNumberTag"][Language];
        YearNumberRow_span.style.fontFamily = longTextParagraphsIntros[Language]["fontFamily"];
        YearNumberRow.appendChild(YearNumberRow_span);
        // - > - > Year - > h5
        var YearNumberRow_h5 = document.createElement("h5");
        YearNumberRow_h5.id = "year-number-name-that-should-be-replaced";
        YearNumberRow_h5.className = "d-flex align-items-start";
        YearNumberRow_h5.style.fontFamily = "'Lilita One', serif";
        // - > - > Year - > h5 - > Styling
        if (window.innerWidth >= 1300) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            YearNumberRow_h5.style.marginBottom = "0px";
            YearNumberRow_h5.style.fontSize = "6vw";

        } else {

            YearNumberRow_h5.style.marginBottom = "0px";

        }
        YearNumberRow_h5.textContent = PassedCoursesForEachSkillStaticContainer[SkillName][index]["YearNumber"];
        YearNumberRow.appendChild(YearNumberRow_h5);
        ShortInformationRow.appendChild(YearNumberRow);

        // - > - > Page Number
        var PageNumberRow = document.createElement("div");
        if ((Language == "فارسی") || (Language == "عَرَبِيّ")) {
            PageNumberRow.dir = "rtl";
        } else {
            PageNumberRow.dir = "ltr";
        }
        PageNumberRow.id = "text-staff-container-jsut";
        PageNumberRow.className = "container-fluid d-inline-flex d-xxl-flex align-items-center align-items-xxl-center";
        // - > - > Page Number - > Styling
        if (window.innerWidth >= 1300) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "5px";
            PageNumberRow.style.marginBottom = "5px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "5px";
            PageNumberRow.style.marginBottom = "5px";

        } else {

            PageNumberRow.style.paddingLeft = "0px";
            PageNumberRow.style.marginTop = "10px";
            PageNumberRow.style.marginBottom = "auto";

        }
        // - > - > Page Number - > span
        var PageNumberRow_span = document.createElement("span");
        PageNumberRow_span.id = "tag-name-that-means-what-is-this-property";
        PageNumberRow_span.className = "d-flex flex-shrink-0 align-items-start";
        PageNumberRow_span.style.fontFamily = "Roboto, sans-serif";
        // - > - > Page Number - > span - > Styling
        if (window.innerWidth >= 1300) {

            PageNumberRow_span.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            PageNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            PageNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            PageNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            PageNumberRow_span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            PageNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            PageNumberRow_span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            PageNumberRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            PageNumberRow_span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            PageNumberRow_span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            PageNumberRow_span.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            PageNumberRow_span.style.fontSize = "6vw";

        } else {

            PageNumberRow_span.style.fontSize = "6vw";

        }

        PageNumberRow_span.textContent = boorRecordsShortInformationTags["ProgrammingLanguagesTag"][Language];
        PageNumberRow_span.style.fontFamily = longTextParagraphsIntros[Language]["fontFamily"];
        PageNumberRow_span.style.whiteSpace = "pre";
        PageNumberRow.appendChild(PageNumberRow_span);
        // - > - > Page Number - > h5
        var PageNumberRow_h5 = document.createElement("h5");
        PageNumberRow_h5.id = "Page-number-name-that-should-be-replaced";
        PageNumberRow_h5.className = "d-flex align-items-start";
        PageNumberRow_h5.style.fontFamily = "'Lilita One', serif";
        // - > - > Page Number - > h5 - > Styling
        if (window.innerWidth >= 1300) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            PageNumberRow_h5.style.marginBottom = "0px";
            PageNumberRow_h5.style.fontSize = "6vw";

        } else {

            PageNumberRow_h5.style.marginBottom = "0px";

        }
        PageNumberRow_h5.textContent = PassedCoursesForEachSkillStaticContainer[SkillName][index]["ProgrammingLanguages"];
        PageNumberRow.appendChild(PageNumberRow_h5);
        ShortInformationRow.appendChild(PageNumberRow);

        // - > - > Short Description
        var ShortDescriptionRow = document.createElement("div");
        if ((Language == "فارسی") || (Language == "عَرَبِيّ")) {
            ShortDescriptionRow.dir = "rtl";
        } else {
            ShortDescriptionRow.dir = "ltr";
        }
        ShortDescriptionRow.id = "text-staff-container-jsut-short-description-paragraph";
        ShortDescriptionRow.className = "container-fluid d-xxl-flex justify-content-start align-items-start align-items-xxl-start";
        // - > - > Short Description - > Styling
        if (window.innerWidth >= 1300) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.marginBottom = "auto";
            ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "5px";
            ShortDescriptionRow.style.marginBottom = "5px";
            // ShortDescriptionRow.style.paddingBottom = "10px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "5px";
            ShortDescriptionRow.style.marginBottom = "5px";
            // ShortDescriptionRow.style.paddingBottom = "10px";

        } else {

            ShortDescriptionRow.style.paddingLeft = "0px";
            ShortDescriptionRow.style.marginTop = "10px";
            ShortDescriptionRow.style.marginBottom = "auto";
            ShortDescriptionRow.style.paddingBottom = "10px";

        }
        // - > - > Short Description - > span
        var ShortDescriptionRow_span = document.createElement("span");
        ShortDescriptionRow_span.id = "tag-name-that-means-what-is-this-property";
        ShortDescriptionRow_span.className = "d-flex flex-shrink-0 flex-fill align-items-start";
        // - > - > Short Description - > span - > Styling
        ShortDescriptionRow_span.style.fontFamily = "Roboto, sans-serif";
        if (window.innerWidth >= 1300) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "1.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "3.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "3vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "5vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "6vw";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";
            ShortDescriptionRow_span.style.fontSize = "6vw";

        } else {

            ShortDescriptionRow_span.style.width = "auto";
            ShortDescriptionRow_span.style.marginBottom = "10px";

        }
        ShortDescriptionRow_span.textContent = boorRecordsShortInformationTags["ShortDescriptionTag"][Language];
        ShortDescriptionRow_span.style.fontFamily = longTextParagraphsIntros[Language]["fontFamily"];
        ShortDescriptionRow.appendChild(ShortDescriptionRow_span);
        // - > - > Short Description - > h5
        var ShortDescriptionRow_h5 = document.createElement("h5");
        ShortDescriptionRow_h5.id = "short-description-text-paragraph-name-that-should-be-replaced";
        ShortDescriptionRow_h5.className = "d-flex";
        // - > - > Short Description - > h5 - > Styling
        if (window.innerWidth >= 1300) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "1.5vw";
            ShortDescriptionRow_h5.style.lineHeight = "45px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "3vw";
            ShortDescriptionRow_h5.style.lineHeight = "50px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "3vw";
            ShortDescriptionRow_h5.style.lineHeight = "45px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "3vw";
            ShortDescriptionRow_h5.style.lineHeight = "45px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "3vw";
            ShortDescriptionRow_h5.style.lineHeight = "40px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "3vw";
            ShortDescriptionRow_h5.style.lineHeight = "40px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "3vw";
            ShortDescriptionRow_h5.style.lineHeight = "40px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "3vw";
            ShortDescriptionRow_h5.style.lineHeight = "35px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "4vw";
            ShortDescriptionRow_h5.style.lineHeight = "45px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "5vw";
            ShortDescriptionRow_h5.style.lineHeight = "40px";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "5vw";
            ShortDescriptionRow_h5.style.lineHeight = "28px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "5vw";
            ShortDescriptionRow_h5.style.lineHeight = "18px";

        } else {

            ShortDescriptionRow_h5.style.fontFamily = "Roboto, sans-serif";
            ShortDescriptionRow_h5.style.marginBottom = "0px";
            ShortDescriptionRow_h5.style.borderStyle = "none";
            ShortDescriptionRow_h5.style.fontSize = "5vw";

        }
        var ShortDescriptionRow_h5_strong = document.createElement("strong");
        var ShortDescriptionRow_h5_strong_span = document.createElement("span");
        ShortDescriptionRow_h5_strong_span.style.color = "rgb(56, 58, 66)";
        ShortDescriptionRow_h5_strong_span.textContent = PassedCoursesForEachSkillStaticContainer[SkillName][index]["shortDescriptionsForCourseReviewing"][Language];
        ShortDescriptionRow_h5_strong_span.style.fontFamily = longTextParagraphsIntros[Language]["fontFamily"];
        ShortDescriptionRow_h5_strong.appendChild(ShortDescriptionRow_h5_strong_span);
        ShortDescriptionRow_h5.appendChild(ShortDescriptionRow_h5_strong);
        ShortDescriptionRow.appendChild(ShortDescriptionRow_h5);
        ShortInformationRow.appendChild(ShortDescriptionRow);

        // - > - > See More Anchor Link
        var SeeMoreRow = document.createElement("a");
        SeeMoreRow.id = "text-staff-container-jsut";
        SeeMoreRow.href = PassedCoursesForEachSkillStaticContainer[SkillName][index]["DetailPageScreenToShowEachBookDetails"] + "?direction=" + encodeURIComponent(SkillName) + "&language=" + encodeURI(Language);
        SeeMoreRow.target = "_blank"
        // - > - > See More Anchor Link - > styling
        if (window.innerWidth >= 1300) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "10px";

        } else {

            SeeMoreRow.style.marginTop = "10px";
            SeeMoreRow.style.marginBottom = "auto";

        }
        // - > - > See More Anchor Link - > Button
        var SeeMoreRow_button = document.createElement("button");
        SeeMoreRow_button.id = "see-more-button-to-go-to-the-book-details";
        SeeMoreRow_button.className = "btn btn-primary";
        SeeMoreRow_button.dataset.bsToggle = "tooltip";
        SeeMoreRow_button.dataset.bsPlacement = "bottom";
        SeeMoreRow_button.type = "button";
        // - > - > See More Anchor Link - > Button - > Styling
        if (window.innerWidth >= 1300) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "14px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "1.5vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "2vw";
            SeeMoreRow_button.style.paddingRight = "2vw";
            SeeMoreRow_button.style.paddingTop = "0.5vw";
            SeeMoreRow_button.style.paddingBottom = "0.5vw";

        } else if ((window.innerWidth < 1300) && (window.innerWidth >= 1200)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "2vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "3vw";
            SeeMoreRow_button.style.paddingRight = "3vw";
            SeeMoreRow_button.style.paddingTop = "1vw";
            SeeMoreRow_button.style.paddingBottom = "1vw";

        } else if ((window.innerWidth < 1200) && (window.innerWidth >= 1100)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "2vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "3vw";
            SeeMoreRow_button.style.paddingRight = "3vw";
            SeeMoreRow_button.style.paddingTop = "1vw";
            SeeMoreRow_button.style.paddingBottom = "1vw";

        } else if ((window.innerWidth < 1100) && (window.innerWidth >= 1000)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "2vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "3vw";
            SeeMoreRow_button.style.paddingRight = "3vw";
            SeeMoreRow_button.style.paddingTop = "1vw";
            SeeMoreRow_button.style.paddingBottom = "1vw";

        } else if ((window.innerWidth < 1000) && (window.innerWidth >= 900)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "2vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "3vw";
            SeeMoreRow_button.style.paddingRight = "3vw";
            SeeMoreRow_button.style.paddingTop = "1vw";
            SeeMoreRow_button.style.paddingBottom = "1vw";

        } else if ((window.innerWidth < 900) && (window.innerWidth >= 800)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "2vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "3vw";
            SeeMoreRow_button.style.paddingRight = "3vw";
            SeeMoreRow_button.style.paddingTop = "1vw";
            SeeMoreRow_button.style.paddingBottom = "1vw";

        } else if ((window.innerWidth < 800) && (window.innerWidth >= 700)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "2.5vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "3vw";
            SeeMoreRow_button.style.paddingRight = "3vw";
            SeeMoreRow_button.style.paddingTop = "1.5vw";
            SeeMoreRow_button.style.paddingBottom = "1.5vw";

        } else if ((window.innerWidth < 700) && (window.innerWidth >= 600)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "2vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "3vw";
            SeeMoreRow_button.style.paddingRight = "3vw";
            SeeMoreRow_button.style.paddingTop = "1.5vw";
            SeeMoreRow_button.style.paddingBottom = "1.5vw";

        } else if ((window.innerWidth < 600) && (window.innerWidth >= 500)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "4vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "5vw";
            SeeMoreRow_button.style.paddingRight = "5vw";
            SeeMoreRow_button.style.paddingTop = "2vw";
            SeeMoreRow_button.style.paddingBottom = "2vw";

        } else if ((window.innerWidth < 500) && (window.innerWidth >= 400)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "4vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";
            SeeMoreRow_button.style.paddingLeft = "5vw";
            SeeMoreRow_button.style.paddingRight = "5vw";
            SeeMoreRow_button.style.paddingTop = "2vw";
            SeeMoreRow_button.style.paddingBottom = "2vw";

        } else if ((window.innerWidth < 400) && (window.innerWidth >= 300)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "5vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";

        } else if ((window.innerWidth < 300) && (window.innerWidth >= 200)) {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "5vw";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";

        } else {

            SeeMoreRow_button.style.background = "rgb(252, 163, 17)";
            SeeMoreRow_button.style.borderRadius = "10px";
            SeeMoreRow_button.style.fontFamily = "'Lilita One', serif";
            SeeMoreRow_button.style.fontSize = "14px";
            SeeMoreRow_button.style.marginLeft = "0px";
            SeeMoreRow_button.style.borderColor = "rgba(255, 255, 255, 0)";
            SeeMoreRow_button.style.color = "rgb(0, 0, 0)";

        }
        SeeMoreRow_button.title = "My Contact Information";
        SeeMoreRow_button.dataset.bsTarget = '"end-section-of-page"';
        SeeMoreRow_button.textContent = boorRecordsShortInformationTags["SeeMoreRowTag"][Language];
        SeeMoreRow_button.style.fontFamily = downloadMyResumeTranslations[Language]["fontFamily"];
        SeeMoreRow.appendChild(SeeMoreRow_button);
        ShortInformationRow.appendChild(SeeMoreRow);
        rowBook.appendChild(ImageColumn);
        rowBook.appendChild(ShortInformationRow);

    } // End Book Row Creator
}

// Documentation
// This function will handle the Read Book List functionlaity
function ReadBooksListCallFunctionFunctionality(SkillName, Language) {

    // Checking whether there is book in skill book store or not
    if (PassedCoursesForEachSkillStaticContainer[SkillName].length >= 1) {
        // Next Book Slides Buttons Indicator - Paginations
        if ((SkillName === "") || (SkillName === " ") || (SkillName == null)) {
            // Leave the page default
        } else {
            if ((PassedCoursesForEachSkillStaticContainer[SkillName].length <= 3) && (document.getElementById('pagination-section-to-show-other-books').childNodes.length == 0)) {

                // Add 1 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var FirstButton = document.createElement('a');
                FirstButton.id = "active-current-paginateion-first-button";
                FirstButton.className = "pagination-item active";
                FirstButton.href = "#";
                FirstButton.style.fontFamily = "'Lilita One', serif";
                FirstButton.style.borderColor = "rgba(244, 130, 32, 0)";
                FirstButton.style.background = "linear-gradient(#fca311, #fca311)";
                FirstButton.style.color = "rgb(255, 255, 255)";
                FirstButton.style.borderRadius = "8px";
                FirstButton.textContent = "1";
                parent.appendChild(FirstButton);

            } else if ((PassedCoursesForEachSkillStaticContainer[SkillName].length <= 6) && (PassedCoursesForEachSkillStaticContainer[SkillName].length >= 4) && (document.getElementById('pagination-section-to-show-other-books').childNodes.length == 0)) {

                // Add Previous Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var PreviousButton = document.createElement('a');
                PreviousButton.className = "pagination-item";
                PreviousButton.id = "previous-page-paginateion-zero-button";
                PreviousButton.href = "javascript:pagination_functionality();";
                PreviousButton.setAttribute("onclick", "pagination_functionality(event)");
                PreviousButton.style.background = "linear-gradient(#000000, #000000)";
                var SVGIconPreviousButton = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
                SVGIconPreviousButton.id = "previous-button-book-pagination-icon";
                SVGIconPreviousButton.className = "bi bi-caret-left-fill";
                SVGIconPreviousButton.setAttribute("color", "white");
                SVGIconPreviousButton.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                SVGIconPreviousButton.setAttribute("width", "1em");
                SVGIconPreviousButton.setAttribute("height", "1em");
                SVGIconPreviousButton.setAttribute("fill", "currentColor");
                SVGIconPreviousButton.setAttribute("viewBox", "0 0 16 16");
                SVGIconPreviousButton.setAttribute("style", "font-size: 25px");
                var PathSVGOfPreviousButton = document.createElementNS("http://www.w3.org/2000/svg", 'path');
                PathSVGOfPreviousButton.setAttribute("d", "m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z");
                SVGIconPreviousButton.appendChild(PathSVGOfPreviousButton);
                PreviousButton.appendChild(SVGIconPreviousButton);
                var SpanPreviousButton = document.createElement('span');
                SpanPreviousButton.style.fontFamily = "'Lilita One', serif";
                SpanPreviousButton.textContent = "Previous";
                SpanPreviousButton.style.color = "white";
                PreviousButton.appendChild(SpanPreviousButton);
                parent.appendChild(PreviousButton);

                // Add 1 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var FirstButton = document.createElement('a');
                FirstButton.id = "active-current-paginateion-first-button";
                FirstButton.className = "pagination-item active";
                FirstButton.href = "javascript:pagination_functionality();";
                FirstButton.setAttribute("onclick", "pagination_functionality(event)");
                FirstButton.style.fontFamily = "'Lilita One', serif";
                FirstButton.style.borderColor = "rgba(244, 130, 32, 0)";
                FirstButton.style.background = "linear-gradient(#fca311, #fca311)";
                FirstButton.style.color = "rgb(255, 255, 255)";
                FirstButton.textContent = "1";
                parent.appendChild(FirstButton);

                // Add 2 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var SecondButton = document.createElement('a');
                SecondButton.id = "second-page-current-paginateion-first-button";
                SecondButton.className = "pagination-item";
                SecondButton.href = "javascript:pagination_functionality();";
                SecondButton.setAttribute("onclick", "pagination_functionality(event)");
                SecondButton.style.fontFamily = "'Lilita One', serif";
                SecondButton.style.borderColor = "rgba(70, 69, 68, 0)";
                SecondButton.style.background = "linear-gradient(#393939, #393939)";
                SecondButton.style.color = "rgb(255, 255, 255)";
                SecondButton.textContent = "2";
                parent.appendChild(SecondButton);

                // Next Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var nextAnchorLink = document.createElement('a');
                nextAnchorLink.id = "Next-button-pagination-to-go-the-next-rows";
                nextAnchorLink.className = "d-xxl-flex align-items-xxl-center pagination-item";
                nextAnchorLink.href = "javascript:pagination_functionality();";
                nextAnchorLink.setAttribute("onclick", "pagination_functionality(event)");
                nextAnchorLink.style.background = "linear-gradient(#000000, #000000)";
                var SpanNextText = document.createElement('span');
                SpanNextText.style.fontFamily = "'Lilita One', serif";
                SpanNextText.style.color = "white";
                SpanNextText.textContent = "Next";
                nextAnchorLink.appendChild(SpanNextText);
                var svgIconNextButton = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
                svgIconNextButton.className = "bi bi-caret-right-fill";
                svgIconNextButton.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                svgIconNextButton.setAttribute("color", "white");
                svgIconNextButton.setAttribute("width", "1em");
                svgIconNextButton.setAttribute("height", "1em");
                svgIconNextButton.setAttribute("fill", "currentColor");
                svgIconNextButton.setAttribute("viewBox", "0 0 16 16");
                svgIconNextButton.setAttribute("style", "font-size: 25px;");
                var pathOfSVGNextButton = document.createElementNS("http://www.w3.org/2000/svg", 'path');
                pathOfSVGNextButton.setAttribute("d", "m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z");
                // pathOfSVGNextButton.style.d = "m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z";
                svgIconNextButton.appendChild(pathOfSVGNextButton);
                nextAnchorLink.appendChild(svgIconNextButton);
                parent.appendChild(nextAnchorLink);

            } else if ((PassedCoursesForEachSkillStaticContainer[SkillName].length <= 9) && (PassedCoursesForEachSkillStaticContainer[SkillName].length >= 7) && (document.getElementById('pagination-section-to-show-other-books').childNodes.length == 0)) {

                // Add Previous Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var PreviousButton = document.createElement('a');
                PreviousButton.className = "pagination-item";
                PreviousButton.id = "previous-page-paginateion-zero-button";
                // PreviousButton.href = "javascript:pagination_functionality();";
                PreviousButton.setAttribute("onclick", "pagination_Previous_Button_JUST_1_2_3_BUTTONS()");
                PreviousButton.style.background = "linear-gradient(#000000, #000000)";
                var SVGIconPreviousButton = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
                SVGIconPreviousButton.id = "previous-button-book-pagination-icon";
                SVGIconPreviousButton.className = "bi bi-caret-left-fill";
                SVGIconPreviousButton.setAttribute("color", "white");
                SVGIconPreviousButton.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                SVGIconPreviousButton.setAttribute("width", "1em");
                SVGIconPreviousButton.setAttribute("height", "1em");
                SVGIconPreviousButton.setAttribute("fill", "currentColor");
                SVGIconPreviousButton.setAttribute("viewBox", "0 0 16 16");
                SVGIconPreviousButton.setAttribute("style", "font-size: 25px");
                var PathSVGOfPreviousButton = document.createElementNS("http://www.w3.org/2000/svg", 'path');
                PathSVGOfPreviousButton.setAttribute("d", "m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z");
                SVGIconPreviousButton.appendChild(PathSVGOfPreviousButton);
                PreviousButton.appendChild(SVGIconPreviousButton);
                var SpanPreviousButton = document.createElement('span');
                SpanPreviousButton.style.fontFamily = "'Lilita One', serif";
                SpanPreviousButton.textContent = "Previous";
                SpanPreviousButton.style.color = "white";
                PreviousButton.appendChild(SpanPreviousButton);
                parent.appendChild(PreviousButton);

                // Add 1 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var FirstButton = document.createElement('a');
                FirstButton.id = "active-current-paginateion-first-button";
                FirstButton.className = "pagination-item active";
                FirstButton.href = "javascript:pagination_functionality();";
                FirstButton.setAttribute("onclick", "pagination_functionality(event)");
                FirstButton.style.fontFamily = "'Lilita One', serif";
                FirstButton.style.borderColor = "rgba(244, 130, 32, 0)";
                FirstButton.style.background = "linear-gradient(#fca311, #fca311)";
                FirstButton.style.color = "rgb(255, 255, 255)";
                FirstButton.textContent = "1";
                parent.appendChild(FirstButton);

                // Add 2 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var SecondButton = document.createElement('a');
                SecondButton.id = "second-page-current-paginateion-first-button";
                SecondButton.className = "pagination-item";
                SecondButton.href = "javascript:pagination_functionality();";
                SecondButton.setAttribute("onclick", "pagination_functionality(event)");
                SecondButton.style.fontFamily = "'Lilita One', serif";
                SecondButton.style.borderColor = "rgba(70, 69, 68, 0)";
                SecondButton.style.background = "linear-gradient(#393939, #393939)";
                SecondButton.style.color = "rgb(255, 255, 255)";
                SecondButton.textContent = "2";
                parent.appendChild(SecondButton);

                // Add 3 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var ThirdButton = document.createElement("a");
                ThirdButton.id = "third-page-current-paginateion-first-button";
                ThirdButton.className = "pagination-item";
                ThirdButton.href = "javascript:pagination_functionality();";
                ThirdButton.setAttribute("onclick", "pagination_functionality(event)");
                ThirdButton.style.fontFamily = "'Lilita One', serif";
                ThirdButton.style.borderColor = "rgba(70, 69, 68, 0)";
                ThirdButton.style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";
                ThirdButton.style.color = "rgb(255, 255, 255)";
                ThirdButton.textContent = "3";
                parent.appendChild(ThirdButton);

                // Next Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var nextAnchorLink = document.createElement('a');
                nextAnchorLink.id = "Next-button-pagination-to-go-the-next-rows";
                nextAnchorLink.className = "d-xxl-flex align-items-xxl-center pagination-item";
                // nextAnchorLink.href = "javascript:pagination_functionality();";
                nextAnchorLink.setAttribute("onclick", "pagination_Next_Button_JUST_1_2_3_BUTTONS()");
                nextAnchorLink.style.background = "linear-gradient(#000000, #000000)";
                var SpanNextText = document.createElement('span');
                SpanNextText.style.fontFamily = "'Lilita One', serif";
                SpanNextText.style.color = "white";
                SpanNextText.textContent = "Next";
                nextAnchorLink.appendChild(SpanNextText);
                var svgIconNextButton = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
                svgIconNextButton.className = "bi bi-caret-right-fill";
                svgIconNextButton.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                svgIconNextButton.setAttribute("color", "white");
                svgIconNextButton.setAttribute("width", "1em");
                svgIconNextButton.setAttribute("height", "1em");
                svgIconNextButton.setAttribute("fill", "currentColor");
                svgIconNextButton.setAttribute("viewBox", "0 0 16 16");
                svgIconNextButton.setAttribute("style", "font-size: 25px;");
                var pathOfSVGNextButton = document.createElementNS("http://www.w3.org/2000/svg", 'path');
                pathOfSVGNextButton.setAttribute("d", "m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z");
                svgIconNextButton.appendChild(pathOfSVGNextButton);
                nextAnchorLink.appendChild(svgIconNextButton);
                parent.appendChild(nextAnchorLink);

            } else if ((PassedCoursesForEachSkillStaticContainer[SkillName].length >= 10) && (document.getElementById('pagination-section-to-show-other-books').childNodes.length == 0)) {

                // Add Previous Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var PreviousButton = document.createElement('a');
                PreviousButton.className = "pagination-item";
                PreviousButton.id = "previous-page-paginateion-zero-button";
                // PreviousButton.href = "javascript:FourButton3DotExistedPaginationPreviousButton();";
                PreviousButton.setAttribute("onclick", "FourButton3DotExistedPaginationPreviousButton()");
                PreviousButton.style.background = "linear-gradient(#000000, #000000)";
                var SVGIconPreviousButton = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
                SVGIconPreviousButton.id = "previous-button-book-pagination-icon";
                SVGIconPreviousButton.className = "bi bi-caret-left-fill";
                SVGIconPreviousButton.setAttribute("color", "white");
                SVGIconPreviousButton.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                SVGIconPreviousButton.setAttribute("width", "1em");
                SVGIconPreviousButton.setAttribute("height", "1em");
                SVGIconPreviousButton.setAttribute("fill", "currentColor");
                SVGIconPreviousButton.setAttribute("viewBox", "0 0 16 16");
                SVGIconPreviousButton.setAttribute("style", "font-size: 25px");
                var PathSVGOfPreviousButton = document.createElementNS("http://www.w3.org/2000/svg", 'path');
                PathSVGOfPreviousButton.setAttribute("d", "m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z");
                SVGIconPreviousButton.appendChild(PathSVGOfPreviousButton);
                PreviousButton.appendChild(SVGIconPreviousButton);
                var SpanPreviousButton = document.createElement('span');
                SpanPreviousButton.style.fontFamily = "'Lilita One', serif";
                SpanPreviousButton.textContent = "Previous";
                SpanPreviousButton.style.color = "white";
                PreviousButton.appendChild(SpanPreviousButton);
                parent.appendChild(PreviousButton);

                // Add 1 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var FirstButton = document.createElement('a');
                FirstButton.id = "active-current-paginateion-first-button";
                FirstButton.className = "pagination-item active";
                FirstButton.href = "javascript:pagination_functionality();";
                FirstButton.setAttribute("onclick", "pagination_functionality(event)");
                FirstButton.style.fontFamily = "'Lilita One', serif";
                FirstButton.style.borderColor = "rgba(244, 130, 32, 0)";
                FirstButton.style.background = "linear-gradient(#fca311, #fca311)";
                FirstButton.style.color = "rgb(255, 255, 255)";
                FirstButton.textContent = "1";
                parent.appendChild(FirstButton);

                // Add 2 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var SecondButton = document.createElement('a');
                SecondButton.id = "second-page-current-paginateion-first-button";
                SecondButton.className = "pagination-item";
                SecondButton.href = "javascript:pagination_functionality();";
                SecondButton.setAttribute("onclick", "pagination_functionality(event)");
                SecondButton.style.fontFamily = "'Lilita One', serif";
                SecondButton.style.borderColor = "rgba(70, 69, 68, 0)";
                SecondButton.style.background = "linear-gradient(#393939, #393939)";
                SecondButton.style.color = "rgb(255, 255, 255)";
                SecondButton.textContent = "2";
                parent.appendChild(SecondButton);

                // Add 3 Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var ThirdButton = document.createElement("a");
                ThirdButton.id = "third-page-current-paginateion-first-button";
                ThirdButton.className = "pagination-item";
                ThirdButton.href = "javascript:pagination_functionality();";
                ThirdButton.setAttribute("onclick", "pagination_functionality(event)");
                ThirdButton.style.fontFamily = "'Lilita One', serif";
                ThirdButton.style.borderColor = "rgba(70, 69, 68, 0)";
                ThirdButton.style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";
                ThirdButton.style.color = "rgb(255, 255, 255)";
                ThirdButton.textContent = "3";
                parent.appendChild(ThirdButton);

                // Add ... Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var FourthButton = document.createElement("a");
                FourthButton.id = "more-page-current-paginateion-first-button-to-update";
                FourthButton.className = "pagination-item";
                // FourthButton.href = "javascript:pagination_functionality();";
                FourthButton.setAttribute("onclick", "pagination_3Dot_button_LoadBooksRows()");
                FourthButton.style.fontFamily = "'Lilita One', serif";
                FourthButton.style.borderColor = "rgba(70, 69, 68, 0)";
                FourthButton.textContent = "...";
                parent.appendChild(FourthButton);

                // Next Button
                var parent = document.getElementById('pagination-section-to-show-other-books');
                var nextAnchorLink = document.createElement('a');
                nextAnchorLink.id = "Next-button-pagination-to-go-the-next-rows";
                nextAnchorLink.className = "d-xxl-flex align-items-xxl-center pagination-item";
                // nextAnchorLink.href = "javascript:FourButton3DotExistedPagination();";
                nextAnchorLink.setAttribute("onclick", "FourButton3DotExistedPagination()");
                nextAnchorLink.style.background = "linear-gradient(#000000, #000000)";
                var SpanNextText = document.createElement('span');
                SpanNextText.style.fontFamily = "'Lilita One', serif";
                SpanNextText.style.color = "white";
                SpanNextText.textContent = "Next";
                nextAnchorLink.appendChild(SpanNextText);
                var svgIconNextButton = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
                svgIconNextButton.className = "bi bi-caret-right-fill";
                svgIconNextButton.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                svgIconNextButton.setAttribute("color", "white");
                svgIconNextButton.setAttribute("width", "1em");
                svgIconNextButton.setAttribute("height", "1em");
                svgIconNextButton.setAttribute("fill", "currentColor");
                svgIconNextButton.setAttribute("viewBox", "0 0 16 16");
                svgIconNextButton.setAttribute("style", "font-size: 25px;");
                var pathOfSVGNextButton = document.createElementNS("http://www.w3.org/2000/svg", 'path');
                pathOfSVGNextButton.setAttribute("d", "m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z");
                svgIconNextButton.appendChild(pathOfSVGNextButton);
                nextAnchorLink.appendChild(svgIconNextButton);
                parent.appendChild(nextAnchorLink);
            }
        }

        // Creating the For loop to create the book page
        let BookExistedRecord = document.getElementById("Book-record-for-styling");

        if (BookExistedRecord == null) {

            if (PassedCoursesForEachSkillStaticContainer[SkillName].length < 3) {

                // Creating the book records which has one or two books
                BookListRowCreator(SkillName, Language, 0, PassedCoursesForEachSkillStaticContainer[SkillName].length);

            } else {

                // Creating the book records which has more than two books
                BookListRowCreator(SkillName, Language, 0, 3);

            }

        }
    } else {
        // If there is no book in the skill book store
    }
}

// Documentation
// This Function is used to get URL parameters
function getQueryParam(param) {
    var searchParams = new URLSearchParams(window.location.search);
    return searchParams.get(param);
}

// Documentation
// This function is used to toggle the show drop down
function toggleDropdown(nameOfEleemnt) {
    var content = document.getElementById(nameOfEleemnt);
    content.classList.toggle("show");
}

// Documentation
// This function is used to close the drop down
function closeDropdownOnClickOutside(event, elementNamedropDown, DropDownToggleName) {
    var dropdown = document.getElementById(elementNamedropDown);
    var dropdownToggle = document.getElementById(DropDownToggleName);

    // If the clicked target is not the dropdown or its children
    if (!dropdown.contains(event.target) && event.target !== dropdownToggle) {
        dropdown.classList.remove('show');
    }
}

// Documentation
// This function is used to stylize the current selected item in drop down in that
function stylingCurrentSelectedOptionInDropDown(dropDownNameID, toCompareArugument) {
    var dropdownItems = document.querySelectorAll('#' + dropDownNameID + ' .dropdown-item');

    dropdownItems.forEach(function (item) {
        if (item.textContent == toCompareArugument) {
            item.style = "font-family: Roboto, sans-serif;font-size: 80%;font-weight: bold;color: rgb(252,163,17);";
        } else {
            item.style = "font-family: Roboto, sans-serif;font-size: 80%;";
        }
    });
}

// Documentation
// This function will be Next paginatioin button to go to the next book row
function FourButton3DotExistedPagination() {
    // 4th state
    // Next Button
    if (!nextButtonClicked) {
        var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if (Pagination_3Dot_Button != null) {

            // Getting the number of Books
            var BookNumbers = PassedCoursesForEachSkillStaticContainer[neededProperties.Currrent_Skill_Selected].length;

            // Calculating the number of Buttons Rows
            var ButtonsRows = Math.floor(BookNumbers / 3);

            if (BookNumbers % 3 == 0) {
                // It is added in floor
            } else {
                ButtonsRows = ButtonsRows + 1;
            }

            if ((document.getElementById("active-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("active-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {

                if (!nextButtonClicked) {

                    if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 1 <= ButtonsRows) && (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 1 > 0)) {

                        // Chaningg the colors
                        document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
                        document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
                        document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

                        // Removing current book rows
                        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
                        while (BookRowSection.firstChild) {
                            BookRowSection.removeChild(BookRowSection.lastChild);
                        }

                        // Recreating the Book Rows
                        BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) * 3);

                        // Scroll to the top of the section
                        document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                            behavior: "smooth",
                        });

                    }

                }

                nextButtonClicked = true;
            }

            if ((document.getElementById("second-page-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("second-page-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {

                if (!nextButtonClicked) {

                    if ((parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) != ButtonsRows)) {

                        // Chaningg the colors
                        document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
                        document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";
                        document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";

                        // Removing current book rows
                        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
                        while (BookRowSection.firstChild) {
                            BookRowSection.removeChild(BookRowSection.lastChild);
                        }

                        // Recreating the Book Rows
                        BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) * 3);

                        // Scroll to the top of the section
                        document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                            behavior: "smooth",
                        });

                    }

                }

                nextButtonClicked = true;

            }

            if ((document.getElementById("third-page-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("third-page-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {

                if (!nextButtonClicked) {

                    if (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) {

                        // Chaningg the colors
                        document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
                        document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
                        document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

                        // Checking whether the next buttons possibly could be existed or not
                        // - > 1 Button
                        if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("active-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("active-current-paginateion-first-button").textContent = (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3).toString();

                        } else {

                            // Hide the first active buttton
                            document.getElementById("active-current-paginateion-first-button").style.display = "none";

                        }
                        // - > 2 Button
                        if ((parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("second-page-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("second-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3).toString();

                        } else {

                            // Hide the first active buttton
                            document.getElementById("second-page-current-paginateion-first-button").style.display = "none";

                        }
                        // - > 3 Button
                        if ((parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("third-page-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("third-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3).toString();

                            // Arranging the order of buttons
                            if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) == ButtonsRows) || (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) == ButtonsRows) || (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) == ButtonsRows)) {

                                // Arranging the order of buttons
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                            } else {

                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                            }


                        } else {

                            // Hide the first active buttton
                            document.getElementById("third-page-current-paginateion-first-button").style.display = "none";

                            // Arranging the order of buttons
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                        }

                        // Removing current book rows
                        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
                        while (BookRowSection.firstChild) {
                            BookRowSection.removeChild(BookRowSection.lastChild);
                        }

                        // Recreating the Book Rows
                        BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3);

                        // Scroll to the top of the section
                        document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                            behavior: "smooth",
                        });

                    } else if (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) {

                        // Chaningg the colors
                        document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
                        document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
                        document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

                        // Checking whether the next buttons possibly could be existed or not
                        // - > 1 Button
                        if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("active-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("active-current-paginateion-first-button").textContent = (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3).toString();

                        } else {

                            // Hide the first active buttton
                            document.getElementById("active-current-paginateion-first-button").style.display = "none";

                        }
                        // - > 2 Button
                        if ((parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("second-page-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("second-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3).toString();

                        } else {

                            // Hide the first active buttton
                            document.getElementById("second-page-current-paginateion-first-button").style.display = "none";

                        }
                        // - > 3 Button
                        if ((parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("third-page-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("third-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3).toString();

                            // Arranging the order of buttons
                            if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) == ButtonsRows) || (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) == ButtonsRows) || (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) == ButtonsRows)) {

                                // Arranging the order of buttons
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                            } else {

                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                            }


                        } else {

                            // Hide the first active buttton
                            document.getElementById("third-page-current-paginateion-first-button").style.display = "none";

                            // Arranging the order of buttons
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                        }

                        // Removing current book rows
                        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
                        while (BookRowSection.firstChild) {
                            BookRowSection.removeChild(BookRowSection.lastChild);
                        }

                        // Recreating the Book Rows
                        BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3);

                        // Scroll to the top of the section
                        document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                            behavior: "smooth",
                        });

                    } else if (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) {

                        // Chaningg the colors
                        document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
                        document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
                        document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

                        // Checking whether the next buttons possibly could be existed or not
                        // - > 1 Button
                        if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("active-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("active-current-paginateion-first-button").textContent = (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3).toString();

                        } else {

                            // Hide the first active buttton
                            document.getElementById("active-current-paginateion-first-button").style.display = "none";

                        }
                        // - > 2 Button
                        if ((parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("second-page-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("second-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3).toString();

                        } else {

                            // Hide the first active buttton
                            document.getElementById("second-page-current-paginateion-first-button").style.display = "none";

                        }
                        // - > 3 Button
                        if ((parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 > 0)) {

                            // Display the first active buttton
                            document.getElementById("third-page-current-paginateion-first-button").style.display = "";

                            // Incrementing the buttons numbers
                            document.getElementById("third-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3).toString();

                            // Arranging the order of buttons
                            if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) == ButtonsRows) || (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) == ButtonsRows) || (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) == ButtonsRows)) {

                                // Arranging the order of buttons
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                            } else {

                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                            }


                        } else {

                            // Hide the first active buttton
                            document.getElementById("third-page-current-paginateion-first-button").style.display = "none";

                            // Arranging the order of buttons
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                        }

                        // Removing current book rows
                        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
                        while (BookRowSection.firstChild) {
                            BookRowSection.removeChild(BookRowSection.lastChild);
                        }

                        // Recreating the Book Rows
                        BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3);

                        // Scroll to the top of the section
                        document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                            behavior: "smooth",
                        });

                    } else {
                    }

                }

                nextButtonClicked = true;

            }

        }
    }

    pagination_next_button_pressed_bool_change_to_false();
}

// Documentation
// This function will be Next paginatioin button to go to the next book row
function FourButton3DotExistedPaginationPreviousButton() {
    // 4th state
    // Previous Button
    if (!previousButtonClicked) {

        var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if (Pagination_3Dot_Button != null) {

            // Getting the number of Books
            var BookNumbers = PassedCoursesForEachSkillStaticContainer[neededProperties.Currrent_Skill_Selected].length;

            // Calculating the number of Buttons Rows
            var ButtonsRows = Math.floor(BookNumbers / 3);

            if (BookNumbers % 3 == 0) {
                // It is added in floor
            } else {
                ButtonsRows = ButtonsRows + 1;
            }

            if ((document.getElementById("active-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("active-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {

                if (!previousButtonClicked) {

                    if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) - 3 <= ButtonsRows) && (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) - 3 > 0)) {

                        // Chaningg the colors
                        document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
                        document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";
                        document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";

                        // Show the buttons
                        document.getElementById("active-current-paginateion-first-button").style.display = "";
                        document.getElementById("second-page-current-paginateion-first-button").style.display = "";
                        document.getElementById("third-page-current-paginateion-first-button").style.display = "";

                        // Changing the text content values
                        var container_Number = parseInt(document.getElementById("active-current-paginateion-first-button").textContent);
                        document.getElementById("active-current-paginateion-first-button").textContent = (container_Number - 3).toString();
                        document.getElementById("second-page-current-paginateion-first-button").textContent = (container_Number - 2).toString();
                        document.getElementById("third-page-current-paginateion-first-button").textContent = (container_Number - 1).toString();

                        // Change the ... button to the end of the w3-row
                        if (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) == 3) {

                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                        } else {

                            // Change the ... button to the end of the w3-row
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                        }

                        // Removing current book rows
                        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
                        while (BookRowSection.firstChild) {
                            BookRowSection.removeChild(BookRowSection.lastChild);
                        }

                        // Recreating the Book Rows
                        BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) * 3);

                        // Scroll to the top of the section
                        document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                            behavior: "smooth",
                        });

                    } else {

                        // Change the ... button to the end of the w3-row
                        document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                        document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                        document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                        document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

                    }

                }

                previousButtonClicked = true;

            }

            if ((document.getElementById("second-page-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("second-page-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {

                if (!previousButtonClicked) {

                    // Chaningg the colors
                    document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
                    document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
                    document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

                    // Removing current book rows
                    var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
                    while (BookRowSection.firstChild) {
                        BookRowSection.removeChild(BookRowSection.lastChild);
                    }

                    // Recreating the Book Rows
                    BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3);

                    // Scroll to the top of the section
                    document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                        behavior: "smooth",
                    });

                }

                previousButtonClicked = true;

            }

            if ((document.getElementById("third-page-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("third-page-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {

                if (!previousButtonClicked) {

                    // Three buttons which are 1, 2, and 3 are existed

                    // Chaningg the colors
                    document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
                    document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
                    document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

                    // Removing current book rows
                    var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
                    while (BookRowSection.firstChild) {
                        BookRowSection.removeChild(BookRowSection.lastChild);
                    }

                    // Recreating the Book Rows
                    BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) * 3);

                    // Scroll to the top of the section
                    document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                        behavior: "smooth",
                    });

                }

                previousButtonClicked = true;

            }

        }

    }

    pagination_next_button_pressed_bool_change_to_false();
}

// Documentation
// Bool from true  to false
function pagination_next_button_pressed_bool_change_to_false() {
    previousButtonClicked = false;
    nextButtonClicked = false;
}

// Documentation
// This is the ... Button to load the more book rows
function pagination_3Dot_button_LoadBooksRows() {
    var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
    if (Pagination_3Dot_Button != null) {

        // Getting the number of Books
        var BookNumbers = PassedCoursesForEachSkillStaticContainer[neededProperties.Currrent_Skill_Selected].length;

        // Calculating the number of Buttons Rows
        var ButtonsRows = Math.floor(BookNumbers / 3);

        if (BookNumbers % 3 == 0) {
            // It is added in floor
        } else {
            ButtonsRows = ButtonsRows + 1;
        }

        // Chaningg the colors
        document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
        document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
        document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

        // Increment the button numbers
        if (document.getElementById("pagination-section-to-show-other-books").children[4].id == "more-page-current-paginateion-first-button-to-update") {

            if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3 > 0)) {

                document.getElementById("active-current-paginateion-first-button").textContent = (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 3).toString();

            } else {

                // Don't increase the buttons

                // Change the ... button to the first of the w3-row
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

            }

            if ((parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3 > 0)) {

                document.getElementById("second-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 3).toString();

            } else {

                // Hide the buttons
                document.getElementById("active-current-paginateion-first-button").style.display = "";
                document.getElementById("second-page-current-paginateion-first-button").style.display = "none";
                document.getElementById("third-page-current-paginateion-first-button").style.display = "none";

                // Change the ... button to the first of the w3-row
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

            }

            if ((parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 <= ButtonsRows) && (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3 > 0)) {

                document.getElementById("third-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 3).toString();

            } else {

                // Hide the buttons
                // document.getElementById("active-current-paginateion-first-button").style.display = "";
                // document.getElementById("second-page-current-paginateion-first-button").style.display = "";
                document.getElementById("third-page-current-paginateion-first-button").style.display = "none";

                // Change the ... button to the first of the w3-row
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

            }


        } else if (document.getElementById("pagination-section-to-show-other-books").children[1].id == "more-page-current-paginateion-first-button-to-update") {

            // Chaning the numbers to correctly decrease
            document.getElementById("active-current-paginateion-first-button").style.display = "";
            document.getElementById("second-page-current-paginateion-first-button").style.display = "";
            document.getElementById("third-page-current-paginateion-first-button").style.display = "";

            // Show the buttons
            var High_Number = parseInt(document.getElementById("active-current-paginateion-first-button").textContent);
            document.getElementById("active-current-paginateion-first-button").textContent = (High_Number).toString();
            document.getElementById("second-page-current-paginateion-first-button").textContent = (High_Number + 1).toString();
            document.getElementById("third-page-current-paginateion-first-button").textContent = (High_Number + 2).toString();

            if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) - 3 <= ButtonsRows) && (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) - 3 > 0)) {

                document.getElementById("active-current-paginateion-first-button").textContent = (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) - 3).toString();

            } else {

                // Show the buttons
                document.getElementById("active-current-paginateion-first-button").style.display = "";
                document.getElementById("second-page-current-paginateion-first-button").style.display = "";
                document.getElementById("third-page-current-paginateion-first-button").style.display = "";

                // Change the ... button to the end of the w3-row
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

            }

            if ((parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) - 3 <= ButtonsRows) && (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) - 3 > 0)) {

                document.getElementById("second-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) - 3).toString();

            } else {

                // Show the buttons
                document.getElementById("active-current-paginateion-first-button").style.display = "";
                document.getElementById("second-page-current-paginateion-first-button").style.display = "";
                document.getElementById("third-page-current-paginateion-first-button").style.display = "";

                // Change the ... button to the end of the w3-row
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

            }

            if ((parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) - 3 <= ButtonsRows) && (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) - 3 > 0)) {

                document.getElementById("third-page-current-paginateion-first-button").textContent = (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) - 3).toString();

            } else {

                // Show the buttons
                document.getElementById("active-current-paginateion-first-button").style.display = "";
                document.getElementById("second-page-current-paginateion-first-button").style.display = "";
                document.getElementById("third-page-current-paginateion-first-button").style.display = "";

                // Change the ... button to the end of the w3-row
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
                document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

            }

        }

        // Checking to position the ... button in appropriate position
        if ((parseInt(document.getElementById("active-current-paginateion-first-button").textContent) + 1 > ButtonsRows) || (parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) + 1 > ButtonsRows) || (parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) + 1 > ButtonsRows)) {

            // Change the ... button to the end of the w3-row
            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[1]);
            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[4]);

        } else if (parseInt(document.getElementById("active-current-paginateion-first-button").textContent) - 1 <= 0) {

            // Change the ... button to the end of the w3-row
            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("active-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[1]);
            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("second-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[2]);
            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("third-page-current-paginateion-first-button"), document.getElementById("pagination-section-to-show-other-books").children[3]);
            document.getElementById("pagination-section-to-show-other-books").insertBefore(document.getElementById("more-page-current-paginateion-first-button-to-update"), document.getElementById("pagination-section-to-show-other-books").children[4]);

        }

        // Removing current book rows
        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
        while (BookRowSection.firstChild) {
            BookRowSection.removeChild(BookRowSection.lastChild);
        }

        // Recreating the Book Rows
        BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3);

        // Scroll to the top of the section
        document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
            behavior: "smooth",
        });

    }
}

// Documentation
// this function will be used for next button pressed
function pagination_Next_Button_JUST_1_2_3_BUTTONS() {
    // - > Next Button
    var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
    if (Pagination_3Dot_Button == null) {

        // Checking which one of 1 or two are currently active

        // - > 1 Button is active
        if ((document.getElementById("active-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("active-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {
            // Changing the backgrounds
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 3, 6);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
        }
        // - > 2 Button is active
        else if ((document.getElementById("second-page-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("second-page-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {
            // Changing the backgrounds
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 6, PassedCoursesForEachSkillStaticContainer[neededProperties.Currrent_Skill_Selected].length);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
        }
        // - > 3 Button is active
        else if ((document.getElementById("third-page-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("third-page-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {
            // Do nothing because there is no any other next buttons which the next button navigate to
        }

    }

}

// Documentation
// this function will be used for next button pressed
function pagination_Previous_Button_JUST_1_2_3_BUTTONS() {
    // - > Previous Button

    var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
    if (Pagination_3Dot_Button == null) {

        // Checking which one of 1 or two are currently active
        // - > 1 Button is active
        if ((document.getElementById("active-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("active-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {
            // Do nothing because there is no any other previous buttons which the Previous button navigate to
        }
        // - > 2 Button is active
        else if ((document.getElementById("second-page-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("second-page-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {
            // Changing the backgrounds
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 0, 3);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
        }
        // - > 3 Button is active
        else if ((document.getElementById("third-page-current-paginateion-first-button").style.background == 'linear-gradient(#fca311, #fca311)') || (document.getElementById("third-page-current-paginateion-first-button").style.background == 'linear-gradient(rgb(252, 163, 17), rgb(252, 163, 17))')) {
            // Changing the backgrounds
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 3, 6);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
        }

    }

}

// Documentation
// This function will handle the pagination functionality
function pagination_functionality(event) {

    event.preventDefault();

    // 1st State
    // If there are just one set of three book, There is no need for any functionality

    // 2nd State
    // There are two set of three rows of Book
    // - > Next Button
    document.getElementById("Next-button-pagination-to-go-the-next-rows").addEventListener("click", function () {
        var Pagination_3_Button = document.getElementById("third-page-current-paginateion-first-button");
        var Pagination_3D_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if ((Pagination_3_Button == null) && (Pagination_3D_Button == null)) {

            // There are two set of three rows of Book
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }
            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 3, PassedCoursesForEachSkillStaticContainer[neededProperties.Currrent_Skill_Selected].length);
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
            console.log("Next Clicked");

        }
    });
    // 2 Button Pressed
    document.getElementById("second-page-current-paginateion-first-button").addEventListener("click", function () {
        var Pagination_3_Button = document.getElementById("third-page-current-paginateion-first-button");
        var Pagination_3D_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if ((Pagination_3_Button == null) && (Pagination_3D_Button == null)) {

            // There are two set of three rows of Book
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }
            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 3, PassedCoursesForEachSkillStaticContainer[neededProperties.Currrent_Skill_Selected].length);
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
            console.log("Next Clicked");

        }
    });
    // - > Previous Button
    document.getElementById("previous-page-paginateion-zero-button").addEventListener("click", function () {
        var Pagination_3_Button = document.getElementById("third-page-current-paginateion-first-button");
        var Pagination_3D_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if ((Pagination_3_Button == null) && (Pagination_3D_Button == null)) {

            // There are two set of three rows of Book
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }
            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 0, 3);
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });

        }
    });
    // 1 Button Pressed
    document.getElementById("active-current-paginateion-first-button").addEventListener("click", function () {
        var Pagination_3_Button = document.getElementById("third-page-current-paginateion-first-button");
        var Pagination_3D_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if ((Pagination_3_Button == null) && (Pagination_3D_Button == null)) {

            // There are two set of three rows of Book
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }
            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 0, 3);
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });

        }
    });

    // 3rd State
    // When there are three set of Three Books Rows, 1,2 and 3 button is exsited and ... button is not existed
    // 1 Button Pressed
    document.getElementById("active-current-paginateion-first-button").addEventListener("click", function () {
        var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if (Pagination_3Dot_Button == null) {

            // Checking which one of 1 or two are currently active
            // - > 1 Button is active
            // Changing the backgrounds
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 0, 3);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
        }
    });
    // 2 Button Pressed
    document.getElementById("second-page-current-paginateion-first-button").addEventListener("click", function () {
        var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if (Pagination_3Dot_Button == null) {

            // Checking which one of 1 or two are currently active
            // - > 2 Button is active
            // Changing the backgrounds
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 3, 6);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
        }
    });
    // 3 Button Pressed
    document.getElementById("third-page-current-paginateion-first-button").addEventListener("click", function () {
        var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if (Pagination_3Dot_Button == null) {

            // Checking which one of 1 or two are currently active
            // - > 2 Button is active
            // Changing the backgrounds
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, 6, PassedCoursesForEachSkillStaticContainer[neededProperties.Currrent_Skill_Selected].length);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });
        }
    });

    // 4th state
    // There is the ... Button which the books are more than 9 books
    // 1 Button
    document.getElementById("active-current-paginateion-first-button").addEventListener("click", function () {

        var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if (Pagination_3Dot_Button != null) {

            // Chaningg the colors
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("active-current-paginateion-first-button").textContent) * 3);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });

        }

    });
    // 2 Button
    document.getElementById("second-page-current-paginateion-first-button").addEventListener("click", function () {

        var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if (Pagination_3Dot_Button != null) {

            // Chaningg the colors
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("second-page-current-paginateion-first-button").textContent) * 3);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });

        }

    });
    // 3 Button
    document.getElementById("third-page-current-paginateion-first-button").addEventListener("click", function () {

        var Pagination_3Dot_Button = document.getElementById("more-page-current-paginateion-first-button-to-update");
        if (Pagination_3Dot_Button != null) {

            // Chaningg the colors
            document.getElementById("active-current-paginateion-first-button").style.background = "linear-gradient(#393939, #393939)";
            document.getElementById("second-page-current-paginateion-first-button").style.background = "linear-gradient(#5e5e5e, #5e5e5e 100%)";
            document.getElementById("third-page-current-paginateion-first-button").style.background = "linear-gradient(#fca311, #fca311)";

            // Removing current book rows
            var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
            while (BookRowSection.firstChild) {
                BookRowSection.removeChild(BookRowSection.lastChild);
            }

            // Recreating the Book Rows
            BookListRowCreator(neededProperties.Currrent_Skill_Selected, neededProperties.Currrent_Language_Selected, parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) * 3 - 3, parseInt(document.getElementById("third-page-current-paginateion-first-button").textContent) * 3);

            // Scroll to the top of the section
            document.getElementById("secon-d-section-of-book-list-to-show").scrollIntoView({
                behavior: "smooth",
            });

        }

    });

}

// ---------------------------------------- ↑ Functions ↑ ----------------------------------------

// ---------------------------------------- ↓ Needed Properties ↓ ----------------------------------------

var neededProperties = {
    Currrent_Language_Selected: "",
    Currrent_Skill_Selected: "",

    // ---------------------------------------- ↓ Language Set and Get ↓ ----------------------------------------

    get CurrentLanguageSelectedMethod() {
        return this.Currrent_Language_Selected;
    },

    set CurrentLanguageSelectedMethod(newLanguage) {

        // Saving the current language
        this.Currrent_Language_Selected = newLanguage;

        // ---------------------------------------- ↓ Changing the Properties Based on the Language ↓ ----------------------------------------

        // Top Nav Bar
        // - > Home Link
        document.getElementById('Home-button-link-to-go-to-the-first-pagea').textContent = BoldFirstHeireachyFont[newLanguage]['HomeButtonLinkTopNavigationBar'];
        document.getElementById('Home-button-link-to-go-to-the-first-pagea').style.fontFamily = BoldFirstHeireachyFont[newLanguage]['fontFamily'];
        // - > Download My Resume Link
        document.getElementById('download-my-resume-pdf-id-tag-button-link').textContent = BoldFirstHeireachyFont[newLanguage]['DownloadMyResumeButtonTopNavigationBar'];
        document.getElementById('download-my-resume-pdf-id-tag-button-link').style.fontFamily = BoldFirstHeireachyFont[newLanguage]['fontFamily'];

        // First View
        // - > Top Indicator
        document.getElementById('link-button-to-go-the-individual-skill-page-top-indicatotor').href = "../DetailScreen/DetailSkillsIndividuals.html?direction=" + encodeURIComponent(neededProperties.Currrent_Skill_Selected) + "&language=" + encodeURI(newLanguage);
        // - > Intro Skill Heading
        document.getElementById('first-view-skill-name-heading-introduction').textContent = BoldFirstHeireachyFont[newLanguage]['FirstViewIntroductionHeadingWhichSkillIsSelected'][this.Currrent_Skill_Selected];
        document.getElementById('first-view-skill-name-heading-introduction').style.fontFamily = BoldFirstHeireachyFont[newLanguage]['fontFamily'];
        // - > Intro Paragraph
        document.getElementById('first-view-intro-short-description-text-paragraph').textContent = individualSkillsDescriptionsSecondhierachy[newLanguage]['FirstViewBooksListPageFirstViewIntroductionShortHelp'][this.Currrent_Skill_Selected];
        document.getElementById('first-view-intro-short-description-text-paragraph').style.fontFamily = individualSkillsDescriptionsSecondhierachy[newLanguage]['fontFamily'];


        // -------------------------- Right To Left | Left To Right --------------------------
        if ((newLanguage == "فارسی") || (newLanguage == "عَرَبِيّ")) {

            // First View
            // - > Intro Skill Heading
            document.getElementById('first-view-skill-name-heading-introduction').style.textAlign = "start";
            document.getElementById('first-view-skill-name-heading-introduction').dir = "rtl";
            // - > Intro Paragraph
            document.getElementById('first-view-intro-short-description-text-paragraph').style.textAlign = "start";
            document.getElementById('first-view-intro-short-description-text-paragraph').dir = "rtl";
            document.getElementById('first-view-div-element-for-short-description-just').align = "end";

        } else {

            // First View
            // - > Intro Skill Heading
            document.getElementById('first-view-skill-name-heading-introduction').style.textAlign = "start";
            document.getElementById('first-view-skill-name-heading-introduction').dir = "ltr";
            // - > Intro Paragraph
            document.getElementById('first-view-intro-short-description-text-paragraph').style.textAlign = "start";
            document.getElementById('first-view-intro-short-description-text-paragraph').dir = "ltr";
            document.getElementById('first-view-div-element-for-short-description-just').align = "start";

        }

        // ------- ↓ Changing the current drop down value ↓ -------
        // changing the current selected language
        // Listen to changing the language of the page
        var dropdownToggle = document.getElementById('ForToggling'); // Get the dropdown toggle button by its ID
        dropdownToggle.innerHTML = '';
        var languageIcon = document.createElement('i');
        languageIcon.className = "material-icons d-xxl-flex justify-content-xxl-center align-items-xxl-center";
        languageIcon.textContent = 'language';
        document.getElementById("ForToggling").appendChild(languageIcon);
        var wrapper = document.createElement('span');
        wrapper.className = "d-flex d-xxl-flex align-items-center align-items-xxl-center";
        wrapper.appendChild(languageIcon);
        var textContent = document.createTextNode(newLanguage);
        wrapper.appendChild(textContent);
        dropdownToggle.innerHTML = '';
        dropdownToggle.appendChild(wrapper);
        dropdownToggle.style.fontFamily = BoldFirstHeireachyFont[newLanguage]['fontFamily'];
        // ------- ↑ Changing the current drop down value ↑ -------

        // ---------------------------------------- ↓ Changing the Properties Based on the Language ↓ ----------------------------------------

        // Reset the Book Cover Basedon changing the language and skill name
        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
        while (BookRowSection.firstChild) {
            BookRowSection.removeChild(BookRowSection.lastChild);
        }

        var PaginationRowDiv = document.getElementById("pagination-section-to-show-other-books");
        while (PaginationRowDiv.firstChild) {
            PaginationRowDiv.removeChild(PaginationRowDiv.lastChild);
        }

        ResponsiveAdaptive();
    },

    // ---------------------------------------- ↑ Language Set and Get ↑ ----------------------------------------


    // ---------------------------------------- ↓ Skill Set and Get ↓ ----------------------------------------

    get CurrentSkillSelectedMethod() {
        return this.Currrent_Skill_Selected;
    },

    set CurrentSkillSelectedMethod(newSkill) {

        // Saving the current Skill
        this.Currrent_Skill_Selected = newSkill;

        // ---------------------------------------- ↓ Changing the Properties Based on the Skill ↓ ----------------------------------------

        // Webpage title
        document.title = "MHA - " + newSkill;

        // First View
        // - > Top Indicator - href or Link
        document.getElementById('link-button-to-go-the-individual-skill-page-top-indicatotor').href = "../DetailScreen/DetailSkillsIndividuals.html?direction=" + encodeURIComponent(newSkill) + "&language=" + encodeURI(neededProperties.Currrent_Language_Selected);
        // - > Top Indicator - Text Shower
        document.getElementById('link-button-to-go-the-individual-skill-page-top-indicatotor').textContent = newSkill;
        // - > Intro Skill Heading
        document.getElementById('first-view-skill-name-heading-introduction').textContent = BoldFirstHeireachyFont[neededProperties.Currrent_Language_Selected]['FirstViewIntroductionHeadingWhichSkillIsSelected'][newSkill];
        document.getElementById('first-view-skill-name-heading-introduction').style.fontFamily = BoldFirstHeireachyFont[neededProperties.Currrent_Language_Selected]['fontFamily'];
        // - > Intro Skill Card Image
        document.getElementById('first-view-card-image-intro-skill-book-page').src = BoldFirstHeireachyFont['FirstViewSkillImageCardImage'][newSkill];
        document.getElementById('first-view-card-image-intro-skill-book-page').style.boxShadow = "0px 0px 20px 20px rgba(0, 0, 0, 0.08)";
        // - > Intro Paragraph
        document.getElementById('first-view-intro-short-description-text-paragraph').textContent = individualSkillsDescriptionsSecondhierachy[neededProperties.Currrent_Language_Selected]['FirstViewBooksListPageFirstViewIntroductionShortHelp'][newSkill];
        document.getElementById('first-view-intro-short-description-text-paragraph').style.fontFamily = individualSkillsDescriptionsSecondhierachy[neededProperties.Currrent_Language_Selected]['fontFamily'];



        // -------------------------- Right To Left | Left To Right --------------------------
        if ((neededProperties.Currrent_Language_Selected == "فارسی") || (neededProperties.Currrent_Language_Selected == "عَرَبِيّ")) {

            // First View
            // - > Intro Skill Heading
            document.getElementById('first-view-skill-name-heading-introduction').style.textAlign = "start";
            document.getElementById('first-view-skill-name-heading-introduction').dir = "rtl";
            // - > Intro Paragraph
            document.getElementById('first-view-intro-short-description-text-paragraph').style.textAlign = "start";
            document.getElementById('first-view-intro-short-description-text-paragraph').dir = "rtl";
            document.getElementById('first-view-div-element-for-short-description-just').align = "end";

        } else {

            // First View
            // - > Intro Skill Heading
            document.getElementById('first-view-skill-name-heading-introduction').style.textAlign = "start";
            document.getElementById('first-view-skill-name-heading-introduction').dir = "ltr";
            // - > Intro Paragraph
            document.getElementById('first-view-intro-short-description-text-paragraph').style.textAlign = "start";
            document.getElementById('first-view-intro-short-description-text-paragraph').dir = "ltr";
            document.getElementById('first-view-div-element-for-short-description-just').align = "start";

        }


        // ------- ↓ Changing the current drop down value ↓ -------
        var dropdownToggle = document.getElementById('DropDownValueShowingSkills'); // Get the dropdown toggle link by its ID

        // Setting the current style of option of skill
        stylingCurrentSelectedOptionInDropDown('skillssss-drop-down-opened-to-style', neededProperties.Currrent_Skill_Selected);
        stylingCurrentSelectedOptionInDropDown('languagesssss-drop-down-menu-items', neededProperties.Currrent_Language_Selected);

        dropdownToggle.textContent = newSkill; // Set the new value as the dropdown toggle text
        // ------- ↑ Changing the current drop down value ↑ -------

        // ---------------------------------------- ↓ Changing the Properties Based on the Skill ↓ ----------------------------------------

        // Reset the Book Cover Basedon changing the language and skill name
        var BookRowSection = document.getElementById("secon-d-section-of-book-list-to-show");
        while (BookRowSection.firstChild) {
            BookRowSection.removeChild(BookRowSection.lastChild);
        }

        var PaginationRowDiv = document.getElementById("pagination-section-to-show-other-books");
        while (PaginationRowDiv.firstChild) {
            PaginationRowDiv.removeChild(PaginationRowDiv.lastChild);
        }
    },

    // ---------------------------------------- ↑ Skill Set and Get ↑ ----------------------------------------
}

// ---------------------------------------- ↑ Needed Properties ↑ ----------------------------------------

// --------------------- ↓ Getting the current or passed lanauge ↓ ---------------------

// Get the 'language' parameter from the URL
var lanauge_show = getQueryParam('language');
// Get the 'header' parameter from the URL
var headerText = getQueryParam('direction');

// If the lanauge_show is not null, update the header element
if (lanauge_show) {
    if (headerText) {
        neededProperties.CurrentLanguageSelectedMethod = decodeURIComponent(lanauge_show);
        neededProperties.CurrentSkillSelectedMethod = decodeURIComponent(headerText);

        ReadBooksListCallFunctionFunctionality(neededProperties.CurrentSkillSelectedMethod, neededProperties.CurrentLanguageSelectedMethod);
    }
}

// --------------------- ↑ Getting the current or passed lanauge ↑ ---------------------

// ---------------------------------------- ↓ DOM Content Loading ↓ ----------------------------------------

// Documentation
// This Content Loader is used to change the fixed or flow of drop down and some stuff like that
document.addEventListener("DOMContentLoaded", function () {
    // Loading The Nav Bar
    if (window.innerWidth < 768) {
        // Navigation Bar
        // - > Opacity of Toggle
        // document.getElementById('navcol-1').style.opacity = "1";
        // - > Making the Nab Bar Sticky
        document.getElementById('top-navigation-bar-individual-bar').className = "navbar navbar-expand-md bg-body shadow-lg py-3";
        // Navigation Bar
        document.getElementById('Skills-Drop-Down-top-nav-bar').style.zIndex = "1";
    } else {
        // Navigation Bar
        // - > Opacity of Toggle
        document.getElementById('navcol-1').style.opacity = "1";
        // - > Making the Nab Bar Sticky
        document.getElementById('top-navigation-bar-individual-bar').className = "navbar navbar-expand-md fixed-top bg-body shadow-lg py-3";
    }

    // Calling the Responsive Function
    ResponsiveAdaptive();
    // Calling pagination function
    pagination_functionality(event);
});

// Documentation
// This section is for when the page is resized
document.addEventListener('resize', function () {
    // Calling the Responsive Function
    ResponsiveAdaptive();
});
window.addEventListener('resize', function () {
    // Calling the Responsive Function
    ResponsiveAdaptive();
});
ResponsiveAdaptive();

// Documentation
// This section is used to handle the clicking behavior of language drop down
document.getElementById('ForToggling').addEventListener("click", function () {
    // Listen to changing the language of the page
    var dropdownToggle = document.getElementById('ForToggling'); // Get the dropdown toggle button by its ID

    // Get the dropdown menu container
    var dropdownMenu = dropdownToggle.nextElementSibling;

    // Get all the dropdown items within the dropdown menu
    var dropdownItems = dropdownMenu.getElementsByClassName('dropdown-item');

    // Convert HTMLCollection to an array to use forEach
    Array.from(dropdownItems).forEach(function (item) {
        // Add click event listener to each dropdown item
        item.addEventListener('click', function (event) {
            // Prevent the default anchor click behavior
            event.preventDefault();

            // Close the dropdown menu by removing 'show' class from the 'dropdown-menu' and 'dropdown'
            var dropdownElement = this.closest('.dropdown');
            if (dropdownElement) {
                var dropdownMenu = dropdownElement.querySelector('.dropdown-menu');
                if (dropdownMenu.classList.contains('show')) {
                    dropdownMenu.classList.remove('show');
                    dropdownElement.classList.remove('show');
                }
            }

            // Update the dropdown toggle button text with the clicked item's text
            var languageIcon = document.createElement('i');
            languageIcon.className = "material-icons d-xxl-flex justify-content-xxl-center align-items-xxl-center";
            languageIcon.textContent = 'language';
            document.getElementById("ForToggling").appendChild(languageIcon);
            var wrapper = document.createElement('span');
            wrapper.className = "d-flex d-xxl-flex align-items-center align-items-xxl-center";
            wrapper.appendChild(languageIcon);
            var textContent = document.createTextNode(this.textContent);
            wrapper.appendChild(textContent);
            dropdownToggle.innerHTML = '';
            dropdownToggle.appendChild(wrapper);
            dropdownToggle.style.fontFamily = BoldFirstHeireachyFont[this.textContent]['fontFamily'];
            neededProperties.CurrentLanguageSelectedMethod = this.textContent;

            ReadBooksListCallFunctionFunctionality(neededProperties.CurrentSkillSelectedMethod, neededProperties.CurrentLanguageSelectedMethod);

            document.addEventListener('click', function () {
                closeDropdownOnClickOutside(event, 'Main-Intro-language-individual-skills-drop-down-change-languages', 'ForToggling');
            });

            stylingCurrentSelectedOptionInDropDown('languagesssss-drop-down-menu-items', neededProperties.Currrent_Language_Selected);

            pagination_functionality(event);
        });
    });
});

// Documentation
// This section is used to handle the skill click action behavior - Skill Drop Down Change
document.getElementById('DropDownValueShowingSkills').addEventListener('click', function () {
    // Get the dropdown toggle button by its ID
    var dropdownToggle = document.getElementById('DropDownValueShowingSkills');

    // Get the dropdown menu container
    var dropdownMenu = dropdownToggle.nextElementSibling;

    // Get all the dropdown items within the dropdown menu
    var dropdownItems = dropdownMenu.getElementsByClassName('dropdown-item');

    // Convert HTMLCollection to an array to use forEach
    Array.from(dropdownItems).forEach(function (item) {
        // Add click event listener to each dropdown item
        item.addEventListener('click', function (event) {
            // Prevent the default anchor click behavior
            event.preventDefault();

            // Close the dropdown menu by removing 'show' class from the 'dropdown-menu' and 'dropdown'
            var dropdownElement = this.closest('.dropdown');
            if (dropdownElement) {
                var dropdownMenu = dropdownElement.querySelector('.dropdown-menu');
                if (dropdownMenu.classList.contains('show')) {
                    dropdownMenu.classList.remove('show');
                    dropdownElement.classList.remove('show');
                }
            }

            // Update the dropdown toggle button text with the clicked item's text
            dropdownToggle.textContent = this.textContent;
            neededProperties.CurrentSkillSelectedMethod = this.textContent;

            ReadBooksListCallFunctionFunctionality(neededProperties.CurrentSkillSelectedMethod, neededProperties.CurrentLanguageSelectedMethod);
            pagination_functionality(event);
        });
    });
});

// ---------------------------------------- ↑ DOM Content Loading ↑ ----------------------------------------

// --------------------- ↓ Togging the Drop Down to Being Smooth ↓ ---------------------

// Add event listener to your dropdown button
document.getElementById("ForToggling").addEventListener("click", function () {
    toggleDropdown("Main-Intro-language-individual-skills-drop-down-change-languages");
});
document.addEventListener('click', function () {
    closeDropdownOnClickOutside(event, 'Main-Intro-language-individual-skills-drop-down-change-languages', 'ForToggling');
});

document.getElementById("DropDownValueShowingSkills").addEventListener("click", function () {
    toggleDropdown("Skills-Drop-Down-top-nav-bar");
});
document.addEventListener('click', function () {
    closeDropdownOnClickOutside(event, 'Skills-Drop-Down-top-nav-bar', 'DropDownValueShowingSkills');
});

// --------------------- ↑ Togging the Drop Down to Being Smooth ↑ ---------------------

//##############################################################################################################################################################
//##############################################################################################################################################################
//##############################################################################################################################################################
//##############################################################################################################################################################
//################################################# © All Rights reserved BY Muhammad Husain Aboutalebi © ######################################################
//##############################################################################################################################################################
//##############################################################################################################################################################
//##############################################################################################################################################################
//##############################################################################################################################################################